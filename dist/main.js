//
// ___________________________________________________________
//
//  _____  _    _ _______  ______ _______ _____ __   _ ______
// |     |  \  /  |______ |_____/ |  |  |   |   | \  | |     \
// |_____|   \/   |______ |    \_ |  |  | __|__ |  \_| |_____/
//
// _______________________ Screeps AI ________________________
//
//
// Overmind repository: github.com/bencbartlett/overmind
//

'use strict';

/* eslint no-bitwise: "off" */
const digestLength = 32;
const blockSize = 64;
// Convert a string to a Uint8Array
function stringToUint8Array(str) {
    const arrayBuffer = new ArrayBuffer(str.length * 1);
    const newUint = new Uint8Array(arrayBuffer);
    newUint.forEach((_, i) => {
        newUint[i] = str.charCodeAt(i);
    });
    return newUint;
}
// SHA-256 constants
const K = new Uint32Array([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1,
    0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,
    0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,
    0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,
    0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,
    0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
]);
function hashBlocks(w, v, p, pos, len) {
    let a, b, c, d, e, f, g, h, u, i, j, t1, t2;
    while (len >= 64) {
        a = v[0];
        b = v[1];
        c = v[2];
        d = v[3];
        e = v[4];
        f = v[5];
        g = v[6];
        h = v[7];
        for (i = 0; i < 16; i++) {
            j = pos + i * 4;
            w[i] =
                ((p[j] & 0xff) << 24) |
                    ((p[j + 1] & 0xff) << 16) |
                    ((p[j + 2] & 0xff) << 8) |
                    (p[j + 3] & 0xff);
        }
        for (i = 16; i < 64; i++) {
            u = w[i - 2];
            t1 =
                ((u >>> 17) | (u << (32 - 17))) ^
                    ((u >>> 19) | (u << (32 - 19))) ^
                    (u >>> 10);
            u = w[i - 15];
            t2 =
                ((u >>> 7) | (u << (32 - 7))) ^
                    ((u >>> 18) | (u << (32 - 18))) ^
                    (u >>> 3);
            w[i] = ((t1 + w[i - 7]) | 0) + ((t2 + w[i - 16]) | 0);
        }
        for (i = 0; i < 64; i++) {
            t1 =
                ((((((e >>> 6) | (e << (32 - 6))) ^
                    ((e >>> 11) | (e << (32 - 11))) ^
                    ((e >>> 25) | (e << (32 - 25)))) +
                    ((e & f) ^ (~e & g))) |
                    0) +
                    ((h + ((K[i] + w[i]) | 0)) | 0)) |
                    0;
            t2 =
                ((((a >>> 2) | (a << (32 - 2))) ^
                    ((a >>> 13) | (a << (32 - 13))) ^
                    ((a >>> 22) | (a << (32 - 22)))) +
                    ((a & b) ^ (a & c) ^ (b & c))) |
                    0;
            h = g;
            g = f;
            f = e;
            e = (d + t1) | 0;
            d = c;
            c = b;
            b = a;
            a = (t1 + t2) | 0;
        }
        v[0] += a;
        v[1] += b;
        v[2] += c;
        v[3] += d;
        v[4] += e;
        v[5] += f;
        v[6] += g;
        v[7] += h;
        pos += 64;
        len -= 64;
    }
    return pos;
}
// Hash implements SHA256 hash algorithm.
class Hash {
    constructor() {
        this.digestLength = digestLength;
        this.blockSize = blockSize;
        // Int32Array is used instead of Uint32Array for performance reasons.
        this.state = new Int32Array(8); // hash state
        this.temp = new Int32Array(64); // temporary state
        this.buffer = new Uint8Array(128); // buffer for data to hash
        this.bufferLength = 0; // number of bytes in buffer
        this.bytesHashed = 0; // number of total bytes hashed
        this.finished = false; // indicates whether the hash was finalized
        this.reset();
    }
    // Resets hash state making it possible
    // to re-use this instance to hash other data.
    reset() {
        this.state[0] = 0x6a09e667;
        this.state[1] = 0xbb67ae85;
        this.state[2] = 0x3c6ef372;
        this.state[3] = 0xa54ff53a;
        this.state[4] = 0x510e527f;
        this.state[5] = 0x9b05688c;
        this.state[6] = 0x1f83d9ab;
        this.state[7] = 0x5be0cd19;
        this.bufferLength = 0;
        this.bytesHashed = 0;
        this.finished = false;
        return this;
    }
    // Cleans internal buffers and re-initializes hash state.
    clean() {
        for (let i = 0; i < this.buffer.length; i++) {
            this.buffer[i] = 0;
        }
        for (let i = 0; i < this.temp.length; i++) {
            this.temp[i] = 0;
        }
        this.reset();
    }
    // Updates hash state with the given data.
    //
    // Optionally, length of the data can be specified to hash
    // fewer bytes than data.length.
    //
    // Throws error when trying to update already finalized hash:
    // instance must be reset to use it again.
    update(data, dataLength = data.length) {
        if (this.finished) {
            throw new Error("SHA256: can't update because hash was finished.");
        }
        let dataPos = 0;
        this.bytesHashed += dataLength;
        if (this.bufferLength > 0) {
            while (this.bufferLength < 64 && dataLength > 0) {
                this.buffer[this.bufferLength++] = data[dataPos++];
                dataLength--;
            }
            if (this.bufferLength === 64) {
                hashBlocks(this.temp, this.state, this.buffer, 0, 64);
                this.bufferLength = 0;
            }
        }
        if (dataLength >= 64) {
            dataPos = hashBlocks(this.temp, this.state, data, dataPos, dataLength);
            dataLength %= 64;
        }
        while (dataLength > 0) {
            this.buffer[this.bufferLength++] = data[dataPos++];
            dataLength--;
        }
        return this;
    }
    // Finalizes hash state and puts hash into out.
    //
    // If hash was already finalized, puts the same value.
    finish(out) {
        if (!this.finished) {
            const bytesHashed = this.bytesHashed;
            const left = this.bufferLength;
            const bitLenHi = (bytesHashed / 0x20000000) | 0;
            const bitLenLo = bytesHashed << 3;
            const padLength = bytesHashed % 64 < 56 ? 64 : 128;
            this.buffer[left] = 0x80;
            for (let i = left + 1; i < padLength - 8; i++) {
                this.buffer[i] = 0;
            }
            this.buffer[padLength - 8] = (bitLenHi >>> 24) & 0xff;
            this.buffer[padLength - 7] = (bitLenHi >>> 16) & 0xff;
            this.buffer[padLength - 6] = (bitLenHi >>> 8) & 0xff;
            this.buffer[padLength - 5] = (bitLenHi >>> 0) & 0xff;
            this.buffer[padLength - 4] = (bitLenLo >>> 24) & 0xff;
            this.buffer[padLength - 3] = (bitLenLo >>> 16) & 0xff;
            this.buffer[padLength - 2] = (bitLenLo >>> 8) & 0xff;
            this.buffer[padLength - 1] = (bitLenLo >>> 0) & 0xff;
            hashBlocks(this.temp, this.state, this.buffer, 0, padLength);
            this.finished = true;
        }
        for (let i = 0; i < 8; i++) {
            out[i * 4 + 0] = (this.state[i] >>> 24) & 0xff;
            out[i * 4 + 1] = (this.state[i] >>> 16) & 0xff;
            out[i * 4 + 2] = (this.state[i] >>> 8) & 0xff;
            out[i * 4 + 3] = (this.state[i] >>> 0) & 0xff;
        }
        return this;
    }
    // Returns the final hash digest.
    digest() {
        const out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
    }
    // Internal function for use in HMAC for optimization.
    _saveState(out) {
        for (let i = 0; i < this.state.length; i++) {
            out[i] = this.state[i];
        }
    }
    // Internal function for use in HMAC for optimization.
    _restoreState(from, bytesHashed) {
        for (let i = 0; i < this.state.length; i++) {
            this.state[i] = from[i];
        }
        this.bytesHashed = bytesHashed;
        this.finished = false;
        this.bufferLength = 0;
    }
}
// Returns SHA256 hash of data.
function sha256(data) {
    const h = new Hash().update(stringToUint8Array(data));
    const digest = h.digest();
    h.clean();
    return digest;
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */


function __decorate$1(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

// A bunch of unicode string constants
const bullet = "\u2023 ";
const rightArrow = "\u27f6";
const leftArrow = "\u27f5";
const alignedNewline = "\n" +
    " ".repeat("INFO    ".length + Game.time.toString().length + " ".length);

// Random utilities that don't belong anywhere else
/** dereference any object from identifier */
function deref(ref) {
    return (Game.getObjectById(ref) ||
        Game.flags[ref] ||
        Game.creeps[ref] ||
        Game.spawns[ref] ||
        null);
}
function derefRoomPosition(protoPos) {
    try {
        return new RoomPosition(protoPos.x, protoPos.y, protoPos.roomName);
    }
    catch (e) {
        throw new Error(`Failed to deref ${JSON.stringify(protoPos)}`);
    }
}
/** JSON-serialize arguments for output */
function dump(...args) {
    let message = "";
    for (const arg of args) {
        let cache = [];
        const msg = JSON.stringify(arg, function (key, value) {
            if (typeof value === "object" && value !== null) {
                if (cache.indexOf(value) !== -1) {
                    // Duplicate reference found
                    try {
                        // If this value does not reference a parent it can be deduped
                        // eslint-disable-next-line
                        return JSON.parse(JSON.stringify(value));
                    }
                    catch (error) {
                        // discard key if value cannot be deduped
                        return;
                    }
                }
                // Store value in our collection
                cache.push(value);
            }
            // eslint-disable-next-line
            return value;
        }, "\t");
        // @ts-expect-error Clear out the cache
        cache = null;
        message += "\n" + msg;
    }
    return message;
}
function getAllRooms() {
    if (!Game._allRooms) {
        Game._allRooms = _.values(Game.rooms); // this is cleared every tick
    }
    return Game._allRooms;
}
function getOwnedRooms() {
    if (!Game._ownedRooms) {
        Game._ownedRooms = _.filter(getAllRooms(), (room) => room.my); // this is cleared every tick
    }
    return Game._ownedRooms;
}
function canClaimAnotherRoom() {
    return getOwnedRooms().length < Game.gcl.level;
}
function printRoomName(roomName, aligned = false) {
    if (aligned) {
        const msg = '<a href="#!/room/' +
            Game.shard.name +
            "/" +
            roomName +
            '">' +
            roomName +
            "</a>";
        const extraSpaces = "E12S34".length - roomName.length;
        return msg + " ".repeat(extraSpaces);
    }
    else {
        return ('<a href="#!/room/' +
            Game.shard.name +
            "/" +
            roomName +
            '">' +
            roomName +
            "</a>");
    }
}
function color(str, color) {
    return `<font color='${color}'>${str}</font>`;
}
function componentToHex(n) {
    const hex = n.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
}
function rgbToHex(r, g, b) {
    return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
}
function interpolateColor(c0, c1, f) {
    const s0 = c0.match(/#?([0-9A-F]{1,2})([0-9A-F]{1,2})([0-9A-F]{1,2})/);
    const s1 = c1.match(/#?([0-9A-F]{1,2})([0-9A-F]{1,2})([0-9A-F]{1,2})/);
    if (!s0) {
        throw new TypeError(`invalid value for c0: ${c0}`);
    }
    if (!s1) {
        throw new TypeError(`invalid value for c1: ${c1}`);
    }
    if (typeof f !== "number" || f < 0 || f > 1) {
        throw new TypeError(`f must be a number between 0.0 and 1.0`);
    }
    const n0 = s0.map((oct) => parseInt(oct, 16) * (1 - f));
    const n1 = s1.map((oct) => parseInt(oct, 16) * f);
    const ci = [1, 2, 3].map((i) => Math.min(Math.round(n0[i] + n1[i]), 255));
    return ("#" +
        ci
            // eslint-disable-next-line no-bitwise
            .reduce((a, v) => (a << 8) + v, 0)
            .toString(16)
            .padStart(6, "0"));
}
/**
 * Correct generalization of the modulo operator to negative numbers
 */
function mod(n, m) {
    return ((n % m) + m) % m;
}
function minMax(value, min, max) {
    return Math.max(Math.min(value, max), min);
}
function hasMinerals(store) {
    for (const resourceType in store) {
        if (resourceType != RESOURCE_ENERGY &&
            (store[resourceType] || 0) > 0) {
            return true;
        }
    }
    return false;
}
/**
 * Obtain the username of the player
 */
function getMyUsername() {
    for (const i in Game.rooms) {
        const room = Game.rooms[i];
        if (room.controller && room.controller.owner && room.controller.my) {
            return room.controller.owner.username;
        }
    }
    for (const i in Game.creeps) {
        const creep = Game.creeps[i];
        if (creep.owner) {
            return creep.owner.username;
        }
    }
    console.log("ERROR: Could not determine username. You can set this manually in src/settings/settings_user");
    return "ERROR: Could not determine username.";
}
function isAlly(username) {
    return (username == MUON ||
        username === MY_USERNAME ||
        (Memory.settings.allies || []).includes(username));
}
/** Names for server-managed players */
const NPC_NAMES = new Set(["Invader", "Source Keeper", "Screeps"]);
function isPlayer(username) {
    return !NPC_NAMES.has(username);
}
function hasJustSpawned() {
    return (_.keys(Overmind.colonies).length == 1 &&
        _.keys(Game.creeps).length == 0 &&
        _.keys(Game.spawns).length == 1);
}
function onPublicServer() {
    return Game.shard.name.includes("shard");
}
function onTrainingEnvironment() {
    return (!!Memory.reinforcementLearning && !!Memory.reinforcementLearning.enabled);
}
function getReinforcementLearningTrainingVerbosity() {
    if (Memory.reinforcementLearning) {
        if (Memory.reinforcementLearning.verbosity != undefined) {
            return Memory.reinforcementLearning.verbosity;
        }
    }
    return 0;
}
function bulleted(text, aligned = true, startWithNewLine = true) {
    if (text.length == 0) {
        return "";
    }
    const prefix = (startWithNewLine ?
        aligned ? alignedNewline
            : "\n"
        : "") + bullet;
    if (aligned) {
        return prefix + text.join(alignedNewline + bullet);
    }
    else {
        return prefix + text.join("\n" + bullet);
    }
}
/**
 * Create column-aligned text array from object with string key/values
 */
function toColumns(obj, opts = {}) {
    _.defaults(opts, {
        padChar: " ", // Character to pad with, e.g. "." would be key........val
        justify: false, // Right align values column?
    });
    const ret = [];
    const keyPadding = _.max(_.map(_.keys(obj), (str) => str.length)) + 1;
    const valPadding = _.max(_.mapValues(obj, (str) => str.length));
    for (const key in obj) {
        if (opts.justify) {
            ret.push(key.padEnd(keyPadding, opts.padChar) +
                obj[key].padStart(valPadding, opts.padChar));
        }
        else {
            ret.push(key.padEnd(keyPadding, opts.padChar) + obj[key]);
        }
    }
    return ret;
}
/**
 * Merges a list of store-like objects, summing overlapping keys. Useful for calculating assets from multiple sources
 */
function mergeSum(...stores) {
    var _a;
    const ret = {};
    for (const store of stores) {
        for (const [key, amount] of (Object.entries(store))) {
            (_a = ret[key]) !== null && _a !== void 0 ? _a : (ret[key] = 0);
            ret[key] += amount;
        }
    }
    return ret;
}
// export function coordName(coord: Coord): string {
// 	return coord.x + ':' + coord.y;
// }
// const CHARCODE_A = 65;
/**
 * Returns a compact two-character encoding of the coordinate
 */
// export function compactCoordName(coord: Coord): string {
// 	return String.fromCharCode(CHARCODE_A + coord.x, CHARCODE_A + coord.y);
// }
//
// export function derefCoords(coordName: string, roomName: string): RoomPosition {
// 	const [x, y] = coordName.split(':');
// 	return new RoomPosition(parseInt(x, 10), parseInt(y, 10), roomName);
// }
function posFromReadableName(str) {
    if (!str) {
        return;
    }
    const posName = _.first(str.match(/(E|W)\d+(N|S)\d+:\d+:\d+/g) || []);
    if (posName) {
        const [roomName, x, y] = posName.split(":");
        return new RoomPosition(parseInt(x, 10), parseInt(y, 10), roomName);
    }
}
function equalXYR(pos1, pos2) {
    return (pos1.x == pos2.x && pos1.y == pos2.y && pos1.roomName == pos2.roomName);
}
/** Equivalent to Object.values, but preserving the types */
function values(obj) {
    return Object.values(obj);
}
/** Equivalent to Object.entries, but preserving the types */
function entries(obj) {
    return Object.entries(obj);
}
/**
 * Equivalent to lodash.minBy() method
 */
function minBy(objects, iteratee) {
    let minObj;
    let minVal = Infinity;
    let val;
    for (const obj of objects) {
        val = iteratee(obj);
        if (val !== false && val < minVal) {
            minVal = val;
            minObj = obj;
        }
    }
    return minObj;
}
/**
 * Equivalent to lodash.maxBy() method
 */
function maxBy(objects, iteratee) {
    let maxObj;
    let maxVal = -Infinity;
    let val;
    for (const obj of objects) {
        val = iteratee(obj);
        if (val !== false && val > maxVal) {
            maxVal = val;
            maxObj = obj;
        }
    }
    return maxObj;
}
/**
 * Return whether the IVM is enabled
 */
function isIVM() {
    return typeof Game.cpu.getHeapStatistics === "function";
}
/**
 * Generate a randomly-offset cache expiration time
 */
function getCacheExpiration(timeout, offset = 5) {
    return (Game.time + timeout + Math.round(Math.random() * offset * 2 - offset));
}
const hexChars = "0123456789abcdef";
/**
 * Generate a random hex string of specified length
 */
function randomHex(length) {
    let result = "";
    for (let i = 0; i < length; i++) {
        result += hexChars[Math.floor(Math.random() * hexChars.length)];
    }
    return result;
}
/**
 * Compute an exponential moving average
 */
function ema(current, avg, window, zeroThreshold = 1e-9) {
    let newAvg = (current + (avg || 0) * (window - 1)) / window;
    if (zeroThreshold && Math.abs(newAvg) < zeroThreshold) {
        newAvg = 0;
    }
    return newAvg;
}
/**
 * Create a shallow copy of a 2D array
 */
function clone2DArray(a) {
    return _.map(a, (e) => e.slice());
}
/**
 * Rotate a square matrix in place clockwise by 90 degrees
 */
function rotateMatrix(matrix) {
    // reverse the rows
    matrix.reverse();
    // swap the symmetric elements
    for (let i = 0; i < matrix.length; i++) {
        for (let j = 0; j < i; j++) {
            const temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }
}
/**
 * Return a copy of a 2D array rotated by specified number of clockwise 90 turns
 */
function rotatedMatrix(matrix, clockwiseTurns) {
    const mat = clone2DArray(matrix);
    for (let i = 0; i < clockwiseTurns; i++) {
        rotateMatrix(mat);
    }
    return mat;
}
/**
 * A simple tick clock
 *
 * This function will count down ticks until it hits the period (the 0),
 * keeping it in sync with what a simpler `Game.time % period === 0`
 * would do.
 *
 * @param period The length of the clock period
 * @param phase The clock's initial phase
 */
function tickClock(period, phase = 0) {
    return ((Game.time - 1 + phase) % period) - period + 1;
}

// Global settings file containing player information
/**
 * My Screeps username; used for a variety of updating and communications purposes. (Changing this might break things.)
 */
const MUON = "Muon";
/**
 * Your username - you shouldn't need to change this.
 */
const MY_USERNAME = getMyUsername();
/**
 * Enable this to build from source including screeps-profiler. (This is separate from Overmind-Profiler.)
 */
const USE_SCREEPS_PROFILER = false;
/**
 * Profiling is incredibly expensive and can cause the script to time out. By setting this option, you can limit the
 * number of colonies that will be handled while profiling. Colonies above this limit do not get run.
 */
const PROFILER_COLONY_LIMIT = Math.ceil(Game.gcl.level / 2);
/**
 * While profiling, ensure these colonies are included in the randomly chosen ones specified by PROFILER_COLONY_LIMIT.
 */
const PROFILER_INCLUDE_COLONIES = [
/* 'E15S49'*/
];
/**
 * Enable this to wrap evaluations of constructor, init, and run phase for each colony in try...catch statemenets.
 */
const USE_TRY_CATCH = true;
/**
 * Enable this to suppress alerts of invalid flag color codes. (Don't do this unless you know what you're doing.)
 */
const SUPPRESS_INVALID_DIRECTIVE_ALERTS = false;
/**
 * Default controller signature; don't change this.
 * You can set your controller signature with the console command "setSignature()"
 * Operation will be penalized by skipping every 3rd tick for using a signature that does not contain the substring
 * "overmind" or the small-caps variant.
 */
const OVERMIND_SMALL_CAPS$2 = "\u1D0F\u1D20\u1D07\u0280\u1D0D\u026A\u0274\u1D05";
const DEFAULT_OVERMIND_SIGNATURE$1 = `«${OVERMIND_SMALL_CAPS$2}»`;
/**
 * If this is enabled, Memory.bot will default to true. This will not change the mode if already set - use setMode().
 */
const DEFAULT_OPERATION_MODE = "automatic";
/**
 * Limit how many rooms you can claim (for any shard)
 */
const MAX_SHARD_OWNED_ROOMS = {
    shard3: 3, // shard3 has a CPU limit of 20, only claim this many rooms
};
/**
 * Maximum limit for shards not specified in {@link MAX_SHARD_OWNED_ROOMS}
 */
const MAX_OWNED_ROOMS = Infinity;
/**
 * List of known shards for the server
 */
const SERVER_SHARDS$1 = ["shard0", "shard1", "shard2", "shard3"];
/**
 * The amount of credits that Overmind will try to keep in the bank. Default:
 * Private servers: 1,000 (will spend aggressively)
 * Public servers: 100,000 if you are below RCL 10, otherwise 1,000,000.
 */
const RESERVE_CREDITS = onPublicServer() ?
    Game.gcl.level >= 10 ?
        1e6
        : 1e5
    : 1000;
/**
 * The global Overmind object will be re-instantiated after this many ticks. In the meantime, refresh() is used.
 */
const NEW_OVERMIND_INTERVAL = onPublicServer() ? 20 : 5;
/**
 * How frequently should we log statistics
 */
const LOG_STATS_INTERVAL$1 = 60;
/**
 * Master scale for the RoomVisuals GUI // TODO: not plugged in yet
 */
const GUI_SCALE = 1.0;
/**
 * If this is set to true, a stripped-down version of Overmind suitable for training with my python screeps environment
 * will be run instead. The main loop will be disabled and creeps will be controlled based on serialized actions
 * communicated to them from the RL model through memory.
 * WARNING: enabling RL_TRAINING_MODE will wipe the contents of your memory!
 */
const RL_TRAINING_MODE = onTrainingEnvironment();
/**
 * Configure how much stuff gets logged to console
 * 0: no logging
 * 1: log every 100th, 101th tick
 * 2: log every tick
 */
const RL_TRAINING_VERBOSITY = getReinforcementLearningTrainingVerbosity();
// #region Terminal Network thresholds
const TERMINAL_NETWORK_DEFAULT_TARGET = 2 * LAB_MINERAL_CAPACITY + 1000; // 7000 is default for most resources
const TERMINAL_NETWORK_DEFAULT_SURPLUS = 15 * LAB_MINERAL_CAPACITY; // 45000 is default surplus
const TERMINAL_NETWORK_ENERGY_SURPLUS = 500000;
const TERMINAL_NETWORK_DEFAULT_TOLERANCE = LAB_MINERAL_CAPACITY / 3; // 1000 is default tolerance
const TERMINAL_NETWORK_THRESHOLDS = {
    default: {
        target: TERMINAL_NETWORK_DEFAULT_TARGET,
        tolerance: TERMINAL_NETWORK_DEFAULT_TOLERANCE,
        surplus: TERMINAL_NETWORK_DEFAULT_SURPLUS,
    },
    /** thresholds for stuff you don't need but don't not want */
    dontCare: {
        target: 0,
        tolerance: 0,
        surplus: undefined,
    },
    /** thresholds for stuff you actively don't want */
    dontWant: {
        target: 0,
        tolerance: 0,
        surplus: 0,
    },
    boostsT1: {
        target: TERMINAL_NETWORK_DEFAULT_TARGET + 2 * LAB_MINERAL_CAPACITY, // max: 7000 + 2*6000 = 19000 -> 14% capacity for all T1
        surplus: 25000,
        tolerance: TERMINAL_NETWORK_DEFAULT_TARGET + 2 * LAB_MINERAL_CAPACITY,
    },
    boostsT2: {
        target: TERMINAL_NETWORK_DEFAULT_TARGET + 2 * LAB_MINERAL_CAPACITY, // max: 7000 + 2*6000 = 19000 -> 14% capacity for all T2
        surplus: 25000,
        tolerance: TERMINAL_NETWORK_DEFAULT_TARGET + 2 * LAB_MINERAL_CAPACITY,
    },
    boostsT3: {
        target: TERMINAL_NETWORK_DEFAULT_TARGET + 10 * LAB_MINERAL_CAPACITY, // max: 7000 + 2*30000 = 67000 -> 51% capacity for all T3
        surplus: 75000,
        tolerance: TERMINAL_NETWORK_DEFAULT_TOLERANCE + 10 * LAB_MINERAL_CAPACITY,
    },
    intermediates: {
        target: LAB_MINERAL_CAPACITY + 1000,
        surplus: 3 * LAB_MINERAL_CAPACITY,
        tolerance: LAB_MINERAL_CAPACITY / 3,
    },
    /** this takes a long time to make so let's keep a bit more of it around */
    [RESOURCE_HYDROXIDE]: {
        target: TERMINAL_NETWORK_DEFAULT_TARGET,
        tolerance: TERMINAL_NETWORK_DEFAULT_TOLERANCE,
        surplus: TERMINAL_NETWORK_DEFAULT_SURPLUS,
    },
    [RESOURCE_GHODIUM]: {
        target: 10000,
        tolerance: 5000,
        surplus: 20000,
    },
    [RESOURCE_POWER]: {
        // low target ensures power gets spread among room (cheaper than shipping energy)
        target: 2500,
        tolerance: 2500,
        surplus: undefined,
    },
    [RESOURCE_OPS]: {
        target: 2500,
        tolerance: 2500,
        surplus: undefined,
    },
};
// #endregion
/**
 * This will get used as defaults when building Memory.settings.
 * Use it to provide specific values when spawning/respawning.
 */
const DEFAULT_SETTINGS = {};

var config = /*#__PURE__*/Object.freeze({
	__proto__: null,
	DEFAULT_OPERATION_MODE: DEFAULT_OPERATION_MODE,
	DEFAULT_OVERMIND_SIGNATURE: DEFAULT_OVERMIND_SIGNATURE$1,
	DEFAULT_SETTINGS: DEFAULT_SETTINGS,
	GUI_SCALE: GUI_SCALE,
	LOG_STATS_INTERVAL: LOG_STATS_INTERVAL$1,
	MAX_OWNED_ROOMS: MAX_OWNED_ROOMS,
	MAX_SHARD_OWNED_ROOMS: MAX_SHARD_OWNED_ROOMS,
	MUON: MUON,
	MY_USERNAME: MY_USERNAME,
	NEW_OVERMIND_INTERVAL: NEW_OVERMIND_INTERVAL,
	PROFILER_COLONY_LIMIT: PROFILER_COLONY_LIMIT,
	PROFILER_INCLUDE_COLONIES: PROFILER_INCLUDE_COLONIES,
	RESERVE_CREDITS: RESERVE_CREDITS,
	RL_TRAINING_MODE: RL_TRAINING_MODE,
	RL_TRAINING_VERBOSITY: RL_TRAINING_VERBOSITY,
	SERVER_SHARDS: SERVER_SHARDS$1,
	SUPPRESS_INVALID_DIRECTIVE_ALERTS: SUPPRESS_INVALID_DIRECTIVE_ALERTS,
	TERMINAL_NETWORK_DEFAULT_SURPLUS: TERMINAL_NETWORK_DEFAULT_SURPLUS,
	TERMINAL_NETWORK_DEFAULT_TARGET: TERMINAL_NETWORK_DEFAULT_TARGET,
	TERMINAL_NETWORK_DEFAULT_TOLERANCE: TERMINAL_NETWORK_DEFAULT_TOLERANCE,
	TERMINAL_NETWORK_ENERGY_SURPLUS: TERMINAL_NETWORK_ENERGY_SURPLUS,
	TERMINAL_NETWORK_THRESHOLDS: TERMINAL_NETWORK_THRESHOLDS,
	USE_SCREEPS_PROFILER: USE_SCREEPS_PROFILER,
	USE_TRY_CATCH: USE_TRY_CATCH
});

let SERVER_SHARDS = SERVER_SHARDS$1;
if (!SERVER_SHARDS.includes(Game.shard.name)) {
    console.log(`ERROR Current shard ${Game.shard.name} isn't in the list of server shards: ${SERVER_SHARDS}!`);
    SERVER_SHARDS = [Game.shard.name];
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

/* eslint-disable */

// This is a modified version of screeps-profiler taken from https://github.com/samogot/screeps-profiler

let usedOnStart = 0;
let enabled = false;
let depth = 0;
let parentFn = "(tick)";

function AlreadyWrappedError() {
	this.name = "AlreadyWrappedError";
	this.message = "Error attempted to double wrap a function.";
	this.stack = new Error().stack;
}

function setupProfiler() {
	depth = 0; // reset depth, this needs to be done each tick.
	parentFn = "(tick)";
	Game.profiler = {
		stream(duration, filter) {
			setupMemory("stream", duration || 10, filter);
		},
		email(duration, filter) {
			setupMemory("email", duration || 100, filter);
		},
		profile(duration, filter) {
			setupMemory("profile", duration || 100, filter);
		},
		background(filter) {
			setupMemory("background", false, filter);
		},
		callgrind(duration, filter) {
			setupMemory("callgrind", duration || 100, filter);
		},
		restart() {
			if (Profiler.isProfiling()) {
				const filter = Memory.screepsProfiler.filter;
				let duration = false;
				if (!!Memory.screepsProfiler.disableTick) {
					// Calculate the original duration, profile is enabled on the tick after the first call,
					// so add 1.
					duration =
						Memory.screepsProfiler.disableTick -
						Memory.screepsProfiler.enabledTick +
						1;
				}
				const type = Memory.screepsProfiler.type;
				setupMemory(type, duration, filter);
			}
		},
		reset: resetMemory,
		output: Profiler.output,
	};

	overloadCPUCalc();
}

function setupMemory(profileType, duration, filter) {
	resetMemory();
	const disableTick =
		Number.isInteger(duration) ? Game.time + duration : false;
	if (!Memory.screepsProfiler) {
		Memory.screepsProfiler = {
			map: {},
			totalTime: 0,
			enabledTick: Game.time + 1,
			disableTick,
			type: profileType,
			filter,
		};
	}
}

function resetMemory() {
	Memory.screepsProfiler = null;
}

function overloadCPUCalc() {
	if (Game.rooms.sim) {
		usedOnStart = 0; // This needs to be reset, but only in the sim.
		Game.cpu.getUsed = function getUsed() {
			return performance.now() - usedOnStart;
		};
	}
}

function getFilter() {
	return Memory.screepsProfiler.filter;
}

const functionBlackList = [
	"getUsed", // Let's avoid wrapping this... may lead to recursion issues and should be inexpensive.
	"constructor", // es6 class constructors need to be called with `new`
];

const commonProperties = ["length", "name", "arguments", "caller", "prototype"];

function wrapFunction(name, originalFunction) {
	if (originalFunction.profilerWrapped) {
		throw new AlreadyWrappedError();
	}

	function wrappedFunction() {
		if (Profiler.isProfiling()) {
			const nameMatchesFilter = name === getFilter();
			const start = Game.cpu.getUsed();
			if (nameMatchesFilter) {
				depth++;
			}
			const curParent = parentFn;
			parentFn = name;
			let result;
			if (this && this.constructor === wrappedFunction) {
				// eslint-disable-next-line new-cap
				result = new originalFunction(...arguments);
			} else {
				result = originalFunction.apply(this, arguments);
			}
			parentFn = curParent;
			if (depth > 0 || !getFilter()) {
				const end = Game.cpu.getUsed();
				Profiler.record(name, end - start, parentFn);
			}
			if (nameMatchesFilter) {
				depth--;
			}
			return result;
		}

		if (this && this.constructor === wrappedFunction) {
			// eslint-disable-next-line new-cap
			return new originalFunction(...arguments);
		}
		return originalFunction.apply(this, arguments);
	}

	wrappedFunction.profilerWrapped = true;
	wrappedFunction.toString = () =>
		`// screeps-profiler wrapped function:\n${originalFunction.toString()}`;

	Object.getOwnPropertyNames(originalFunction).forEach((property) => {
		if (!commonProperties.includes(property)) {
			wrappedFunction[property] = originalFunction[property];
		}
	});

	return wrappedFunction;
}

function hookUpPrototypes() {
	Profiler.prototypes.forEach((proto) => {
		profileObjectFunctions(proto.val, proto.name);
	});
}

function profileObjectFunctions(object, label) {
	if (object.prototype) {
		profileObjectFunctions(object.prototype, label);
	}
	const objectToWrap = object;

	Object.getOwnPropertyNames(objectToWrap).forEach((functionName) => {
		const extendedLabel = `${label}.${functionName}`;

		const isBlackListed = functionBlackList.indexOf(functionName) !== -1;
		if (isBlackListed) {
			return;
		}

		const descriptor = Object.getOwnPropertyDescriptor(
			objectToWrap,
			functionName
		);
		if (!descriptor) {
			return;
		}

		const hasAccessor = descriptor.get || descriptor.set;
		if (hasAccessor) {
			const configurable = descriptor.configurable;
			if (!configurable) {
				return;
			}

			const profileDescriptor = {};

			if (descriptor.get) {
				const extendedLabelGet = `${extendedLabel}:get`;
				profileDescriptor.get = profileFunction(
					descriptor.get,
					extendedLabelGet
				);
			}

			if (descriptor.set) {
				const extendedLabelSet = `${extendedLabel}:set`;
				profileDescriptor.set = profileFunction(
					descriptor.set,
					extendedLabelSet
				);
			}

			Object.defineProperty(
				objectToWrap,
				functionName,
				profileDescriptor
			);
			return;
		}

		const isFunction = typeof descriptor.value === "function";
		if (!isFunction || !descriptor.writable) {
			return;
		}
		const originalFunction = objectToWrap[functionName];
		objectToWrap[functionName] = profileFunction(
			originalFunction,
			extendedLabel
		);
	});

	return objectToWrap;
}

function profileFunction(fn, functionName) {
	const fnName = functionName || fn.name;
	if (!fnName) {
		console.log("Couldn't find a function name for - ", fn);
		console.log("Will not profile this function.");
		return fn;
	}

	return wrapFunction(fnName, fn);
}

const Profiler = {
	printProfile() {
		console.log(Profiler.output());
	},

	emailProfile() {
		Game.notify(Profiler.output(1000));
	},

	downloadCallgrind() {
		const id = `id${Math.random()}`;
		/* eslint-disable */
		const download = `
<script>
var element = document.getElementById('${id}');
if (!element) {
element = document.createElement('a');
element.setAttribute('id', '${id}');
element.setAttribute('href', 'data:text/plain;charset=utf-8,${encodeURIComponent(
			Profiler.callgrind()
		)}');
element.setAttribute('download', 'callgrind.out.${Game.time}');

element.style.display = 'none';
document.body.appendChild(element);

element.click();
}
</script>
  `;
		/* eslint-enable */
		console.log(
			download
				.split("\n")
				.map((s) => s.trim())
				.join("")
		);
	},

	callgrind() {
		const elapsedTicks = Game.time - Memory.screepsProfiler.enabledTick + 1;
		Memory.screepsProfiler.map["(tick)"].calls = elapsedTicks;
		Memory.screepsProfiler.map["(tick)"].time =
			Memory.screepsProfiler.totalTime;
		Profiler.checkMapItem("(root)");
		Memory.screepsProfiler.map["(root)"].calls = 1;
		Memory.screepsProfiler.map["(root)"].time =
			Memory.screepsProfiler.totalTime;
		Profiler.checkMapItem(
			"(tick)",
			Memory.screepsProfiler.map["(root)"].subs
		);
		Memory.screepsProfiler.map["(root)"].subs["(tick)"].calls =
			elapsedTicks;
		Memory.screepsProfiler.map["(root)"].subs["(tick)"].time =
			Memory.screepsProfiler.totalTime;
		let body = `events: ns\nsummary: ${Math.round(
			Memory.screepsProfiler.totalTime * 1000000
		)}\n`;
		for (const fnName of Object.keys(Memory.screepsProfiler.map)) {
			const fn = Memory.screepsProfiler.map[fnName];
			let callsBody = "";
			let callsTime = 0;
			for (const callName of Object.keys(fn.subs)) {
				const call = fn.subs[callName];
				const ns = Math.round(call.time * 1000000);
				callsBody += `cfn=${callName}\ncalls=${call.calls} 1\n1 ${ns}\n`;
				callsTime += call.time;
			}
			body += `\nfn=${fnName}\n1 ${Math.round(
				(fn.time - callsTime) * 1000000
			)}\n${callsBody}`;
		}
		return body;
	},

	output(passedOutputLengthLimit) {
		const outputLengthLimit = passedOutputLengthLimit || 1000;
		if (!Memory.screepsProfiler || !Memory.screepsProfiler.enabledTick) {
			return "Profiler not active.";
		}

		const endTick = Math.min(
			Memory.screepsProfiler.disableTick || Game.time,
			Game.time
		);
		const startTick = Memory.screepsProfiler.enabledTick;
		const elapsedTicks = endTick - startTick + 1;
		const header = "calls\t\ttime\t\tavg\t\tfunction";
		const footer = [
			`Ticks: ${elapsedTicks}`,
			`Total: ${Memory.screepsProfiler.totalTime.toFixed(2)}`,
			`Avg: ${(Memory.screepsProfiler.totalTime / elapsedTicks).toFixed(
				2
			)}`,
		].join("\t");

		const lines = [header];
		let currentLength = header.length + 1 + footer.length;
		const allLines = Profiler.lines();
		let done = false;
		while (!done && allLines.length) {
			const line = allLines.shift();
			// each line added adds the line length plus a new line character.
			if (currentLength + line.length + 1 < outputLengthLimit) {
				lines.push(line);
				currentLength += line.length + 1;
			} else {
				done = true;
			}
		}
		lines.push(footer);
		return lines.join("\n");
	},

	lines() {
		const stats = Object.keys(Memory.screepsProfiler.map)
			.map((functionName) => {
				const functionCalls = Memory.screepsProfiler.map[functionName];
				return {
					name: functionName,
					calls: functionCalls.calls,
					totalTime: functionCalls.time,
					averageTime: functionCalls.time / functionCalls.calls,
				};
			})
			.sort((val1, val2) => {
				return val2.totalTime - val1.totalTime;
			});

		const lines = stats.map((data) => {
			return [
				data.calls,
				data.totalTime.toFixed(1),
				data.averageTime.toFixed(3),
				data.name,
			].join("\t\t");
		});

		return lines;
	},

	prototypes: [
		{ name: "Game", val: commonjsGlobal.Game },
		{ name: "Map", val: commonjsGlobal.Game.map },
		{ name: "Market", val: commonjsGlobal.Game.market },
		{ name: "PathFinder", val: commonjsGlobal.PathFinder },
		{ name: "RawMemory", val: commonjsGlobal.RawMemory },
		{ name: "ConstructionSite", val: commonjsGlobal.ConstructionSite },
		{ name: "Creep", val: commonjsGlobal.Creep },
		{ name: "Flag", val: commonjsGlobal.Flag },
		{ name: "Mineral", val: commonjsGlobal.Mineral },
		{ name: "Nuke", val: commonjsGlobal.Nuke },
		{ name: "OwnedStructure", val: commonjsGlobal.OwnedStructure },
		{ name: "CostMatrix", val: commonjsGlobal.PathFinder.CostMatrix },
		{ name: "Resource", val: commonjsGlobal.Resource },
		{ name: "Room", val: commonjsGlobal.Room },
		{ name: "RoomObject", val: commonjsGlobal.RoomObject },
		{ name: "RoomPosition", val: commonjsGlobal.RoomPosition },
		{ name: "RoomVisual", val: commonjsGlobal.RoomVisual },
		{ name: "Source", val: commonjsGlobal.Source },
		{ name: "Structure", val: commonjsGlobal.Structure },
		{ name: "StructureContainer", val: commonjsGlobal.StructureContainer },
		{ name: "StructureController", val: commonjsGlobal.StructureController },
		{ name: "StructureExtension", val: commonjsGlobal.StructureExtension },
		{ name: "StructureExtractor", val: commonjsGlobal.StructureExtractor },
		{ name: "StructureKeeperLair", val: commonjsGlobal.StructureKeeperLair },
		{ name: "StructureLab", val: commonjsGlobal.StructureLab },
		{ name: "StructureLink", val: commonjsGlobal.StructureLink },
		{ name: "StructureNuker", val: commonjsGlobal.StructureNuker },
		{ name: "StructureObserver", val: commonjsGlobal.StructureObserver },
		{ name: "StructurePowerBank", val: commonjsGlobal.StructurePowerBank },
		{ name: "StructurePowerSpawn", val: commonjsGlobal.StructurePowerSpawn },
		{ name: "StructurePortal", val: commonjsGlobal.StructurePortal },
		{ name: "StructureRampart", val: commonjsGlobal.StructureRampart },
		{ name: "StructureRoad", val: commonjsGlobal.StructureRoad },
		{ name: "StructureSpawn", val: commonjsGlobal.StructureSpawn },
		{ name: "StructureStorage", val: commonjsGlobal.StructureStorage },
		{ name: "StructureTerminal", val: commonjsGlobal.StructureTerminal },
		{ name: "StructureTower", val: commonjsGlobal.StructureTower },
		{ name: "StructureWall", val: commonjsGlobal.StructureWall },
	],

	checkMapItem(functionName, map = Memory.screepsProfiler.map) {
		if (!map[functionName]) {
			// eslint-disable-next-line no-param-reassign
			map[functionName] = {
				time: 0,
				calls: 0,
				subs: {},
			};
		}
	},

	record(functionName, time, parent) {
		this.checkMapItem(functionName);
		Memory.screepsProfiler.map[functionName].calls++;
		Memory.screepsProfiler.map[functionName].time += time;
		if (parent) {
			this.checkMapItem(parent);
			this.checkMapItem(
				functionName,
				Memory.screepsProfiler.map[parent].subs
			);
			Memory.screepsProfiler.map[parent].subs[functionName].calls++;
			Memory.screepsProfiler.map[parent].subs[functionName].time += time;
		}
	},

	endTick() {
		if (Game.time >= Memory.screepsProfiler.enabledTick) {
			const cpuUsed = Game.cpu.getUsed();
			Memory.screepsProfiler.totalTime += cpuUsed;
			Profiler.report();
		}
	},

	report() {
		if (Profiler.shouldPrint()) {
			Profiler.printProfile();
		} else if (Profiler.shouldEmail()) {
			Profiler.emailProfile();
		} else if (Profiler.shouldCallgrind()) {
			Profiler.downloadCallgrind();
		}
	},

	isProfiling() {
		if (!enabled || !Memory.screepsProfiler) {
			return false;
		}
		return (
			!Memory.screepsProfiler.disableTick ||
			Game.time <= Memory.screepsProfiler.disableTick
		);
	},

	type() {
		return Memory.screepsProfiler.type;
	},

	shouldPrint() {
		const streaming = Profiler.type() === "stream";
		const profiling = Profiler.type() === "profile";
		const onEndingTick = Memory.screepsProfiler.disableTick === Game.time;
		return streaming || (profiling && onEndingTick);
	},

	shouldEmail() {
		return (
			Profiler.type() === "email" &&
			Memory.screepsProfiler.disableTick === Game.time
		);
	},

	shouldCallgrind() {
		return (
			Profiler.type() === "callgrind" &&
			Memory.screepsProfiler.disableTick === Game.time
		);
	},
};

var screepsProfiler = {
	wrap(callback) {
		if (enabled) {
			setupProfiler();
		}

		if (Profiler.isProfiling()) {
			usedOnStart = Game.cpu.getUsed();

			// Commented lines are part of an on going experiment to keep the profiler
			// performant, and measure certain types of overhead.

			// var callbackStart = Game.cpu.getUsed();
			const returnVal = callback();
			// var callbackEnd = Game.cpu.getUsed();
			Profiler.endTick();
			// var end = Game.cpu.getUsed();

			// var profilerTime = (end - start) - (callbackEnd - callbackStart);
			// var callbackTime = callbackEnd - callbackStart;
			// var unaccounted = end - profilerTime - callbackTime;
			// console.log('total-', end, 'profiler-', profilerTime, 'callbacktime-',
			// callbackTime, 'start-', start, 'unaccounted', unaccounted);
			return returnVal;
		}

		return callback();
	},

	enable() {
		enabled = true;
		hookUpPrototypes();
	},

	output: Profiler.output,
	// callgrind: Profiler.callgrind,

	registerObject: profileObjectFunctions,
	registerFN: profileFunction,
	registerClass: profileObjectFunctions,
};

var profiler = /*@__PURE__*/getDefaultExportFromCjs(screepsProfiler);

function profile(target, key, _descriptor) {
    {
        return;
    }
}

var Log_1;
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["FATAL"] = -1] = "FATAL";
    LogLevel[LogLevel["ERROR"] = 0] = "ERROR";
    LogLevel[LogLevel["WARNING"] = 1] = "WARNING";
    LogLevel[LogLevel["ALERT"] = 2] = "ALERT";
    LogLevel[LogLevel["INFO"] = 3] = "INFO";
    LogLevel[LogLevel["DEBUG"] = 4] = "DEBUG";
})(LogLevel || (LogLevel = {}));
/**
 * Default debug level for log output
 */
const LOG_LEVEL = LogLevel.INFO;
/**
 * Prepend log output with current tick number.
 */
const LOG_PRINT_TICK = true;
/**
 * Prepend log output with source line.
 */
const LOG_PRINT_LINES = false;
/**
 * Maximum padding for source links (for aligning log output).
 */
const LOG_MAX_PAD = 100;
// <caller> (<source>:<line>:<column>)
const stackLineRe = /([^ ]*) \(([^:]*):([0-9]*):([0-9]*)\)/;
const fatalColor = "#d65156";
function resolve(fileLine) {
    var _a, _b;
    const split = _.trim(fileLine).match(stackLineRe);
    if (!split || !Log.sourceMap) {
        return { compiled: fileLine, final: fileLine };
    }
    const pos = {
        column: parseInt(split[4], 10),
        line: parseInt(split[3], 10),
    };
    const original = Log.sourceMap.originalPositionFor(pos);
    const line = `${split[1]} (${original.source}:${original.line})`;
    const out = {
        caller: split[1],
        compiled: fileLine,
        final: line,
        line: (_a = original.line) !== null && _a !== void 0 ? _a : undefined,
        original: line,
        path: (_b = original.source) !== null && _b !== void 0 ? _b : undefined,
    };
    return out;
}
function makeVSCLink(pos) {
    {
        return pos.final;
    }
}
function tooltip(str, tooltip) {
    return `<abbr title='${tooltip}'>${str}</abbr>`;
}
function time() {
    return color(Game.time.toString(), "gray");
}
/**
 * Log provides methods for displaying pretty-printed text into the Screeps console
 */
let Log = Log_1 = class Log {
    constructor() {
        this._maxFileString = 0;
    }
    static loadSourceMap() {
        // try {
        // 	// tslint:disable-next-line
        // 	const map = require('main.js.map');
        // 	if (map) {
        // 		Log.sourceMap = new SourceMapConsumer(map);
        // 	}
        // } catch (err) {
        console.log("Source mapping deprecated.");
        // }
    }
    get level() {
        var _a;
        return (_a = Memory.settings.log.level) !== null && _a !== void 0 ? _a : LOG_LEVEL;
    }
    setLogLevel(value) {
        let changeValue = true;
        switch (value) {
            case LogLevel.ERROR:
                console.log(`Logging level set to ${value}. Displaying: ERROR.`);
                break;
            case LogLevel.WARNING:
                console.log(`Logging level set to ${value}. Displaying: ERROR, WARNING.`);
                break;
            case LogLevel.ALERT:
                console.log(`Logging level set to ${value}. Displaying: ERROR, WARNING, ALERT.`);
                break;
            case LogLevel.INFO:
                console.log(`Logging level set to ${value}. Displaying: ERROR, WARNING, ALERT, INFO.`);
                break;
            case LogLevel.DEBUG:
                console.log(`Logging level set to ${value}. Displaying: ERROR, WARNING, ALERT, INFO, DEBUG.`);
                break;
            default:
                console.log(`Invalid input: ${value}. Loging level can be set to integers between ` +
                    LogLevel.ERROR +
                    " and " +
                    LogLevel.DEBUG +
                    ", inclusive.");
                changeValue = false;
                break;
        }
        if (changeValue) {
            Memory.settings.log.level = value;
        }
    }
    get showSource() {
        var _a;
        return (_a = Memory.settings.log.showSource) !== null && _a !== void 0 ? _a : LOG_PRINT_LINES;
    }
    set showSource(value) {
        Memory.settings.log.showSource = value;
    }
    get showTick() {
        var _a;
        return (_a = Memory.settings.log.showTick) !== null && _a !== void 0 ? _a : LOG_PRINT_TICK;
    }
    set showTick(value) {
        Memory.settings.log.showTick = value;
    }
    trace(error) {
        if (this.level >= LogLevel.ERROR && error.stack) {
            console.log(this.resolveStack(error.stack));
        }
        return this;
    }
    throw(e) {
        console.log.apply(this, this.buildArguments(LogLevel.FATAL).concat([
            color(e.toString(), fatalColor),
        ]));
    }
    _log(level, args) {
        // console.log(`_log: ${typeof args}`);
        // args = _.flatten(args);
        for (let i = 0; i < args.length; i++) {
            // console.log(`_log: ${typeof args[i]} ${Array.isArray(args[i])}`);
            const argFunc = args[i];
            if (_.isFunction(argFunc)) {
                // console.log(`_log: argFunc: ${argFunc}`);
                const arg = argFunc();
                args.splice(i, 1, arg);
            }
        }
        console.log.apply(this, this.buildArguments(level).concat([].slice.call(args)));
    }
    error(...args) {
        if (this.level >= LogLevel.ERROR) {
            this._log(LogLevel.ERROR, args);
        }
        return undefined;
    }
    warning(...args) {
        if (this.level >= LogLevel.WARNING) {
            this._log(LogLevel.WARNING, args);
        }
        return undefined;
    }
    alert(...args) {
        if (this.level >= LogLevel.ALERT) {
            this._log(LogLevel.ALERT, args);
        }
        return undefined;
    }
    notify(message) {
        this.alert(message);
        Game.notify(message);
        return undefined;
    }
    info(...args) {
        if (this.level >= LogLevel.INFO) {
            this._log(LogLevel.INFO, args);
        }
        return undefined;
    }
    debug(...args) {
        if (this.level >= LogLevel.DEBUG) {
            this._log(LogLevel.DEBUG, args);
        }
    }
    debugCreep(creep, ...args) {
        if (creep.memory && creep.memory.debug) {
            this.info(`${creep.name}@${creep.pos.print}: `, ...args);
        }
    }
    printObject(obj) {
        this._log(LogLevel.DEBUG, [JSON.stringify(obj)]);
    }
    getFileLine(upStack = 4) {
        const stack = new Error("").stack;
        if (stack) {
            const lines = stack.split("\n");
            if (lines.length > upStack) {
                const originalLines = _.drop(lines, upStack).map(resolve);
                const hoverText = _.map(originalLines, "final").join("&#10;");
                return this.adjustFileLine(originalLines[0].final, tooltip(makeVSCLink(originalLines[0]), hoverText));
            }
        }
        return "";
    }
    buildArguments(level) {
        const out = [];
        switch (level) {
            case LogLevel.ERROR:
                out.push(color("ERROR  ", "red"));
                break;
            case LogLevel.WARNING:
                out.push(color("WARNING", "orange"));
                break;
            case LogLevel.ALERT:
                out.push(color("ALERT  ", "yellow"));
                break;
            case LogLevel.INFO:
                out.push(color("INFO   ", "green"));
                break;
            case LogLevel.DEBUG:
                out.push(color("DEBUG  ", "gray"));
                break;
            case LogLevel.FATAL:
                out.push(color("FATAL  ", fatalColor));
                break;
        }
        if (this.showTick) {
            out.push(time());
        }
        if (this.showSource && level <= LogLevel.ERROR) {
            out.push(this.getFileLine());
        }
        return out;
    }
    resolveStack(stack) {
        if (!Log_1.sourceMap) {
            return stack;
        }
        return _.map(stack.split("\n").map(resolve), "final").join("\n");
    }
    adjustFileLine(visibleText, line) {
        const newPad = Math.max(visibleText.length, this._maxFileString);
        this._maxFileString = Math.min(newPad, LOG_MAX_PAD);
        return `|${_.padRight(line, line.length + this._maxFileString - visibleText.length, " ")}|`;
    }
};
Log = Log_1 = __decorate$1([
    profile
], Log);
const log = new Log();

const MAX_ACTIVE_SEGMENTS = 10;
const DefaultSegmenterMemory = {
    activeSegments: [],
    activeForeignSegment: undefined,
    publicSegments: [],
};
const SEGMENTS = {
    stats: 55,
    reinforcementLearning: 70,
    remoteDebugger: 97,
    assimilator: 98,
    version: 99,
};
Memory.segmenter = _.defaultsDeep(Memory.segmenter, DefaultSegmenterMemory);
/**
 * The segmenter module controls public and private segment memory access
 */
let Segmenter = class Segmenter {
    static get memory() {
        return Memory.segmenter;
    }
    static debug(...args) {
    }
    static requestSegments(...ids) {
        for (const id of ids) {
            if (!this.memory.activeSegments.includes(id)) {
                this.memory.activeSegments.push(id);
                if (this.memory.activeSegments.length > MAX_ACTIVE_SEGMENTS) {
                    const removeSegment = this.memory.activeSegments.shift();
                    console.log(`Maximum active segments reached. Discarding segment ${removeSegment}.`);
                }
            }
        }
    }
    static getSegment(id) {
        var _a, _b;
        this.debug(`getSegment: segment ${id}: atime: ${this.cache.lastAccessed[id]}, mtime: ${this.cache.lastAccessed[id]}`);
        if (((_a = this.cache.lastAccessed[id]) !== null && _a !== void 0 ? _a : 0) >=
            ((_b = this.cache.lastModified[id]) !== null && _b !== void 0 ? _b : 0) &&
            this.cache.segments[id]) {
            this.debug(`getSegment: returning cached segment ${id}`);
            return this.cache.segments[id];
        }
        const str = RawMemory.segments[id];
        this.debug(`getSegment: raw ${str}`);
        let segment;
        try {
            segment = JSON.parse(str);
        }
        catch (e) {
            log.warning(`Creating new object for RawMemory.segments[${id}]`);
            this.debug(`error: ${e}, str: ${str}`);
            segment = {};
            this.cache.segments[id] = segment;
            this.cache.lastModified[id] = Game.time;
        }
        this.cache.segments[id] = segment;
        this.cache.lastAccessed[id] = Game.time;
        this.debug(`getSegment: returning parsed segment ${id}`);
        return this.cache.segments[id];
    }
    static getSegmentProperty(id, key) {
        const segment = this.getSegment(id);
        const obj = segment[key];
        // eslint-disable-next-line
        return obj;
    }
    static setSegment(id, value) {
        this.cache.segments[id] = value;
        this.cache.lastModified[id] = Game.time;
        this.debug(`setSegment: segment ${id}: mtime: ${this.cache.lastModified[id]}, value: ${JSON.stringify(value)}`);
    }
    static setSegmentProperty(id, key, value) {
        const segment = this.getSegment(id);
        segment[key] = value;
        this.cache.lastModified[id] = Game.time;
    }
    static requestForeignSegment(username, id) {
        if (username) {
            this.memory.activeForeignSegment = {
                username: username,
                id: id,
            };
        }
    }
    static markSegmentAsPublic(id) {
        if (!this.memory.publicSegments.includes(id)) {
            this.memory.publicSegments.push(id);
        }
    }
    static getForeignSegment(expectedUsername, expectedId) {
        if (!RawMemory.foreignSegment) {
            return undefined;
        }
        const { id, username, data } = RawMemory.foreignSegment;
        if (expectedUsername !== username || expectedId !== id) {
            log.warning(`Segmenter: loaded foreign segment doesn't match expected! (${id}/${expectedId}, ${username}/${expectedUsername})`);
            return undefined;
        }
        let segment;
        try {
            segment = JSON.parse(data);
            return segment;
        }
        catch (e) {
            log.warning(`Segmenter: Could not parse RawMemory.foreignSegment.data!`);
        }
    }
    static getForeignSegmentProperty(expectedUsername, expectedId, key) {
        var _a;
        const { id, username, data } = (_a = RawMemory.foreignSegment) !== null && _a !== void 0 ? _a : {};
        if (expectedUsername !== username || expectedId !== id) {
            log.warning(`Segmenter: loaded foreign segment doesn't match expected! (${id}/${expectedId}, ${username}/${expectedUsername})`);
            return undefined;
        }
        let segment;
        try {
            segment = JSON.parse(data);
            if (segment) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                return segment[key];
            }
        }
        catch (e) {
            log.warning(`Segmenter: Could not parse RawMemory.foreignSegment.data!`);
        }
        return undefined;
    }
    static run() {
        // Set active, public, and foreign segments
        RawMemory.setActiveSegments(this.memory.activeSegments);
        RawMemory.setPublicSegments(this.memory.publicSegments);
        if (this.memory.activeForeignSegment) {
            RawMemory.setActiveForeignSegment(this.memory.activeForeignSegment.username, this.memory.activeForeignSegment.id);
        }
        else {
            RawMemory.setActiveForeignSegment(null);
        }
        // Write things that have been modified this tick to memory
        const start = Game.cpu.getUsed();
        let count = 0;
        for (const id in this.cache.lastModified) {
            this.debug(`checking segment ${id} for writing: ${this.cache.lastModified[id]}`);
            if (this.cache.lastModified[id] == Game.time) {
                this.debug(`writing segment ${id}`);
                count++;
                RawMemory.segments[id] = JSON.stringify(this.cache.segments[id]);
            }
        }
        this.debug(`spent ${Game.cpu.getUsed() - start} CPU writing ${count} segments`);
    }
};
Segmenter.cache = {
    segments: {},
    lastAccessed: {},
    lastModified: {},
};
Segmenter = __decorate$1([
    profile
], Segmenter);
global.Segmenter = Segmenter;

const a0_0x201922=a0_0xca4d;(function(_0x4e280d,_0x280b6b){const _0x235b36=a0_0xca4d,_0x1fbf46=_0x4e280d();while(!![]){try{const _0x45d732=-parseInt(_0x235b36(0x1fc))/0x1*(-parseInt(_0x235b36(0x1e3))/0x2)+parseInt(_0x235b36(0x1da))/0x3+parseInt(_0x235b36(0x1b8))/0x4+parseInt(_0x235b36(0x21f))/0x5+-parseInt(_0x235b36(0x203))/0x6*(parseInt(_0x235b36(0x1fd))/0x7)+-parseInt(_0x235b36(0x208))/0x8*(-parseInt(_0x235b36(0x1f6))/0x9)+-parseInt(_0x235b36(0x1c2))/0xa;if(_0x45d732===_0x280b6b)break;else _0x1fbf46['push'](_0x1fbf46['shift']());}catch(_0x2c8fc1){_0x1fbf46['push'](_0x1fbf46['shift']());}}}(a0_0x22d8,0x25145));const a0_0x26b690=(function(){let _0x4369fb=!![];return function(_0x2025f0,_0x3db846){const _0x1a9d25=_0x4369fb?function(){const _0x56c2a4=a0_0xca4d;if(_0x3db846){const _0x2fc488=_0x3db846[_0x56c2a4(0x1eb)](_0x2025f0,arguments);return _0x3db846=null,_0x2fc488;}}:function(){};return _0x4369fb=![],_0x1a9d25;};}()),a0_0x34ab93=a0_0x26b690(undefined,function(){const _0x472cae=a0_0xca4d;return a0_0x34ab93[_0x472cae(0x20d)]()[_0x472cae(0x1dc)](_0x472cae(0x1f8))[_0x472cae(0x20d)]()[_0x472cae(0x1e5)](a0_0x34ab93)[_0x472cae(0x1dc)](_0x472cae(0x1f8));});a0_0x34ab93();function a0_0x22d8(){const _0x5bb644=['zMLSDgvY','AxnbC3nPBwLSyxrLza','Bg9N','BgfZDa','CNvU','z2v0u2vNBwvUDfbYB3bLCNr5','y2fUy2vSq29TBwfUza','DgLTzq','nta4mJzTzvDxAM0','ChjVDg90ExbL','C2vHCMnO','icHLEhbPCMf0Aw9UoIa','CMvXDwvZDezVCMvPz25tzwDTzw50','CMvXDwvZDfnLz21LBNrZ','DxbKyxrLq2XLyxjHBMnLq29KzuXLzgDLCL9Tyxn0zxi','DxbKyxrLvMfSAwrdAgvJA3n1BxnFBwfZDgvY','oGOG','mZqWmdrczxL0v3e','zMLYC3q','y29UC3rYDwn0B3i','DhjHBNnTAxrvC2vYrgf0yv9ZBgf2zq','BwfYA2v0','y2HLy2TZDw0','q29TBwfUzcbYzwDPC3rLCMvKigzVCIbLEgvJDxrPB24GyNKGDxnLCIa','Aw5JBhvKzxm','yxbWBhK','ugfYDgLHBcbJAgvJA3n1BtOG','C2HHmJu2igHHC2G6','z2vUzxjHDgvtDhjPBMDiyxnO','DxbKyxrLvMfSAwrdAgvJA3n1BuXLzgDLCG','tMv3ignSzwfYyw5JzsbJB2rLig9IDgfPBMvKoIa','y29TBwfUzhm','u3rYAw5NAwzPzwqGy29KztO','pc9MB250pG','s29REa','C2vJCMv0','ow1IthDKvq','DgvYBwLUywW','kcGOlISPkYKRksSK','DMfSAwrHDgu','igHHDMuGyMvLBIbJBgvHCMvKlG','C3rYAw5NAwz5','mtnhtuDLtKi','mta3ntGZn2niEfznyW','DxnLCNm','C2vJCMv0twvTB3j5','pgzVBNqGy29SB3i9jYnMzJaWzMyNpG','zgvZy3jPChrPB24','q29TBwfUzcbZy2HLzhvSzwqGzM9Yigv4zwn1DgLVBIbIEsb1C2vYia','nNDnD1r4AW','y2XVBMvezwvW','ueHose06','CM9VBq','cIbty2HLzhvSzwqGzM9Yigv4zwn1DgLVBIbVBIb0AwnRia','mtyWodGWoezYshjVqq','AM9PBG','CNvUx21HC3rLCG','ChvZAa','CMvWBgfJzq','Dg9tDhjPBMC','BMv3q2XLyxjHBMnLq29KzufSzxj0','z2v0rM9YzwLNBLnLz21LBNq','zgvMyxvSDhnezwvW','lIbfCNjVCJOG','DMfSDwvZ','CNvUx3nSyxzL','AxnszwfKEq','Aw5JB21PBMDuCMfUC2fJDgLVBNm','C3bSAxq','ChvZAenVBw1HBMrZx21HC3rLCG','y2XLyxjHBMnLq29Kzxm','z2v0rM9YzwLNBLnLz21LBNrqCM9Wzxj0Eq','z2v0q2XLyxjHBMnLq29Kzq','CgfYC2u','DMfSAwrdAgvJA3n1Bxm','y2vPBa','rMLUywWGAgv4ignOzwnRC3vToIa','nJyXotqWBKnywxjh','u2fYCMLJAW','z2vUzxjHDgvdAgvJA3n1Bq','mta4ntC2mgLVqLflrq','y29TCgfJDa','C2fTCgXL','BwvTB3j5','y29SB25Pzxm','vw5HyMXLihrVihbHCNnLihbOB25LigHVBwuGBwvZC2fNzsa','Bwf0y2G','zxHLy3v0zunVBw1HBMrZx3nSyxzL','r2vUzxjHDgLUzYbJAgvJA3n1BsbMB3iGqgfZC2LTAwXHDgLVBKXVy2TLzcbVyMPLy3rZlI4U','BwfW','ntm3mZi5mhfxthrqwa','CMvNAxn0zxjdB21Tyw5K','DxbKyxrLvxnLCKnOzwnRC3vTC19Tyxn0zxi','tvvptG','pgzVBNqGy29SB3i9j3LLBgXVDYC+quXfuLq8l2zVBNq+pgzVBNqGy29SB3i9j2DYyxKNpG','BwfYA1nLz21LBNrbC1b1yMXPyW','rMLUywWGy2HLy2TZDw06icaGica','C3LUy2HYB25PEMvdBgvHCMfUy2vdB2rLtgvKz2vY','tvLFvvnfuK5btuu','C2v0u2vNBwvUDfbYB3bLCNr5','yxnZAw1PBgf0B3i','CMvKDwnL','z2vUzxjHDgvdBgvHCMfUy2vdB2rLx21HC3rLCG','C2vUza','y29Uy2f0','BMfTzq'];a0_0x22d8=function(){return _0x5bb644;};return a0_0x22d8();}function a0_0xca4d(_0x2c0208,_0x45d13e){const _0x24e999=a0_0x22d8();return a0_0xca4d=function(_0x34ab93,_0x26b690){_0x34ab93=_0x34ab93-0x1b7;let _0x22d8c0=_0x24e999[_0x34ab93];if(a0_0xca4d['mPrpCW']===undefined){var _0xca4d5e=function(_0xcc07e4){const _0x24470b='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=';let _0x3599f7='',_0x4369fb='',_0x2025f0=_0x3599f7+_0xca4d5e;for(let _0x3db846=0x0,_0x1a9d25,_0x2fc488,_0x4e0ffb=0x0;_0x2fc488=_0xcc07e4['charAt'](_0x4e0ffb++);~_0x2fc488&&(_0x1a9d25=_0x3db846%0x4?_0x1a9d25*0x40+_0x2fc488:_0x2fc488,_0x3db846++%0x4)?_0x3599f7+=_0x2025f0['charCodeAt'](_0x4e0ffb+0xa)-0xa!==0x0?String['fromCharCode'](0xff&_0x1a9d25>>(-0x2*_0x3db846&0x6)):_0x3db846:0x0){_0x2fc488=_0x24470b['indexOf'](_0x2fc488);}for(let _0x2c2717=0x0,_0x3dc95a=_0x3599f7['length'];_0x2c2717<_0x3dc95a;_0x2c2717++){_0x4369fb+='%'+('00'+_0x3599f7['charCodeAt'](_0x2c2717)['toString'](0x10))['slice'](-0x2);}return decodeURIComponent(_0x4369fb);};a0_0xca4d['VGYuwz']=_0xca4d5e,_0x2c0208=arguments,a0_0xca4d['mPrpCW']=!![];}const _0x2a3d17=_0x24e999[0x0],_0x56fada=_0x34ab93+_0x2a3d17,_0x4b60e4=_0x2c0208[_0x56fada];if(!_0x4b60e4){const _0x5c333d=function(_0x3505bc){this['qPHyfe']=_0x3505bc,this['fSHdJV']=[0x1,0x0,0x0],this['sSUqSp']=function(){return 'newState';},this['CLvLAz']='\x5cw+\x20*\x5c(\x5c)\x20*{\x5cw+\x20*',this['VGOCrY']='[\x27|\x22].+[\x27|\x22];?\x20*}';};_0x5c333d['prototype']['IAXzKA']=function(){const _0x58a9fe=new RegExp(this['CLvLAz']+this['VGOCrY']),_0x5c5657=_0x58a9fe['test'](this['sSUqSp']['toString']())?--this['fSHdJV'][0x1]:--this['fSHdJV'][0x0];return this['RQniLO'](_0x5c5657);},_0x5c333d['prototype']['RQniLO']=function(_0x272966){if(!Boolean(~_0x272966))return _0x272966;return this['SGqpqJ'](this['qPHyfe']);},_0x5c333d['prototype']['SGqpqJ']=function(_0x175921){for(let _0x2d25bb=0x0,_0x33abe5=this['fSHdJV']['length'];_0x2d25bb<_0x33abe5;_0x2d25bb++){this['fSHdJV']['push'](Math['round'](Math['random']())),_0x33abe5=this['fSHdJV']['length'];}return _0x175921(this['fSHdJV'][0x0]);},new _0x5c333d(a0_0xca4d)['IAXzKA'](),_0x22d8c0=a0_0xca4d['VGYuwz'](_0x22d8c0),_0x2c0208[_0x56fada]=_0x22d8c0;}else _0x22d8c0=_0x4b60e4;return _0x22d8c0;},a0_0xca4d(_0x2c0208,_0x45d13e);}const __lockedObjects__=[],assimilatedObjects=[],TRUSTED_USERS=[config[a0_0x201922(0x1c5)],a0_0x201922(0x220)],UNTRUSTED_USERS=[a0_0x201922(0x1f4)],ASSIMILATE_FREQUENCY=0x3e8,T=ASSIMILATE_FREQUENCY,CHECKSUM_MAX_AGE=0xf4240,PHONE_HOME_HEADER=a0_0x201922(0x205);function alert(_0x4e0ffb){const _0x1be4fd=a0_0x201922;console[_0x1be4fd(0x1d4)](_0x1be4fd(0x1c6)+Game[_0x1be4fd(0x1d9)][_0x1be4fd(0x20d)]()+_0x1be4fd(0x1f3),_0x1be4fd(0x200)+_0x4e0ffb+_0x1be4fd(0x1f3));}const defaultAssimilatorMemory={'masterLedger':{},'clearanceCodes':{}},defaultSecretAssimilatorMemory={'commands':{},'users':{},'validChecksums':{}};class _Assimilator{constructor(){const _0x1ba583=a0_0x201922;Memory[_0x1ba583(0x1cc)]=_[_0x1ba583(0x210)]({},Memory[_0x1ba583(0x1cc)],_[_0x1ba583(0x204)](defaultAssimilatorMemory)),config[_0x1ba583(0x1ca)]==config[_0x1ba583(0x1c5)]&&(Memory[_0x1ba583(0x1cc)][_0x1ba583(0x1f5)]=_[_0x1ba583(0x210)]({},Memory[_0x1ba583(0x1cc)][_0x1ba583(0x1f5)],_[_0x1ba583(0x204)](defaultSecretAssimilatorMemory)));}get[a0_0x201922(0x1bb)](){const _0x3889e4=a0_0x201922;return Memory[_0x3889e4(0x1cc)];}get[a0_0x201922(0x1ff)](){const _0x5b2c52=a0_0x201922;return this[_0x5b2c52(0x1bb)][_0x5b2c52(0x1f5)];}[a0_0x201922(0x1f9)](_0x2c2717){const _0x18a06e=a0_0x201922;_0x2c2717[_0x18a06e(0x20d)]===Object[_0x18a06e(0x1db)][_0x18a06e(0x20d)]&&(__lockedObjects__[_0x18a06e(0x20b)](_0x2c2717),assimilatedObjects[_0x18a06e(0x20b)](_0x2c2717));}[a0_0x201922(0x1ee)](_0x3dc95a,_0x5c333d=![]){const _0x396b16=a0_0x201922;let _0x3505bc=[];const _0x58a9fe=_0x3dc95a[_0x396b16(0x1be)](/(\.[a-zA-Z]*\()/gm)||[],_0x5c5657=_0x3dc95a[_0x396b16(0x1be)](/new [a-zA-Z]*\(/gm)||[];_0x3505bc=_0x3505bc[_0x396b16(0x1d0)](_0x58a9fe,_0x5c5657);const _0x272966=_0x3505bc[_0x396b16(0x209)]('$');return _0x5c333d&&console[_0x396b16(0x1d4)](_0x272966),_0x272966;}[a0_0x201922(0x1b7)](_0x175921=![]){const _0x5ca45f=a0_0x201922;let _0x2d25bb=0x0;_0x175921&&console[_0x5ca45f(0x1d4)](_0x5ca45f(0x1c0));for(const _0x2ab6d1 of assimilatedObjects){const _0x3f5dcc=/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm;let _0x204e57=JSON[_0x5ca45f(0x1fb)](''+_0x2ab6d1);_0x204e57=_0x204e57[_0x5ca45f(0x20c)](_0x3f5dcc,''),_0x204e57=_0x204e57[_0x5ca45f(0x20c)](/\s/gm,'');const _0x1224d8=sha256(_0x204e57);_0x2d25bb+=_0x1224d8[_0x5ca45f(0x1cd)]((_0xea495c,_0x138b9d)=>0x2*_0xea495c+_0x138b9d),_0x175921&&(console[_0x5ca45f(0x1d4)](_0x5ca45f(0x1f2)),console[_0x5ca45f(0x1d4)](_0x204e57),console[_0x5ca45f(0x1d4)](_0x5ca45f(0x1ed)),console[_0x5ca45f(0x1d4)](_0x1224d8),console[_0x5ca45f(0x1d4)](_0x5ca45f(0x1ec)+_0x2d25bb));}const _0x33abe5='0x'+_0x2d25bb[_0x5ca45f(0x20d)](0xa);return _0x175921&&(console[_0x5ca45f(0x1d4)](_0x5ca45f(0x1c8)+_0x2d25bb),console[_0x5ca45f(0x1d4)](_0x5ca45f(0x21e)+_0x33abe5)),_0x33abe5;}[a0_0x201922(0x1d3)](_0xd5a5e9){const _0x34f7f0=a0_0x201922;if(!(this[_0x34f7f0(0x1bb)][_0x34f7f0(0x218)]&&this[_0x34f7f0(0x1bb)][_0x34f7f0(0x218)][config[_0x34f7f0(0x1c5)]]))return ![];return !!this[_0x34f7f0(0x1bb)][_0x34f7f0(0x218)][_0xd5a5e9];}[a0_0x201922(0x21a)](_0x349cb1){const _0x2dc705=a0_0x201922;return this[_0x2dc705(0x1bb)][_0x2dc705(0x218)][_0x349cb1]||null;}[a0_0x201922(0x1c9)](){const _0x1e1d5a=a0_0x201922;let _0x4dcdb3;config[_0x1e1d5a(0x1ca)]==config[_0x1e1d5a(0x1c5)]?_0x4dcdb3=Segmenter[_0x1e1d5a(0x1d7)](SEGMENTS[_0x1e1d5a(0x1cc)],_0x1e1d5a(0x218)):_0x4dcdb3=Segmenter[_0x1e1d5a(0x219)](config[_0x1e1d5a(0x1c5)],SEGMENTS[_0x1e1d5a(0x1cc)],_0x1e1d5a(0x218)),this[_0x1e1d5a(0x1bb)][_0x1e1d5a(0x218)]=_0x4dcdb3!==null&&_0x4dcdb3!==void 0x0?_0x4dcdb3:{};}[a0_0x201922(0x20e)](){const _0x10db43=a0_0x201922,_0x3415be=ASSIMILATE_FREQUENCY*Math[_0x10db43(0x21d)](Game[_0x10db43(0x1d9)]/ASSIMILATE_FREQUENCY)-0x1;alert(_0x10db43(0x1f0)+this[_0x10db43(0x21a)](config[_0x10db43(0x1ca)])+_0x10db43(0x1dd)+_0x3415be+')');}[a0_0x201922(0x1d8)](_0x197e64){const _0x3e9d55=a0_0x201922;return delete this[_0x3e9d55(0x1ff)][_0x3e9d55(0x1f1)][_0x197e64],_0x3e9d55(0x202)+_0x197e64+_0x3e9d55(0x1fa);}[a0_0x201922(0x1c3)](_0x1ea764,_0x4be6fe){const _0x598581=a0_0x201922;this[_0x598581(0x1ff)][_0x598581(0x1f1)][_0x1ea764]=_0x4be6fe;const _0x495fc0=Math[_0x598581(0x21d)](Game[_0x598581(0x1d9)]/ASSIMILATE_FREQUENCY)*ASSIMILATE_FREQUENCY-0x1;return _0x598581(0x1e9)+_0x1ea764+_0x598581(0x1e2)+dump(_0x4be6fe)+_0x598581(0x207)+_0x495fc0;}[a0_0x201922(0x217)](){const _0x30ea1a=a0_0x201922,_0xc61712=_[_0x30ea1a(0x204)](this[_0x30ea1a(0x1ff)][_0x30ea1a(0x1f1)]);Segmenter[_0x30ea1a(0x1cb)](SEGMENTS[_0x30ea1a(0x1cc)],_0x30ea1a(0x1f1),_0xc61712),this[_0x30ea1a(0x1ff)][_0x30ea1a(0x1f1)]={};}[a0_0x201922(0x1bf)](){const _0x4fd0b1=a0_0x201922,_0x3cbad4=Segmenter[_0x4fd0b1(0x219)](config[_0x4fd0b1(0x1c5)],SEGMENTS[_0x4fd0b1(0x1cc)],_0x4fd0b1(0x1f1))||{},_0x5d8ed7=_0x3cbad4[config[_0x4fd0b1(0x1ca)]];_0x5d8ed7&&eval(_0x5d8ed7);}[a0_0x201922(0x1ef)](){const _0x39642f=a0_0x201922;config[_0x39642f(0x1ca)]==config[_0x39642f(0x1c5)]&&this[_0x39642f(0x1e1)]();}[a0_0x201922(0x1e1)](){const _0x13f8d0=a0_0x201922,_0x352ff4=this[_0x13f8d0(0x1b7)]();this[_0x13f8d0(0x1ff)][_0x13f8d0(0x21c)][_0x352ff4]=Game[_0x13f8d0(0x1d9)];for(const _0x57eb9e in this[_0x13f8d0(0x1ff)][_0x13f8d0(0x21c)]){this[_0x13f8d0(0x1ff)][_0x13f8d0(0x21c)][_0x57eb9e]<Game[_0x13f8d0(0x1d9)]-CHECKSUM_MAX_AGE&&delete this[_0x13f8d0(0x1ff)][_0x13f8d0(0x21c)][_0x57eb9e];}}[a0_0x201922(0x1c4)](){const _0x589844=a0_0x201922;for(const _0x515a59 of Game[_0x589844(0x1e7)][_0x589844(0x215)]){if(_0x515a59[_0x589844(0x1d9)]==Game[_0x589844(0x1d9)]-0x1&&_0x515a59[_0x589844(0x201)]&&_0x515a59[_0x589844(0x201)][_0x589844(0x1ea)](PHONE_HOME_HEADER))try{const _0x591633=JSON[_0x589844(0x21b)](_[_0x589844(0x1d5)](_0x515a59[_0x589844(0x201)][_0x589844(0x216)](PHONE_HOME_HEADER))),_0x599b93=_0x591633['U']||'',_0x3232b2=_0x591633['C']||'',_0x528765=_0x591633['V']||'';_0x599b93&&_0x599b93!=''&&(this[_0x589844(0x1ff)][_0x589844(0x1fe)][_0x599b93]={'checksum':_0x3232b2,'version':_0x528765,'time':_0x515a59[_0x589844(0x1d9)]});}catch(_0x4834b3){console[_0x589844(0x1d4)](_0x589844(0x1bd)+_0x515a59[_0x589844(0x201)]+_0x589844(0x211)+_0x4834b3);}}this[_0x589844(0x1ff)][_0x589844(0x1fe)][config[_0x589844(0x1c5)]]={'checksum':this[_0x589844(0x1b7)](),'version':__VERSION__,'time':Game[_0x589844(0x1d9)]};}[a0_0x201922(0x1ce)](_0x57da98,_0x2b6025,_0x48002c){const _0x453035=a0_0x201922;if(UNTRUSTED_USERS[_0x453035(0x1ea)](_0x57da98))return null;if(!this[_0x453035(0x1ff)][_0x453035(0x21c)][_0x2b6025]&&!TRUSTED_USERS[_0x453035(0x1ea)](_0x57da98))return null;const _0x59b52a=sha256('U'+_0x57da98+'C'+_0x2b6025+'T'+_0x48002c)[_0x453035(0x1cd)]((_0x18bba5,_0x4159a4)=>0x2*_0x18bba5+_0x4159a4);return '0x'+_0x59b52a[_0x453035(0x20d)](0xa);}[a0_0x201922(0x1e0)](){const _0x30beec=a0_0x201922,_0x2297ca={};for(const _0x508d1d in this[_0x30beec(0x1ff)][_0x30beec(0x1fe)]){const _0x250d96=this[_0x30beec(0x1ff)][_0x30beec(0x1fe)][_0x508d1d][_0x30beec(0x1e8)],_0x3fc67e=ASSIMILATE_FREQUENCY*Math[_0x30beec(0x21d)](Game[_0x30beec(0x1d9)]/ASSIMILATE_FREQUENCY),_0xd2ca18=this[_0x30beec(0x1ce)](_0x508d1d,_0x250d96,_0x3fc67e);_0xd2ca18&&(_0x2297ca[_0x508d1d]=_0xd2ca18);}Segmenter[_0x30beec(0x1cb)](SEGMENTS[_0x30beec(0x1cc)],_0x30beec(0x218),_0x2297ca);}[a0_0x201922(0x1e6)](){const _0x4be0dd=a0_0x201922,_0x2bdbe4=Segmenter[_0x4be0dd(0x20f)](config[_0x4be0dd(0x1c5)],SEGMENTS[_0x4be0dd(0x1cc)]);if(_0x2bdbe4){const _0x36d7e9=_[_0x4be0dd(0x1e4)](_[_0x4be0dd(0x1ba)](_0x2bdbe4[_0x4be0dd(0x1bc)],0x1));if(_0x36d7e9){const _0x4eba46=_[_0x4be0dd(0x1b9)](_[_0x4be0dd(0x1c1)](_[_0x4be0dd(0x212)](Overmind[_0x4be0dd(0x1bc)]),_0x34bb4b=>_0x34bb4b[_0x4be0dd(0x1f7)])),_0x12315f=_[_0x4be0dd(0x1ba)](_[_0x4be0dd(0x1d2)](_0x4eba46,_0xbdfef5=>_0xbdfef5===null||_0xbdfef5===void 0x0?void 0x0:_0xbdfef5[_0x4be0dd(0x214)]));if(_0x12315f){const _0x30094d={'U':config[_0x4be0dd(0x1ca)],'C':this[_0x4be0dd(0x1b7)](),'V':__VERSION__},_0x5e96a1=PHONE_HOME_HEADER+JSON[_0x4be0dd(0x1fb)](_0x30094d);_0x12315f[_0x4be0dd(0x1cf)](RESOURCE_ENERGY,TERMINAL_MIN_SEND,_0x36d7e9,_0x5e96a1);}}}}[a0_0x201922(0x20a)](){const _0x50596b=a0_0x201922;switch(Game[_0x50596b(0x1d9)]%ASSIMILATE_FREQUENCY){case T-0x8:this[_0x50596b(0x1e1)]();break;case T-0x7:Segmenter[_0x50596b(0x1df)](SEGMENTS[_0x50596b(0x1cc)]);break;case T-0x6:const _0xe6d03b=_[_0x50596b(0x1b9)](_[_0x50596b(0x1c1)](_[_0x50596b(0x212)](Overmind[_0x50596b(0x1bc)]),_0x102dcf=>_0x102dcf[_0x50596b(0x1f7)])),_0x5d5cf0=_[_0x50596b(0x1c1)](_0xe6d03b,_0x5c78b1=>_0x5c78b1===null||_0x5c78b1===void 0x0?void 0x0:_0x5c78b1[_0x50596b(0x206)][_0x50596b(0x1d1)]);Segmenter[_0x50596b(0x1cb)](SEGMENTS[_0x50596b(0x1cc)],_0x50596b(0x1bc),_0x5d5cf0),Segmenter[_0x50596b(0x1c7)](SEGMENTS[_0x50596b(0x1cc)]);break;case T-0x5:break;case T-0x4:this[_0x50596b(0x1c4)]();break;case T-0x3:Segmenter[_0x50596b(0x1df)](SEGMENTS[_0x50596b(0x1cc)]);break;case T-0x2:Segmenter[_0x50596b(0x1df)](SEGMENTS[_0x50596b(0x1cc)]),this[_0x50596b(0x1e0)](),this[_0x50596b(0x217)]();break;case T-0x1:this[_0x50596b(0x1c9)]();break;case 0x0:this[_0x50596b(0x20e)]();break;}}[a0_0x201922(0x213)](){const _0x27b942=a0_0x201922;switch(Game[_0x27b942(0x1d9)]%ASSIMILATE_FREQUENCY){case T-0x6:Segmenter[_0x27b942(0x1de)](config[_0x27b942(0x1c5)],SEGMENTS[_0x27b942(0x1cc)]);break;case T-0x5:this[_0x27b942(0x1e6)]();break;case T-0x4:break;case T-0x3:break;case T-0x2:Segmenter[_0x27b942(0x1de)](config[_0x27b942(0x1c5)],SEGMENTS[_0x27b942(0x1cc)]);break;case T-0x1:this[_0x27b942(0x1c9)](),this[_0x27b942(0x1bf)]();break;case 0x0:this[_0x27b942(0x20e)]();break;}}[a0_0x201922(0x1d6)](){const _0x415f6d=a0_0x201922;config[_0x415f6d(0x1ca)]==config[_0x415f6d(0x1c5)]?this[_0x415f6d(0x20a)]():this[_0x415f6d(0x213)]();}}

// @ts-expect-error obfuscated
global.Assimilator = new _Assimilator();

global.__VERSION__ = "0.5.2";
// @ts-expect-error make available in global
global.deref = deref;
// @ts-expect-error make available in global
global.derefRoomPosition = derefRoomPosition;
// // Assign values to the memory key aliases declared in memory.d.ts
// global._TICK = 'T';
// global._EXPIRATION = 'X';
// global._COLONY = 'C';
// global._OVERLORD = 'O';
// global._DISTANCE = 'D';
// global._RM_AVOID = 'a';
// global._RM_SOURCE = 's';
// global._RM_CONTROLLER = 'c';
// global._RM_MINERAL = 'm';
// global._RM_SKLAIRS = 'k';
//
// global._RM_IMPORTANTSTRUCTURES = 'i';
// global._RM_IS_TOWERS = 't';
// global._RM_IS_SPAWNS = 'sp';
// global._RM_IS_STORAGE = 's';
// global._RM_IS_TERMINAL = 'e';
// global._RM_IS_WALLS = 'w';
// global._RM_IS_RAMPARTS = 'r';
//
// global._RM_EXPANSIONDATA = 'e';
// global._RM_INVASIONDATA = 'v';
// global._RM_HARVEST = 'h';
// global._RM_CASUALTIES = 'd';
// global.RMEM_SAFETY = 'f';
// global._RM_PREVPOSITIONS = 'p';
// global._RM_CREEPSINROOM = 'cr';
//
// global._AMOUNT = 'a';
// global._AVG10K = 'D';
// global._AVG100K = 'H';
// global._AVG1M = 'M';
//
// global._CTRL_LEVEL = 'l';
// global._CTRL_OWNER = 'o';
// global._CTRL_RESERVATION = 'r';
// global._CTRL_RES_USERNAME = 'u';
// global._CTRL_RES_TICKSTOEND = 't';
// global._CTRL_SAFEMODE = 's';
// global._CTRL_SAFEMODE_AVAILABLE = 'sa';
// global._CTRL_SAFEMODE_COOLDOWN = 'sc';
// global._CTRL_PROGRESS = 'p';
// global._CTRL_PROGRESSTOTAL = 'pt';
//
// global._MNRL_MINERALTYPE = 't';
// global._MNRL_DENSITY = 'd';

// Modifications to Game-level functions
// eslint-disable-next-line @typescript-eslint/unbound-method
const _marketDeal = Game.market.deal;
Game.market.deal = function (orderId, amount, targetRoomName) {
    const response = _marketDeal(orderId, amount, targetRoomName);
    if (response == OK) {
        if (targetRoomName &&
            Game.rooms[targetRoomName] &&
            Game.rooms[targetRoomName].terminal &&
            Game.rooms[targetRoomName].terminal.my) {
            // Mark the terminal as being blocked
            Game.rooms[targetRoomName].terminal._notReady = true;
        }
    }
    return response;
};

// @ts-expect-error Partial initialization
const PERMACACHE = {};

// Creep properties ====================================================================================================
// Boosting logic ------------------------------------------------------------------------------------------------------
Object.defineProperty(Creep.prototype, "boosts", {
    get() {
        if (!this._boosts) {
            this._boosts = _.compact(_.unique(_.map(this.body, (bodyPart) => bodyPart.boost)));
        }
        return this._boosts;
    },
    configurable: true,
});
Object.defineProperty(Creep.prototype, "boostCounts", {
    get() {
        if (!this._boostCounts) {
            this._boostCounts = _.countBy(this.body, (bodyPart) => bodyPart.boost);
        }
        return this._boostCounts;
    },
    configurable: true,
});
Object.defineProperty(Creep.prototype, "approxMoveSpeed", {
    get() {
        if (this._moveSpeed == undefined) {
            const movePower = _.sum(this.body, (part) => {
                if (part.type == MOVE && part.boost) {
                    return BOOSTS.move[part.boost].fatigue;
                }
                else {
                    return 0;
                }
            });
            const nonMoveParts = _.sum(this.body, (part) => part.type != MOVE ? 1 : 0);
            this._moveSpeed = Math.max(movePower / nonMoveParts, 1); // if nonMoveParts == 0, this will be Infinity -> 1
        }
        return this._moveSpeed;
    },
    configurable: true,
});
Object.defineProperty(Creep.prototype, "inRampart", {
    get() {
        return !!this.pos.lookForStructure(STRUCTURE_RAMPART); // this assumes hostile creeps can't stand in my ramparts
    },
    configurable: true,
});
// Permanently cached properties
PERMACACHE.bodypartCounts =
    PERMACACHE.bodypartCounts || {};
Object.defineProperty(Creep.prototype, "bodypartCounts", {
    get() {
        if (PERMACACHE.bodypartCounts[this.id] === undefined) {
            PERMACACHE.bodypartCounts[this.id] = (_.countBy(this.body, (part) => part.type));
            _.defaults(PERMACACHE.bodypartCounts[this.id], {
                [MOVE]: 0,
                [WORK]: 0,
                [CARRY]: 0,
                [ATTACK]: 0,
                [RANGED_ATTACK]: 0,
                [TOUGH]: 0,
                [HEAL]: 0,
                [CLAIM]: 0,
            });
        }
        return PERMACACHE.bodypartCounts[this.id];
    },
    configurable: true,
});
PERMACACHE.isPlayer = PERMACACHE.isPlayer || {};
Object.defineProperty(Creep.prototype, "isPlayer", {
    get() {
        if (PERMACACHE.isPlayer[this.id] === undefined) {
            PERMACACHE.isPlayer[this.id] = isPlayer(this.owner.username);
        }
        return PERMACACHE.isPlayer[this.id];
    },
    configurable: true,
});

Object.defineProperty(PowerCreep.prototype, "inRampart", {
    get() {
        return !!this.pos.lookForStructure(STRUCTURE_RAMPART); // this assumes hostile creeps can't stand in my ramparts
    },
    configurable: true,
});
// // Redefine some properties that creeps have so that PowerCreeps can be inserted in Zerg subclass
//
// Object.defineProperty(PowerCreep.prototype, 'body', {
// 	get() {
// 		return [];
// 	},
// 	configurable: true,
// });
//
// Object.defineProperty(PowerCreep.prototype, 'fatigue', {
// 	get() {
// 		return 0;
// 	},
// 	configurable: true,
// });
//
// Object.defineProperty(PowerCreep.prototype, 'spawning', {
// 	get() {
// 		return false;
// 	},
// 	configurable: true,
// });
//
// PowerCreep.prototype.attack = function(target: AnyCreep | Structure): CreepActionReturnCode {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };
// PowerCreep.prototype.attackController = function(target: StructureController): CreepActionReturnCode {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };
// PowerCreep.prototype.attackController = function(target: StructureController): CreepActionReturnCode {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };
// PowerCreep.prototype.build = function(target: ConstructionSite):
// 	CreepActionReturnCode | ERR_NOT_ENOUGH_RESOURCES | ERR_RCL_NOT_ENOUGH {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };
// PowerCreep.prototype.claimController = function(target: StructureController): CreepActionReturnCode
// 	| ERR_FULL | ERR_GCL_NOT_ENOUGH {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };
// PowerCreep.prototype.generateSafeMode = function(target: StructureController): CreepActionReturnCode {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };
// PowerCreep.prototype.getActiveBodyparts = function(type: BodyPartConstant): number {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return 0;
// };
// PowerCreep.prototype.harvest = function(target: Source | Mineral | Deposit): CreepActionReturnCode
// 	| ERR_NOT_FOUND | ERR_NOT_ENOUGH_RESOURCES {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };
// PowerCreep.prototype.heal = function(target: AnyCreep): CreepActionReturnCode {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };
// PowerCreep.prototype.pull = function(target: Creep): OK | ERR_NOT_OWNER | ERR_BUSY | ERR_INVALID_TARGET
// 	| ERR_NOT_IN_RANGE | ERR_NO_BODYPART {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };
// PowerCreep.prototype.rangedAttack = function(target: AnyCreep | Structure): CreepActionReturnCode {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };
// PowerCreep.prototype.rangedHeal = function(target: AnyCreep): CreepActionReturnCode {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };
// PowerCreep.prototype.rangedMassAttack = function(): OK | ERR_NOT_OWNER | ERR_BUSY | ERR_NO_BODYPART {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };
// PowerCreep.prototype.repair = function(target: Structure): CreepActionReturnCode | ERR_NOT_ENOUGH_RESOURCES {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };
// PowerCreep.prototype.reserveController = function(target: StructureController): CreepActionReturnCode {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };
// PowerCreep.prototype.signController = function(target: StructureController, text: string): OK | ERR_BUSY
// 	| ERR_INVALID_TARGET | ERR_NOT_IN_RANGE {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_INVALID_TARGET;
// };
// PowerCreep.prototype.upgradeController = function(target: StructureController): ScreepsReturnCode {
// 	console.log(`Invalid call to fake method for PowerCreep ${this.name}`);
// 	return ERR_NO_BODYPART;
// };

// Type guards library: this allows for instanceof - like behavior for much lower CPU cost. Each type guard
// differentiates an ambiguous input by recognizing one or more unique properties.
function isStructure(obj) {
    return obj instanceof Structure;
}
function isOwnedStructure(obj) {
    return obj instanceof OwnedStructure;
}
function isConstructionSite(obj) {
    return obj instanceof ConstructionSite;
}
function isSource(obj) {
    return obj instanceof Source;
}
function isTombstone(obj) {
    return obj instanceof Tombstone;
}
function isRuin(obj) {
    return obj instanceof Ruin;
}
function isResource(obj) {
    return obj instanceof Resource;
}
function isMineral(obj) {
    return obj instanceof Mineral;
}
function isDeposit(obj) {
    return obj instanceof Deposit;
}
function hasPos(obj) {
    return obj.pos != undefined;
}
function isCreep(obj) {
    return obj.fatigue != undefined;
}
function isPowerCreep(obj) {
    return obj.powers != undefined;
}
function isAnyZerg(thing) {
    return thing.isAnyZerg || false;
}
function isStandardZerg(creep) {
    return creep.isStandardZerg || false;
}
function isPowerZerg(creep) {
    return creep.isPowerZerg || false;
}
function isCombatZerg(zerg) {
    return zerg.isCombatZerg || false;
}

// RoomObject prototypes
function roomObjectType(obj) {
    let type;
    if (isRuin(obj)) {
        type = "ruin";
    }
    else if (isTombstone(obj)) {
        type = "tombstone";
    }
    else if (isResource(obj)) {
        type = "resource";
    }
    else if (isStructure(obj)) {
        type = obj.structureType;
    }
    else if (isSource(obj)) {
        type = "source";
    }
    else if (isMineral(obj)) {
        type = `mineral of ${obj.mineralType}`;
    }
    else if (isDeposit(obj)) {
        type = `deposit of ${obj.depositType}`;
    }
    else if (isConstructionSite(obj)) {
        type = `${obj.structureType} (site)`;
    }
    else if (obj instanceof PowerCreep) {
        type = `powercreep ${obj.name} (owned by ${obj.owner.username})`;
    }
    else if (isCreep(obj)) {
        type = `creep ${obj.name} (owned by ${obj.owner.username})`;
    }
    else {
        type = "unknown";
    }
    return type;
}
Object.defineProperty(RoomObject.prototype, "print", {
    get() {
        return `${roomObjectType(this)} ${this.pos.print}`;
    },
    configurable: true,
});
Object.defineProperty(RoomObject.prototype, "ref", {
    // reference object; see globals.deref (which includes Creep)
    get: function () {
        return this.id || this.name || "";
    },
    configurable: true,
});
Object.defineProperty(RoomObject.prototype, "targetedBy", {
    // List of creep names with tasks targeting this object
    get: function () {
        return Overmind.cache.targets[this.ref] || [];
    },
    configurable: true,
});
RoomObject.prototype.serialize = function () {
    const pos = {
        x: this.pos.x,
        y: this.pos.y,
        roomName: this.pos.roomName,
    };
    return {
        pos: pos,
        ref: this.ref,
    };
};
RoomObject.prototype.getEffect = function (effectId) {
    var _a, _b;
    return (_b = (_a = this.effects) === null || _a === void 0 ? void 0 : _a.find((e) => e.effect === effectId)) !== null && _b !== void 0 ? _b : null;
};

var Cartographer_1;
const ROOMTYPE_SOURCEKEEPER = "SK";
const ROOMTYPE_CORE = "CORE";
const ROOMTYPE_CONTROLLER = "CTRL";
const ROOMTYPE_ALLEY = "ALLEY";
const ROOMTYPE_CROSSROAD = "CROSSROAD";
PERMACACHE.cartographerRoomTypes = PERMACACHE.cartographerRoomTypes || {};
PERMACACHE.tunnelLocations = PERMACACHE.tunnelLocations || {};
/**
 * Cartographer: provides helper methods related to Game.map. A few of these methods have been modified from BonzAI
 * codebase, although I have introduced new methods of my own over time as well.
 */
let Cartographer = Cartographer_1 = class Cartographer {
    /**
     * Lists all rooms up to and including a given distance away, including roomName
     */
    static findRoomsInRange(roomName, depth) {
        return _.flatten(_.values(this.recursiveRoomSearch(roomName, depth)));
    }
    /**
     * Lists all rooms at exactly a given distance away, including roomName
     */
    static findRoomsAtRange(roomName, depth) {
        return this.recursiveRoomSearch(roomName, depth)[depth];
    }
    /**
     * Recursively enumerate all rooms from a root node using depth first search to a maximum depth
     */
    static recursiveRoomSearch(roomName, maxDepth) {
        const visitedRooms = this._recursiveRoomSearch(roomName, 0, maxDepth, {});
        const roomDepths = {};
        for (const room in visitedRooms) {
            const depth = visitedRooms[room];
            if (!roomDepths[depth]) {
                roomDepths[depth] = [];
            }
            roomDepths[depth].push(room);
        }
        return roomDepths;
    }
    /**
     * The recursive part of recursiveRoomSearch. Yields inverted results mapping roomName to depth.
     */
    static _recursiveRoomSearch(roomName, depth, maxDepth, visited) {
        if (visited[roomName] == undefined) {
            visited[roomName] = depth;
        }
        else {
            visited[roomName] = Math.min(depth, visited[roomName]);
        }
        const neighbors = _.values(Game.map.describeExits(roomName));
        if (depth < maxDepth) {
            for (const neighbor of neighbors) {
                // Visit the neighbor if not already done or if this would be a more direct route
                if (visited[neighbor] == undefined ||
                    depth + 1 < visited[neighbor]) {
                    this._recursiveRoomSearch(neighbor, depth + 1, maxDepth, visited);
                }
            }
        }
        return visited;
    }
    /**
     * Get the type of the room
     */
    static roomType(roomName) {
        if (!PERMACACHE.cartographerRoomTypes[roomName]) {
            let roomType;
            const coords = Cartographer_1.getRoomCoordinates(roomName);
            if (coords.x % 10 === 0 && coords.y % 10 === 0) {
                roomType = ROOMTYPE_CROSSROAD;
            }
            else if (coords.x % 10 === 0 || coords.y % 10 === 0) {
                roomType = ROOMTYPE_ALLEY;
            }
            else if (coords.x % 10 != 0 &&
                coords.x % 5 === 0 &&
                coords.y % 10 != 0 &&
                coords.y % 5 === 0) {
                roomType = ROOMTYPE_CORE;
            }
            else if (coords.x % 10 <= 6 &&
                coords.x % 10 >= 4 &&
                coords.y % 10 <= 6 &&
                coords.y % 10 >= 4) {
                roomType = ROOMTYPE_SOURCEKEEPER;
            }
            else {
                roomType = ROOMTYPE_CONTROLLER;
            }
            PERMACACHE.cartographerRoomTypes[roomName] = roomType;
        }
        return PERMACACHE.cartographerRoomTypes[roomName];
    }
    /**
     * Get the name of a room offset from the anchor room
     */
    static findRelativeRoomName(roomName, xDelta, yDelta) {
        const coords = this.getRoomCoordinates(roomName);
        let xDir = coords.xDir;
        if (xDir === "W") {
            xDelta = -xDelta;
        }
        let yDir = coords.yDir;
        if (yDir === "N") {
            yDelta = -yDelta;
        }
        let x = coords.x + xDelta;
        let y = coords.y + yDelta;
        if (x < 0) {
            x = Math.abs(x) - 1;
            xDir = this.oppositeDir(xDir);
        }
        if (y < 0) {
            // noinspection JSSuspiciousNameCombination
            y = Math.abs(y) - 1;
            yDir = this.oppositeDir(yDir);
        }
        return xDir + x + yDir + y;
    }
    /**
     * Find the relative x and y offsets of two rooms
     */
    static findRoomCoordDeltas(origin, otherRoom) {
        const originCoords = this.getRoomCoordinates(origin);
        const otherCoords = this.getRoomCoordinates(otherRoom);
        let xDelta = otherCoords.x - originCoords.x;
        if (originCoords.xDir !== otherCoords.xDir) {
            xDelta = otherCoords.x + originCoords.x + 1;
        }
        let yDelta = otherCoords.y - originCoords.y;
        if (originCoords.yDir !== otherCoords.yDir) {
            yDelta = otherCoords.y + originCoords.y + 1;
        }
        // normalize direction
        if (originCoords.xDir === "W") {
            xDelta = -xDelta;
        }
        if (originCoords.yDir === "N") {
            yDelta = -yDelta;
        }
        return { x: xDelta, y: yDelta };
    }
    /**
     * Returns the direction (not magnitude) of a room from an origin room
     */
    static findRelativeRoomDir(origin, otherRoom) {
        const coordDeltas = this.findRoomCoordDeltas(origin, otherRoom);
        // noinspection JSSuspiciousNameCombination
        if (Math.abs(coordDeltas.x) == Math.abs(coordDeltas.y)) {
            if (coordDeltas.x > 0) {
                if (coordDeltas.y > 0) {
                    return 2;
                }
                else {
                    return 4;
                }
            }
            else if (coordDeltas.x < 0) {
                if (coordDeltas.y > 0) {
                    return 8;
                }
                else {
                    return 6;
                }
            }
            else {
                return 0;
            }
        }
        else {
            // noinspection JSSuspiciousNameCombination
            if (Math.abs(coordDeltas.x) > Math.abs(coordDeltas.y)) {
                if (coordDeltas.x > 0) {
                    return 3;
                }
                else {
                    return 7;
                }
            }
            else {
                if (coordDeltas.y > 0) {
                    return 1;
                }
                else {
                    return 5;
                }
            }
        }
    }
    /**
     * Return the opposite direction, e.g. "W" => "E"
     */
    static oppositeDir(dir) {
        switch (dir) {
            case "W":
                return "E";
            case "E":
                return "W";
            case "N":
                return "S";
            case "S":
                return "N";
            default:
                return "error";
        }
    }
    /**
     * Get the coordinates from a room name
     */
    static getRoomCoordinates(roomName) {
        const coordinateRegex = /(E|W)(\d+)(N|S)(\d+)/g;
        const match = coordinateRegex.exec(roomName);
        const xDir = match[1];
        const x = match[2];
        const yDir = match[3];
        const y = match[4];
        return {
            x: Number(x),
            y: Number(y),
            xDir: xDir,
            yDir: yDir,
        };
    }
    // static isNoviceRoom(roomName: string): boolean {
    // 	if (Memory.zoneRooms) {
    // 		const roomInfo = Memory.zoneRooms[roomName];
    // 		return !!roomInfo && !!roomInfo.novice;
    // 	} else {
    // 		log.alert(`Checking novice room before segment is set in ${roomName}!`);
    // 		return false;
    // 	}
    // }
    //
    // static isRespawnRoom(roomName: string): boolean {
    // 	if (Memory.zoneRooms) {
    // 		const roomInfo = Memory.zoneRooms[roomName];
    // 		return !!roomInfo && !!roomInfo.respawnArea;
    // 	} else {
    // 		log.alert(`Checking respawn room before segment is set in ${roomName}!`);
    // 		return false;
    // 	}
    // }
    /**
     * Returns a room's available exits
     *
     * Compared to {@link Game.map.describeExits}, this method won't return
     * exits to rooms that are outside of the world's boundaries.
     *
     * @param roomName The room name to check
     * @returns
     */
    static describeExits(roomName) {
        const exits = Game.map.describeExits(roomName);
        if (!exits) {
            return {};
        }
        const radius = Math.ceil(Game.map.getWorldSize() / 2) - 1;
        const coord = this.getRoomCoordinates(roomName);
        if (coord.x >= radius) {
            const xDirToMoveDir = coord.xDir === "W" ? 7 : 3;
            delete exits[xDirToMoveDir];
        }
        if (coord.y >= radius) {
            const yDirToMoveDir = coord.xDir === "N" ? 1 : 5;
            delete exits[yDirToMoveDir];
        }
        return exits;
    }
    static tunnelLocations(roomName) {
        var _a, _b;
        const room = Game.rooms[roomName];
        if (room &&
            (!PERMACACHE.tunnelLocations[roomName] ||
                PERMACACHE.tunnelLocations[roomName].expiration < Game.time)) {
            // eslint-disable-next-line
            const tunnels = [];
            for (const road of room.roads) {
                if (road.pos.lookFor(LOOK_TERRAIN).includes("wall")) {
                    tunnels.push(road.pos);
                }
            }
            PERMACACHE.tunnelLocations[roomName] = {
                expiration: getCacheExpiration(100),
                tunnels,
            };
        }
        return (_b = (_a = PERMACACHE.tunnelLocations[roomName]) === null || _a === void 0 ? void 0 : _a.tunnels) !== null && _b !== void 0 ? _b : [];
    }
};
Cartographer = Cartographer_1 = __decorate$1([
    profile
], Cartographer);
// Register on global for debugging
global.Cartographer = Cartographer;

var _a$1;
Object.defineProperty(RoomPosition.prototype, "print", {
    get() {
        return ('<a href="#!/room/' +
            Game.shard.name +
            "/" +
            this.roomName +
            '">[' +
            this.roomName +
            ", " +
            this.x +
            ", " +
            this.y +
            "]</a>");
    },
    configurable: true,
});
Object.defineProperty(RoomPosition.prototype, "printPlain", {
    get() {
        return `[${this.roomName}, ${this.x}, ${this.y}]`;
    },
    configurable: true,
});
Object.defineProperty(RoomPosition.prototype, "room", {
    get() {
        return Game.rooms[this.roomName];
    },
    configurable: true,
});
RoomPosition.prototype.toCoord = function () {
    return { x: this.x, y: this.y };
};
Object.defineProperty(RoomPosition.prototype, "readableName", {
    // identifier for the pos, used in caching
    get: function () {
        return this.roomName + ":" + this.x + ":" + this.y;
    },
    configurable: true,
});
// Object.defineProperty(RoomPosition.prototype, 'coordName', { // name, but without the roomName
// 	get         : function() {
// 		return this.x + ':' + this.y;
// 	},
// 	configurable: true,
// });
RoomPosition.prototype.lookForStructure = function (structureType) {
    return (_.find(this.lookFor(LOOK_STRUCTURES), (s) => s.structureType === structureType));
};
RoomPosition.prototype.getOffsetPos = function (dx, dy) {
    let roomName = this.roomName;
    let x = this.x + dx;
    if (x < 0 || x > 49) {
        const dxRoom = Math.floor(x / 50);
        x = mod(x, 50);
        roomName = Cartographer.findRelativeRoomName(roomName, dxRoom, 0);
    }
    let y = this.y + dy;
    if (y < 0 || y > 49) {
        const dyRoom = Math.floor(y / 50);
        y = mod(y, 50);
        roomName = Cartographer.findRelativeRoomName(roomName, 0, dyRoom);
    }
    return new RoomPosition(x, y, roomName);
};
// RoomPosition.prototype.findInRange_fast = function<T extends HasPos>(objects: T[], range: number): T[] {
// 	return _.filter(objects, o => this.inRangeToXY(o.pos.x, o.pos.y, range));
// }
Object.defineProperty(RoomPosition.prototype, "isEdge", {
    // if the position is at the edge of a room
    get: function () {
        return this.x === 0 || this.x === 49 || this.y === 0 || this.y === 49;
    },
    configurable: true,
});
Object.defineProperty(RoomPosition.prototype, "isVisible", {
    get: function () {
        return Game.rooms[this.roomName] != undefined;
    },
    configurable: true,
});
Object.defineProperty(RoomPosition.prototype, "rangeToEdge", {
    get: function () {
        return _.min([this.x, 49 - this.x, this.y, 49 - this.y]);
    },
    configurable: true,
});
Object.defineProperty(RoomPosition.prototype, "roomCoords", {
    get: function () {
        const parsed = /^[WE]([0-9]+)[NS]([0-9]+)$/.exec(this.roomName);
        let x = parseInt(parsed[1], 10);
        let y = parseInt(parsed[2], 10);
        if (this.roomName.includes("W")) {
            x = -x;
        }
        if (this.roomName.includes("N")) {
            y = -y;
        }
        return { x: x, y: y };
    },
    configurable: true,
});
Object.defineProperty(RoomPosition.prototype, "neighbors", {
    get: function () {
        const adjPos = [];
        for (const dx of [-1, 0, 1]) {
            for (const dy of [-1, 0, 1]) {
                if (!(dx == 0 && dy == 0)) {
                    const x = this.x + dx;
                    const y = this.y + dy;
                    if (0 < x && x < 49 && 0 < y && y < 49) {
                        adjPos.push(new RoomPosition(x, y, this.roomName));
                    }
                }
            }
        }
        return adjPos;
    },
    configurable: true,
});
let lastSitePlacedFullTick;
// eslint-disable-next-line @typescript-eslint/unbound-method
const _createConstructionSite = RoomPosition.prototype.createConstructionSite;
RoomPosition.prototype.createConstructionSite = function (structureType, name) {
    if (lastSitePlacedFullTick === Game.time) {
        return ERR_FULL;
    }
    // @ts-expect-error function wrapping
    const result = _createConstructionSite.call(this, structureType, name);
    if (result === ERR_FULL) {
        // For some reason, when you place a construction site, the last check they run to see if
        // you're already at max placed sites searches through EVERY SINGLE GAME OBJECT you have
        // access to, which is quite expensive! Don't try to make a bunch more of these or you'll
        // murder your CPU.
        if (lastSitePlacedFullTick !== Game.time) {
            log.warning(`RoomPosition.createConstructionSite: ERR_FULL triggered, disabling construction for tick ${Game.time}`);
        }
        lastSitePlacedFullTick = Game.time;
    }
    return result;
};
RoomPosition.prototype.inRangeToPos = function (pos, range) {
    return (this.roomName === pos.roomName &&
        (pos.x - this.x < 0 ? this.x - pos.x : pos.x - this.x) <= range &&
        (pos.y - this.y < 0 ? this.y - pos.y : pos.y - this.y) <= range);
};
RoomPosition.prototype.inRangeToXY = function (x, y, range) {
    return ((x - this.x < 0 ? this.x - x : x - this.x) <= range &&
        (y - this.y < 0 ? this.y - y : y - this.y) <= range);
};
RoomPosition.prototype.getRangeToXY = function (x, y) {
    return Math.max(x - this.x < 0 ? this.x - x : x - this.x, y - this.y < 0 ? this.y - y : y - this.y);
};
RoomPosition.prototype.getPositionsInRange = function (range, includeWalls = false, includeEdges = false) {
    const terrain = Game.map.getRoomTerrain(this.roomName);
    const adjPos = [];
    const [xmin, xmax] = includeEdges ? [0, 49] : [1, 48];
    const [ymin, ymax] = includeEdges ? [0, 49] : [1, 48];
    for (let dx = -1 * range; dx <= range; dx++) {
        for (let dy = -1 * range; dy <= range; dy++) {
            const x = this.x + dx;
            const y = this.y + dy;
            if (xmin <= x && x <= xmax && ymin <= y && y <= ymax) {
                if (includeWalls || terrain.get(x, y) !== TERRAIN_MASK_WALL) {
                    adjPos.push(new RoomPosition(x, y, this.roomName));
                }
            }
        }
    }
    return adjPos;
};
RoomPosition.prototype.getPositionsAtRange = function (range, includeWalls = false, includeEdges = false) {
    const terrain = Game.map.getRoomTerrain(this.roomName);
    const adjPos = [];
    const [xmin, xmax] = includeEdges ? [0, 49] : [1, 48];
    const [ymin, ymax] = includeEdges ? [0, 49] : [1, 48];
    for (let dx = -1 * range; dx <= range; dx++) {
        for (let dy = -1 * range; dy <= range; dy++) {
            if (Math.max(Math.abs(dx), Math.abs(dy)) < range) {
                continue;
            }
            const x = this.x + dx;
            const y = this.y + dy;
            if (xmin <= x && x <= xmax && ymin <= y && y <= ymax) {
                if (includeWalls || terrain.get(x, y) !== TERRAIN_MASK_WALL) {
                    adjPos.push(new RoomPosition(x, y, this.roomName));
                }
            }
        }
    }
    return adjPos;
};
RoomPosition.prototype.isWalkable = function (ignoreCreeps = false) {
    // Is terrain passable?
    if (Game.map.getRoomTerrain(this.roomName).get(this.x, this.y) ==
        TERRAIN_MASK_WALL) {
        return false;
    }
    if (this.isVisible) {
        // Are there creeps?
        if (ignoreCreeps == false && this.lookFor(LOOK_CREEPS).length > 0) {
            return false;
        }
        // Are there structures?
        if (_.filter(this.lookFor(LOOK_STRUCTURES), (s) => !s.isWalkable).length > 0) {
            return false;
        }
    }
    return true;
};
PERMACACHE.positionNeighbors = (_a$1 = PERMACACHE.positionNeighbors) !== null && _a$1 !== void 0 ? _a$1 : {};
RoomPosition.prototype.availableNeighbors = function (ignoreCreeps = false) {
    if (ignoreCreeps) {
        const key = `${this.readableName}`;
        if (!PERMACACHE.positionNeighbors[key]) {
            PERMACACHE.positionNeighbors[key] = this.neighbors.filter((pos) => pos.isWalkable(ignoreCreeps));
        }
        return PERMACACHE.positionNeighbors[key];
    }
    else {
        return this.neighbors.filter((pos) => pos.isWalkable(ignoreCreeps));
    }
};
RoomPosition.prototype.getPositionAtDirection = function (direction, range = 1) {
    let dx = 0;
    let dy = 0;
    switch (direction) {
        case 1:
            dy = -range;
            break;
        case 2:
            dy = -range;
            dx = range;
            break;
        case 3:
            dx = range;
            break;
        case 4:
            dx = range;
            dy = range;
            break;
        case 5:
            dy = range;
            break;
        case 6:
            dy = range;
            dx = -range;
            break;
        case 7:
            dx = -range;
            break;
        case 8:
            dx = -range;
            dy = -range;
            break;
    }
    return this.getOffsetPos(dx, dy);
};
// Object.defineProperty(RoomPosition.prototype, 'availableAdjacentSpots', {
// 	get: function () {
// 		if (this.isVisible) {
// 			let spots: RoomPosition[] = [];
// 			for (let spot of this.adjacentSpots) {
// 				let structures = this.look;
// 				if (Game.map.getTerrainAt(neighbor) != 'wall') {
// 					// Doesn't include constructed walls
// 					spots.push(neighbor);
// 				}
// 			}
// 			return spots;
// 		} else {
// 			return this.adjacentSpots; // Assume there's nothing there
// 		}
// 	}
// });
RoomPosition.prototype.getMultiRoomRangeTo = function (pos) {
    if (this.roomName == pos.roomName) {
        return this.getRangeTo(pos);
    }
    else {
        const from = this.roomCoords;
        const to = pos.roomCoords;
        const dx = Math.abs(50 * (to.x - from.x) + pos.x - this.x);
        const dy = Math.abs(50 * (to.y - from.y) + pos.y - this.y);
        return _.max([dx, dy]);
    }
};
RoomPosition.prototype.findClosestByLimitedRange = function (objects, rangeLimit, opts) {
    var _a;
    const objectsInRange = this.findInRange(objects, rangeLimit, opts);
    return (_a = this.findClosestByRange(objectsInRange, opts)) !== null && _a !== void 0 ? _a : undefined;
};
RoomPosition.prototype.findClosestByMultiRoomRange = function (objects) {
    return minBy(objects, (obj) => this.getMultiRoomRangeTo(obj.pos));
};
// This should only be used within a single room
RoomPosition.prototype.findClosestByRangeThenPath = function (objects) {
    var _a, _b;
    const distances = _.map(objects, (obj) => this.getRangeTo(obj));
    const minDistance = _.min(distances);
    if (minDistance > 4) {
        return (_a = this.findClosestByRange(objects)) !== null && _a !== void 0 ? _a : undefined;
    }
    else {
        const closestObjects = _.filter(objects, (obj) => this.getRangeTo(obj) == minDistance);
        // don't clutter up pathing.distance cached values
        return (_b = this.findClosestByPath(closestObjects)) !== null && _b !== void 0 ? _b : undefined;
    }
};

RoomVisual.prototype.infoBox = function (info, x, y, opts = {}) {
    var _a;
    _.defaults(opts, {
        color: colors.infoBoxGood,
        textstyle: false,
        textsize: speechSize,
        textfont: "verdana",
        opacity: 0.7,
    });
    let fontstring = "";
    if (opts.textstyle) {
        fontstring = opts.textstyle + " ";
    }
    fontstring += opts.textsize + " " + opts.textfont;
    let pointer = [
        [0.9, -0.25],
        [0.9, 0.25],
        [0.3, 0.0],
    ];
    pointer = relPoly(x, y, pointer);
    pointer.push(pointer[0]);
    // Draw arrow
    this.poly(pointer, {
        fill: undefined,
        stroke: opts.color,
        opacity: opts.opacity,
        strokeWidth: 0.0,
    });
    // // Draw box
    // this.rect(x + 0.9, y - 0.8 * opts.textsize,
    // 	0.55 * opts.textsize * _.max(_.map(info, line => line.length)), info.length * opts.textsize,
    // 	{
    // 		fill   : undefined,
    // 		opacity: opts.opacity
    // 	});
    // Draw vertical bar
    const x0 = x + 0.9;
    const y0 = y - 0.8 * opts.textsize;
    this.line(x0, y0, x0, y0 + info.length * opts.textsize, {
        color: opts.color,
    });
    // Draw text
    let dy = 0;
    for (const line of info) {
        this.text(line, x + 1, y + dy, {
            color: (_a = opts.textcolor) !== null && _a !== void 0 ? _a : opts.color,
            // backgroundColor  : opts.background,
            backgroundPadding: 0.1,
            opacity: opts.opacity,
            font: fontstring,
            align: "left",
        });
        dy += opts.textsize;
    }
    return this;
};
RoomVisual.prototype.multitext = function (textLines, x, y, opts = {}) {
    _.defaults(opts, {
        color: colors.infoBoxGood,
        textstyle: false,
        textsize: speechSize,
        textfont: "verdana",
        opacity: 0.7,
    });
    let fontstring = "";
    if (opts.textstyle) {
        fontstring = opts.textstyle + " ";
    }
    fontstring += opts.textsize + " " + opts.textfont;
    // // Draw vertical bar
    // let x0 = x + 0.9;
    // let y0 = y - 0.8 * opts.textsize;
    // this.line(x0, y0, x0, y0 + textLines.length * opts.textsize, {
    // 	color: opts.color,
    // });
    // Draw text
    let dy = 0;
    for (const line of textLines) {
        this.text(line, x, y + dy, {
            color: opts.color,
            // backgroundColor  : opts.background,
            backgroundPadding: 0.1,
            opacity: opts.opacity,
            font: fontstring,
            align: "left",
        });
        dy += opts.textsize;
    }
    return this;
};
RoomVisual.prototype.box = function (x, y, w, h, style) {
    return this.line(x, y, x + w, y, style)
        .line(x + w, y, x + w, y + h, style)
        .line(x + w, y + h, x, y + h, style)
        .line(x, y + h, x, y, style);
};
// Taken from https://github.com/screepers/RoomVisual with slight modification: ========================================
const colors = {
    gray: "#555555",
    light: "#AAAAAA",
    road: "#666", // >:D
    energy: "#FFE87B",
    power: "#F53547",
    dark: "#181818",
    outline: "#8FBB93",
    speechText: "#000000",
    speechBackground: "#aebcc4",
    infoBoxGood: "#09ff00",
    infoBoxBad: "#ff2600",
};
const speechSize = 0.5;
const speechFont = "Times New Roman";
RoomVisual.prototype.structure = function (x, y, type, opts = {}) {
    var _a;
    _.defaults(opts, { opacity: 0.5 });
    switch (type) {
        case STRUCTURE_EXTENSION:
            this.circle(x, y, {
                radius: 0.5,
                fill: colors.dark,
                stroke: colors.outline,
                strokeWidth: 0.05,
                opacity: opts.opacity,
            });
            this.circle(x, y, {
                radius: 0.35,
                fill: colors.gray,
                opacity: opts.opacity,
            });
            break;
        case STRUCTURE_SPAWN:
            this.circle(x, y, {
                radius: 0.65,
                fill: colors.dark,
                stroke: "#CCCCCC",
                strokeWidth: 0.1,
                opacity: opts.opacity,
            });
            this.circle(x, y, {
                radius: 0.4,
                fill: colors.energy,
                opacity: opts.opacity,
            });
            break;
        case STRUCTURE_POWER_SPAWN:
            this.circle(x, y, {
                radius: 0.65,
                fill: colors.dark,
                stroke: colors.power,
                strokeWidth: 0.1,
                opacity: opts.opacity,
            });
            this.circle(x, y, {
                radius: 0.4,
                fill: colors.energy,
                opacity: opts.opacity,
            });
            break;
        case STRUCTURE_LINK: {
            // let osize = 0.3;
            // let isize = 0.2;
            let outer = [
                [0.0, -0.5],
                [0.4, 0.0],
                [0.0, 0.5],
                [-0.4, 0.0],
            ];
            let inner = [
                [0.0, -0.3],
                [0.25, 0.0],
                [0.0, 0.3],
                [-0.25, 0.0],
            ];
            outer = relPoly(x, y, outer);
            inner = relPoly(x, y, inner);
            outer.push(outer[0]);
            inner.push(inner[0]);
            this.poly(outer, {
                fill: colors.dark,
                stroke: colors.outline,
                strokeWidth: 0.05,
                opacity: opts.opacity,
            });
            this.poly(inner, {
                fill: colors.gray,
                opacity: opts.opacity,
            });
            break;
        }
        case STRUCTURE_TERMINAL: {
            let outer = [
                [0.0, -0.8],
                [0.55, -0.55],
                [0.8, 0.0],
                [0.55, 0.55],
                [0.0, 0.8],
                [-0.55, 0.55],
                [-0.8, 0.0],
                [-0.55, -0.55],
            ];
            let inner = [
                [0.0, -0.65],
                [0.45, -0.45],
                [0.65, 0.0],
                [0.45, 0.45],
                [0.0, 0.65],
                [-0.45, 0.45],
                [-0.65, 0.0],
                [-0.45, -0.45],
            ];
            outer = relPoly(x, y, outer);
            inner = relPoly(x, y, inner);
            outer.push(outer[0]);
            inner.push(inner[0]);
            this.poly(outer, {
                fill: colors.dark,
                stroke: colors.outline,
                strokeWidth: 0.05,
                opacity: opts.opacity,
            });
            this.poly(inner, {
                fill: colors.light,
                opacity: opts.opacity,
            });
            this.rect(x - 0.45, y - 0.45, 0.9, 0.9, {
                fill: colors.gray,
                stroke: colors.dark,
                strokeWidth: 0.1,
                opacity: opts.opacity,
            });
            break;
        }
        case STRUCTURE_LAB:
            this.circle(x, y - 0.025, {
                radius: 0.55,
                fill: colors.dark,
                stroke: colors.outline,
                strokeWidth: 0.05,
                opacity: opts.opacity,
            });
            this.circle(x, y - 0.025, {
                radius: 0.4,
                fill: colors.gray,
                opacity: opts.opacity,
            });
            this.rect(x - 0.45, y + 0.3, 0.9, 0.25, {
                fill: colors.dark,
                opacity: opts.opacity,
            });
            {
                let box = [
                    [-0.45, 0.3],
                    [-0.45, 0.55],
                    [0.45, 0.55],
                    [0.45, 0.3],
                ];
                box = relPoly(x, y, box);
                this.poly(box, {
                    stroke: colors.outline,
                    strokeWidth: 0.05,
                    opacity: opts.opacity,
                });
            }
            break;
        case STRUCTURE_TOWER:
            this.circle(x, y, {
                radius: 0.6,
                fill: colors.dark,
                stroke: colors.outline,
                strokeWidth: 0.05,
                opacity: opts.opacity,
            });
            this.rect(x - 0.4, y - 0.3, 0.8, 0.6, {
                fill: colors.gray,
                opacity: opts.opacity,
            });
            this.rect(x - 0.2, y - 0.9, 0.4, 0.5, {
                fill: colors.light,
                stroke: colors.dark,
                strokeWidth: 0.07,
                opacity: opts.opacity,
            });
            break;
        case STRUCTURE_ROAD:
            this.circle(x, y, {
                radius: 0.175,
                fill: colors.road,
                opacity: opts.opacity,
            });
            (_a = this.roads) !== null && _a !== void 0 ? _a : (this.roads = []);
            this.roads.push([x, y]);
            break;
        case STRUCTURE_RAMPART:
            this.circle(x, y, {
                radius: 0.65,
                fill: "#434C43",
                stroke: "#5D735F",
                strokeWidth: 0.1,
                opacity: opts.opacity,
            });
            break;
        case STRUCTURE_WALL:
            this.circle(x, y, {
                radius: 0.4,
                fill: colors.dark,
                stroke: colors.light,
                strokeWidth: 0.05,
                opacity: opts.opacity,
            });
            break;
        case STRUCTURE_STORAGE:
            const storageOutline = relPoly(x, y, [
                [-0.45, -0.55],
                [0, -0.65],
                [0.45, -0.55],
                [0.55, 0],
                [0.45, 0.55],
                [0, 0.65],
                [-0.45, 0.55],
                [-0.55, 0],
                [-0.45, -0.55],
            ]);
            this.poly(storageOutline, {
                stroke: colors.outline,
                strokeWidth: 0.05,
                fill: colors.dark,
                opacity: opts.opacity,
            });
            this.rect(x - 0.35, y - 0.45, 0.7, 0.9, {
                fill: colors.energy,
                opacity: opts.opacity,
            });
            break;
        case STRUCTURE_OBSERVER:
            this.circle(x, y, {
                fill: colors.dark,
                radius: 0.45,
                stroke: colors.outline,
                strokeWidth: 0.05,
                opacity: opts.opacity,
            });
            this.circle(x + 0.225, y, {
                fill: colors.outline,
                radius: 0.2,
                opacity: opts.opacity,
            });
            break;
        case STRUCTURE_NUKER:
            let outline = [
                [0, -1],
                [-0.47, 0.2],
                [-0.5, 0.5],
                [0.5, 0.5],
                [0.47, 0.2],
                [0, -1],
            ];
            outline = relPoly(x, y, outline);
            this.poly(outline, {
                stroke: colors.outline,
                strokeWidth: 0.05,
                fill: colors.dark,
                opacity: opts.opacity,
            });
            let inline = [
                [0, -0.8],
                [-0.4, 0.2],
                [0.4, 0.2],
                [0, -0.8],
            ];
            inline = relPoly(x, y, inline);
            this.poly(inline, {
                stroke: colors.outline,
                strokeWidth: 0.01,
                fill: colors.gray,
                opacity: opts.opacity,
            });
            break;
        case STRUCTURE_CONTAINER:
            this.rect(x - 0.225, y - 0.3, 0.45, 0.6, {
                fill: "yellow",
                opacity: opts.opacity,
                stroke: colors.dark,
                strokeWidth: 0.1,
            });
            break;
        default:
            this.circle(x, y, {
                fill: colors.light,
                radius: 0.35,
                stroke: colors.dark,
                strokeWidth: 0.2,
                opacity: opts.opacity,
            });
            break;
    }
    return this;
};
const dirs = [
    [],
    [0, -1],
    [1, -1],
    [1, 0],
    [1, 1],
    [0, 1],
    [-1, 1],
    [-1, 0],
    [-1, -1],
];
RoomVisual.prototype.connectRoads = function (opts = {}) {
    _.defaults(opts, { opacity: 0.5 });
    const color = opts.color || colors.road || "white";
    if (!this.roads) {
        return;
    }
    // this.text(this.roads.map(r=>r.join(',')).join(' '),25,23)
    this.roads.forEach((r) => {
        // this.text(`${r[0]},${r[1]}`,r[0],r[1],{ size: 0.2 })
        for (let i = 1; i <= 4; i++) {
            const d = dirs[i];
            const c = [r[0] + d[0], r[1] + d[1]];
            const rd = _.some(this.roads, (r) => r[0] == c[0] && r[1] == c[1]);
            // this.text(`${c[0]},${c[1]}`,c[0],c[1],{ size: 0.2, color: rd?'green':'red' })
            if (rd) {
                this.line(r[0], r[1], c[0], c[1], {
                    color: color,
                    width: 0.35,
                    opacity: opts.opacity,
                });
            }
        }
    });
    return this;
};
RoomVisual.prototype.speech = function (text, x, y, opts = {}) {
    const background = !!opts.background ? opts.background : colors.speechBackground;
    const textcolor = !!opts.textcolor ? opts.textcolor : colors.speechText;
    const textstyle = !!opts.textstyle ? opts.textstyle : false;
    const textsize = !!opts.textsize ? opts.textsize : speechSize;
    const textfont = !!opts.textfont ? opts.textfont : speechFont;
    const opacity = !!opts.opacity ? opts.opacity : 1;
    let fontstring = "";
    if (textstyle) {
        fontstring = textstyle + " ";
    }
    fontstring += textsize + " " + textfont;
    let pointer = [
        [-0.2, -0.8],
        [0.2, -0.8],
        [0, -0.3],
    ];
    pointer = relPoly(x, y, pointer);
    pointer.push(pointer[0]);
    this.poly(pointer, {
        fill: background,
        stroke: background,
        opacity: opacity,
        strokeWidth: 0.0,
    });
    this.text(text, x, y - 1, {
        color: textcolor,
        backgroundColor: background,
        backgroundPadding: 0.1,
        opacity: opacity,
        font: fontstring,
    });
    return this;
};
RoomVisual.prototype.animatedPosition = function (x, y, opts = {}) {
    const color = !!opts.color ? opts.color : "blue";
    const opacity = !!opts.opacity ? opts.opacity : 0.5;
    let radius = !!opts.radius ? opts.radius : 0.75;
    const frames = !!opts.frames ? opts.frames : 6;
    const angle = (((Game.time % frames) * 90) / frames) * (Math.PI / 180);
    const s = Math.sin(angle);
    const c = Math.cos(angle);
    const sizeMod = Math.abs((Game.time % frames) - frames / 2) / 10;
    radius += radius * sizeMod;
    const points = [
        rotate(0, -radius, s, c, x, y),
        rotate(radius, 0, s, c, x, y),
        rotate(0, radius, s, c, x, y),
        rotate(-radius, 0, s, c, x, y),
        rotate(0, -radius, s, c, x, y),
    ];
    this.poly(points, { stroke: color, opacity: opacity });
    return this;
};
function rotate(x, y, s, c, px, py) {
    const xDelta = x * c - y * s;
    const yDelta = x * s + y * c;
    return [px + xDelta, py + yDelta];
}
function relPoly(x, y, poly) {
    return poly.map((p) => {
        p[0] += x;
        p[1] += y;
        return p;
    });
}
RoomVisual.prototype.test = function () {
    const demopos = [19, 24];
    this.clear();
    this.structure(demopos[0] + 0, demopos[1] + 0, STRUCTURE_LAB);
    this.structure(demopos[0] + 1, demopos[1] + 1, STRUCTURE_TOWER);
    this.structure(demopos[0] + 2, demopos[1] + 0, STRUCTURE_LINK);
    this.structure(demopos[0] + 3, demopos[1] + 1, STRUCTURE_TERMINAL);
    this.structure(demopos[0] + 4, demopos[1] + 0, STRUCTURE_EXTENSION);
    this.structure(demopos[0] + 5, demopos[1] + 1, STRUCTURE_SPAWN);
    this.animatedPosition(demopos[0] + 7, demopos[1]);
    this.speech("This is a test!", demopos[0] + 10, demopos[1], {
        opacity: 0.7,
    });
    // this.infoBox(['This is', 'a test', 'mmmmmmmmmmmmm'], demopos[0] + 15, demopos[1]);
    return this;
};
const ColorSets = {
    white: ["#ffffff", "#4c4c4c"],
    grey: ["#b4b4b4", "#4c4c4c"],
    red: ["#ff7b7b", "#592121"],
    yellow: ["#fdd388", "#5d4c2e"],
    green: ["#00f4a2", "#236144"],
    blue: ["#50d7f9", "#006181"],
    purple: ["#a071ff", "#371383"],
};
const ResourceColors = {
    [RESOURCE_ENERGY]: ColorSets.yellow,
    [RESOURCE_POWER]: ColorSets.red,
    [RESOURCE_HYDROGEN]: ColorSets.grey,
    [RESOURCE_OXYGEN]: ColorSets.grey,
    [RESOURCE_UTRIUM]: ColorSets.blue,
    [RESOURCE_LEMERGIUM]: ColorSets.green,
    [RESOURCE_KEANIUM]: ColorSets.purple,
    [RESOURCE_ZYNTHIUM]: ColorSets.yellow,
    [RESOURCE_CATALYST]: ColorSets.red,
    [RESOURCE_GHODIUM]: ColorSets.white,
    [RESOURCE_HYDROXIDE]: ColorSets.grey,
    [RESOURCE_ZYNTHIUM_KEANITE]: ColorSets.grey,
    [RESOURCE_UTRIUM_LEMERGITE]: ColorSets.grey,
    [RESOURCE_UTRIUM_HYDRIDE]: ColorSets.blue,
    [RESOURCE_UTRIUM_OXIDE]: ColorSets.blue,
    [RESOURCE_KEANIUM_HYDRIDE]: ColorSets.purple,
    [RESOURCE_KEANIUM_OXIDE]: ColorSets.purple,
    [RESOURCE_LEMERGIUM_HYDRIDE]: ColorSets.green,
    [RESOURCE_LEMERGIUM_OXIDE]: ColorSets.green,
    [RESOURCE_ZYNTHIUM_HYDRIDE]: ColorSets.yellow,
    [RESOURCE_ZYNTHIUM_OXIDE]: ColorSets.yellow,
    [RESOURCE_GHODIUM_HYDRIDE]: ColorSets.white,
    [RESOURCE_GHODIUM_OXIDE]: ColorSets.white,
    [RESOURCE_UTRIUM_ACID]: ColorSets.blue,
    [RESOURCE_UTRIUM_ALKALIDE]: ColorSets.blue,
    [RESOURCE_KEANIUM_ACID]: ColorSets.purple,
    [RESOURCE_KEANIUM_ALKALIDE]: ColorSets.purple,
    [RESOURCE_LEMERGIUM_ACID]: ColorSets.green,
    [RESOURCE_LEMERGIUM_ALKALIDE]: ColorSets.green,
    [RESOURCE_ZYNTHIUM_ACID]: ColorSets.yellow,
    [RESOURCE_ZYNTHIUM_ALKALIDE]: ColorSets.yellow,
    [RESOURCE_GHODIUM_ACID]: ColorSets.white,
    [RESOURCE_GHODIUM_ALKALIDE]: ColorSets.white,
    [RESOURCE_CATALYZED_UTRIUM_ACID]: ColorSets.blue,
    [RESOURCE_CATALYZED_UTRIUM_ALKALIDE]: ColorSets.blue,
    [RESOURCE_CATALYZED_KEANIUM_ACID]: ColorSets.purple,
    [RESOURCE_CATALYZED_KEANIUM_ALKALIDE]: ColorSets.purple,
    [RESOURCE_CATALYZED_LEMERGIUM_ACID]: ColorSets.green,
    [RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE]: ColorSets.green,
    [RESOURCE_CATALYZED_ZYNTHIUM_ACID]: ColorSets.yellow,
    [RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE]: ColorSets.yellow,
    [RESOURCE_CATALYZED_GHODIUM_ACID]: ColorSets.white,
    [RESOURCE_CATALYZED_GHODIUM_ALKALIDE]: ColorSets.white,
};
RoomVisual.prototype.resource = function (type, x, y, size = 0.25, opacity = 1) {
    if (type == RESOURCE_ENERGY || type == RESOURCE_POWER) {
        this._fluid(type, x, y, size, opacity);
    }
    else if ([
        RESOURCE_CATALYST,
        RESOURCE_HYDROGEN,
        RESOURCE_OXYGEN,
        RESOURCE_LEMERGIUM,
        RESOURCE_UTRIUM,
        RESOURCE_ZYNTHIUM,
        RESOURCE_KEANIUM,
    ].includes(type)) {
        this._mineral(type, x, y, size, opacity);
    }
    else if (ResourceColors[type] != undefined) {
        this._compound(type, x, y, size, opacity);
    }
    else {
        return ERR_INVALID_ARGS;
    }
    return OK;
};
RoomVisual.prototype._fluid = function (type, x, y, size = 0.25, opacity = 1) {
    this.circle(x, y, {
        radius: size,
        fill: ResourceColors[type][0],
        opacity: opacity,
    });
    this.text(type[0], x, y - size * 0.1, {
        font: size * 1.5,
        color: ResourceColors[type][1],
        backgroundColor: ResourceColors[type][0],
        backgroundPadding: 0,
        opacity: opacity,
    });
};
RoomVisual.prototype._mineral = function (type, x, y, size = 0.25, opacity = 1) {
    this.circle(x, y, {
        radius: size,
        fill: ResourceColors[type][0],
        opacity: opacity,
    });
    this.circle(x, y, {
        radius: size * 0.8,
        fill: ResourceColors[type][1],
        opacity: opacity,
    });
    this.text(type, x, y + size * 0.03, {
        font: "bold " + size * 1.25 + " arial",
        color: ResourceColors[type][0],
        backgroundColor: ResourceColors[type][1],
        backgroundPadding: 0,
        opacity: opacity,
    });
};
RoomVisual.prototype._compound = function (type, x, y, size = 0.25, opacity = 1) {
    const label = type.replace("2", "₂");
    this.text(label, x, y, {
        font: "bold " + size * 1 + " arial",
        color: ResourceColors[type][1],
        backgroundColor: ResourceColors[type][0],
        backgroundPadding: 0.3 * size,
        opacity: opacity,
    });
};

// Room prototypes - commonly used room properties and methods
// Logging =============================================================================================================
Object.defineProperty(Room.prototype, "print", {
    get() {
        return ('<a href="#!/room/' +
            Game.shard.name +
            "/" +
            this.name +
            '">' +
            this.name +
            "</a>");
    },
    configurable: true,
});
// Room properties =====================================================================================================
Object.defineProperty(Room.prototype, "my", {
    get() {
        return this.controller && this.controller.my;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, "isColony", {
    get() {
        return Overmind.colonies[this.name] != undefined;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, "isOutpost", {
    get() {
        return Overmind.colonyMap[this.name] != undefined;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, "owner", {
    get() {
        return this.controller && this.controller.owner ?
            this.controller.owner.username
            : undefined;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, "reservedByMe", {
    get() {
        return (this.controller &&
            this.controller.reservation &&
            this.controller.reservation.username == MY_USERNAME);
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, "signedByMe", {
    get() {
        return (this.controller &&
            this.controller.sign &&
            this.controller.sign.text == Memory.settings.signature);
    },
    configurable: true,
});
// Room properties: creeps =============================================================================================
// Creeps physically in the room
Object.defineProperty(Room.prototype, "creeps", {
    get() {
        if (!this._creeps) {
            this._creeps = this.find(FIND_MY_CREEPS);
        }
        return this._creeps;
    },
    configurable: true,
});
// Room properties: hostiles ===========================================================================================
Object.defineProperty(Room.prototype, "hostiles", {
    get() {
        if (!this._hostiles) {
            this._hostiles = this.find(FIND_HOSTILE_CREEPS, {
                filter: (creep) => !isAlly(creep.owner.username),
            });
        }
        return this._hostiles;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, "friendlies", {
    get() {
        if (!this._friendlies) {
            this._friendlies = this.find(FIND_CREEPS, {
                filter: (creep) => isAlly(creep.owner.username),
            });
        }
        return this._friendlies;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, "invaders", {
    get() {
        if (!this._invaders) {
            this._invaders = _.filter(this.hostiles, (creep) => creep.owner.username == "Invader");
        }
        return this._invaders;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, "sourceKeepers", {
    get() {
        if (!this._sourceKeepers) {
            this._sourceKeepers = _.filter(this.hostiles, (creep) => creep.owner.username == "Source Keeper");
        }
        return this._sourceKeepers;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, "playerHostiles", {
    get() {
        if (!this._playerHostiles) {
            this._playerHostiles = _.filter(this.hostiles, (creep) => creep.isPlayer);
        }
        return this._playerHostiles;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, "dangerousHostiles", {
    get() {
        if (!this._dangerousHostiles) {
            if (this.my) {
                this._dangerousHostiles = _.filter(this.hostiles, (creep) => creep.getActiveBodyparts(ATTACK) > 0 ||
                    creep.getActiveBodyparts(RANGED_ATTACK) > 0 ||
                    creep.getActiveBodyparts(WORK) > 0);
            }
            else {
                this._dangerousHostiles = _.filter(this.hostiles, (creep) => creep.getActiveBodyparts(ATTACK) > 0 ||
                    creep.getActiveBodyparts(RANGED_ATTACK) > 0);
            }
        }
        return this._dangerousHostiles;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, "dangerousPlayerHostiles", {
    get() {
        if (!this._dangerousPlayerHostiles) {
            if (this.my) {
                this._dangerousPlayerHostiles = _.filter(this.playerHostiles, (creep) => creep.getActiveBodyparts(ATTACK) > 0 ||
                    creep.getActiveBodyparts(RANGED_ATTACK) > 0 ||
                    creep.getActiveBodyparts(CLAIM) > 0 ||
                    creep.getActiveBodyparts(WORK) > 0);
            }
            else {
                this._dangerousPlayerHostiles = _.filter(this.playerHostiles, (creep) => creep.getActiveBodyparts(ATTACK) > 0 ||
                    creep.getActiveBodyparts(RANGED_ATTACK) > 0);
            }
        }
        return this._dangerousPlayerHostiles;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, "fleeDefaults", {
    get() {
        if (!this._fleeDefaults) {
            this._fleeDefaults = [
                ...this.dangerousHostiles,
                ..._.filter(this.keeperLairs, (l) => (l.ticksToSpawn || Infinity) <= 10),
            ];
        }
        return this._fleeDefaults;
    },
    configurable: true,
});
// Hostile structures currently in the room
Object.defineProperty(Room.prototype, "structures", {
    get() {
        if (!this._allStructures) {
            this._allStructures = this.find(FIND_STRUCTURES);
        }
        return this._allStructures;
    },
    configurable: true,
});
// Hostile structures currently in the room
Object.defineProperty(Room.prototype, "hostileStructures", {
    get() {
        if (!this._hostileStructures) {
            this._hostileStructures = this.find(FIND_HOSTILE_STRUCTURES, {
                filter: (s) => s.hitsMax && !isAlly(_.get(s, ["owner", "username"])),
            });
        }
        return this._hostileStructures;
    },
    configurable: true,
});
// Room properties: flags ==============================================================================================
// Flags physically in this room
Object.defineProperty(Room.prototype, "flags", {
    get() {
        if (!this._flags) {
            this._flags = this.find(FIND_FLAGS);
        }
        return this._flags;
    },
    configurable: true,
});
// Room properties: structures =========================================================================================
Object.defineProperty(Room.prototype, "constructionSites", {
    get() {
        if (!this._constructionSites) {
            this._constructionSites = this.find(FIND_MY_CONSTRUCTION_SITES);
        }
        return this._constructionSites;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, "allConstructionSites", {
    get() {
        if (!this._allConstructionSites) {
            this._allConstructionSites = this.find(FIND_CONSTRUCTION_SITES);
        }
        return this._allConstructionSites;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, "hostileConstructionSites", {
    get() {
        if (!this._hostileConstructionSites) {
            this._hostileConstructionSites = this.find(FIND_HOSTILE_CONSTRUCTION_SITES);
        }
        return this._hostileConstructionSites;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, "tombstones", {
    get() {
        if (!this._tombstones) {
            this._tombstones = this.find(FIND_TOMBSTONES);
        }
        return this._tombstones;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, "ruins", {
    get() {
        if (!this._ruins) {
            this._ruins = this.find(FIND_RUINS);
        }
        return this._ruins;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, "drops", {
    get() {
        if (!this._drops) {
            this._drops = _.groupBy(this.find(FIND_DROPPED_RESOURCES), (r) => r.resourceType);
        }
        return this._drops;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, "deposits", {
    get() {
        if (!this._deposits) {
            this._deposits = this.find(FIND_DEPOSITS);
        }
        return this._deposits;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, "droppedEnergy", {
    get() {
        return this.drops[RESOURCE_ENERGY] || [];
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, "droppedPower", {
    get() {
        return this.drops[RESOURCE_POWER] || [];
    },
    configurable: true,
});

// Intra- and inter-tick structure caching, adapted from semperRabbit's IVM module
const roomStructureIDs = {};
const roomStructuresExpiration = {};
const multipleList = [
    STRUCTURE_SPAWN,
    STRUCTURE_EXTENSION,
    STRUCTURE_ROAD,
    STRUCTURE_WALL,
    STRUCTURE_RAMPART,
    STRUCTURE_KEEPER_LAIR,
    STRUCTURE_PORTAL,
    STRUCTURE_LINK,
    STRUCTURE_TOWER,
    STRUCTURE_LAB,
    STRUCTURE_CONTAINER,
    STRUCTURE_POWER_BANK,
];
const singleList = [
    STRUCTURE_OBSERVER,
    STRUCTURE_POWER_SPAWN,
    STRUCTURE_EXTRACTOR,
    STRUCTURE_NUKER,
    STRUCTURE_FACTORY,
    STRUCTURE_INVADER_CORE,
    // STRUCTURE_TERMINAL,   STRUCTURE_CONTROLLER,   STRUCTURE_STORAGE, // These already have room.* shortcuts to them
];
const notRepairable = [
    STRUCTURE_KEEPER_LAIR,
    STRUCTURE_PORTAL,
    STRUCTURE_POWER_BANK,
    STRUCTURE_INVADER_CORE,
];
const STRUCTURE_TIMEOUT = onPublicServer() ? 50 : 10;
Room.prototype._refreshStructureCache = function () {
    // if cache is expired or doesn't exist
    if (!roomStructuresExpiration[this.name] ||
        !roomStructureIDs[this.name] ||
        Game.time > roomStructuresExpiration[this.name]) {
        roomStructuresExpiration[this.name] =
            getCacheExpiration(STRUCTURE_TIMEOUT);
        roomStructureIDs[this.name] = _.mapValues(_.groupBy(this.find(FIND_STRUCTURES), (s) => s.structureType), (structures) => _.map(structures, (s) => s.id));
    }
};
multipleList.forEach(function (type) {
    Object.defineProperty(Room.prototype, type + "s", {
        get: function () {
            const key = `_${type}s`;
            // @ts-expect-error property access
            let val = this[key];
            if (val) {
                return val;
            }
            else {
                this._refreshStructureCache();
                if (roomStructureIDs[this.name][type]) {
                    val = _.compact(_.map(roomStructureIDs[this.name][type], (id) => Game.getObjectById(id)));
                }
                else {
                    val = [];
                }
                // @ts-expect-error property access
                this[key] = val;
                return val;
            }
        },
        configurable: true,
    });
});
singleList.forEach(function (type) {
    Object.defineProperty(Room.prototype, type, {
        get: function () {
            const key = `_${type}`;
            // @ts-expect-error property access
            let val = this[key];
            if (val) {
                return val;
            }
            else {
                this._refreshStructureCache();
                if (roomStructureIDs[this.name][type]) {
                    val = Game.getObjectById(roomStructureIDs[this.name][type][0]);
                }
                else {
                    val = undefined;
                }
                // @ts-expect-error property access
                this[key] = val;
                return val;
            }
        },
        configurable: true,
    });
});
Object.defineProperty(Room.prototype, "storageUnits", {
    get() {
        if (!this._storageUnits) {
            const special = [
                this.storage,
                this.terminal,
            ];
            this._storageUnits = (_.compact(special).concat(this.containers));
        }
        return this._storageUnits;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, "sources", {
    get() {
        if (!this._sources) {
            this._sources = this.find(FIND_SOURCES);
        }
        return this.find(FIND_SOURCES);
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, "mineral", {
    get() {
        if (!this._mineral) {
            this._mineral = this.find(FIND_MINERALS)[0];
        }
        return this._mineral;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, "repairables", {
    get() {
        if (!this._repairables) {
            this._refreshStructureCache();
            if (roomStructureIDs[this.name].repairables) {
                return (this._repairables = _.compact(_.map(roomStructureIDs[this.name].repairables, (o) => Game.getObjectById(o))));
            }
            else {
                let repairables = [];
                for (const structureType of singleList) {
                    const o = this[structureType];
                    if (!o || notRepairable.includes(structureType)) {
                        continue;
                    }
                    repairables.push(o);
                }
                for (const structureType of multipleList) {
                    if (structureType != STRUCTURE_WALL &&
                        structureType != STRUCTURE_RAMPART &&
                        structureType != STRUCTURE_ROAD &&
                        !notRepairable.includes(structureType)) {
                        const obj = this;
                        repairables = repairables.concat(obj[structureType + "s"]);
                    }
                }
                roomStructureIDs[this.name].repairables = _.map(repairables, (s) => s.id);
                return (this._repairables = repairables);
            }
        }
        return this._repairables;
    },
    configurable: true,
});
// TODO: this is expensive and easy to over-use. Perhaps remove this.
Object.defineProperty(Room.prototype, "walkableRamparts", {
    get() {
        if (!this._walkableRamparts) {
            this._refreshStructureCache();
            if (roomStructureIDs[this.name].walkableRamparts) {
                return (this._walkableRamparts = _.compact(_.map(roomStructureIDs[this.name].walkableRamparts, (o) => Game.getObjectById(o))));
            }
            else {
                const walkableRamparts = _.filter(this.ramparts, (r) => r.pos.isWalkable(true));
                roomStructureIDs[this.name].walkableRamparts = _.map(walkableRamparts, (r) => r.id);
                return (this._walkableRamparts = walkableRamparts);
            }
        }
        return this._walkableRamparts;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, "rechargeables", {
    get() {
        if (!this._rechargeables) {
            this._rechargeables = [
                ...this.storageUnits,
                ...this.droppedEnergy,
                ...this.tombstones,
                ...this.ruins,
            ];
        }
        return this._rechargeables;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, "barriers", {
    get() {
        if (!this._barriers) {
            this._barriers = [].concat(this.ramparts, this.constructedWalls);
        }
        return this._barriers;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, "walls", {
    get() {
        return this.constructedWalls;
    },
    configurable: true,
});
Object.defineProperty(StructurePortal.prototype, "shardDestination", {
    get() {
        if (!(this.destination instanceof RoomPosition)) {
            return this.destination;
        }
        return undefined;
    },
    configurable: true,
});
Object.defineProperty(StructurePortal.prototype, "roomDestination", {
    get() {
        if (this.destination instanceof RoomPosition) {
            return this.destination;
        }
        return undefined;
    },
    configurable: true,
});

// All structure prototypes
// General structure prototypes ========================================================================================
PERMACACHE.structureWalkability = PERMACACHE.structureWalkability || {};
Object.defineProperty(Structure.prototype, "isWalkable", {
    get() {
        if (PERMACACHE.structureWalkability[this.id] !== undefined) {
            return PERMACACHE.structureWalkability[this.id];
        }
        if (this.structureType === STRUCTURE_RAMPART) {
            return this.my || this.isPublic;
        }
        else {
            PERMACACHE.structureWalkability[this.id] =
                this.structureType == STRUCTURE_ROAD ||
                    this.structureType == STRUCTURE_CONTAINER ||
                    this.structureType == STRUCTURE_PORTAL;
            return PERMACACHE.structureWalkability[this.id];
        }
    },
    configurable: true,
});
// monkey-patch OwnedStructure.isActive to include some caching since it's actually pretty expensive
// const _OwnedStructureIsActive = OwnedStructure.prototype.isActive;
// OwnedStructure.prototype._isActive = OwnedStructure.prototype.isActive;
// OwnedStructure.prototype.isActive = function() {
// 	// Do a quick check to see if the room is owned by same owner of structure and/or if it's RCL 8
// 	if (this.room.controller) {
// 		const thisOwner = this.owner ? this.owner.username : 'noThisOwner';
// 		const controllerOwner = this.room.controller.owner ? this.room.controller.username : 'noControllerOwner';
// 		if (thisOwner != controllerOwner) { // if it's not owned by room owner, it's not active
// 			return false;
// 		}
// 		const level = this.room.controller.level || 0;
// 		if (level == 8) { // everything is active at RCL 8
// 			return true;
// 		}
// 	}
// 	// Otherwise use cached value or call this.inActive()
// 	if (this._isActiveValue == undefined) {
// 		this._isActiveValue = this._isActive();
// 	}
// 	return this._isActiveValue;
// };
// Storage prototypes ================================================================================================
const StorageLikeStructures = [
    StructureContainer,
    StructureExtension,
    StructureLink,
    StructureStorage,
    StructureTerminal,
    StructureSpawn,
    Tombstone,
    Ruin,
];
for (const structure of StorageLikeStructures) {
    if (!structure.prototype.hasOwnProperty("energy")) {
        Object.defineProperty(structure.prototype, "energy", {
            get() {
                return this.store.getUsedCapacity(RESOURCE_ENERGY);
            },
            configurable: true,
        });
    }
    Object.defineProperty(structure.prototype, "isFull", {
        // if this container-like object is full
        get() {
            return this.store.getFreeCapacity() === 0;
        },
        configurable: true,
    });
    Object.defineProperty(structure.prototype, "isEmpty", {
        // if this container-like object is empty
        get() {
            return this.store.getUsedCapacity() === 0;
        },
        configurable: true,
    });
}
// Link prototypes =====================================================================================================
// Controller prototypes ===============================================================================================
Object.defineProperty(StructureController.prototype, "reservedByMe", {
    get() {
        return (this.reservation && this.reservation.username == MY_USERNAME);
    },
    configurable: true,
});
Object.defineProperty(StructureController.prototype, "signedByMe", {
    get() {
        return (this.sign &&
            this.sign.username == MY_USERNAME &&
            Game.time - this.sign.time < 250000);
    },
    configurable: true,
});
Object.defineProperty(StructureController.prototype, "signedByScreeps", {
    get() {
        return this.sign && this.sign.username == "Screeps";
    },
    configurable: true,
});
Object.defineProperty(Store.prototype, "contents", {
    get() {
        return Object.entries(this);
    },
    configurable: true,
});
// Storage prototypes ==================================================================================================
// Terminal prototypes =================================================================================================
Object.defineProperty(StructureTerminal.prototype, "isReady", {
    // the terminal is ready to send or deal
    get() {
        return this.cooldown == 0 && !this._notReady;
    },
    configurable: true,
});
Object.defineProperty(StructureTerminal.prototype, "hasReceived", {
    // terminal received this tick via send/deal
    get() {
        return this._hasReceived;
    },
    configurable: true,
});
// eslint-disable-next-line @typescript-eslint/unbound-method
const _terminalSend = StructureTerminal.prototype.send;
StructureTerminal.prototype.send = function (resourceType, amount, destination, description) {
    const response = _terminalSend.call(this, resourceType, amount, destination, description);
    if (response == OK) {
        this._notReady = true;
        const receiver = Game.rooms[destination] && Game.rooms[destination].terminal;
        if (receiver) {
            receiver._hasReceived = true;
        }
    }
    return response;
};

Number.prototype.toPercent = function (decimals = 0) {
    return (this * 100).toFixed(decimals) + "%";
};
Number.prototype.truncate = function (decimals) {
    const re = new RegExp("(\\d+\\.\\d{" + decimals + "})(\\d)"), m = this.toString().match(re);
    return m ? parseFloat(m[1]) : this.valueOf();
};
PERMACACHE.structureWalkability = PERMACACHE.structureWalkability || {};
Object.defineProperty(ConstructionSite.prototype, "isWalkable", {
    get() {
        if (PERMACACHE.structureWalkability[this.id] === undefined) {
            PERMACACHE.structureWalkability[this.id] =
                this.structureType == STRUCTURE_ROAD ||
                    this.structureType == STRUCTURE_CONTAINER ||
                    this.structureType == STRUCTURE_RAMPART;
        }
        return PERMACACHE.structureWalkability[this.id];
    },
    configurable: true,
});

const NO_ACTION = 1;
const ERR_NOT_IMPLEMENTED = -999;
const ERR_ROOM_ENERGY_CAPACITY_NOT_ENOUGH = -20;
const ERR_SPECIFIED_SPAWN_BUSY = -21;
const ERR_CANNOT_PUSH_CREEP = -30;
const ERR_SWARM_BUSY = -90;
const ERR_SWARM_ROTATE_FAILED_1 = -200;
const ERR_NO_ORDER_TO_BUY_FROM = -101;
const ERR_NO_ORDER_TO_SELL_TO = -102;
const ERR_INSUFFICIENT_ENERGY_IN_TERMINAL = -103;
const ERR_NOT_ENOUGH_MARKET_DATA = -104;
const ERR_TOO_MANY_ORDERS_OF_TYPE = -105;
const ERR_SELL_DIRECT_PRICE_TOO_LOW = -106;
const ERR_BUY_DIRECT_PRICE_TOO_HIGH = -107;
const ERR_CREDIT_THRESHOLDS = -108;
const ERR_DONT_BUY_REACTION_INTERMEDIATES = -109;
const ERR_DRY_RUN_ONLY_SUPPORTS_DIRECT_TRANSACTIONS = -110;
const errorMap = {
    "21": "CROSSING_PORTAL",
    "1": "NO_ACTION",
    "0": "OK",
    "-1": "ERR_NOT_OWNER",
    "-2": "ERR_NO_PATH",
    "-3": "ERR_NAME_EXISTS",
    "-4": "ERR_BUSY",
    "-5": "ERR_NOT_FOUND",
    "-6": "ERR_INSUFFICIENT",
    // "-6": "ERR_NOT_ENOUGH_ENERGY",
    // "-6": "ERR_NOT_ENOUGH_EXTENSIONS",
    // "-6": "ERR_NOT_ENOUGH_RESOURCES",
    "-7": "ERR_INVALID_TARGET",
    "-8": "ERR_FULL",
    "-9": "ERR_NOT_IN_RANGE",
    "-10": "ERR_INVALID_ARGS",
    "-11": "ERR_TIRED",
    "-12": "ERR_NO_BODYPART",
    "-14": "ERR_RCL_NOT_ENOUGH",
    "-15": "ERR_GCL_NOT_ENOUGH",
    "-20": "ERR_ROOM_ENERGY_CAPACITY_NOT_ENOUGH",
    "-21": "ERR_SPECIFIED_SPAWN_BUSY",
    "-30": "ERR_CANNOT_PUSH_CREEP",
    "-90": "ERR_SWARM_BUSY",
    "-101": "ERR_NO_ORDER_TO_BUY_FROM",
    "-102": "ERR_NO_ORDER_TO_SELL_TO",
    "-103": "ERR_INSUFFICIENT_ENERGY_IN_TERMINAL",
    "-104": "ERR_NOT_ENOUGH_MARKET_DATA",
    "-105": "ERR_TOO_MANY_ORDERS_OF_TYPE",
    "-106": "ERR_SELL_DIRECT_PRICE_TOO_LOW",
    "-107": "ERR_BUY_DIRECT_PRICE_TOO_HIGH",
    "-108": "ERR_CREDIT_THRESHOLDS",
    "-109": "ERR_DONT_BUY_REACTION_INTERMEDIATES",
    "-110": "ERR_DRY_RUN_ONLY_SUPPORTS_DIRECT_TRANSACTIONS",
    "-200": "ERR_SWARM_ROTATE_FAILED_1",
    "-201": "ERR_SWARM_ROTATE_FAILED_2",
    "-202": "ERR_SWARM_ROTATE_FAILED_3",
    "-203": "ERR_SWARM_ROTATE_FAILED_4",
    "-999": "ERR_NOT_IMPLEMENTED",
    // "-1000": "ERR_NO_AVAILABLE_SPAWNER",
};
function errorForCode(code) {
    return errorMap[code] ? `${errorMap[code]} (${code})` : `unknown (${code})`;
}

/**
 * Creep tasks setup instructions
 *
 * Javascript:
 * 1. In main.js:   require("tasks/prototypes.js");
 * 2. As needed:    var Tasks = require("<path to Tasks.js>");
 *
 * Typescript:
 * 1. In main.ts:   import "./tasks/prototypes";
 * 2. As needed:    import {Tasks} from "<path to Tasks.ts>"
 *
 * If you use Travler, change all occurrences of creep.moveTo() to creep.goTo()
 */
function isAbstractTarget(target) {
    return !!target && target._pos !== undefined;
}
function isRoomRefTarget(target) {
    return !!target && target.ref !== undefined;
}
function isRoomObjectTarget(target) {
    return !!target && target.pos !== undefined;
}
// export type GenericTask<Z extends AnyZerg = AnyZerg, T extends ConcreteTaskTarget = ConcreteTaskTarget> = Task<Z, T>
/**
 * An abstract class for encapsulating creep actions. This generalizes the concept of "do action X to thing Y until
 * condition Z is met" and saves a lot of convoluted and duplicated code in creep logic. A Task object contains
 * the necessary logic for traveling to a target, performing a task, and realizing when a task is no longer sensible
 * to continue.
 */
let Task = class Task {
    constructor(taskName, target, options = {}) {
        // Parameters for the task
        this.name = taskName;
        this._creep = {
            name: "",
        };
        // Handles edge cases like when you're done building something and target disappears
        if (target instanceof RoomPosition) {
            this._target = {
                ref: "",
                _pos: { x: target.x, y: target.y, roomName: target.room.name },
            };
        }
        else if (isAbstractTarget(target)) {
            this._target = {
                ref: target.ref,
                _pos: target._pos,
            };
        }
        else if (isRoomRefTarget(target)) {
            this._target = {
                ref: target.ref,
                _pos: target.pos,
            };
        }
        else if (isRoomObjectTarget(target)) {
            this._target = {
                ref: "",
                _pos: target.pos,
            };
        }
        else {
            this._target = {
                ref: "",
                _pos: {
                    x: -1,
                    y: -1,
                    roomName: "",
                },
            };
        }
        // log.debug(`creating task ${this.constructor.name}, ${taskName}, target: ${target}, ${print(this._target)}`);
        this._parent = null;
        this.settings = {
            targetRange: 1,
            workOffRoad: false,
            oneShot: false,
            timeout: Infinity,
            blind: true,
        };
        this.tick = Game.time;
        this.options = options;
        this.data = {};
    }
    /**
     * Get a serialized ProtoTask from the current task
     */
    get proto() {
        return {
            name: this.name,
            _creep: this._creep,
            _target: this._target,
            _parent: this._parent,
            tick: this.tick,
            options: this.options,
            data: this.data,
        };
    }
    /**
     * Set the current task from a serialized ProtoTask
     */
    set proto(protoTask) {
        // Don't write to this.name; used in task switcher
        this._creep = protoTask._creep;
        this._target = protoTask._target;
        this._parent = protoTask._parent;
        this.tick = protoTask.tick;
        this.options = protoTask.options;
        this.data = protoTask.data;
    }
    /**
     * Return the wrapped creep which is executing this task
     */
    get creep() {
        // Get task's own creep by its name
        // Returns zerg wrapper instead of creep to use monkey-patched functions
        // @ts-expect-error type substitution galore
        return (Overmind.zerg[this._creep.name] ||
            Overmind.powerZerg[this._creep.name]);
    }
    /**
     * Set the creep which is executing this task
     */
    set creep(creep) {
        this._creep.name = creep.name;
        if (this._parent) {
            this.parent.creep = creep;
        }
    }
    /**
     * Dereferences the Task's target
     */
    get target() {
        return deref(this._target.ref);
    }
    /**
     * Dereferences the saved target position; useful for situations where you might lose vision
     */
    get targetPos() {
        // refresh if you have visibility of the target
        if (!this._targetPos) {
            if (this.target) {
                this._target._pos = this.target.pos;
            }
            this._targetPos = derefRoomPosition(this._target._pos);
        }
        return this._targetPos;
    }
    /**
     * Get the Task's parent
     */
    get parent() {
        return this._parent ? initializeTask(this._parent) : null;
    }
    /**
     * Set the Task's parent
     */
    set parent(parentTask) {
        this._parent = parentTask ? parentTask.proto : null;
        // If the task is already assigned to a creep, update their memory
        if (this.creep) {
            this.creep.task = this;
        }
    }
    /**
     * Return a list of [this, this.parent, this.parent.parent, ...] as tasks
     */
    get manifest() {
        const manifest = [this];
        let parent = this.parent;
        while (parent) {
            manifest.push(parent);
            parent = parent.parent;
        }
        return manifest;
    }
    /**
     * Return a list of [this.target, this.parent.target, ...] without fully instantiating the list of tasks
     */
    get targetManifest() {
        const targetRefs = [this._target.ref];
        let parent = this._parent;
        while (parent) {
            targetRefs.push(parent._target.ref);
            parent = parent._parent;
        }
        return _.map(targetRefs, (ref) => deref(ref));
    }
    /**
     * Return a list of [this.targetPos, this.parent.targetPos, ...] without fully instantiating the list of tasks
     */
    get targetPosManifest() {
        const targetPositions = [this._target._pos];
        let parent = this._parent;
        while (parent) {
            targetPositions.push(parent._target._pos);
            parent = parent._parent;
        }
        return _.map(targetPositions, (protoPos) => derefRoomPosition(protoPos));
    }
    /**
     * Fork the task, assigning a new task to the creep with this task as its parent
     */
    fork(newTask) {
        newTask.parent = this;
        if (this.creep) {
            this.creep.task = newTask;
        }
        return newTask;
    }
    /**
     * Test if the task is valid; if it is not, automatically remove task and transition to parent
     */
    isValid() {
        let validTask = false;
        if (this.creep) {
            validTask =
                this.isValidTask() &&
                    Game.time - this.tick < this.settings.timeout;
        }
        let validTarget = false;
        if (this.target) {
            validTarget = this.isValidTarget();
        }
        else if ((this.settings.blind || this.options.blind) &&
            !Game.rooms[this.targetPos.roomName]) {
            // If you can't see the target's room but you have blind enabled, then that's okay
            validTarget = true;
        }
        // Return if the task is valid; if not, finalize/delete the task and return false
        if (validTask && validTarget) {
            return true;
        }
        else {
            // Switch to parent task if there is one
            this.finish();
            const isValid = this.parent ? this.parent.isValid() : false;
            return isValid;
        }
    }
    /**
     * Move to within range of the target
     */
    moveToTarget(range = this.settings.targetRange) {
        const moveOpts = _.defaultsDeep(this.options.moveOptions, {
            range: range,
        });
        return this.creep.goTo(this.targetPos, moveOpts);
    }
    /**
     * Moves to the next position on the agenda if specified - call this in some tasks after work() is completed
     */
    moveToNextPos() {
        if (this.data.nextPos) {
            const nextPos = derefRoomPosition(this.data.nextPos);
            return this.creep.goTo(nextPos);
        }
        return ERR_NO_PATH;
    }
    /**
     * Return expected number of ticks until creep arrives at its first destination
     */
    get eta() {
        if (this.creep && this.creep.memory._go && this.creep.memory._go.path) {
            return this.creep.memory._go.path.length;
        }
    }
    /**
     * Execute this task each tick. Returns nothing unless work is done.
     */
    run() {
        if (this.isWorking) {
            delete this.creep.memory._go;
            // if (this.settings.workOffRoad) { // this is disabled as movement priorities makes it unnecessary
            // 	// Move to somewhere nearby that isn't on a road
            // 	this.creep.park(this.targetPos, true);
            // }
            const result = this.work();
            if (this.settings.oneShot && result === OK) {
                this.finish();
            }
            return result;
        }
        else {
            const result = this.moveToTarget();
            if (result !== OK && result !== ERR_TIRED) {
                log.debugCreep(this.creep, `failed to move to target: ${errorForCode(result)}`);
            }
            return result;
        }
    }
    /**
     * Return whether the creep is currently performing its task action near the target
     */
    get isWorking() {
        return (this.creep.pos.inRangeToPos(this.targetPos, this.settings.targetRange) && !this.creep.pos.isEdge);
    }
    /**
     * Finalize the task and switch to parent task (or null if there is none)
     */
    finish() {
        this.moveToNextPos();
        if (this.creep) {
            this.creep.task = this.parent;
        }
        else {
            log.debug(`No creep executing ${this.name}! Proto: ${JSON.stringify(this.proto)}`);
        }
    }
};
Task = __decorate$1([
    profile
], Task);

const attackTaskName = "attack";
let TaskAttack = class TaskAttack extends Task {
    constructor(target, options = {}) {
        super(attackTaskName, { ref: target.ref, _pos: target.pos }, options);
        // Settings
        this.settings.targetRange = 3;
    }
    isValidTask() {
        return (this.creep.getActiveBodyparts(ATTACK) > 0 ||
            this.creep.getActiveBodyparts(RANGED_ATTACK) > 0);
    }
    isValidTarget() {
        return this.target && this.target.hits > 0;
    }
    work() {
        const creep = this.creep;
        const target = this.target;
        let attackReturn = 0;
        let rangedAttackReturn = 0;
        if (creep.getActiveBodyparts(ATTACK) > 0) {
            if (creep.pos.isNearTo(target)) {
                attackReturn = creep.attack(target);
            }
            else {
                attackReturn = this.moveToTarget(1); // approach target if you also have attack parts
            }
        }
        if (creep.pos.inRangeTo(target, 3) &&
            creep.getActiveBodyparts(RANGED_ATTACK) > 0) {
            rangedAttackReturn = creep.rangedAttack(target);
        }
        if (attackReturn == OK && rangedAttackReturn == OK) {
            return OK;
        }
        else {
            if (attackReturn != OK) {
                return rangedAttackReturn;
            }
            else {
                return attackReturn;
            }
        }
    }
};
TaskAttack = __decorate$1([
    profile
], TaskAttack);

const buildTaskName = "build";
let TaskBuild = class TaskBuild extends Task {
    constructor(target, options = {}) {
        super(buildTaskName, target, options);
        // Settings
        this.settings.targetRange = 3;
        this.settings.workOffRoad = true;
    }
    isValidTask() {
        return this.creep.store.energy > 0;
    }
    isValidTarget() {
        return (this.target &&
            this.target.my &&
            this.target.progress < this.target.progressTotal);
    }
    work() {
        // Fixes issue #9 - workers freeze if creep sitting on square
        if (!this.target.isWalkable) {
            const creepOnTarget = this.target.pos.lookFor(LOOK_CREEPS)[0];
            if (creepOnTarget) {
                const zerg = Overmind.zerg[creepOnTarget.name];
                if (zerg) {
                    this.creep.say("move pls");
                    zerg.moveOffCurrentPos();
                }
            }
        }
        return this.creep.build(this.target);
    }
};
TaskBuild = __decorate$1([
    profile
], TaskBuild);

const claimTaskName = "claim";
let TaskClaim = class TaskClaim extends Task {
    constructor(target, options = {}) {
        super(claimTaskName, target, options);
        // Settings
    }
    isValidTask() {
        return this.creep.getActiveBodyparts(CLAIM) > 0;
    }
    isValidTarget() {
        return this.target != null && (!this.target.room || !this.target.owner);
    }
    work() {
        return this.creep.claimController(this.target);
    }
};
TaskClaim = __decorate$1([
    profile
], TaskClaim);

const dismantleTaskName = "dismantle";
let TaskDismantle = class TaskDismantle extends Task {
    constructor(target, options = {}) {
        super(dismantleTaskName, target, options);
        this.settings.timeout = 100;
    }
    isValidTask() {
        return this.creep.getActiveBodyparts(WORK) > 0;
    }
    isValidTarget() {
        return this.target && this.target.hits > 0;
    }
    work() {
        return this.creep.dismantle(this.target);
    }
};
TaskDismantle = __decorate$1([
    profile
], TaskDismantle);

var TaskDrop_1;
const dropTaskName = "drop";
let TaskDrop = TaskDrop_1 = class TaskDrop extends Task {
    constructor(target, resourceType = RESOURCE_ENERGY, amount, options = {}) {
        if (target instanceof RoomPosition) {
            super(TaskDrop_1.taskName, { ref: "", _pos: target }, options);
        }
        else {
            super(TaskDrop_1.taskName, { ref: target.ref, _pos: target.pos }, options);
        }
        // Settings
        this.settings.targetRange = 0;
        this.settings.oneShot = true;
        // Data
        this.data.resourceType = resourceType;
        this.data.amount = amount;
    }
    isValidTask() {
        const amount = this.data.amount || 1;
        const resourcesInCarry = this.creep.store[this.data.resourceType] || 0;
        return resourcesInCarry >= amount;
    }
    isValidTarget() {
        return true;
    }
    isValid() {
        // It's necessary to override task.isValid() for tasks which do not have a RoomObject target
        let validTask = false;
        if (this.creep) {
            validTask = this.isValidTask();
        }
        // Return if the task is valid; if not, finalize/delete the task and return false
        if (validTask) {
            return true;
        }
        else {
            // Switch to parent task if there is one
            let isValid = false;
            if (this.parent) {
                isValid = this.parent.isValid();
            }
            this.finish();
            return isValid;
        }
    }
    work() {
        return this.creep.drop(this.data.resourceType, this.data.amount);
    }
};
TaskDrop.taskName = "drop";
TaskDrop = TaskDrop_1 = __decorate$1([
    profile
], TaskDrop);

const fortifyTaskName = "fortify";
let TaskFortify = class TaskFortify extends Task {
    constructor(target, hitsMax, options = {}) {
        super(fortifyTaskName, target, options);
        // Settings
        this.settings.timeout = 100; // Don't want workers to fortify indefinitely
        this.settings.targetRange = 3;
        this.settings.workOffRoad = true;
        this.data.hitsMax = hitsMax;
    }
    isValidTask() {
        return this.creep.store.energy > 0; // Times out once creep is out of energy
    }
    isValidTarget() {
        return (this.target &&
            this.target.hits < (this.data.hitsMax || this.target.hitsMax));
    }
    work() {
        return this.creep.repair(this.target);
    }
};
TaskFortify = __decorate$1([
    profile
], TaskFortify);

const generateSafeModeTaskName = "generateSafeMode";
let TaskGenerateSafeMode = class TaskGenerateSafeMode extends Task {
    constructor(target, options = {}) {
        super(generateSafeModeTaskName, target, options);
    }
    isValidTask() {
        return this.creep.store[RESOURCE_GHODIUM] >= 1000;
    }
    isValidTarget() {
        // Allows targeting other players for allies
        return this.target != null && !!this.target.owner;
    }
    work() {
        return this.creep.generateSafeMode(this.target);
    }
};
TaskGenerateSafeMode = __decorate$1([
    profile
], TaskGenerateSafeMode);

const RESOURCES_ALL_EXCEPT_ENERGY = _.without(RESOURCES_ALL, RESOURCE_ENERGY);
const BOOSTS_T3 = [
    RESOURCE_CATALYZED_GHODIUM_ALKALIDE,
    RESOURCE_CATALYZED_GHODIUM_ACID,
    RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE,
    RESOURCE_CATALYZED_ZYNTHIUM_ACID,
    RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,
    RESOURCE_CATALYZED_LEMERGIUM_ACID,
    RESOURCE_CATALYZED_KEANIUM_ALKALIDE,
    RESOURCE_CATALYZED_KEANIUM_ACID,
    RESOURCE_CATALYZED_UTRIUM_ALKALIDE,
    RESOURCE_CATALYZED_UTRIUM_ACID,
];
const BOOSTS_T2 = [
    RESOURCE_GHODIUM_ALKALIDE,
    RESOURCE_GHODIUM_ACID,
    RESOURCE_ZYNTHIUM_ALKALIDE,
    RESOURCE_ZYNTHIUM_ACID,
    RESOURCE_LEMERGIUM_ALKALIDE,
    RESOURCE_LEMERGIUM_ACID,
    RESOURCE_KEANIUM_ALKALIDE,
    RESOURCE_KEANIUM_ACID,
    RESOURCE_UTRIUM_ALKALIDE,
    RESOURCE_UTRIUM_ACID,
];
const BOOSTS_T1 = [
    RESOURCE_GHODIUM_OXIDE,
    RESOURCE_GHODIUM_HYDRIDE,
    RESOURCE_ZYNTHIUM_OXIDE,
    RESOURCE_ZYNTHIUM_HYDRIDE,
    RESOURCE_LEMERGIUM_OXIDE,
    RESOURCE_LEMERGIUM_HYDRIDE,
    RESOURCE_KEANIUM_OXIDE,
    RESOURCE_KEANIUM_HYDRIDE,
    RESOURCE_UTRIUM_OXIDE,
    RESOURCE_UTRIUM_HYDRIDE,
];
const INTERMEDIATE_REACTANTS = [
    RESOURCE_HYDROXIDE,
    RESOURCE_ZYNTHIUM_KEANITE,
    RESOURCE_UTRIUM_LEMERGITE,
    RESOURCE_GHODIUM,
];
const BASE_RESOURCES = [
    RESOURCE_CATALYST,
    RESOURCE_ZYNTHIUM,
    RESOURCE_LEMERGIUM,
    RESOURCE_KEANIUM,
    RESOURCE_UTRIUM,
    RESOURCE_OXYGEN,
    RESOURCE_HYDROGEN,
];
const _baseResourcesLookup = _.zipObject(BASE_RESOURCES, _.map(BASE_RESOURCES, () => true));
const RESOURCE_IMPORTANCE = [
    RESOURCE_CATALYZED_GHODIUM_ALKALIDE,
    RESOURCE_CATALYZED_GHODIUM_ACID,
    RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE,
    RESOURCE_CATALYZED_ZYNTHIUM_ACID,
    RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,
    RESOURCE_CATALYZED_LEMERGIUM_ACID,
    RESOURCE_CATALYZED_KEANIUM_ALKALIDE,
    RESOURCE_CATALYZED_KEANIUM_ACID,
    RESOURCE_CATALYZED_UTRIUM_ALKALIDE,
    RESOURCE_CATALYZED_UTRIUM_ACID,
    RESOURCE_OPS,
    RESOURCE_GHODIUM_ALKALIDE,
    RESOURCE_GHODIUM_ACID,
    RESOURCE_ZYNTHIUM_ALKALIDE,
    RESOURCE_ZYNTHIUM_ACID,
    RESOURCE_LEMERGIUM_ALKALIDE,
    RESOURCE_LEMERGIUM_ACID,
    RESOURCE_KEANIUM_ALKALIDE,
    RESOURCE_KEANIUM_ACID,
    RESOURCE_UTRIUM_ALKALIDE,
    RESOURCE_UTRIUM_ACID,
    RESOURCE_GHODIUM_OXIDE,
    RESOURCE_GHODIUM_HYDRIDE,
    RESOURCE_ZYNTHIUM_OXIDE,
    RESOURCE_ZYNTHIUM_HYDRIDE,
    RESOURCE_LEMERGIUM_OXIDE,
    RESOURCE_LEMERGIUM_HYDRIDE,
    RESOURCE_KEANIUM_OXIDE,
    RESOURCE_KEANIUM_HYDRIDE,
    RESOURCE_UTRIUM_OXIDE,
    RESOURCE_UTRIUM_HYDRIDE,
    RESOURCE_GHODIUM,
    RESOURCE_UTRIUM_LEMERGITE,
    RESOURCE_ZYNTHIUM_KEANITE,
    RESOURCE_HYDROXIDE,
    RESOURCE_CATALYST,
    RESOURCE_ZYNTHIUM,
    RESOURCE_LEMERGIUM,
    RESOURCE_KEANIUM,
    RESOURCE_UTRIUM,
    RESOURCE_OXYGEN,
    RESOURCE_HYDROGEN,
    RESOURCE_POWER,
    RESOURCE_ENERGY,
    // All other resources are unimportant
];
const RESOURCE_IMPORTANCE_ALL = _.sortBy(RESOURCES_ALL, (r) => {
    const idx = RESOURCE_IMPORTANCE.indexOf(r);
    return idx === -1 ? Infinity : idx;
});
const REAGENTS = {
    // Tier 3
    [RESOURCE_CATALYZED_GHODIUM_ALKALIDE]: [
        RESOURCE_GHODIUM_ALKALIDE,
        RESOURCE_CATALYST,
    ],
    [RESOURCE_CATALYZED_GHODIUM_ACID]: [
        RESOURCE_GHODIUM_ACID,
        RESOURCE_CATALYST,
    ],
    [RESOURCE_CATALYZED_ZYNTHIUM_ACID]: [
        RESOURCE_ZYNTHIUM_ACID,
        RESOURCE_CATALYST,
    ],
    [RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE]: [
        RESOURCE_ZYNTHIUM_ALKALIDE,
        RESOURCE_CATALYST,
    ],
    [RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE]: [
        RESOURCE_LEMERGIUM_ALKALIDE,
        RESOURCE_CATALYST,
    ],
    [RESOURCE_CATALYZED_LEMERGIUM_ACID]: [
        RESOURCE_LEMERGIUM_ACID,
        RESOURCE_CATALYST,
    ],
    [RESOURCE_CATALYZED_KEANIUM_ALKALIDE]: [
        RESOURCE_KEANIUM_ALKALIDE,
        RESOURCE_CATALYST,
    ],
    [RESOURCE_CATALYZED_KEANIUM_ACID]: [
        RESOURCE_KEANIUM_ACID,
        RESOURCE_CATALYST,
    ],
    [RESOURCE_CATALYZED_UTRIUM_ACID]: [RESOURCE_UTRIUM_ACID, RESOURCE_CATALYST],
    [RESOURCE_CATALYZED_UTRIUM_ALKALIDE]: [
        RESOURCE_UTRIUM_ALKALIDE,
        RESOURCE_CATALYST,
    ],
    // Tier 2
    [RESOURCE_GHODIUM_ACID]: [RESOURCE_GHODIUM_HYDRIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_GHODIUM_ALKALIDE]: [RESOURCE_GHODIUM_OXIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_ZYNTHIUM_ACID]: [RESOURCE_ZYNTHIUM_HYDRIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_ZYNTHIUM_ALKALIDE]: [RESOURCE_ZYNTHIUM_OXIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_LEMERGIUM_ALKALIDE]: [
        RESOURCE_LEMERGIUM_OXIDE,
        RESOURCE_HYDROXIDE,
    ],
    [RESOURCE_LEMERGIUM_ACID]: [RESOURCE_LEMERGIUM_HYDRIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_KEANIUM_ALKALIDE]: [RESOURCE_KEANIUM_OXIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_KEANIUM_ACID]: [RESOURCE_KEANIUM_HYDRIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_UTRIUM_ACID]: [RESOURCE_UTRIUM_HYDRIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_UTRIUM_ALKALIDE]: [RESOURCE_UTRIUM_OXIDE, RESOURCE_HYDROXIDE],
    // Tier 1
    [RESOURCE_GHODIUM_HYDRIDE]: [RESOURCE_GHODIUM, RESOURCE_HYDROGEN],
    [RESOURCE_GHODIUM_OXIDE]: [RESOURCE_GHODIUM, RESOURCE_OXYGEN],
    [RESOURCE_ZYNTHIUM_HYDRIDE]: [RESOURCE_ZYNTHIUM, RESOURCE_HYDROGEN],
    [RESOURCE_ZYNTHIUM_OXIDE]: [RESOURCE_ZYNTHIUM, RESOURCE_OXYGEN],
    [RESOURCE_LEMERGIUM_OXIDE]: [RESOURCE_LEMERGIUM, RESOURCE_OXYGEN],
    [RESOURCE_LEMERGIUM_HYDRIDE]: [RESOURCE_LEMERGIUM, RESOURCE_HYDROGEN],
    [RESOURCE_KEANIUM_OXIDE]: [RESOURCE_KEANIUM, RESOURCE_OXYGEN],
    [RESOURCE_KEANIUM_HYDRIDE]: [RESOURCE_KEANIUM, RESOURCE_HYDROGEN],
    [RESOURCE_UTRIUM_HYDRIDE]: [RESOURCE_UTRIUM, RESOURCE_HYDROGEN],
    [RESOURCE_UTRIUM_OXIDE]: [RESOURCE_UTRIUM, RESOURCE_OXYGEN],
    // Tier 0
    [RESOURCE_GHODIUM]: [RESOURCE_ZYNTHIUM_KEANITE, RESOURCE_UTRIUM_LEMERGITE],
    [RESOURCE_HYDROXIDE]: [RESOURCE_OXYGEN, RESOURCE_HYDROGEN],
    [RESOURCE_ZYNTHIUM_KEANITE]: [RESOURCE_ZYNTHIUM, RESOURCE_KEANIUM],
    [RESOURCE_UTRIUM_LEMERGITE]: [RESOURCE_UTRIUM, RESOURCE_LEMERGIUM],
};
const MINERAL_COMPOUNDS_ALL = _.keys(REAGENTS).concat(BASE_RESOURCES);
const _mineralCompoundsAllLookup = _.zipObject(MINERAL_COMPOUNDS_ALL, _.map(MINERAL_COMPOUNDS_ALL, () => true));
const BOOST_PARTS = {
    UH: ATTACK,
    UO: WORK,
    KH: CARRY,
    KO: RANGED_ATTACK,
    LH: WORK,
    LO: HEAL,
    ZH: WORK,
    ZO: MOVE,
    GH: WORK,
    GO: TOUGH,
    UH2O: ATTACK,
    UHO2: WORK,
    KH2O: CARRY,
    KHO2: RANGED_ATTACK,
    LH2O: WORK,
    LHO2: HEAL,
    ZH2O: WORK,
    ZHO2: MOVE,
    GH2O: WORK,
    GHO2: TOUGH,
    XUH2O: ATTACK,
    XUHO2: WORK,
    XKH2O: CARRY,
    XKHO2: RANGED_ATTACK,
    XLH2O: WORK,
    XLHO2: HEAL,
    XZH2O: WORK,
    XZHO2: MOVE,
    XGH2O: WORK,
    XGHO2: TOUGH,
};
const HARVEST = "harvest";
const CONSTRUCT = "construct";
const DISMANTLE = "dismantle";
const UPGRADE = "upgrade";
const BoostTypeBodyparts = {
    [ATTACK]: ATTACK,
    [CARRY]: CARRY,
    [RANGED_ATTACK]: RANGED_ATTACK,
    [HEAL]: HEAL,
    [MOVE]: MOVE,
    [TOUGH]: TOUGH,
    [HARVEST]: WORK,
    [CONSTRUCT]: WORK,
    [DISMANTLE]: WORK,
    [UPGRADE]: WORK,
};
const BoostTypeToBoostArray = {
    [ATTACK]: ATTACK,
    [CARRY]: "capacity",
    [RANGED_ATTACK]: "rangedAttack",
    // [RANGED_MASS_ATTACK]: "rangedMassAttack",
    [HEAL]: HEAL,
    [MOVE]: "fatigue",
    [TOUGH]: "damage",
    [HARVEST]: "harvest",
    [CONSTRUCT]: "build",
    // [REPAIR]: "repair",
    [DISMANTLE]: "dismantle",
    [UPGRADE]: "upgradeController",
};
const BOOST_TIERS = {
    attack: {
        T1: "UH",
        T2: "UH2O",
        T3: "XUH2O",
    },
    carry: {
        T1: "KH",
        T2: "KH2O",
        T3: "XKH2O",
    },
    ranged_attack: {
        T1: "KO",
        T2: "KHO2",
        T3: "XKHO2",
    },
    heal: {
        T1: "LO",
        T2: "LHO2",
        T3: "XLHO2",
    },
    move: {
        T1: "ZO",
        T2: "ZHO2",
        T3: "XZHO2",
    },
    tough: {
        T1: "GO",
        T2: "GHO2",
        T3: "XGHO2",
    },
    harvest: {
        T1: "UO",
        T2: "UHO2",
        T3: "XUHO2",
    },
    construct: {
        T1: "LH",
        T2: "LH2O",
        T3: "XLH2O",
    },
    dismantle: {
        T1: "ZH",
        T2: "ZH2O",
        T3: "XZH2O",
    },
    upgrade: {
        T1: "GH",
        T2: "GH2O",
        T3: "XGH2O",
    },
};
// This inverts the second-level values from above, so you get an object that looks like:
// { attack: { UH: T1, UH2O: T2, XUH2O: T3 }, carry: { ... } ... }
const _boostTypesTierLookup = _.mapValues(BOOST_TIERS, (boostType) => _.invert(boostType));
// This inverts the second-level values from above, so you get an object that looks like:
// { attack: { UH: T1, UH2O: T2, XUH2O: T3 }, carry: { ... } ... }
const _boostTierLookupAllTypes = _.extend({}, ..._.values(_boostTypesTierLookup));
const COMMODITIES_DATA = {
    // Compressed mineral compounds
    [RESOURCE_UTRIUM_BAR]: { lvl: 0 },
    [RESOURCE_LEMERGIUM_BAR]: { lvl: 0 },
    [RESOURCE_ZYNTHIUM_BAR]: { lvl: 0 },
    [RESOURCE_KEANIUM_BAR]: { lvl: 0 },
    [RESOURCE_GHODIUM_MELT]: { lvl: 0 },
    [RESOURCE_OXIDANT]: { lvl: 0 },
    [RESOURCE_REDUCTANT]: { lvl: 0 },
    [RESOURCE_PURIFIER]: { lvl: 0 },
    [RESOURCE_BATTERY]: { lvl: 0 },
    // Higher commodities
    [RESOURCE_COMPOSITE]: { lvl: 1, chain: "common" },
    [RESOURCE_CRYSTAL]: { lvl: 1, chain: "common" },
    [RESOURCE_LIQUID]: { lvl: 1, chain: "common" },
    // Mechanical chain
    [RESOURCE_ALLOY]: { lvl: 0, chain: RESOURCE_METAL },
    [RESOURCE_TUBE]: { lvl: 1, chain: RESOURCE_METAL },
    [RESOURCE_FIXTURES]: { lvl: 2, chain: RESOURCE_METAL },
    [RESOURCE_FRAME]: { lvl: 3, chain: RESOURCE_METAL },
    [RESOURCE_HYDRAULICS]: { lvl: 4, chain: RESOURCE_METAL },
    [RESOURCE_MACHINE]: { lvl: 5, chain: RESOURCE_METAL },
    // Biological chain
    [RESOURCE_CELL]: { lvl: 0, chain: RESOURCE_BIOMASS },
    [RESOURCE_PHLEGM]: { lvl: 1, chain: RESOURCE_BIOMASS },
    [RESOURCE_TISSUE]: { lvl: 2, chain: RESOURCE_BIOMASS },
    [RESOURCE_MUSCLE]: { lvl: 3, chain: RESOURCE_BIOMASS },
    [RESOURCE_ORGANOID]: { lvl: 4, chain: RESOURCE_BIOMASS },
    [RESOURCE_ORGANISM]: { lvl: 5, chain: RESOURCE_BIOMASS },
    // Electronic chain
    [RESOURCE_WIRE]: { lvl: 0, chain: RESOURCE_SILICON },
    [RESOURCE_SWITCH]: { lvl: 1, chain: RESOURCE_SILICON },
    [RESOURCE_TRANSISTOR]: { lvl: 2, chain: RESOURCE_SILICON },
    [RESOURCE_MICROCHIP]: { lvl: 3, chain: RESOURCE_SILICON },
    [RESOURCE_CIRCUIT]: { lvl: 4, chain: RESOURCE_SILICON },
    [RESOURCE_DEVICE]: { lvl: 5, chain: RESOURCE_SILICON },
    // Mystical chain
    [RESOURCE_CONDENSATE]: { lvl: 0, chain: RESOURCE_MIST },
    [RESOURCE_CONCENTRATE]: { lvl: 1, chain: RESOURCE_MIST },
    [RESOURCE_EXTRACT]: { lvl: 2, chain: RESOURCE_MIST },
    [RESOURCE_SPIRIT]: { lvl: 3, chain: RESOURCE_MIST },
    [RESOURCE_EMANATION]: { lvl: 4, chain: RESOURCE_MIST },
    [RESOURCE_ESSENCE]: { lvl: 5, chain: RESOURCE_MIST },
};
Object.entries(COMMODITIES_DATA)
    .filter(([_, data]) => data.chain)
    .map(([res, _]) => res);
const DEPOSITS_ALL = [
    RESOURCE_SILICON,
    RESOURCE_BIOMASS,
    RESOURCE_METAL,
    RESOURCE_MIST,
];
const ALL_ZERO_ASSETS = _.zipObject(RESOURCES_ALL, _.map(RESOURCES_ALL, () => 0));

const getBoostedTaskName = "getBoosted";
const MIN_LIFETIME_FOR_BOOST = 0.85;
let TaskGetBoosted = class TaskGetBoosted extends Task {
    constructor(target, boostType, partCount, options = {}) {
        super(getBoostedTaskName, target, options);
        // Settings
        this.data.resourceType = boostType;
        this.data.amount = partCount;
    }
    isValidTask() {
        var _a;
        const lifetime = _.any(this.creep.body, (part) => part.type == CLAIM) ?
            CREEP_CLAIM_LIFE_TIME
            : CREEP_LIFE_TIME;
        if (this.creep.ticksToLive &&
            this.creep.ticksToLive < MIN_LIFETIME_FOR_BOOST * lifetime) {
            // timeout after this amount of lifespan has passed
            return false;
        }
        // else if (BOOST_PARTS[this.data.resourceType] == MOVE &&
        // this.creep.getActiveBodyparts(BOOST_PARTS[this.data.resourceType]) >= this.creep.body.length / 2) {
        // 	Game.notify(`Bad boosting of move on creep ${this.creep}, invalid task.`);
        // 	return false;
        // }
        const { resourceType } = this.data;
        const partCount = this.partCount;
        return ((_a = this.creep.boostCounts[resourceType]) !== null && _a !== void 0 ? _a : 0) < partCount;
    }
    get partCount() {
        var _a;
        const { amount, resourceType } = this.data;
        const partCount = (_a = amount !== null && amount !== void 0 ? amount : this.creep.getActiveBodyparts(BOOST_PARTS[resourceType])) !== null && _a !== void 0 ? _a : 0;
        return partCount;
    }
    get targetHasEnoughMinerals() {
        const { resourceType } = this.data;
        const partCount = this.partCount;
        return (this.target &&
            this.target.mineralType === resourceType &&
            this.target.store[resourceType] >= LAB_BOOST_MINERAL * partCount &&
            this.target.store[RESOURCE_ENERGY] >= LAB_BOOST_ENERGY * partCount);
    }
    isValidTarget() {
        return this.targetHasEnoughMinerals;
    }
    work() {
        var _a;
        if (this.creep.spawning) {
            return ERR_INVALID_TARGET;
        }
        const { amount, resourceType } = this.data;
        const partCount = this.partCount;
        // amount || this.creep.getActiveBodyparts(BOOST_PARTS[resourceType]);
        // if (BOOST_PARTS[this.data.resourceType] == MOVE && partCount >= this.creep.body.length / 2){
        // 	Game.notify(`Bad boosting of move on creep ${this.creep}, exiting work.`);
        // 	return ERR_INVALID_TARGET;
        // }
        if (!this.targetHasEnoughMinerals) {
            return ERR_NOT_ENOUGH_RESOURCES;
        }
        const result = this.target.boostCreep(deref(this._creep.name), amount);
        if (result === OK) {
            // We do not want tasks to depend on stuff like Colony, so hide that
            (_a = this.creep.colony) === null || _a === void 0 ? void 0 : _a.trackEnergyUse("lab", -LAB_BOOST_ENERGY);
        }
        log.info(`${this.target.print}@${this.target.pos.print}: boosting creep ${this.creep.print} with ${partCount} of ${resourceType} (${this.target.mineralType})! ${errorForCode(result)}`);
        return result;
    }
};
TaskGetBoosted = __decorate$1([
    profile
], TaskGetBoosted);

const getRenewedTaskName = "getRenewed";
let TaskGetRenewed = class TaskGetRenewed extends Task {
    constructor(target, options = {}) {
        super(getRenewedTaskName, target, options);
    }
    isValidTask() {
        const hasClaimPart = _.filter(this.creep.body, (part) => part.type == CLAIM).length > 0;
        const lifetime = hasClaimPart ? CREEP_CLAIM_LIFE_TIME : CREEP_LIFE_TIME;
        return (this.creep.ticksToLive != undefined &&
            this.creep.ticksToLive < 0.9 * lifetime);
    }
    isValidTarget() {
        return this.target.my && !this.target.spawning;
    }
    work() {
        return this.target.renewCreep(this.creep.creep);
    }
};
TaskGetRenewed = __decorate$1([
    profile
], TaskGetRenewed);

const goToTaskName = "goTo";
let TaskGoTo = class TaskGoTo extends Task {
    constructor(target, options = {}) {
        if (hasPos(target)) {
            super(goToTaskName, { ref: "", pos: target.pos }, options);
        }
        else {
            super(goToTaskName, { ref: "", pos: target }, options);
        }
        // Settings
        this.settings.targetRange = 1;
    }
    isValidTask() {
        return !this.creep.pos.inRangeTo(this.targetPos, this.settings.targetRange);
    }
    isValidTarget() {
        return true;
    }
    isValid() {
        let validTask = false;
        if (this.creep) {
            validTask = this.isValidTask();
        }
        // Return if the task is valid; if not, finalize/delete the task and return false
        if (validTask) {
            return true;
        }
        else {
            // Switch to parent task if there is one
            let isValid = false;
            if (this.parent) {
                isValid = this.parent.isValid();
            }
            this.finish();
            return isValid;
        }
    }
    work() {
        return OK;
    }
};
TaskGoTo = __decorate$1([
    profile
], TaskGoTo);

const goToRoomTaskName = "goToRoom";
let TaskGoToRoom = class TaskGoToRoom extends Task {
    constructor(roomName, options = {}) {
        super(goToRoomTaskName, { ref: "", _pos: new RoomPosition(25, 25, roomName) }, options);
        // Settings
        this.settings.targetRange = 23; // Target is almost always controller flag, so range of 2 is acceptable
    }
    isValidTask() {
        return !this.creep.pos.inRangeTo(this.targetPos, this.settings.targetRange);
    }
    isValidTarget() {
        return this.creep.room.name !== this.targetPos.roomName;
    }
    isValid() {
        let validTask = false;
        if (this.creep) {
            validTask = this.isValidTask();
        }
        // Return if the task is valid; if not, finalize/delete the task and return false
        if (validTask) {
            return true;
        }
        else {
            // Switch to parent task if there is one
            let isValid = false;
            if (this.parent) {
                isValid = this.parent.isValid();
            }
            this.finish();
            return isValid;
        }
    }
    work() {
        return OK;
    }
};
TaskGoToRoom = __decorate$1([
    profile
], TaskGoToRoom);

const harvestTaskName = "harvest";
let TaskHarvest = class TaskHarvest extends Task {
    constructor(target, options = {}) {
        super(harvestTaskName, target, options);
    }
    isValidTask() {
        return (this.creep.store.getUsedCapacity() < this.creep.store.getCapacity());
    }
    isValidTarget() {
        if (isSource(this.target)) {
            return this.target.energy > 0;
        }
        else {
            return this.target.mineralAmount > 0;
        }
    }
    work() {
        return this.creep.harvest(this.target);
    }
};
TaskHarvest = __decorate$1([
    profile
], TaskHarvest);

const healTaskName = "heal";
let TaskHeal = class TaskHeal extends Task {
    constructor(target, options = {}) {
        super(healTaskName, target, options);
        // Settings
        this.settings.targetRange = 3;
    }
    isValidTask() {
        return this.creep.getActiveBodyparts(HEAL) > 0;
    }
    isValidTarget() {
        return (this.target &&
            this.target.hits < this.target.hitsMax &&
            this.target.my);
    }
    work() {
        if (this.creep.pos.isNearTo(this.target)) {
            return this.creep.heal(this.target);
        }
        else {
            this.moveToTarget(1);
        }
        return this.creep.rangedHeal(this.target);
    }
};
TaskHeal = __decorate$1([
    profile
], TaskHeal);

// Invalid task assigned if instantiation fails.
const invalidTarget = {
    ref: "",
    pos: {
        x: 25,
        y: 25,
        roomName: "W6N1",
    },
};
let TaskInvalid = class TaskInvalid extends Task {
    constructor() {
        super("INVALID", invalidTarget);
    }
    isValidTask() {
        return false;
    }
    isValidTarget() {
        return false;
    }
    work() {
        return OK;
    }
};
TaskInvalid = __decorate$1([
    profile
], TaskInvalid);

const meleeAttackTaskName = "meleeAttack";
let TaskMeleeAttack = class TaskMeleeAttack extends Task {
    constructor(target, options = {}) {
        super(meleeAttackTaskName, target, options);
        // Settings
        this.settings.targetRange = 1;
    }
    isValidTask() {
        return this.creep.getActiveBodyparts(ATTACK) > 0;
    }
    isValidTarget() {
        const target = this.target;
        return target && target.hits > 0; // && target.my == false);
    }
    work() {
        return this.creep.attack(this.target);
    }
};
TaskMeleeAttack = __decorate$1([
    profile
], TaskMeleeAttack);

const pickupTaskName = "pickup";
let TaskPickup = class TaskPickup extends Task {
    constructor(target, options = {}) {
        super("pickup", target, options);
        this.settings.oneShot = true;
    }
    isValidTask() {
        return (this.creep.store.getUsedCapacity() < this.creep.store.getCapacity());
    }
    isValidTarget() {
        return this.target && this.target.amount > 0;
    }
    work() {
        return this.creep.pickup(this.target);
    }
};
TaskPickup = __decorate$1([
    profile
], TaskPickup);

const rangedAttackTaskName = "rangedAttack";
let TaskRangedAttack = class TaskRangedAttack extends Task {
    constructor(target, options = {}) {
        super(rangedAttackTaskName, target, options);
        // Settings
        this.settings.targetRange = 3;
    }
    isValidTask() {
        return this.creep.getActiveBodyparts(RANGED_ATTACK) > 0;
    }
    isValidTarget() {
        return this.target && this.target.hits > 0;
    }
    work() {
        return this.creep.rangedAttack(this.target);
    }
};
TaskRangedAttack = __decorate$1([
    profile
], TaskRangedAttack);

var ansiRegex$1 = ({onlyFirst = false} = {}) => {
	const pattern = [
		'[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
		'(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
	].join('|');

	return new RegExp(pattern, onlyFirst ? undefined : 'g');
};

const ansiRegex = ansiRegex$1;

var stripAnsi$1 = string => typeof string === 'string' ? string.replace(ansiRegex(), '') : string;

var wcwidth$4 = {exports: {}};

var clone$1 = {exports: {}};

(function (module) {
	var clone = (function() {

	/**
	 * Clones (copies) an Object using deep copying.
	 *
	 * This function supports circular references by default, but if you are certain
	 * there are no circular references in your object, you can save some CPU time
	 * by calling clone(obj, false).
	 *
	 * Caution: if `circular` is false and `parent` contains circular references,
	 * your program may enter an infinite loop and crash.
	 *
	 * @param `parent` - the object to be cloned
	 * @param `circular` - set to true if the object to be cloned may contain
	 *    circular references. (optional - true by default)
	 * @param `depth` - set to a number if the object is only to be cloned to
	 *    a particular depth. (optional - defaults to Infinity)
	 * @param `prototype` - sets the prototype to be used when cloning an object.
	 *    (optional - defaults to parent prototype).
	*/
	function clone(parent, circular, depth, prototype) {
	  if (typeof circular === 'object') {
	    depth = circular.depth;
	    prototype = circular.prototype;
	    circular.filter;
	    circular = circular.circular;
	  }
	  // maintain two arrays for circular references, where corresponding parents
	  // and children have the same index
	  var allParents = [];
	  var allChildren = [];

	  var useBuffer = typeof Buffer != 'undefined';

	  if (typeof circular == 'undefined')
	    circular = true;

	  if (typeof depth == 'undefined')
	    depth = Infinity;

	  // recurse this function so we don't reset allParents and allChildren
	  function _clone(parent, depth) {
	    // cloning null always returns null
	    if (parent === null)
	      return null;

	    if (depth == 0)
	      return parent;

	    var child;
	    var proto;
	    if (typeof parent != 'object') {
	      return parent;
	    }

	    if (clone.__isArray(parent)) {
	      child = [];
	    } else if (clone.__isRegExp(parent)) {
	      child = new RegExp(parent.source, __getRegExpFlags(parent));
	      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
	    } else if (clone.__isDate(parent)) {
	      child = new Date(parent.getTime());
	    } else if (useBuffer && Buffer.isBuffer(parent)) {
	      if (Buffer.allocUnsafe) {
	        // Node.js >= 4.5.0
	        child = Buffer.allocUnsafe(parent.length);
	      } else {
	        // Older Node.js versions
	        child = new Buffer(parent.length);
	      }
	      parent.copy(child);
	      return child;
	    } else {
	      if (typeof prototype == 'undefined') {
	        proto = Object.getPrototypeOf(parent);
	        child = Object.create(proto);
	      }
	      else {
	        child = Object.create(prototype);
	        proto = prototype;
	      }
	    }

	    if (circular) {
	      var index = allParents.indexOf(parent);

	      if (index != -1) {
	        return allChildren[index];
	      }
	      allParents.push(parent);
	      allChildren.push(child);
	    }

	    for (var i in parent) {
	      var attrs;
	      if (proto) {
	        attrs = Object.getOwnPropertyDescriptor(proto, i);
	      }

	      if (attrs && attrs.set == null) {
	        continue;
	      }
	      child[i] = _clone(parent[i], depth - 1);
	    }

	    return child;
	  }

	  return _clone(parent, depth);
	}

	/**
	 * Simple flat clone using prototype, accepts only objects, usefull for property
	 * override on FLAT configuration object (no nested props).
	 *
	 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
	 * works.
	 */
	clone.clonePrototype = function clonePrototype(parent) {
	  if (parent === null)
	    return null;

	  var c = function () {};
	  c.prototype = parent;
	  return new c();
	};

	// private utility functions

	function __objToStr(o) {
	  return Object.prototype.toString.call(o);
	}	clone.__objToStr = __objToStr;

	function __isDate(o) {
	  return typeof o === 'object' && __objToStr(o) === '[object Date]';
	}	clone.__isDate = __isDate;

	function __isArray(o) {
	  return typeof o === 'object' && __objToStr(o) === '[object Array]';
	}	clone.__isArray = __isArray;

	function __isRegExp(o) {
	  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
	}	clone.__isRegExp = __isRegExp;

	function __getRegExpFlags(re) {
	  var flags = '';
	  if (re.global) flags += 'g';
	  if (re.ignoreCase) flags += 'i';
	  if (re.multiline) flags += 'm';
	  return flags;
	}	clone.__getRegExpFlags = __getRegExpFlags;

	return clone;
	})();

	if (module.exports) {
	  module.exports = clone;
	} 
} (clone$1));

var cloneExports = clone$1.exports;

var clone = cloneExports;

var defaults$1 = function(options, defaults) {
  options = options || {};

  Object.keys(defaults).forEach(function(key) {
    if (typeof options[key] === 'undefined') {
      options[key] = clone(defaults[key]);
    }
  });

  return options;
};

var combining$1 = [
    [ 0x0300, 0x036F ], [ 0x0483, 0x0486 ], [ 0x0488, 0x0489 ],
    [ 0x0591, 0x05BD ], [ 0x05BF, 0x05BF ], [ 0x05C1, 0x05C2 ],
    [ 0x05C4, 0x05C5 ], [ 0x05C7, 0x05C7 ], [ 0x0600, 0x0603 ],
    [ 0x0610, 0x0615 ], [ 0x064B, 0x065E ], [ 0x0670, 0x0670 ],
    [ 0x06D6, 0x06E4 ], [ 0x06E7, 0x06E8 ], [ 0x06EA, 0x06ED ],
    [ 0x070F, 0x070F ], [ 0x0711, 0x0711 ], [ 0x0730, 0x074A ],
    [ 0x07A6, 0x07B0 ], [ 0x07EB, 0x07F3 ], [ 0x0901, 0x0902 ],
    [ 0x093C, 0x093C ], [ 0x0941, 0x0948 ], [ 0x094D, 0x094D ],
    [ 0x0951, 0x0954 ], [ 0x0962, 0x0963 ], [ 0x0981, 0x0981 ],
    [ 0x09BC, 0x09BC ], [ 0x09C1, 0x09C4 ], [ 0x09CD, 0x09CD ],
    [ 0x09E2, 0x09E3 ], [ 0x0A01, 0x0A02 ], [ 0x0A3C, 0x0A3C ],
    [ 0x0A41, 0x0A42 ], [ 0x0A47, 0x0A48 ], [ 0x0A4B, 0x0A4D ],
    [ 0x0A70, 0x0A71 ], [ 0x0A81, 0x0A82 ], [ 0x0ABC, 0x0ABC ],
    [ 0x0AC1, 0x0AC5 ], [ 0x0AC7, 0x0AC8 ], [ 0x0ACD, 0x0ACD ],
    [ 0x0AE2, 0x0AE3 ], [ 0x0B01, 0x0B01 ], [ 0x0B3C, 0x0B3C ],
    [ 0x0B3F, 0x0B3F ], [ 0x0B41, 0x0B43 ], [ 0x0B4D, 0x0B4D ],
    [ 0x0B56, 0x0B56 ], [ 0x0B82, 0x0B82 ], [ 0x0BC0, 0x0BC0 ],
    [ 0x0BCD, 0x0BCD ], [ 0x0C3E, 0x0C40 ], [ 0x0C46, 0x0C48 ],
    [ 0x0C4A, 0x0C4D ], [ 0x0C55, 0x0C56 ], [ 0x0CBC, 0x0CBC ],
    [ 0x0CBF, 0x0CBF ], [ 0x0CC6, 0x0CC6 ], [ 0x0CCC, 0x0CCD ],
    [ 0x0CE2, 0x0CE3 ], [ 0x0D41, 0x0D43 ], [ 0x0D4D, 0x0D4D ],
    [ 0x0DCA, 0x0DCA ], [ 0x0DD2, 0x0DD4 ], [ 0x0DD6, 0x0DD6 ],
    [ 0x0E31, 0x0E31 ], [ 0x0E34, 0x0E3A ], [ 0x0E47, 0x0E4E ],
    [ 0x0EB1, 0x0EB1 ], [ 0x0EB4, 0x0EB9 ], [ 0x0EBB, 0x0EBC ],
    [ 0x0EC8, 0x0ECD ], [ 0x0F18, 0x0F19 ], [ 0x0F35, 0x0F35 ],
    [ 0x0F37, 0x0F37 ], [ 0x0F39, 0x0F39 ], [ 0x0F71, 0x0F7E ],
    [ 0x0F80, 0x0F84 ], [ 0x0F86, 0x0F87 ], [ 0x0F90, 0x0F97 ],
    [ 0x0F99, 0x0FBC ], [ 0x0FC6, 0x0FC6 ], [ 0x102D, 0x1030 ],
    [ 0x1032, 0x1032 ], [ 0x1036, 0x1037 ], [ 0x1039, 0x1039 ],
    [ 0x1058, 0x1059 ], [ 0x1160, 0x11FF ], [ 0x135F, 0x135F ],
    [ 0x1712, 0x1714 ], [ 0x1732, 0x1734 ], [ 0x1752, 0x1753 ],
    [ 0x1772, 0x1773 ], [ 0x17B4, 0x17B5 ], [ 0x17B7, 0x17BD ],
    [ 0x17C6, 0x17C6 ], [ 0x17C9, 0x17D3 ], [ 0x17DD, 0x17DD ],
    [ 0x180B, 0x180D ], [ 0x18A9, 0x18A9 ], [ 0x1920, 0x1922 ],
    [ 0x1927, 0x1928 ], [ 0x1932, 0x1932 ], [ 0x1939, 0x193B ],
    [ 0x1A17, 0x1A18 ], [ 0x1B00, 0x1B03 ], [ 0x1B34, 0x1B34 ],
    [ 0x1B36, 0x1B3A ], [ 0x1B3C, 0x1B3C ], [ 0x1B42, 0x1B42 ],
    [ 0x1B6B, 0x1B73 ], [ 0x1DC0, 0x1DCA ], [ 0x1DFE, 0x1DFF ],
    [ 0x200B, 0x200F ], [ 0x202A, 0x202E ], [ 0x2060, 0x2063 ],
    [ 0x206A, 0x206F ], [ 0x20D0, 0x20EF ], [ 0x302A, 0x302F ],
    [ 0x3099, 0x309A ], [ 0xA806, 0xA806 ], [ 0xA80B, 0xA80B ],
    [ 0xA825, 0xA826 ], [ 0xFB1E, 0xFB1E ], [ 0xFE00, 0xFE0F ],
    [ 0xFE20, 0xFE23 ], [ 0xFEFF, 0xFEFF ], [ 0xFFF9, 0xFFFB ],
    [ 0x10A01, 0x10A03 ], [ 0x10A05, 0x10A06 ], [ 0x10A0C, 0x10A0F ],
    [ 0x10A38, 0x10A3A ], [ 0x10A3F, 0x10A3F ], [ 0x1D167, 0x1D169 ],
    [ 0x1D173, 0x1D182 ], [ 0x1D185, 0x1D18B ], [ 0x1D1AA, 0x1D1AD ],
    [ 0x1D242, 0x1D244 ], [ 0xE0001, 0xE0001 ], [ 0xE0020, 0xE007F ],
    [ 0xE0100, 0xE01EF ]
];

var defaults = defaults$1;
var combining = combining$1;

var DEFAULTS$1 = {
  nul: 0,
  control: 0
};

wcwidth$4.exports = function wcwidth(str) {
  return wcswidth(str, DEFAULTS$1)
};

wcwidth$4.exports.config = function(opts) {
  opts = defaults(opts || {}, DEFAULTS$1);
  return function wcwidth(str) {
    return wcswidth(str, opts)
  }
};

/*
 *  The following functions define the column width of an ISO 10646
 *  character as follows:
 *  - The null character (U+0000) has a column width of 0.
 *  - Other C0/C1 control characters and DEL will lead to a return value
 *    of -1.
 *  - Non-spacing and enclosing combining characters (general category
 *    code Mn or Me in the
 *    Unicode database) have a column width of 0.
 *  - SOFT HYPHEN (U+00AD) has a column width of 1.
 *  - Other format characters (general category code Cf in the Unicode
 *    database) and ZERO WIDTH
 *    SPACE (U+200B) have a column width of 0.
 *  - Hangul Jamo medial vowels and final consonants (U+1160-U+11FF)
 *    have a column width of 0.
 *  - Spacing characters in the East Asian Wide (W) or East Asian
 *    Full-width (F) category as
 *    defined in Unicode Technical Report #11 have a column width of 2.
 *  - All remaining characters (including all printable ISO 8859-1 and
 *    WGL4 characters, Unicode control characters, etc.) have a column
 *    width of 1.
 *  This implementation assumes that characters are encoded in ISO 10646.
*/

function wcswidth(str, opts) {
  if (typeof str !== 'string') return wcwidth$3(str, opts)

  var s = 0;
  for (var i = 0; i < str.length; i++) {
    var n = wcwidth$3(str.charCodeAt(i), opts);
    if (n < 0) return -1
    s += n;
  }

  return s
}

function wcwidth$3(ucs, opts) {
  // test for 8-bit control characters
  if (ucs === 0) return opts.nul
  if (ucs < 32 || (ucs >= 0x7f && ucs < 0xa0)) return opts.control

  // binary search in table of non-spacing characters
  if (bisearch(ucs)) return 0

  // if we arrive here, ucs is not a combining or C0/C1 control character
  return 1 +
      (ucs >= 0x1100 &&
       (ucs <= 0x115f ||                       // Hangul Jamo init. consonants
        ucs == 0x2329 || ucs == 0x232a ||
        (ucs >= 0x2e80 && ucs <= 0xa4cf &&
         ucs != 0x303f) ||                     // CJK ... Yi
        (ucs >= 0xac00 && ucs <= 0xd7a3) ||    // Hangul Syllables
        (ucs >= 0xf900 && ucs <= 0xfaff) ||    // CJK Compatibility Ideographs
        (ucs >= 0xfe10 && ucs <= 0xfe19) ||    // Vertical forms
        (ucs >= 0xfe30 && ucs <= 0xfe6f) ||    // CJK Compatibility Forms
        (ucs >= 0xff00 && ucs <= 0xff60) ||    // Fullwidth Forms
        (ucs >= 0xffe0 && ucs <= 0xffe6) ||
        (ucs >= 0x20000 && ucs <= 0x2fffd) ||
        (ucs >= 0x30000 && ucs <= 0x3fffd)));
}

function bisearch(ucs) {
  var min = 0;
  var max = combining.length - 1;
  var mid;

  if (ucs < combining[0][0] || ucs > combining[max][1]) return false

  while (max >= min) {
    mid = Math.floor((min + max) / 2);
    if (ucs > combining[mid][1]) min = mid + 1;
    else if (ucs < combining[mid][0]) max = mid - 1;
    else return true
  }

  return false
}

var wcwidthExports = wcwidth$4.exports;

var stripAnsi = stripAnsi$1;
var wcwidth$2 = wcwidthExports;

var width = function(str) {
  return wcwidth$2(stripAnsi(str))
};

var utils = {};

var wcwidth$1 = width;

/**
 * repeat string `str` up to total length of `len`
 *
 * @param String str string to repeat
 * @param Number len total length of output string
 */

function repeatString(str, len) {
  return Array.apply(null, {length: len + 1}).join(str).slice(0, len)
}

/**
 * Pad `str` up to total length `max` with `chr`.
 * If `str` is longer than `max`, padRight will return `str` unaltered.
 *
 * @param String str string to pad
 * @param Number max total length of output string
 * @param String chr optional. Character to pad with. default: ' '
 * @return String padded str
 */

function padRight$1(str, max, chr) {
  str = str != null ? str : '';
  str = String(str);
  var length = max - wcwidth$1(str);
  if (length <= 0) return str
  return str + repeatString(chr || ' ', length)
}

/**
 * Pad `str` up to total length `max` with `chr`.
 * If `str` is longer than `max`, padCenter will return `str` unaltered.
 *
 * @param String str string to pad
 * @param Number max total length of output string
 * @param String chr optional. Character to pad with. default: ' '
 * @return String padded str
 */

function padCenter$1(str, max, chr) {
  str = str != null ? str : '';
  str = String(str);
  var length = max - wcwidth$1(str);
  if (length <= 0) return str
  var lengthLeft = Math.floor(length/2);
  var lengthRight = length - lengthLeft;
  return repeatString(chr || ' ', lengthLeft) + str + repeatString(chr || ' ', lengthRight)
}

/**
 * Pad `str` up to total length `max` with `chr`, on the left.
 * If `str` is longer than `max`, padRight will return `str` unaltered.
 *
 * @param String str string to pad
 * @param Number max total length of output string
 * @param String chr optional. Character to pad with. default: ' '
 * @return String padded str
 */

function padLeft$1(str, max, chr) {
  str = str != null ? str : '';
  str = String(str);
  var length = max - wcwidth$1(str);
  if (length <= 0) return str
  return repeatString(chr || ' ', length) + str
}

/**
 * Split a String `str` into lines of maxiumum length `max`.
 * Splits on word boundaries. Preserves existing new lines.
 *
 * @param String str string to split
 * @param Number max length of each line
 * @return Array Array containing lines.
 */

function splitIntoLines$1(str, max) {
  function _splitIntoLines(str, max) {
    return str.trim().split(' ').reduce(function(lines, word) {
      var line = lines[lines.length - 1];
      if (line && wcwidth$1(line.join(' ')) + wcwidth$1(word) < max) {
        lines[lines.length - 1].push(word); // add to line
      }
      else lines.push([word]); // new line
      return lines
    }, []).map(function(l) {
      return l.join(' ')
    })
  }
  return str.split('\n').map(function(str) {
    return _splitIntoLines(str, max)
  }).reduce(function(lines, line) {
    return lines.concat(line)
  }, [])
}

/**
 * Add spaces and `truncationChar` between words of
 * `str` which are longer than `max`.
 *
 * @param String str string to split
 * @param Number max length of each line
 * @param Number truncationChar character to append to split words
 * @return String
 */

function splitLongWords$1(str, max, truncationChar) {
  str = str.trim();
  var result = [];
  var words = str.split(' ');
  var remainder = '';

  var truncationWidth = wcwidth$1(truncationChar);

  while (remainder || words.length) {
    if (remainder) {
      var word = remainder;
      remainder = '';
    } else {
      var word = words.shift();
    }

    if (wcwidth$1(word) > max) {
      // slice is based on length no wcwidth
      var i = 0;
      var wwidth = 0;
      var limit = max - truncationWidth;
      while (i < word.length) {
        var w = wcwidth$1(word.charAt(i));
        if (w + wwidth > limit) {
          break
        }
        wwidth += w;
        ++i;
      }

      remainder = word.slice(i); // get remainder
      // save remainder for next loop

      word = word.slice(0, i); // grab truncated word
      word += truncationChar; // add trailing … or whatever
    }
    result.push(word);
  }

  return result.join(' ')
}


/**
 * Truncate `str` into total width `max`
 * If `str` is shorter than `max`,  will return `str` unaltered.
 *
 * @param String str string to truncated
 * @param Number max total wcwidth of output string
 * @return String truncated str
 */

function truncateString$1(str, max) {

  str = str != null ? str : '';
  str = String(str);

  if(max == Infinity) return str

  var i = 0;
  var wwidth = 0;
  while (i < str.length) {
    var w = wcwidth$1(str.charAt(i));
    if(w + wwidth > max)
      break
    wwidth += w;
    ++i;
  }
  return str.slice(0, i)
}



/**
 * Exports
 */

utils.padRight = padRight$1;
utils.padCenter = padCenter$1;
utils.padLeft = padLeft$1;
utils.splitIntoLines = splitIntoLines$1;
utils.splitLongWords = splitLongWords$1;
utils.truncateString = truncateString$1;

var wcwidth = width;

var _require = utils,
    padRight = _require.padRight,
    padCenter = _require.padCenter,
    padLeft = _require.padLeft,
    splitIntoLines = _require.splitIntoLines,
    splitLongWords = _require.splitLongWords,
    truncateString = _require.truncateString;

var DEFAULT_HEADING_TRANSFORM = function DEFAULT_HEADING_TRANSFORM(key) {
  return key.toUpperCase();
};

var DEFAULT_DATA_TRANSFORM = function DEFAULT_DATA_TRANSFORM(cell, column, index) {
  return cell;
};

var DEFAULTS = Object.freeze({
  maxWidth: Infinity,
  minWidth: 0,
  columnSplitter: ' ',
  truncate: false,
  truncateMarker: '…',
  preserveNewLines: false,
  paddingChr: ' ',
  showHeaders: true,
  headingTransform: DEFAULT_HEADING_TRANSFORM,
  dataTransform: DEFAULT_DATA_TRANSFORM
});

var columnify = function (items) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


  var columnConfigs = options.config || {};
  delete options.config; // remove config so doesn't appear on every column.

  var maxLineWidth = options.maxLineWidth || Infinity;
  if (maxLineWidth === 'auto') maxLineWidth = process.stdout.columns || Infinity;
  delete options.maxLineWidth; // this is a line control option, don't pass it to column

  // Option defaults inheritance:
  // options.config[columnName] => options => DEFAULTS
  options = mixin({}, DEFAULTS, options);

  options.config = options.config || Object.create(null);

  options.spacing = options.spacing || '\n'; // probably useless
  options.preserveNewLines = !!options.preserveNewLines;
  options.showHeaders = !!options.showHeaders;
  options.columns = options.columns || options.include; // alias include/columns, prefer columns if supplied
  var columnNames = options.columns || []; // optional user-supplied columns to include

  items = toArray(items, columnNames);

  // if not suppled column names, automatically determine columns from data keys
  if (!columnNames.length) {
    items.forEach(function (item) {
      for (var columnName in item) {
        if (columnNames.indexOf(columnName) === -1) columnNames.push(columnName);
      }
    });
  }

  // initialize column defaults (each column inherits from options.config)
  var columns = columnNames.reduce(function (columns, columnName) {
    var column = Object.create(options);
    columns[columnName] = mixin(column, columnConfigs[columnName]);
    return columns;
  }, Object.create(null));

  // sanitize column settings
  columnNames.forEach(function (columnName) {
    var column = columns[columnName];
    column.name = columnName;
    column.maxWidth = Math.ceil(column.maxWidth);
    column.minWidth = Math.ceil(column.minWidth);
    column.truncate = !!column.truncate;
    column.align = column.align || 'left';
  });

  // sanitize data
  items = items.map(function (item) {
    var result = Object.create(null);
    columnNames.forEach(function (columnName) {
      // null/undefined -> ''
      result[columnName] = item[columnName] != null ? item[columnName] : '';
      // toString everything
      result[columnName] = '' + result[columnName];
      if (columns[columnName].preserveNewLines) {
        // merge non-newline whitespace chars
        result[columnName] = result[columnName].replace(/[^\S\n]/gmi, ' ');
      } else {
        // merge all whitespace chars
        result[columnName] = result[columnName].replace(/\s/gmi, ' ');
      }
    });
    return result;
  });

  // transform data cells
  columnNames.forEach(function (columnName) {
    var column = columns[columnName];
    items = items.map(function (item, index) {
      var col = Object.create(column);
      item[columnName] = column.dataTransform(item[columnName], col, index);

      var changedKeys = Object.keys(col);
      // disable default heading transform if we wrote to column.name
      if (changedKeys.indexOf('name') !== -1) {
        if (column.headingTransform !== DEFAULT_HEADING_TRANSFORM) return;
        column.headingTransform = function (heading) {
          return heading;
        };
      }
      changedKeys.forEach(function (key) {
        return column[key] = col[key];
      });
      return item;
    });
  });

  // add headers
  var headers = {};
  if (options.showHeaders) {
    columnNames.forEach(function (columnName) {
      var column = columns[columnName];

      if (!column.showHeaders) {
        headers[columnName] = '';
        return;
      }

      headers[columnName] = column.headingTransform(column.name);
    });
    items.unshift(headers);
  }
  // get actual max-width between min & max
  // based on length of data in columns
  columnNames.forEach(function (columnName) {
    var column = columns[columnName];
    column.width = items.map(function (item) {
      return item[columnName];
    }).reduce(function (min, cur) {
      // if already at maxWidth don't bother testing
      if (min >= column.maxWidth) return min;
      return Math.max(min, Math.min(column.maxWidth, Math.max(column.minWidth, wcwidth(cur))));
    }, 0);
  });

  // split long words so they can break onto multiple lines
  columnNames.forEach(function (columnName) {
    var column = columns[columnName];
    items = items.map(function (item) {
      item[columnName] = splitLongWords(item[columnName], column.width, column.truncateMarker);
      return item;
    });
  });

  // wrap long lines. each item is now an array of lines.
  columnNames.forEach(function (columnName) {
    var column = columns[columnName];
    items = items.map(function (item, index) {
      var cell = item[columnName];
      item[columnName] = splitIntoLines(cell, column.width);

      // if truncating required, only include first line + add truncation char
      if (column.truncate && item[columnName].length > 1) {
        item[columnName] = splitIntoLines(cell, column.width - wcwidth(column.truncateMarker));
        var firstLine = item[columnName][0];
        if (!endsWith(firstLine, column.truncateMarker)) item[columnName][0] += column.truncateMarker;
        item[columnName] = item[columnName].slice(0, 1);
      }
      return item;
    });
  });

  // recalculate column widths from truncated output/lines
  columnNames.forEach(function (columnName) {
    var column = columns[columnName];
    column.width = items.map(function (item) {
      return item[columnName].reduce(function (min, cur) {
        if (min >= column.maxWidth) return min;
        return Math.max(min, Math.min(column.maxWidth, Math.max(column.minWidth, wcwidth(cur))));
      }, 0);
    }).reduce(function (min, cur) {
      if (min >= column.maxWidth) return min;
      return Math.max(min, Math.min(column.maxWidth, Math.max(column.minWidth, cur)));
    }, 0);
  });

  var rows = createRows(items, columns, columnNames, options.paddingChr); // merge lines into rows
  // conceive output
  return rows.reduce(function (output, row) {
    return output.concat(row.reduce(function (rowOut, line) {
      return rowOut.concat(line.join(options.columnSplitter));
    }, []));
  }, []).map(function (line) {
    return truncateString(line, maxLineWidth);
  }).join(options.spacing);
};

/**
 * Convert wrapped lines into rows with padded values.
 *
 * @param Array items data to process
 * @param Array columns column width settings for wrapping
 * @param Array columnNames column ordering
 * @return Array items wrapped in arrays, corresponding to lines
 */

function createRows(items, columns, columnNames, paddingChr) {
  return items.map(function (item) {
    var row = [];
    var numLines = 0;
    columnNames.forEach(function (columnName) {
      numLines = Math.max(numLines, item[columnName].length);
    });
    // combine matching lines of each rows

    var _loop = function _loop(i) {
      row[i] = row[i] || [];
      columnNames.forEach(function (columnName) {
        var column = columns[columnName];
        var val = item[columnName][i] || ''; // || '' ensures empty columns get padded
        if (column.align === 'right') row[i].push(padLeft(val, column.width, paddingChr));else if (column.align === 'center' || column.align === 'centre') row[i].push(padCenter(val, column.width, paddingChr));else row[i].push(padRight(val, column.width, paddingChr));
      });
    };

    for (var i = 0; i < numLines; i++) {
      _loop(i);
    }
    return row;
  });
}

/**
 * Object.assign
 *
 * @return Object Object with properties mixed in.
 */

function mixin() {
  if (Object.assign) return Object.assign.apply(Object, arguments);
  return ObjectAssign.apply(undefined, arguments);
}

function ObjectAssign(target, firstSource) {

  if (target === undefined || target === null) throw new TypeError("Cannot convert first argument to object");

  var to = Object(target);

  var hasPendingException = false;
  var pendingException;

  for (var i = 1; i < arguments.length; i++) {
    var nextSource = arguments[i];
    if (nextSource === undefined || nextSource === null) continue;

    var keysArray = Object.keys(Object(nextSource));
    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
      var nextKey = keysArray[nextIndex];
      try {
        var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== undefined && desc.enumerable) to[nextKey] = nextSource[nextKey];
      } catch (e) {
        if (!hasPendingException) {
          hasPendingException = true;
          pendingException = e;
        }
      }
    }

    if (hasPendingException) throw pendingException;
  }
  return to;
}

/**
 * Adapted from String.prototype.endsWith polyfill.
 */

function endsWith(target, searchString, position) {
  position = position || target.length;
  position = position - searchString.length;
  var lastIndex = target.lastIndexOf(searchString);
  return lastIndex !== -1 && lastIndex === position;
}

function toArray(items, columnNames) {
  if (Array.isArray(items)) return items;
  var rows = [];
  for (var key in items) {
    var item = {};
    item[columnNames[0] || 'key'] = key;
    item[columnNames[1] || 'value'] = items[key];
    rows.push(item);
  }
  return rows;
}

var columnify$1 = /*@__PURE__*/getDefaultExportFromCjs(columnify);

const withdrawTaskName = "withdraw";
let TaskWithdraw = class TaskWithdraw extends Task {
    constructor(target, resourceType = RESOURCE_ENERGY, amount, options = {}) {
        super(withdrawTaskName, target, options);
        // Settings
        this.settings.oneShot = true;
        this.data.resourceType = resourceType;
        this.data.amount = amount;
    }
    isValidTask() {
        const amount = this.data.amount || 1;
        return (this.creep.store.getUsedCapacity() <=
            this.creep.store.getCapacity() - amount);
    }
    isValidTarget() {
        var _a;
        if (!this.target.store) {
            return false;
        }
        const amount = this.data.amount || 1;
        const used = (_a = this.target.store.getUsedCapacity(this.data.resourceType)) !== null && _a !== void 0 ? _a : 0;
        return used >= amount;
    }
    work() {
        return this.creep.withdraw(this.target, this.data.resourceType, this.data.amount);
    }
};
TaskWithdraw = __decorate$1([
    profile
], TaskWithdraw);

var CombatCreepSetup_1;
const allZeroParts = () => ({
    move: 0,
    attack: 0,
    ranged_attack: 0,
    heal: 0,
    tough: 0,
    work: 0,
    carry: 0,
    claim: 0,
});
// This re-declaration is needed to get typings to work since typed-screeps has a hard-on for over-typing things
const BOOST_EFFECTS = BOOSTS;
/**
 * This class creates body plans for combat creeps, especially ones where the body may depend on the available boosts.
 * It extends my old CreepSetup class for backward compatibility; going forward, I will use this class for most
 * CombatOverlord creep requests while I use the old system for standard Overlord creep requests.
 */
let CombatCreepSetup = CombatCreepSetup_1 = class CombatCreepSetup /* extends CreepSetup */ {
    constructor(roleName, opts, bodyGenerator) {
        // super(roleName, {}, []);
        this.role = roleName;
        this.opts = opts;
        this.bodyGenerator = bodyGenerator;
        this.cache = {};
    }
    /**
     * Generate the body and boosts for a requested creep
     */
    create(colony, useCache = false) {
        // If you're allowed to use a cached result (e.g. for estimating wait times), return that
        if (useCache &&
            this.cache[colony.name] &&
            Game.time < this.cache[colony.name].expiration) {
            return this.cache[colony.name].result;
        }
        // Otherwise recompute
        const result = this.bodyGenerator(colony, this.opts);
        this.cache[colony.name] = {
            result: result,
            expiration: Game.time + 20,
        };
        return result;
    }
    // /**
    //  * Here for legacy purposes to that this can extend the old CreepSetup class, but you never want to use this!
    //  */
    // generateBody(availableEnergy: number): BodyPartConstant[] {
    // 	log.error(`CombatCreepSetup.generateBody() should not be used!`);
    // 	return [];
    // }
    /**
     * Returns an object with the best boosts available for each type of boost requested. The object will only have
     * keys for boosts which are requested in opts.boosts and for which opts.bodyRatio has non-zero entries, and
     * if a boost is requested but not available, the key will be present but the value will be undefined.
     */
    static getBestBoostsAvailable(colony, opts) {
        const availableBoosts = {};
        if (colony.evolutionChamber) {
            if (opts.bodyRatio.tough && opts.boosts.includes(TOUGH)) {
                const toughBoostNeeded = LAB_BOOST_MINERAL * (opts.maxParts.tough || 0);
                availableBoosts.tough =
                    colony.evolutionChamber.bestBoostAvailable(TOUGH, toughBoostNeeded);
            }
            if (opts.bodyRatio.heal && opts.boosts.includes(HEAL)) {
                const healBoostNeeded = LAB_BOOST_MINERAL * (opts.maxParts.heal || 0);
                availableBoosts.heal =
                    colony.evolutionChamber.bestBoostAvailable(HEAL, healBoostNeeded);
            }
            if (opts.bodyRatio.ranged_attack &&
                opts.boosts.includes(RANGED_ATTACK)) {
                const rangedBoostNeeded = LAB_BOOST_MINERAL * (opts.maxParts.ranged_attack || 0);
                availableBoosts.ranged =
                    colony.evolutionChamber.bestBoostAvailable(RANGED_ATTACK, rangedBoostNeeded);
            }
            if (opts.bodyRatio.attack && opts.boosts.includes(ATTACK)) {
                const attackBoostNeeded = LAB_BOOST_MINERAL * (opts.maxParts.attack || 0);
                availableBoosts.attack =
                    colony.evolutionChamber.bestBoostAvailable(ATTACK, attackBoostNeeded);
            }
            if (opts.bodyRatio.carry && opts.boosts.includes(CARRY)) {
                const carryBoostNeeded = LAB_BOOST_MINERAL * (opts.maxParts.carry || 0);
                availableBoosts.carry =
                    colony.evolutionChamber.bestBoostAvailable(CARRY, carryBoostNeeded);
            }
            if (opts.bodyRatio.work && opts.boosts.includes(DISMANTLE)) {
                const dismantleBoostNeeded = LAB_BOOST_MINERAL * (opts.maxParts.work || 0);
                availableBoosts.dismantle =
                    colony.evolutionChamber.bestBoostAvailable(DISMANTLE, dismantleBoostNeeded);
            }
            if (opts.bodyRatio.work && opts.boosts.includes(UPGRADE)) {
                const upgradeBoostNeeded = LAB_BOOST_MINERAL * (opts.maxParts.work || 0);
                availableBoosts.upgrade =
                    colony.evolutionChamber.bestBoostAvailable(UPGRADE, upgradeBoostNeeded);
            }
            if (opts.bodyRatio.work && opts.boosts.includes(CONSTRUCT)) {
                const constructBoostNeeded = LAB_BOOST_MINERAL * (opts.maxParts.work || 0);
                availableBoosts.construct =
                    colony.evolutionChamber.bestBoostAvailable(CONSTRUCT, constructBoostNeeded);
            }
            if (opts.bodyRatio.work && opts.boosts.includes(HARVEST)) {
                const harvestBoostNeeded = LAB_BOOST_MINERAL * (opts.maxParts.work || 0);
                availableBoosts.harvest =
                    colony.evolutionChamber.bestBoostAvailable(HARVEST, harvestBoostNeeded);
            }
            if (opts.boosts.includes(MOVE)) {
                const moveBoostNeeded = (LAB_BOOST_MINERAL * 50) / 3; // T1 most boost lets you do move ratio of 2 : 1
                availableBoosts.move =
                    colony.evolutionChamber.bestBoostAvailable(MOVE, moveBoostNeeded);
            }
        }
        if (_.sum(opts.boosts, (b) => [DISMANTLE, UPGRADE, CONSTRUCT, HARVEST].includes(b) ? 1
            : 0) > 1) {
            log.warning(`Multiple boost types requested for work part! opts.boosts: ${dump(opts.boosts)}`);
        }
        return availableBoosts;
    }
    /**
     * Generates a body counts based on a body ratio and a required move ratio (which depends on the available boosts
     * for the generating colony). If carryPartsAreWeighted=true, all carry parts are assumed to be full for the
     * purposes of computing move speed.
     */
    static generateBodyCounts(colony, opts, moveRatio, rootPart, partPriorities, unweightedCarryParts = false) {
        if (partPriorities.includes(rootPart)) {
            log.error(`generateBodyCounts() error: part priorities ${partPriorities} cannot ` +
                `include root part ${rootPart}`);
            return allZeroParts();
        }
        const bodyRatio = _.defaults(_.clone(opts.bodyRatio), allZeroParts());
        const maxParts = _.defaults(_.clone(opts.maxParts), allZeroParts());
        // Compute the most expensive part you may need to add to the body
        const nonZeroParts = _.filter(_.keys(opts.bodyRatio), (part) => opts.bodyRatio[part] > 0);
        const maxPartCost = _.max(_.map(nonZeroParts, (part) => BODYPART_COST[part]));
        // Initialize body counts object
        const bodyCounts = {
            [MOVE]: 1,
            [ATTACK]: bodyRatio.attack > 0 ? 1 : 0,
            [RANGED_ATTACK]: bodyRatio.ranged_attack > 0 ? 1 : 0,
            [HEAL]: bodyRatio.heal > 0 ? 1 : 0,
            [TOUGH]: bodyRatio.tough > 0 ? 1 : 0,
            [WORK]: bodyRatio.work > 0 ? 1 : 0,
            [CARRY]: bodyRatio.carry > 0 ? 1 : 0,
            [CLAIM]: bodyRatio.claim > 0 ? 1 : 0,
        };
        // Initialize cost of starting body counts
        let cost = 0;
        // for (const part in bodyCounts) {
        for (const p in bodyCounts) {
            const part = p;
            cost += bodyCounts[part] * BODYPART_COST[part];
        }
        // Keep adding stuff until you run out of space on the body or out of energy capacity in the room
        while (_.sum(bodyCounts) < MAX_CREEP_SIZE &&
            cost <= colony.room.energyCapacityAvailable - maxPartCost) {
            // Highest priority is add move parts to maintain the target move speed
            const weightedParts = unweightedCarryParts ?
                _.sum(bodyCounts) - bodyCounts.move - bodyCounts.carry
                : _.sum(bodyCounts) - bodyCounts.move;
            if (weightedParts >= moveRatio * bodyCounts.move) {
                bodyCounts.move++;
                cost += BODYPART_COST[MOVE];
            }
            else {
                // If any non-root parts are below the target ratio and below the maxParts limit, add them
                let nonRootPartAdded = false;
                for (const p of partPriorities) {
                    const part = p;
                    if (bodyCounts[part] < maxParts[part] &&
                        bodyCounts[part] / bodyCounts[rootPart] <
                            bodyRatio[part] / bodyRatio[rootPart]) {
                        bodyCounts[part]++;
                        cost += BODYPART_COST[part];
                        nonRootPartAdded = true;
                        break;
                    }
                }
                // Otherwise add another root part
                if (!nonRootPartAdded) {
                    bodyCounts[rootPart]++;
                    cost += BODYPART_COST[rootPart];
                }
            }
        }
        return bodyCounts;
    }
    /**
     * Generate a body array from a count of body parts. Body is ordered as:
     * - TOUGH -> CARRY -> MOVE -> RANGED -> WORK -> ATTACK -> CLAIM -> HEAL if opts.putMoveFirstInBody is true
     * - TOUGH -> CARRY -> RANGED -> WORK -> ATTACK -> HEAL -> CLAIM -> MOVE if opts.putMoveFirstInBody is false
     * - The final MOVE part is always put at the end of the body array
     */
    static arrangeBodyParts(partialBodyCounts, opts) {
        const defaultCounts = {
            move: 1,
            attack: 0,
            ranged_attack: 0,
            heal: 0,
            tough: 0,
            work: 0,
            carry: 0,
            claim: 0,
        };
        const bodyCounts = _.defaults(partialBodyCounts, defaultCounts);
        const body = [];
        _.forEach(_.range(bodyCounts.tough), () => body.push(TOUGH));
        if (opts.putMoveFirstInBody) {
            _.forEach(_.range(bodyCounts.carry), () => body.push(CARRY));
            _.forEach(_.range(bodyCounts.move - 1), () => body.push(MOVE));
            _.forEach(_.range(bodyCounts.ranged_attack), () => body.push(RANGED_ATTACK));
            _.forEach(_.range(bodyCounts.work), () => body.push(WORK));
            _.forEach(_.range(bodyCounts.attack), () => body.push(ATTACK));
            _.forEach(_.range(bodyCounts.claim), () => body.push(CLAIM));
            _.forEach(_.range(bodyCounts.heal), () => body.push(HEAL));
        }
        else {
            _.forEach(_.range(bodyCounts.carry), () => body.push(CARRY));
            _.forEach(_.range(bodyCounts.ranged_attack), () => body.push(RANGED_ATTACK));
            _.forEach(_.range(bodyCounts.work), () => body.push(WORK));
            _.forEach(_.range(bodyCounts.attack), () => body.push(ATTACK));
            _.forEach(_.range(bodyCounts.claim), () => body.push(CLAIM));
            _.forEach(_.range(bodyCounts.move - 1), () => body.push(MOVE));
            _.forEach(_.range(bodyCounts.heal), () => body.push(HEAL));
        }
        body.push(MOVE);
        return body;
    }
    /**
     * Creates a body plan for a creep with body ratios based around melee attack parts. The method will try to create
     * the largest creep which can be spawned from a colony, which has a target move speed after the best available
     * requested move boosts are applied, which has a body ratio specified by opts.bodyRatio, and where max part
     * counts are capped by opts.maxParts.
     */
    static generateMeleeAttackerBody(colony, opts) {
        if (!opts.bodyRatio.attack) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; No attack!`);
            return { body: [], boosts: [] };
        }
        if (opts.bodyRatio.work) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; using work parts requires dismantler body!`);
            return { body: [], boosts: [] };
        }
        if (opts.bodyRatio.ranged_attack) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; using ranged parts requires ranged body!`);
            return { body: [], boosts: [] };
        }
        const DEFAULT_MAX_PARTS_MELEE = { attack: 50, tough: 10, heal: 2 };
        opts.maxParts.attack =
            opts.maxParts.attack || DEFAULT_MAX_PARTS_MELEE.attack;
        opts.maxParts.tough =
            opts.maxParts.tough || DEFAULT_MAX_PARTS_MELEE.tough;
        opts.maxParts.heal = opts.maxParts.heal || DEFAULT_MAX_PARTS_MELEE.heal;
        const availableBoosts = CombatCreepSetup_1.getBestBoostsAvailable(colony, opts);
        if (!availableBoosts.tough) {
            // no point in adding tough parts if they can't be boosted
            opts.bodyRatio.tough = 0;
        }
        const moveRatio = (availableBoosts.move ?
            BOOST_EFFECTS.move[availableBoosts.move].fatigue
            : 1) * opts.moveSpeed;
        // We need attack to be defined for bodyRatio and maxParts
        opts.bodyRatio.attack = opts.bodyRatio.attack || 1;
        opts.bodyRatio.tough = opts.bodyRatio.tough || 0;
        opts.bodyRatio.heal = opts.bodyRatio.heal || 0;
        const rootPart = ATTACK;
        const partPriorities = [TOUGH, HEAL];
        const bodyCounts = CombatCreepSetup_1.generateBodyCounts(colony, opts, moveRatio, rootPart, partPriorities);
        const body = CombatCreepSetup_1.arrangeBodyParts(bodyCounts, opts);
        const boosts = _.compact(_.values(availableBoosts));
        return { body: body, boosts: boosts };
    }
    /**
     * Creates a body plan for a creep with body ratios based around ranged attack parts. The method will try to create
     * the largest creep which can be spawned from a colony, which has a target move speed after the best available
     * requested move boosts are applied, which has a body ratio specified by opts.bodyRatio, and where max part
     * counts are capped by opts.maxParts.
     */
    static generateRangedAttackerBody(colony, opts) {
        var _a, _b, _c, _d;
        var _e, _f, _g, _h;
        if (!opts.bodyRatio.ranged_attack) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; No ranged!`);
            return { body: [], boosts: [] };
        }
        if (opts.bodyRatio.work) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; using work parts requires dismantler body!`);
            return { body: [], boosts: [] };
        }
        if (opts.bodyRatio.attack) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; using ranged parts requires melee body!`);
            return { body: [], boosts: [] };
        }
        const DEFAULT_MAX_PARTS_RANGED = { ranged: 40, tough: 10, heal: 20 };
        (_a = (_e = opts.maxParts).ranged_attack) !== null && _a !== void 0 ? _a : (_e.ranged_attack = DEFAULT_MAX_PARTS_RANGED.ranged);
        (_b = (_f = opts.maxParts).tough) !== null && _b !== void 0 ? _b : (_f.tough = DEFAULT_MAX_PARTS_RANGED.tough);
        (_c = (_g = opts.maxParts).heal) !== null && _c !== void 0 ? _c : (_g.heal = DEFAULT_MAX_PARTS_RANGED.heal);
        const availableBoosts = CombatCreepSetup_1.getBestBoostsAvailable(colony, opts);
        if (!availableBoosts.tough) {
            // no point in adding tough parts if they can't be boosted
            opts.bodyRatio.tough = 0;
        }
        const moveRatio = (availableBoosts.move ?
            BOOST_EFFECTS.move[availableBoosts.move].fatigue
            : 1) * opts.moveSpeed;
        // We need ranged to be defined for bodyRatio and maxParts
        (_d = (_h = opts.bodyRatio).ranged_attack) !== null && _d !== void 0 ? _d : (_h.ranged_attack = 1);
        const rootPart = RANGED_ATTACK;
        const partPriorities = [TOUGH, HEAL];
        const bodyCounts = CombatCreepSetup_1.generateBodyCounts(colony, opts, moveRatio, rootPart, partPriorities);
        const body = CombatCreepSetup_1.arrangeBodyParts(bodyCounts, opts);
        const boosts = _.compact(_.values(availableBoosts));
        return { body: body, boosts: boosts };
    }
    /**
     * Creates a body plan for a creep with body ratios based around heal parts. The method will try to create
     * the largest creep which can be spawned from a colony, which has a target move speed after the best available
     * requested move boosts are applied, which has a body ratio specified by opts.bodyRatio, and where max part
     * counts are capped by opts.maxParts.
     */
    static generateHealerBody(colony, opts) {
        var _a, _b, _c;
        var _d, _e, _f;
        if (!opts.bodyRatio.heal) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; No heal!`);
            return { body: [], boosts: [] };
        }
        if (opts.bodyRatio.work) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; using work parts requires dismantler body!`);
            return { body: [], boosts: [] };
        }
        if (opts.bodyRatio.attack) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; using ranged parts requires melee body!`);
            return { body: [], boosts: [] };
        }
        const DEFAULT_MAX_PARTS_HEAL = { heal: 40, tough: 10, ranged: 30 };
        (_a = (_d = opts.maxParts).heal) !== null && _a !== void 0 ? _a : (_d.heal = DEFAULT_MAX_PARTS_HEAL.heal);
        (_b = (_e = opts.maxParts).ranged_attack) !== null && _b !== void 0 ? _b : (_e.ranged_attack = DEFAULT_MAX_PARTS_HEAL.ranged);
        (_c = (_f = opts.maxParts).tough) !== null && _c !== void 0 ? _c : (_f.tough = DEFAULT_MAX_PARTS_HEAL.tough);
        const availableBoosts = CombatCreepSetup_1.getBestBoostsAvailable(colony, opts);
        if (!availableBoosts.tough) {
            // no point in adding tough parts if they can't be boosted
            opts.bodyRatio.tough = 0;
        }
        const moveRatio = (availableBoosts.move ?
            BOOST_EFFECTS.move[availableBoosts.move].fatigue
            : 1) * opts.moveSpeed;
        // We need heal to be defined for bodyRatio and maxParts
        opts.bodyRatio.heal = opts.bodyRatio.heal || 1;
        const rootPart = HEAL;
        const partPriorities = [TOUGH, RANGED_ATTACK];
        const bodyCounts = CombatCreepSetup_1.generateBodyCounts(colony, opts, moveRatio, rootPart, partPriorities);
        const body = CombatCreepSetup_1.arrangeBodyParts(bodyCounts, opts);
        const boosts = _.compact(_.values(availableBoosts));
        return { body: body, boosts: boosts };
    }
    /**
     * Creates a body plan for a creep with body ratios based around work parts. The method will try to create
     * the largest creep which can be spawned from a colony, which has a target move speed after the best available
     * requested move boosts are applied, which has a body ratio specified by opts.bodyRatio, and where max part
     * counts are capped by opts.maxParts.
     */
    static generateDismantlerBody(colony, opts) {
        var _a, _b, _c;
        var _d, _e, _f;
        if (!opts.bodyRatio.work) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; No dismantle!`);
            return { body: [], boosts: [] };
        }
        if (opts.bodyRatio.attack) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; using attack parts requires melee body!`);
            return { body: [], boosts: [] };
        }
        const DEFAULT_MAX_PARTS_DISMANTLER = {
            work: 40,
            tough: 10,
            ranged: 10,
            heal: 2,
        };
        opts.maxParts.work =
            opts.maxParts.work || DEFAULT_MAX_PARTS_DISMANTLER.work;
        (_a = (_d = opts.maxParts).ranged_attack) !== null && _a !== void 0 ? _a : (_d.ranged_attack = DEFAULT_MAX_PARTS_DISMANTLER.ranged);
        (_b = (_e = opts.maxParts).tough) !== null && _b !== void 0 ? _b : (_e.tough = DEFAULT_MAX_PARTS_DISMANTLER.tough);
        (_c = (_f = opts.maxParts).heal) !== null && _c !== void 0 ? _c : (_f.heal = DEFAULT_MAX_PARTS_DISMANTLER.heal);
        const availableBoosts = CombatCreepSetup_1.getBestBoostsAvailable(colony, opts);
        if (!availableBoosts.tough) {
            // no point in adding tough parts if they can't be boosted
            opts.bodyRatio.tough = 0;
        }
        const moveRatio = (availableBoosts.move ?
            BOOST_EFFECTS.move[availableBoosts.move].fatigue
            : 1) * opts.moveSpeed;
        // We need work to be defined for bodyRatio and maxParts
        opts.bodyRatio.work = opts.bodyRatio.work || 1;
        const rootPart = WORK;
        const partPriorities = [TOUGH, RANGED_ATTACK, HEAL];
        const bodyCounts = CombatCreepSetup_1.generateBodyCounts(colony, opts, moveRatio, rootPart, partPriorities);
        const body = CombatCreepSetup_1.arrangeBodyParts(bodyCounts, opts);
        const boosts = _.compact(_.values(availableBoosts));
        return { body: body, boosts: boosts };
    }
    /**
     * Creates a body plan for a creep with body ratios based around work parts. Move speed for this method
     * assumes that all carry parts are empty, as you won't move an upgrader with energy. The method will try to create
     * the largest creep which can be spawned from a colony, which has a target move speed after the best available
     * requested move boosts are applied, which has a body ratio specified by opts.bodyRatio, and where max part
     * counts are capped by opts.maxParts.
     */
    static generateUpgraderBody(colony, opts) {
        if (!opts.bodyRatio.work) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; No dismantle!`);
            return { body: [], boosts: [] };
        }
        const DEFAULT_MAX_PARTS_UPGRADER = {
            work: 50,
            tough: 10,
            carry: 20,
            heal: 2,
        };
        opts.maxParts.work =
            opts.maxParts.work || DEFAULT_MAX_PARTS_UPGRADER.work;
        opts.maxParts.tough =
            opts.maxParts.tough || DEFAULT_MAX_PARTS_UPGRADER.tough;
        opts.maxParts.carry =
            opts.maxParts.carry || DEFAULT_MAX_PARTS_UPGRADER.carry;
        opts.maxParts.heal =
            opts.maxParts.heal || DEFAULT_MAX_PARTS_UPGRADER.heal;
        const availableBoosts = CombatCreepSetup_1.getBestBoostsAvailable(colony, opts);
        if (!availableBoosts.tough) {
            // no point in adding tough parts if they can't be boosted
            opts.bodyRatio.tough = 0;
        }
        const moveRatio = (availableBoosts.move ?
            BOOST_EFFECTS.move[availableBoosts.move].fatigue
            : 1) * opts.moveSpeed;
        // We need work to be defined for bodyRatio and maxParts
        opts.bodyRatio.work = opts.bodyRatio.work || 1;
        const rootPart = WORK;
        const partPriorities = [TOUGH, CARRY, HEAL];
        const bodyCounts = CombatCreepSetup_1.generateBodyCounts(colony, opts, moveRatio, rootPart, partPriorities, true);
        const body = CombatCreepSetup_1.arrangeBodyParts(bodyCounts, opts);
        const boosts = _.compact(_.values(availableBoosts));
        return { body: body, boosts: boosts };
    }
    /**
     * Creates a body plan for a creep with body ratios based around carry parts. The method will try to create
     * the largest creep which can be spawned from a colony, which has a target move speed after the best available
     * requested move boosts are applied, which has a body ratio specified by opts.bodyRatio, and where max part
     * counts are capped by opts.maxParts.
     */
    static generateCarrierBody(colony, opts) {
        if (!opts.bodyRatio.carry) {
            log.error(`Bad opts.bodyRatio: ${opts.bodyRatio}; No carry!`);
            return { body: [], boosts: [] };
        }
        const DEFAULT_MAX_PARTS_CARRIER = { carry: 50, tough: 10, heal: 3 };
        opts.maxParts.carry =
            opts.maxParts.attack || DEFAULT_MAX_PARTS_CARRIER.carry;
        opts.maxParts.tough =
            opts.maxParts.tough || DEFAULT_MAX_PARTS_CARRIER.tough;
        opts.maxParts.heal =
            opts.maxParts.heal || DEFAULT_MAX_PARTS_CARRIER.heal;
        const availableBoosts = CombatCreepSetup_1.getBestBoostsAvailable(colony, opts);
        if (!availableBoosts.tough) {
            // no point in adding tough parts if they can't be boosted
            opts.bodyRatio.tough = 0;
        }
        const moveRatio = (availableBoosts.move ?
            BOOST_EFFECTS.move[availableBoosts.move].fatigue
            : 1) * opts.moveSpeed;
        // We need carry to be defined for bodyRatio and maxParts
        opts.bodyRatio.carry = opts.bodyRatio.carry || 1;
        opts.bodyRatio.tough = opts.bodyRatio.tough || 0;
        opts.bodyRatio.heal = opts.bodyRatio.heal || 0;
        const rootPart = CARRY;
        const partPriorities = [TOUGH, HEAL];
        const bodyCounts = CombatCreepSetup_1.generateBodyCounts(colony, opts, moveRatio, rootPart, partPriorities);
        const body = CombatCreepSetup_1.arrangeBodyParts(bodyCounts, opts);
        const boosts = _.compact(_.values(availableBoosts));
        return { body: body, boosts: boosts };
    }
};
CombatCreepSetup = CombatCreepSetup_1 = __decorate$1([
    profile
], CombatCreepSetup);
/**
 * Creates a body for a zergling (melee attacker). Takes an object of possible options:
 * - If opts.boosted is true, all parts are requested to be boosted
 * - If opts.armored is true, a 3:1 attack:tough ratio will be used up to 10 tough parts
 * - If opts.healing is true, up to 2 heal parts will be added
 * - Specifying opts.bodyOpts may override any of the behaviors above
 */
class ZerglingSetup extends CombatCreepSetup {
    constructor(opts = {}) {
        _.defaults(opts, {
            moveSpeed: 1,
            boosted: false,
            armored: false,
            healing: false,
            bodyOpts: {},
        });
        const zerglingBodyOpts = {
            moveSpeed: opts.moveSpeed || 1,
            putMoveFirstInBody: true,
            bodyRatio: {
                attack: 30,
                tough: opts.armored ? 10 : 0,
                heal: opts.healing ? 2 : 0,
            },
            maxParts: { attack: 50, tough: 10, heal: 2 },
            boosts: opts.boosted ? [ATTACK, TOUGH, HEAL, MOVE] : [],
        };
        const bodyOpts = _.defaults(opts.bodyOpts || {}, zerglingBodyOpts);
        super(Roles.melee, bodyOpts, (c, o) => CombatCreepSetup.generateMeleeAttackerBody(c, o));
    }
}
/**
 * Creates a body for a hydralisk (ranged attacker which may have some healing). Possible optoins:
 * - If opts.boosted is true, all parts are requested to be boosted
 * - If opts.armored is true, a 4:1 ranged:tough ratio will be used up to 8 tough parts
 * - If opts.healing is true (default), a 3:1 ranged:heal ratio will be used up to 10 heal parts
 * - Specifying opts.bodyOpts may override any of the behaviors above
 */
class HydraliskSetup extends CombatCreepSetup {
    constructor(opts = {}) {
        _.defaults(opts, {
            moveSpeed: 1,
            boosted: false,
            armored: false,
            healing: true,
            bodyOpts: {},
        });
        const hydraliskBodyOpts = {
            moveSpeed: opts.moveSpeed || 1,
            putMoveFirstInBody: false,
            bodyRatio: {
                ranged_attack: 12,
                tough: opts.armored ? 3 : 0,
                heal: opts.healing ? 4 : 0,
            },
            maxParts: { ranged_attack: 30, tough: 8, heal: 10 },
            boosts: opts.boosted ? [RANGED_ATTACK, TOUGH, HEAL, MOVE] : [],
        };
        const bodyOpts = _.defaults(opts.bodyOpts || {}, hydraliskBodyOpts);
        super(Roles.ranged, bodyOpts, (c, o) => CombatCreepSetup.generateRangedAttackerBody(c, o));
    }
}
/**
 * Creates a body for a transfuser (healer which may have some ranged attack parts). Possible optoins:
 * - If opts.boosted is true, all parts are requested to be boosted
 * - If opts.armored is true, a 4:1 heal:tough ratio will be used up to 8 tough parts
 * - If opts.withRanged is true, a 3:1 heal:ranged ratio will be used up to 10 ranged parts
 * - Specifying opts.bodyOpts may override any of the behaviors above
 */
class TransfuserSetup extends CombatCreepSetup {
    constructor(opts = {}) {
        _.defaults(opts, {
            moveSpeed: 1,
            boosted: false,
            armored: false,
            withRanged: false,
            bodyOpts: {},
        });
        const healerBodyOpts = {
            moveSpeed: opts.moveSpeed || 1,
            putMoveFirstInBody: false,
            bodyRatio: {
                heal: 12,
                tough: opts.armored ? 3 : 0,
                ranged_attack: opts.withRanged ? 4 : 0,
            },
            maxParts: { heal: 30, tough: 8, ranged_attack: 10 },
            boosts: opts.boosted ? [RANGED_ATTACK, TOUGH, HEAL, MOVE] : [],
        };
        const bodyOpts = _.defaults(opts.bodyOpts || {}, healerBodyOpts);
        super(Roles.healer, bodyOpts, (c, o) => CombatCreepSetup.generateHealerBody(c, o));
    }
}
/**
 * Creates a body for a lurker (dismantler which may have some ranged or healing). Possible optoins:
 * - If opts.boosted is true, all parts are requested to be boosted
 * - If opts.armored is true, a 4:1 work:tough ratio will be used up to 10 tough parts
 * - If opts.withRanged is true, a 3:1 work:ranged ratoi will be used up to 10 ranged parts
 * - If opts.healing is true, up to 2 heal parts may be added
 * - Specifying opts.bodyOpts may override any of the behaviors above
 */
class LurkerSetup extends CombatCreepSetup {
    constructor(opts = {}) {
        _.defaults(opts, {
            moveSpeed: 1,
            boosted: false,
            armored: false,
            healing: false,
            bodyOpts: {},
        });
        const lurkerBodyOptions = {
            moveSpeed: opts.moveSpeed || 1,
            putMoveFirstInBody: false,
            bodyRatio: {
                work: 24,
                tough: opts.armored ? 6 : 0,
                ranged_attack: opts.withRanged ? 8 : 0,
                heal: opts.healing ? 2 : 0,
            },
            maxParts: { work: 30, tough: 10, ranged_attack: 10, heal: 2 },
            boosts: opts.boosted ?
                [DISMANTLE, RANGED_ATTACK, TOUGH, HEAL, MOVE]
                : [],
        };
        const bodyOpts = _.defaults(opts.bodyOpts || {}, lurkerBodyOptions);
        super(Roles.dismantler, bodyOpts, (c, o) => CombatCreepSetup.generateDismantlerBody(c, o));
    }
}
/**
 * Creates a body for a ravager (melee bunker defender with 0.5 move speed). Takes an object of possible options:
 * - If opts.boosted is true, all parts are requested to be boosted
 * - If opts.armored is true, a 3:1 attack:tough ratio will be used up to 10 tough parts
 * - If opts.healing is true, up to 2 heal parts will be added
 * - Specifying opts.bodyOpts may override any of the behaviors above
 */
class RavagerSetup extends CombatCreepSetup {
    constructor(opts = {}) {
        _.defaults(opts, {
            moveSpeed: 0.5,
            boosted: false,
            armored: false,
            healing: false,
            bodyOpts: {},
        });
        const ravagerBodyDefaults = {
            moveSpeed: opts.moveSpeed || 0.5,
            putMoveFirstInBody: true,
            bodyRatio: {
                attack: 30,
                tough: opts.armored ? 10 : 0,
                heal: opts.healing ? 2 : 0,
            },
            maxParts: { attack: 50, tough: 10, heal: 2 },
            boosts: opts.boosted ? [ATTACK, TOUGH, HEAL, MOVE] : [],
        };
        const bodyOpts = _.defaults(opts.bodyOpts || {}, ravagerBodyDefaults);
        super(Roles.bunkerDefender, bodyOpts, (c, o) => CombatCreepSetup.generateMeleeAttackerBody(c, o));
    }
}
/**
 * Creates a body for a remote upgrader. Possible optoins:
 * - If opts.boosted is true, all parts are requested to be boosted to max level
 * - Specifying opts.bodyOpts may override any of the behaviors above
 */
class RemoteUpgraderSetup extends CombatCreepSetup {
    constructor(opts = {}) {
        _.defaults(opts, { moveSpeed: 1, boosted: false, bodyOpts: {} });
        const remoteUpgraderBodyOptions = {
            moveSpeed: opts.moveSpeed || 1,
            putMoveFirstInBody: false,
            bodyRatio: { work: 8, carry: 1 },
            maxParts: { work: 40, carry: 10 },
            boosts: opts.boosted ? [UPGRADE, CARRY, MOVE] : [],
        };
        const bodyOpts = _.defaults(opts.bodyOpts || {}, remoteUpgraderBodyOptions);
        super(Roles.upgrader, bodyOpts, (c, o) => CombatCreepSetup.generateUpgraderBody(c, o));
    }
}
/**
 * Creates a body for a remote upgrader. Possible optoins:
 * - If opts.boosted is true, all parts are requested to be boosted to max level
 * - If opts.healing is true, up to 2 heal part will be added
 * - Specifying opts.bodyOpts may override any of the behaviors above
 */
class CarrierSetup extends CombatCreepSetup {
    constructor(opts = {}) {
        _.defaults(opts, {
            moveSpeed: 1,
            boosted: false,
            healing: false,
            bodyOpts: {},
        });
        const carrierBodyOptions = {
            moveSpeed: opts.moveSpeed || 1,
            putMoveFirstInBody: false,
            bodyRatio: { carry: 1, heal: opts.healing ? 0.01 : 0 },
            maxParts: { carry: 40, heal: opts.healing ? 1 : 0 },
            boosts: opts.boosted ? [CARRY, MOVE, HEAL] : [],
        };
        const bodyOpts = _.defaults(opts.bodyOpts || {}, carrierBodyOptions);
        super(Roles.transport, bodyOpts, (c, o) => CombatCreepSetup.generateCarrierBody(c, o));
    }
}
global.CombatCreepSetup = CombatCreepSetup;
global.DefaultCombatCreepSetups = {
    zergling: ZerglingSetup,
    hydralisk: HydraliskSetup,
    transfuser: TransfuserSetup,
    lurker: LurkerSetup,
    ravager: RavagerSetup,
    remoteUpgrader: RemoteUpgraderSetup,
    carrier: CarrierSetup,
};

var CreepSetup_1;
/* Return the cost of an entire array of body parts */
function bodyCost(bodyparts) {
    return _.sum(bodyparts, (part) => BODYPART_COST[part]);
}
function patternCost(setup) {
    return bodyCost(setup.bodySetup.pattern);
}
/**
 * The CreepSetup class contains methods for flexibly generating creep body arrays when needed for spawning
 */
let CreepSetup = CreepSetup_1 = class CreepSetup {
    constructor(roleName, bodySetup = {}, boosts) {
        this.role = roleName;
        // Defaults for a creep setup
        _.defaults(bodySetup, {
            pattern: [],
            sizeLimit: Infinity,
            prefix: [],
            suffix: [],
            proportionalPrefixSuffix: false,
            ordered: true,
        });
        this.bodySetup = bodySetup;
        this.boosts = boosts || [];
        this.cache = {};
    }
    /**
     * Returns a new CreepSetup instance which is a copy of the existing setup but with boosts applied. This allows
     * you to easily make boosted versions of the default setups in setups.ts without modifying the original objects.
     */
    static boosted(setup, boosts) {
        return new CreepSetup_1(setup.role, setup.bodySetup, boosts);
    }
    /**
     * Generate the body and best boosts for a requested creep
     */
    create(colony, useCache = false) {
        var _a, _b;
        // If you're allowed to use a cached result (e.g. for estimating wait times), return that
        if (useCache &&
            this.cache[colony.name] &&
            Game.time < this.cache[colony.name].expiration) {
            return this.cache[colony.name].result;
        }
        // Otherwise recompute
        const availableEnergy = colony.state.bootstrapping ?
            _.sum((_b = (_a = colony.hatchery) === null || _a === void 0 ? void 0 : _a.energyStructures) !== null && _b !== void 0 ? _b : [], (s) => s.store.getUsedCapacity(RESOURCE_ENERGY))
            : colony.room.energyCapacityAvailable;
        const body = this.generateBody(availableEnergy);
        const bodyCounts = _.countBy(body);
        const boosts = [];
        if (this.boosts.length > 0 && colony.evolutionChamber) {
            for (const boostType of this.boosts) {
                const numParts = bodyCounts[BoostTypeBodyparts[boostType]];
                const bestBoost = colony.evolutionChamber.bestBoostAvailable(boostType, numParts * LAB_BOOST_MINERAL);
                if (bestBoost) {
                    boosts.push(bestBoost);
                }
            }
        }
        const result = {
            body: body,
            boosts: boosts,
        };
        this.cache[colony.name] = {
            result: result,
            expiration: Game.time + 20,
        };
        return result;
    }
    /**
     * Generate the largest body of a given pattern that can be made from a room, subject to limitations from maxRepeats
     */
    generateBody(availableEnergy) {
        let patternCost, patternLength, numRepeats;
        const prefix = this.bodySetup.prefix;
        const suffix = this.bodySetup.suffix;
        let body = [];
        // calculate repetitions
        if (this.bodySetup.proportionalPrefixSuffix) {
            // if prefix and suffix are to be kept proportional to body size
            patternCost =
                bodyCost(prefix) +
                    bodyCost(this.bodySetup.pattern) +
                    bodyCost(suffix);
            patternLength =
                prefix.length + this.bodySetup.pattern.length + suffix.length;
            const energyLimit = Math.floor(availableEnergy / patternCost); // max number of repeats room can produce
            const maxPartLimit = Math.floor(MAX_CREEP_SIZE / patternLength); // max repetitions resulting in <50 parts
            numRepeats = Math.min(energyLimit, maxPartLimit, this.bodySetup.sizeLimit);
        }
        else {
            // if prefix and suffix don't scale
            const extraCost = bodyCost(prefix) + bodyCost(suffix);
            patternCost = bodyCost(this.bodySetup.pattern);
            patternLength = this.bodySetup.pattern.length;
            const energyLimit = Math.floor((availableEnergy - extraCost) / patternCost);
            const maxPartLimit = Math.floor((MAX_CREEP_SIZE - prefix.length - suffix.length) / patternLength);
            numRepeats = Math.min(energyLimit, maxPartLimit, this.bodySetup.sizeLimit);
        }
        // build the body
        if (this.bodySetup.proportionalPrefixSuffix) {
            // add the prefix
            for (let i = 0; i < numRepeats; i++) {
                body = body.concat(prefix);
            }
        }
        else {
            body = body.concat(prefix);
        }
        if (this.bodySetup.ordered) {
            // repeated body pattern
            for (const part of this.bodySetup.pattern) {
                for (let i = 0; i < numRepeats; i++) {
                    body.push(part);
                }
            }
        }
        else {
            for (let i = 0; i < numRepeats; i++) {
                body = body.concat(this.bodySetup.pattern);
            }
        }
        if (this.bodySetup.proportionalPrefixSuffix) {
            // add the suffix
            for (let i = 0; i < numRepeats; i++) {
                body = body.concat(suffix);
            }
        }
        else {
            body = body.concat(suffix);
        }
        // return it
        return body;
    }
    generateMaxedBody() {
        // TODO hardcoded for our current cap with extensions missing
        return this.generateBody(11100);
    }
    /**
     * Returns the number of parts that a body will have if made from a given colony
     */
    getBodyPotential(partType, colony) {
        // let energyCapacity = Math.max(colony.room.energyCapacityAvailable,
        // 							  colony.incubator ? colony.incubator.room.energyCapacityAvailable : 0);
        let energyCapacity = colony.room.energyCapacityAvailable;
        if (colony.spawnGroup) {
            const colonies = _.compact(_.map(colony.spawnGroup.memory.colonies, (name) => Overmind.colonies[name]));
            energyCapacity = _.max(_.map(colonies, (colony) => colony.room.energyCapacityAvailable));
        }
        const body = this.generateBody(energyCapacity);
        return _.filter(body, (part) => part == partType)
            .length;
    }
};
CreepSetup = CreepSetup_1 = __decorate$1([
    profile
], CreepSetup);

/**
 * A mapping of role types to string constants used for naming creeps and accessing them by role
 */
const Roles = {
    // Civilian roles
    drone: "drone",
    gatherer: "gatherer",
    filler: "filler",
    claim: "infestor",
    pioneer: "pioneer",
    manager: "manager",
    queen: "queen",
    scout: "changeling",
    transport: "transport",
    worker: "worker",
    upgrader: "upgrader",
    praiser: "praiser",
    // Combat roles
    guardMelee: "broodling", // currently not a CombatCreepSetup
    melee: "zergling",
    ranged: "hydralisk",
    rangedDistractor: "babbylisk",
    healer: "transfuser",
    dismantler: "lurker",
    bunkerDefender: "ravager",
    drill: "drill",
    coolant: "coolant",
    roomPoisoner: "poisoner",
    strongholdKiller: "strongman",
};
/**
 * This object contains categorized default body setups for various types of creeps
 */
const Setups = {
    drones: {
        extractor: new CreepSetup(Roles.drone, {
            pattern: [WORK, WORK, MOVE],
            sizeLimit: Infinity,
            prefix: [CARRY, CARRY],
        }),
        miners: {
            default: new CreepSetup(Roles.drone, {
                pattern: [WORK, WORK, CARRY, MOVE],
                sizeLimit: 3,
            }),
            standard: new CreepSetup(Roles.drone, {
                pattern: [
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    CARRY,
                    MOVE,
                    MOVE,
                    MOVE,
                    WORK,
                ],
                sizeLimit: 1,
            }),
            standardCPU: new CreepSetup(Roles.drone, {
                pattern: [
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    CARRY,
                    MOVE,
                    MOVE,
                    MOVE,
                    MOVE,
                    WORK,
                ],
                sizeLimit: 1,
            }),
            linkOptimized: new CreepSetup(Roles.drone, {
                pattern: [WORK, WORK, WORK, CARRY, MOVE, MOVE, WORK],
                sizeLimit: 4,
            }),
            emergency: new CreepSetup(Roles.drone, {
                pattern: [WORK, WORK, CARRY, MOVE],
                sizeLimit: 1,
            }),
            double: new CreepSetup(Roles.drone, {
                pattern: [
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    WORK,
                    CARRY,
                    MOVE,
                    MOVE,
                    MOVE,
                ],
                sizeLimit: 2,
            }),
            sourceKeeper: new CreepSetup(Roles.drone, {
                pattern: [WORK, WORK, CARRY, MOVE],
                sizeLimit: 5,
            }),
        },
    },
    gatherer: {
        deposit: new CreepSetup(Roles.gatherer, {
            pattern: [WORK, WORK, CARRY, MOVE, MOVE],
        }),
    },
    filler: new CreepSetup(Roles.filler, {
        pattern: [CARRY, CARRY, MOVE],
        sizeLimit: 1,
    }),
    infestors: {
        claim: new CreepSetup(Roles.claim, {
            pattern: [CLAIM, MOVE],
            sizeLimit: 1,
        }),
        fastClaim: new CreepSetup(Roles.claim, {
            pattern: [MOVE, MOVE, MOVE, MOVE, CLAIM, MOVE],
            sizeLimit: 1,
        }),
        reserve: new CreepSetup(Roles.claim, {
            pattern: [CLAIM, MOVE],
            sizeLimit: 4,
        }),
        controllerAttacker: new CreepSetup(Roles.claim, {
            pattern: [CLAIM, MOVE],
            sizeLimit: Infinity,
        }),
    },
    pioneer: new CreepSetup(Roles.pioneer, {
        pattern: [WORK, CARRY, MOVE, MOVE],
        sizeLimit: Infinity,
    }),
    managers: {
        default: new CreepSetup(Roles.manager, {
            pattern: [CARRY, CARRY, CARRY, CARRY, MOVE],
            sizeLimit: 5,
        }),
        twoPart: new CreepSetup(Roles.manager, {
            pattern: [CARRY, CARRY, MOVE],
            sizeLimit: 8,
        }),
        stationary: new CreepSetup(Roles.manager, {
            pattern: [CARRY, CARRY],
            sizeLimit: 16,
        }),
        stationary_work: new CreepSetup(Roles.manager, {
            pattern: [WORK, WORK, WORK, WORK, CARRY, CARRY],
            sizeLimit: 8,
        }),
    },
    queens: {
        default: new CreepSetup(Roles.queen, {
            pattern: [CARRY, CARRY, MOVE],
            sizeLimit: Infinity,
        }),
        early: new CreepSetup(Roles.queen, {
            pattern: [CARRY, MOVE],
            sizeLimit: Infinity,
        }),
    },
    scout: new CreepSetup(Roles.scout, {
        pattern: [MOVE],
        sizeLimit: 1,
    }),
    transporters: {
        default: new CreepSetup(Roles.transport, {
            pattern: [CARRY, CARRY, MOVE],
            sizeLimit: Infinity,
        }),
        early: new CreepSetup(Roles.transport, {
            pattern: [CARRY, MOVE],
            sizeLimit: Infinity,
        }),
        boosted: new CarrierSetup({ boosted: true }),
    },
    workers: {
        // TODO: implement inhouse workers to reinforce bunker
        inhouse: new CreepSetup(Roles.worker, {
            pattern: [WORK, WORK, CARRY, MOVE],
            sizeLimit: Infinity,
        }),
        default: new CreepSetup(Roles.worker, {
            pattern: [WORK, CARRY, MOVE],
            sizeLimit: Infinity,
        }),
        early: new CreepSetup(Roles.worker, {
            pattern: [WORK, CARRY, MOVE, MOVE],
            sizeLimit: Infinity,
        }),
    },
    upgraders: {
        default: new CreepSetup(Roles.upgrader, {
            pattern: [WORK, WORK, WORK, CARRY, MOVE],
            sizeLimit: Infinity,
        }),
        rcl8: new CreepSetup(Roles.upgrader, {
            pattern: [WORK, WORK, WORK, CARRY, MOVE],
            sizeLimit: 5,
        }),
        rcl8_boosted: new CreepSetup(Roles.upgrader, {
            pattern: [WORK, WORK, WORK, CARRY, MOVE],
            sizeLimit: 5,
        }, ["upgrade"]),
        remote: new CreepSetup(Roles.upgrader, {
            pattern: [
                WORK,
                WORK,
                WORK,
                WORK,
                CARRY,
                CARRY,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
            ],
            sizeLimit: Infinity,
        }),
        remote_boosted: new RemoteUpgraderSetup({ boosted: true }),
    },
    roomPoisoner: new CreepSetup(Roles.roomPoisoner, {
        pattern: [WORK, CARRY, MOVE, MOVE],
        sizeLimit: 4,
    }),
    praisers: {
        default: new CreepSetup(Roles.upgrader, {
            pattern: [WORK, WORK, WORK, CARRY, MOVE],
            sizeLimit: Infinity,
        }),
    },
};
/**
 * This object contains default body setups for various types of combat-related creeps
 */
const CombatSetups = {
    /**
     * Zerglings are melee-only creeps (with exception of sourceKeeper setup)
     */
    zerglings: {
        // default: new CreepSetup(Roles.melee, {
        // 	pattern  : [ATTACK, MOVE],
        // 	sizeLimit: Infinity,
        // }),
        //
        // limitedDefault: new CreepSetup(Roles.melee, {
        // 	pattern  : [ATTACK, MOVE],
        // 	sizeLimit: 5,
        // }),
        //
        // armored: new CreepSetup(Roles.melee, {
        // 	pattern  : [TOUGH, ATTACK, ATTACK, ATTACK, MOVE, MOVE, MOVE, MOVE],
        // 	sizeLimit: Infinity,
        // }),
        //
        // boosted_T3_defense: new CreepSetup(Roles.melee, {
        // 	pattern  : [TOUGH, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, MOVE, MOVE],
        // 	sizeLimit: Infinity,
        // }),
        //
        // boosted_T3: new CreepSetup(Roles.melee, {
        // 	pattern  : [TOUGH, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, MOVE, MOVE],
        // 	sizeLimit: Infinity,
        // }),
        //
        // boosted_T3_armor: new CreepSetup(Roles.melee, {
        // 	pattern  : [TOUGH, TOUGH, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, MOVE, MOVE],
        // 	sizeLimit: Infinity,
        // }),
        //
        // boosted_T3_strongArmor: new CreepSetup(Roles.melee, {
        // 	pattern  : [TOUGH, TOUGH, TOUGH, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, MOVE, MOVE],
        // 	sizeLimit: Infinity,
        // }),
        default: new ZerglingSetup(),
        healing: new ZerglingSetup({ healing: true }),
        boosted: {
            default: new ZerglingSetup({ boosted: true }),
            armored: new ZerglingSetup({ boosted: true, armored: true }),
            armoredHealing: new ZerglingSetup({
                boosted: true,
                armored: true,
                healing: true,
            }),
        },
        sourceKeeper: new CreepSetup(Roles.melee, {
            pattern: [
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                ATTACK,
                ATTACK,
                ATTACK,
                ATTACK,
                HEAL,
                MOVE,
            ],
            sizeLimit: Infinity,
        }),
    },
    /**
     * Hydralisks are ranged creeps which may have a small amount of healing
     */
    hydralisks: {
        default: new HydraliskSetup(),
        noHeal: new HydraliskSetup({ healing: false }),
        boosted: {
            default: new HydraliskSetup({ boosted: true }),
            armored: new HydraliskSetup({ boosted: true, armored: true }),
            noHeal: new HydraliskSetup({ boosted: true, healing: false }),
        },
        // early: new CreepSetup(Roles.ranged, {
        // 	pattern  : [RANGED_ATTACK, MOVE],
        // 	sizeLimit: Infinity,
        // }),
        //
        // distraction: new CreepSetup(Roles.ranged, {
        // 	pattern  : [MOVE, MOVE, MOVE, MOVE, RANGED_ATTACK, MOVE],
        // 	sizeLimit: 1,
        // }),
        //
        // default: new CreepSetup(Roles.ranged, {
        // 	pattern  : [RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, MOVE, MOVE, MOVE, MOVE, HEAL],
        // 	sizeLimit: Infinity,
        // }),
        //
        // boosted_T3: new CreepSetup(Roles.ranged, {
        // 	pattern  : [TOUGH, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, MOVE,
        // 				MOVE, HEAL, HEAL, HEAL],
        // 	sizeLimit: Infinity,
        // }),
        //
        // boosted_T3_old: new CreepSetup(Roles.ranged, {
        // 	pattern  : [TOUGH, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK,
        // 				MOVE, MOVE, HEAL, HEAL],
        // 	sizeLimit: Infinity,
        // }),
        //
        // siege: new CreepSetup(Roles.ranged, {
        // 	pattern  : [RANGED_ATTACK, RANGED_ATTACK, MOVE, MOVE, MOVE, MOVE, HEAL, HEAL],
        // 	sizeLimit: Infinity,
        // }),
        //
        // siege_T3: new CreepSetup(Roles.ranged, {
        // 	pattern  : [TOUGH, TOUGH, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK,
        // 				MOVE, MOVE, HEAL, HEAL],
        // 	sizeLimit: Infinity,
        // }),
        sourceKeeper: new CreepSetup(Roles.ranged, {
            pattern: [
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                HEAL,
                HEAL,
                MOVE,
            ],
            sizeLimit: Infinity,
        }),
    },
    /**
     * Healers (transfusers) are creeps which only do healing
     */
    transfusers: {
        default: new TransfuserSetup(),
        boosted: {
            default: new TransfuserSetup({ boosted: true }),
            armored: new TransfuserSetup({ boosted: true, armored: true }),
        },
        // default: new CreepSetup(Roles.healer, {
        // 	pattern  : [HEAL, MOVE],
        // 	sizeLimit: Infinity,
        // }),
        //
        // armored: new CreepSetup(Roles.healer, {
        // 	pattern  : [TOUGH, HEAL, HEAL, HEAL, MOVE, MOVE, MOVE, MOVE],
        // 	sizeLimit: Infinity,
        // }),
        //
        // boosted_T3: new CreepSetup(Roles.healer, {
        // 	pattern  : [TOUGH, TOUGH, HEAL, HEAL, HEAL, HEAL, HEAL, HEAL, MOVE, MOVE],
        // 	sizeLimit: Infinity,
        // }),
    },
    /**
     * Broodlings are primarily melee creeps which may have a small amount of healing
     */
    broodlings: {
        early: new CreepSetup(Roles.guardMelee, {
            pattern: [ATTACK, MOVE],
            sizeLimit: Infinity,
        }),
        default: new CreepSetup(Roles.guardMelee, {
            pattern: [
                ATTACK,
                ATTACK,
                MOVE,
                MOVE,
                ATTACK,
                ATTACK,
                MOVE,
                MOVE,
                MOVE,
                HEAL,
            ],
            sizeLimit: Infinity,
        }),
    },
    /**
     * Pure melee raw power creeps that should never leave the bunker. These are the final guards for a room
     */
    bunkerDefender: {
        default: new RavagerSetup(),
        boosted: new RavagerSetup({ boosted: true }),
        // early: new CreepSetup(Roles.bunkerDefender, {
        // 	pattern  : [ATTACK, MOVE],
        // 	sizeLimit: Infinity,
        // }),
        //
        // default: new CreepSetup(Roles.bunkerDefender, {
        // 	pattern  : [ATTACK, ATTACK, MOVE],
        // 	sizeLimit: Infinity,
        // }),
        //
        // tiny: new CreepSetup(Roles.bunkerDefender, {
        // 	pattern  : [ATTACK, ATTACK, MOVE, MOVE],
        // 	sizeLimit: 2,
        // }),
        //
        // halfMove: new CreepSetup(Roles.bunkerDefender, {
        // 	pattern  : [ATTACK, ATTACK, ATTACK, ATTACK, MOVE],
        // 	sizeLimit: Infinity,
        // }),
        //
        // boosted_T3: new CreepSetup(Roles.bunkerDefender, {
        // 	// 22 ATTACK, 3 MOVE times 2
        // 	pattern  : [ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK,
        // 				ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, MOVE, MOVE, MOVE],
        // 	sizeLimit: Infinity,
        // }),
    },
    /**
     * Dismantlers (lurkers) are creeps with work parts for dismantle sieges
     */
    dismantlers: {
        default: new CreepSetup(Roles.dismantler, {
            pattern: [WORK, MOVE],
            sizeLimit: Infinity,
        }),
        attackDismantlers: new CreepSetup(Roles.dismantler, {
            pattern: [ATTACK, MOVE],
            sizeLimit: Infinity,
        }),
        armored: new CreepSetup(Roles.dismantler, {
            pattern: [TOUGH, WORK, WORK, WORK, MOVE, MOVE, MOVE, MOVE],
            sizeLimit: Infinity,
        }),
        boosted_armored_T3: new CreepSetup(Roles.dismantler, {
            pattern: [
                TOUGH,
                TOUGH,
                WORK,
                WORK,
                WORK,
                WORK,
                WORK,
                WORK,
                MOVE,
                MOVE,
            ],
            sizeLimit: Infinity,
        }),
        // boosted_T3: new CreepSetup(Roles.dismantler, {
        // 	pattern  : [WORK, WORK, WORK, WORK, WORK, WORK, WORK, WORK, MOVE, MOVE],
        // 	sizeLimit: Infinity,
        // }),
    },
    distractors: {
        ranged: new CreepSetup(Roles.rangedDistractor, {
            pattern: [MOVE, MOVE, MOVE, MOVE, RANGED_ATTACK, MOVE],
            sizeLimit: 1,
        }),
    },
    drill: {
        default: new CreepSetup(Roles.drill, {
            pattern: [MOVE, ATTACK, ATTACK, MOVE],
            sizeLimit: Infinity,
        }),
    },
    coolant: {
        default: new CreepSetup(Roles.coolant, {
            pattern: [HEAL, MOVE],
            sizeLimit: Infinity,
        }),
        small: new CreepSetup(Roles.coolant, {
            pattern: [HEAL, MOVE],
            sizeLimit: 16,
        }),
    },
    strongholdKiller: {
        // SK deal 200 RA, gotta avoid, levels
        1: new CreepSetup(Roles.strongholdKiller, {
            // 180 damage after tough so 2 tough, 4 healing, 34 RA
            pattern: [
                TOUGH,
                TOUGH,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
            ],
            sizeLimit: 1,
        }),
        2: new CreepSetup(Roles.strongholdKiller, {
            // 360 damage after tough so 4 tough, 8 healing, 28 RA
            pattern: [
                TOUGH,
                TOUGH,
                TOUGH,
                TOUGH,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
            ],
            sizeLimit: 1,
        }),
        3: new CreepSetup(Roles.strongholdKiller, {
            // 540 damage after tough so 6 tough, 12 healing, 22 RA
            pattern: [
                TOUGH,
                TOUGH,
                TOUGH,
                TOUGH,
                TOUGH,
                TOUGH,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
            ],
            sizeLimit: 1,
        }),
        4: new CreepSetup(Roles.strongholdKiller, {
            // 720 damage after tough so 8 tough, 15 healing, 17RA - 15*250+17*150+50*11 = 6.8k
            pattern: [
                TOUGH,
                TOUGH,
                TOUGH,
                TOUGH,
                TOUGH,
                TOUGH,
                TOUGH,
                TOUGH,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                RANGED_ATTACK,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                HEAL,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
                MOVE,
            ],
            sizeLimit: 1,
        }),
    },
};
global.Setups = Setups;

const rechargeTaskName = "recharge";
const RECHARGE_MAX_DISTANCE = 40;
let TaskRecharge = class TaskRecharge extends Task {
    constructor(minEnergy = 0, options = {}) {
        super(rechargeTaskName, null, options);
        this.data.minEnergy = minEnergy;
    }
    get sources() {
        if (!this._sources) {
            if (this.data.sourcesIDs) {
                this._sources = (this.data.sourcesIDs
                    .map((id) => Game.getObjectById(id))
                    .filter((s) => s));
            }
            if (this._sources && this._sources.length === 0) {
                this._sources = this.creep.room.sources;
            }
        }
        return this._sources;
    }
    rechargeRateForCreep(creep, obj) {
        log.debugCreep(creep, () => `checking recharge rate of ${creep.print} against ${obj.print}`);
        if (creep.colony &&
            creep.colony.hatchery &&
            creep.colony.hatchery.batteries &&
            creep.colony.hatchery.batteries.some((b) => b.id === obj.id) &&
            creep.roleName != "queen") {
            log.debugCreep(creep, `\t is not a queen, can't use hatchery battery`);
            return false; // only queens can use the hatchery battery
        }
        const amountAvailable = isResource(obj) ? obj.amount : obj.store[RESOURCE_ENERGY];
        if (amountAvailable < this.data.minEnergy) {
            return false;
        }
        const otherTargeters = _.filter(_.map(obj.targetedBy, (name) => Overmind.zerg[name]), (zerg) => !!zerg &&
            zerg.task &&
            (zerg.task.name == withdrawTaskName ||
                zerg.task.name == pickupTaskName));
        const resourceOutflux = _.sum(_.map(otherTargeters, (other) => other.store.getFreeCapacity()));
        const amountGrabbed = minMax(amountAvailable - resourceOutflux, 0, creep.store.getCapacity());
        const effectiveAmount = amountGrabbed / (creep.pos.getMultiRoomRangeTo(obj.pos) + 1);
        log.debugCreep(creep, () => `\tother targeters are ${columnify$1(otherTargeters.map((creep) => {
            var _a;
            return {
                creep: creep.print,
                free: creep.store.getFreeCapacity(),
                task: (_a = creep.task) === null || _a === void 0 ? void 0 : _a.name,
            };
        }))}`);
        log.debugCreep(creep, () => `\tavailable: ${amountAvailable} resourceOutFlux: ${resourceOutflux}, ` +
            `grabbed: ${amountGrabbed}, effective: ${effectiveAmount}`);
        if (effectiveAmount <= 0) {
            return false;
        }
        else {
            return effectiveAmount;
        }
    }
    // Override creep setter to dispense a valid recharge task
    set creep(creep) {
        this._creep.name = creep.name;
        if (this._parent) {
            this.parent.creep = creep;
        }
        let task = this.goRecharge(creep);
        if (!task) {
            task = this.goHarvest(creep);
        }
        if (!task) {
            log.debugCreep(creep, `No valid recharge target!`);
            creep.task = null;
        }
        creep.task = task;
    }
    goRecharge(creep) {
        // Choose the target to maximize your energy gain subject to other targeting workers
        const possibleTargets = creep.colony && creep.inColonyRoom ?
            creep.colony.rechargeables
            : creep.room.rechargeables;
        const target = maxBy(possibleTargets, (o) => this.rechargeRateForCreep(creep, o));
        log.debugCreep(creep, `selected ${target === null || target === void 0 ? void 0 : target.print} from targets ${possibleTargets
            .map((t) => t.print)
            .join(", ")}`);
        if (!target ||
            creep.pos.getMultiRoomRangeTo(target.pos) > RECHARGE_MAX_DISTANCE) {
            return undefined;
        }
        if (isResource(target)) {
            log.debugCreep(creep, `selected pickup target ${target.print} for ${creep.print}`);
            return new TaskPickup(target);
        }
        else {
            log.debugCreep(creep, `selected withdraw target ${target.print} for ${creep.print}`);
            return new TaskWithdraw(target);
        }
    }
    goHarvest(creep) {
        // workers shouldn't harvest; let drones do it (disabling this check can destabilize early economy)
        const canHarvest = isStandardZerg(creep) &&
            creep.getActiveBodyparts(WORK) > 0 &&
            creep.roleName !== Roles.worker;
        if (!canHarvest) {
            return undefined;
        }
        // Harvest from a source if there is no recharge target available
        const availableSources = _.filter(this.sources, function (source) {
            const filledSource = source.energy > 0 || source.ticksToRegeneration < 20;
            // Only harvest from sources which aren't surrounded by creeps excluding yourself
            const isSurrounded = source.pos.availableNeighbors(false).length == 0;
            return (filledSource && (!isSurrounded || creep.pos.isNearTo(source)));
        });
        const availableSource = creep.pos.findClosestByMultiRoomRange(availableSources);
        if (!availableSource) {
            return undefined;
        }
        return new TaskHarvest(availableSource);
    }
    isValid() {
        return false;
    }
    isValidTask() {
        return false;
    }
    isValidTarget() {
        return false;
    }
    get isWorking() {
        return false;
    }
    work() {
        log.warning(`BAD RESULT: Should not get here...`);
        return ERR_INVALID_TARGET;
    }
};
TaskRecharge = __decorate$1([
    profile
], TaskRecharge);

const repairTaskName = "repair";
let TaskRepair = class TaskRepair extends Task {
    constructor(target, options = {}) {
        super(repairTaskName, target, options);
        // Settings
        this.settings.timeout = 100;
        this.settings.targetRange = 3;
    }
    isValidTask() {
        return this.creep.store.energy > 0;
    }
    isValidTarget() {
        return this.target && this.target.hits < this.target.hitsMax;
    }
    work() {
        const result = this.creep.repair(this.target);
        if (this.target.structureType == STRUCTURE_ROAD) {
            // prevents workers from idling for a tick before moving to next target
            const newHits = this.target.hits +
                this.creep.getActiveBodyparts(WORK) * REPAIR_POWER;
            if (newHits > this.target.hitsMax) {
                this.finish();
            }
        }
        return result;
    }
};
TaskRepair = __decorate$1([
    profile
], TaskRepair);

const reserveTaskName = "colony";
const RESERVE_DEFAULT_AMOUNT = 4999;
let TaskReserve = class TaskReserve extends Task {
    constructor(target, options = {}) {
        _.defaults(options, { reserveAmount: RESERVE_DEFAULT_AMOUNT });
        super(reserveTaskName, target, options);
    }
    isValidTask() {
        return this.creep.getActiveBodyparts(CLAIM) > 0;
    }
    isValidTarget() {
        var _a;
        const target = this.target;
        return (target != null &&
            (!target.reservation ||
                target.reservation.ticksToEnd <
                    ((_a = this.options.reserveAmount) !== null && _a !== void 0 ? _a : RESERVE_DEFAULT_AMOUNT)));
    }
    work() {
        let ret = this.creep.reserveController(this.target);
        if (ret == ERR_INVALID_TARGET) {
            ret = this.creep.attackController(this.target);
        }
        return ret;
    }
};
TaskReserve = __decorate$1([
    profile
], TaskReserve);

const retireTaskName = "retire";
let TaskRetire = class TaskRetire extends Task {
    constructor(target, options = {}) {
        super(retireTaskName, target, options);
        // Settings
        this.settings.timeout = Infinity;
        this.settings.targetRange = 1;
    }
    isValidTask() {
        return true;
    }
    isValidTarget() {
        return !!this.target;
    }
    work() {
        const result = this.target.recycleCreep(this.creep.creep);
        if (result === OK) {
            log.info(`${this.creep.print} successfully <s>recycled</s> retired with ${this.creep.ticksToLive} ticks remaining`);
            this.finish();
        }
        return result;
    }
};
TaskRetire = __decorate$1([
    profile
], TaskRetire);

const signControllerTaskName = "signController";
let TaskSignController = class TaskSignController extends Task {
    constructor(target, options = {}) {
        super(signControllerTaskName, target, options);
    }
    isValidTask() {
        return true;
    }
    isValidTarget() {
        const controller = this.target;
        return ((!controller.sign ||
            controller.sign.text != Memory.settings.signature) &&
            !controller.signedByScreeps);
    }
    work() {
        return this.creep.signController(this.target, Memory.settings.signature);
    }
};
TaskSignController = __decorate$1([
    profile
], TaskSignController);

const transferTaskName = "transfer";
let TaskTransfer = class TaskTransfer extends Task {
    constructor(target, resourceType = RESOURCE_ENERGY, amount, options = {}) {
        super(transferTaskName, target, options);
        // Settings
        this.settings.oneShot = true;
        this.data.resourceType = resourceType;
        this.data.amount = amount;
    }
    isValidTask() {
        const amount = this.data.amount || 1;
        const resourcesInCarry = this.creep.store[this.data.resourceType] || 0;
        return resourcesInCarry >= amount;
    }
    isValidTarget() {
        var _a;
        const amount = this.data.amount || 1;
        return (((_a = this.target.store.getFreeCapacity(this.data.resourceType)) !== null && _a !== void 0 ? _a : 0) >=
            amount);
    }
    work() {
        return this.creep.transfer(this.target, this.data.resourceType, this.data.amount);
    }
};
TaskTransfer = __decorate$1([
    profile
], TaskTransfer);

const transferAllTaskName = "transferAll";
let TaskTransferAll = class TaskTransferAll extends Task {
    constructor(target, skipEnergy = false, options = {}) {
        super(transferAllTaskName, target, options);
        this.data.skipEnergy = skipEnergy;
    }
    isValidTask() {
        for (const [resourceType, amount] of Object.entries(this.creep.store)) {
            if (this.data.skipEnergy && resourceType == RESOURCE_ENERGY) {
                continue;
            }
            if (amount > 0) {
                return true;
            }
        }
        return false;
    }
    isValidTarget() {
        return (this.target.store.getUsedCapacity() <
            this.target.store.getCapacity());
    }
    work() {
        for (const [resourceType, amount] of this.creep.store.contents) {
            if (this.data.skipEnergy && resourceType == RESOURCE_ENERGY) {
                continue;
            }
            if (amount > 0) {
                return this.creep.transfer(this.target, resourceType);
            }
        }
        return -1;
    }
};
TaskTransferAll = __decorate$1([
    profile
], TaskTransferAll);

const upgradeTaskName = "upgrade";
let TaskUpgrade = class TaskUpgrade extends Task {
    constructor(target, options = {}) {
        super(upgradeTaskName, target, options);
        // Settings
        this.settings.targetRange = 3;
        this.settings.workOffRoad = true;
    }
    isValidTask() {
        return this.creep.store.energy > 0;
    }
    isValidTarget() {
        return this.target && !!this.target.my;
    }
    work() {
        return this.creep.upgradeController(this.target);
    }
};
TaskUpgrade = __decorate$1([
    profile
], TaskUpgrade);

/* Withdraw a resource from a target */
const withdrawAllTaskName = "withdrawAll";
let TaskWithdrawAll = class TaskWithdrawAll extends Task {
    constructor(target, options = {}) {
        super(withdrawAllTaskName, target, options);
    }
    isValidTask() {
        return (this.creep.store.getUsedCapacity() < this.creep.store.getCapacity());
    }
    isValidTarget() {
        return (this.target.store.getUsedCapacity() || 0) > 0;
    }
    work() {
        let resourceTransferType;
        for (const [resourceType, amountInStore] of this.target.store
            .contents) {
            if (amountInStore > 0) {
                resourceTransferType = resourceType;
                // Prioritize non-energy
                if (resourceType != RESOURCE_ENERGY) {
                    break;
                }
            }
        }
        if (!!resourceTransferType) {
            return this.creep.withdraw(this.target, resourceTransferType);
        }
        return -1;
    }
};
TaskWithdrawAll = __decorate$1([
    profile
], TaskWithdrawAll);

// Reinstantiation of a task object from ProtoTask data
/**
 * The task initializer maps serialized prototasks to Task instances
 */
function initializeTask(protoTask) {
    // Retrieve name and target data from the ProtoTask
    const taskName = protoTask.name;
    const target = deref(protoTask._target.ref);
    let task;
    // Create a task object of the correct type
    switch (taskName) {
        case attackTaskName:
            task = new TaskAttack(target);
            break;
        case buildTaskName:
            task = new TaskBuild(target);
            break;
        case claimTaskName:
            task = new TaskClaim(target);
            break;
        case dismantleTaskName:
            task = new TaskDismantle(target);
            break;
        case dropTaskName:
            task = new TaskDrop(derefRoomPosition(protoTask._target._pos));
            break;
        // case fleeTaskName:
        // 	task = new TaskFlee(derefRoomPosition(ProtoTask._target._pos) as fleeTargetType);
        // 	break;
        case fortifyTaskName:
            task = new TaskFortify(target);
            break;
        case getBoostedTaskName:
            task = new TaskGetBoosted(target, 
            // @ts-expect-error this is set in the constructor
            protoTask.data.resourceType);
            break;
        case getRenewedTaskName:
            task = new TaskGetRenewed(target);
            break;
        case goToTaskName:
            // task = new TaskGoTo(derefRoomPosition(ProtoTask._target._pos) as goToTargetType);
            task = new TaskInvalid();
            break;
        case goToRoomTaskName:
            task = new TaskGoToRoom(protoTask._target._pos.roomName);
            break;
        case harvestTaskName:
            task = new TaskHarvest(target);
            break;
        case healTaskName:
            task = new TaskHeal(target);
            break;
        case meleeAttackTaskName:
            task = new TaskMeleeAttack(target);
            break;
        case pickupTaskName:
            task = new TaskPickup(target);
            break;
        case rangedAttackTaskName:
            task = new TaskRangedAttack(target);
            break;
        case rechargeTaskName:
            task = new TaskRecharge();
            break;
        case repairTaskName:
            task = new TaskRepair(target);
            break;
        case reserveTaskName:
            task = new TaskReserve(target);
            break;
        case signControllerTaskName:
            task = new TaskSignController(target);
            break;
        case transferTaskName:
            task = new TaskTransfer(target);
            break;
        case transferAllTaskName:
            task = new TaskTransferAll(target);
            break;
        case upgradeTaskName:
            task = new TaskUpgrade(target);
            break;
        case withdrawTaskName:
            task = new TaskWithdraw(target);
            break;
        case withdrawAllTaskName:
            task = new TaskWithdrawAll(target);
            break;
        case generateSafeModeTaskName:
            task = new TaskGenerateSafeMode(target);
            break;
        case retireTaskName:
            task = new TaskRetire(target);
            break;
        default:
            log.error(`Invalid task name: ${taskName}! task.creep: ${protoTask._creep.name}. Deleting from memory!`);
            task = new TaskInvalid();
            break;
    }
    // Modify the task object to reflect any changed properties
    task.proto = protoTask;
    // Return it
    return task;
}
profiler.registerFN(initializeTask, "initializeTask");

const RANGES = {
    BUILD: 3,
    REPAIR: 3,
    TRANSFER: 1,
    WITHDRAW: 1,
    HARVEST: 1,
    ATTACK: 1,
    HEAL: 1,
    RANGED_ATTACK: 3,
    RANGED_HEAL: 3,
    DROP: 0,
};

var _a;
/**
 * Operational statistics, stored in Memory.stats, will be updated every (this many) ticks
 */
const LOG_STATS_INTERVAL = (_a = LOG_STATS_INTERVAL$1) !== null && _a !== void 0 ? _a : 8;
let Stats = class Stats {
    static get mode() {
        return "memory";
    }
    static get useMemory() {
        return this.mode === "memory";
    }
    static get useSegment() {
        return this.mode === "segment";
    }
    static get shouldLog() {
        return tickClock(LOG_STATS_INTERVAL) === 0;
    }
    static clean() {
        if (!this.shouldLog) {
            return;
        }
        log.info(`Stats.clean!`);
        const protectedKeys = ["persistent"];
        if (this.useMemory) {
            for (const key in Memory.stats) {
                if (!protectedKeys.includes(key)) {
                    // @ts-expect-error global shenaningans
                    delete Memory.stats[key];
                }
            }
        }
        if (this.useSegment) {
            const segment = Segmenter.getSegment(SEGMENTS.stats);
            for (const key in segment) {
                if (!protectedKeys.includes(key)) {
                    delete segment[key];
                }
            }
            Segmenter.setSegment(SEGMENTS.stats, segment);
        }
    }
    static set(key, value) {
        // log.info(`Stats.set: key: "${key}": ${JSON.stringify(value)}`);
        if (this.useMemory) {
            Mem.setDeep(Memory.stats, key, value);
        }
        if (this.useSegment) {
            const stats = Segmenter.getSegment(SEGMENTS.stats);
            // log.info(
            // 	`Stats.set: segment: ${JSON.stringify(
            // 		Segmenter.getSegment(SEGMENTS.stats)
            // 	)}`
            // );
            Mem.setDeep(stats, key, value);
            // log.info(`Stats.set: set: ${JSON.stringify(stats)}`);
            Segmenter.setSegment(SEGMENTS.stats, stats);
            // log.info(
            // 	`Stats.set: final: ${JSON.stringify(
            // 		Segmenter.getSegment(SEGMENTS.stats)
            // 	)}`
            // );
        }
    }
    static log(key, value, truncateNumbers = true) {
        if (!this.shouldLog) {
            return;
        }
        if (truncateNumbers && value != undefined) {
            const decimals = 5;
            if (typeof value == "number") {
                value = value.truncate(decimals);
            }
            else {
                for (const i in value) {
                    value[i] = value[i].truncate(decimals);
                }
            }
        }
        this.set(key, value);
    }
    static avg(key, value, window) {
        let source;
        if (this.useMemory) {
            source = Memory.stats;
        }
        else {
            source = Segmenter.getSegment(SEGMENTS.stats);
        }
        const current = _.get(source, key);
        const avg = ema(value, current, window);
        this.set(key, avg);
    }
    // static accumulate(key: string, value: number): void {
    // 	if (!Memory.stats[key]) {
    // 		Memory.stats[key] = 0;
    // 	}
    // 	Memory.stats[key] += value;
    // }
    static run() {
        const clock = tickClock(LOG_STATS_INTERVAL);
        // log.info(
        // 	`Stats.run: ${clock} segment:\n${JSON.stringify(
        // 		Segmenter.getSegment(SEGMENTS.stats)
        // 	)}`
        // );
        switch (clock) {
            case -1: {
                if (!this.useSegment) {
                    break;
                }
                Segmenter.requestSegments(SEGMENTS.stats);
                // fall-through
            }
            default:
                // return; the rest of that method is about stats updates
                return;
            case 0:
                // fall-through, since it's time now
                break;
        }
        // Record IVM heap statistics
        if (Game.cpu.getHeapStatistics) {
            this.set("cpu.heapStatistics", Game.cpu.getHeapStatistics());
        }
        // Log GCL
        this.log("gcl.progress", Game.gcl.progress);
        this.log("gcl.progressTotal", Game.gcl.progressTotal);
        this.log("gcl.level", Game.gcl.level);
        // Log memory usage
        this.log("memory.used", RawMemory.get().length);
        // Log CPU
        this.log("cpu.limit", Game.cpu.limit);
        this.log("cpu.bucket", Game.cpu.bucket);
        const used = Game.cpu.getUsed();
        this.log("cpu.getUsed", used);
        this.avg("persistent.avgCPU", used, LOG_STATS_INTERVAL);
        this.log("persistent.empireAge", Memory.tick);
        this.log("persistent.build", Memory.build);
        if (this.useSegment) {
            // FIXME: There are a few things we have to grab back out of memory
            this.log("persistent.time", Memory.stats.persistent.time);
            this.log("persistent.lastBucket", Memory.stats.persistent.lastBucket);
            this.log("persistent.lastErrorTick", Memory.stats.persistent.lastErrorTick);
            this.log("persistent.avgBucketDelta", Memory.stats.persistent.avgBucketDelta);
            this.log("persistent.lastGlobalReset", Memory.stats.persistent.lastGlobalReset);
            this.set("persistent.trader", Memory.stats.persistent.trader);
            this.set("persistent.terminalNetwork", Memory.stats.persistent.terminalNetwork);
        }
        // if (this.useMemory) {
        // 	log.info(
        // 		`Stats.run: ${clock} done:\n` +
        // 			`memory: ${JSON.stringify(Memory.stats)}`
        // 	);
        // }
        // if (this.useSegment) {
        // 	log.info(
        // 		`Stats.run: ${clock} done:\n` +
        // 			`segment: ${JSON.stringify(
        // 				Segmenter.getSegment(SEGMENTS.stats)
        // 			)}\n` +
        // 			`raw: ${RawMemory.segments[55]}`
        // 	);
        // }
    }
};
Stats = __decorate$1([
    profile
], Stats);

var Mem_1;
var Autonomy;
(function (Autonomy) {
    Autonomy[Autonomy["Manual"] = 0] = "Manual";
    Autonomy[Autonomy["SemiAutomatic"] = 1] = "SemiAutomatic";
    Autonomy[Autonomy["Automatic"] = 2] = "Automatic";
})(Autonomy || (Autonomy = {}));
function getAutonomyLevel() {
    switch (Memory.settings.operationMode) {
        case "manual":
            return Autonomy.Manual;
        case "semiautomatic":
            return Autonomy.SemiAutomatic;
        case "automatic":
            return Autonomy.Automatic;
        default:
            log.warning(`ERROR: ${Memory.settings.operationMode} is not a valid operation mode! ` +
                `Defaulting to ${DEFAULT_OPERATION_MODE}; use setMode() to change.`);
            Memory.settings.operationMode = DEFAULT_OPERATION_MODE;
            return getAutonomyLevel();
    }
}
let lastMemory;
let lastTime = 0;
const MAX_BUCKET = 10000;
const HEAP_CLEAN_FREQUENCY = 200;
const BUCKET_CLEAR_CACHE = 7000;
const BUCKET_CPU_HALT = 4000;
const BUCKET_LOW_WATERMARK = 500;
const PIXEL_GENERATION_GRACE_PERIOD = 500;
const OVERMIND_SMALL_CAPS$1 = "\u1D0F\u1D20\u1D07\u0280\u1D0D\u026A\u0274\u1D05";
const DEFAULT_OVERMIND_SIGNATURE = `«${OVERMIND_SMALL_CAPS$1}»`;
/**
 * This module contains a number of low-level memory clearing and caching functions
 */
let Mem = Mem_1 = class Mem {
    static shouldRun() {
        let shouldRun = true;
        if (!isIVM()) {
            log.warning(`Overmind requires isolated-VM to run. Change settings at screeps.com/a/#!/account/runtime`);
            shouldRun = false;
        }
        if (Game.cpu.bucket < BUCKET_LOW_WATERMARK &&
            (!Memory.pixelsTick ||
                Game.time - Memory.pixelsTick >= PIXEL_GENERATION_GRACE_PERIOD)) {
            if (_.keys(Game.spawns).length > 1 &&
                !Memory.resetBucket &&
                !Memory.haltTick) {
                // don't run CPU reset routine at very beginning or if it's already triggered
                log.warning(`CPU bucket is critically low (${Game.cpu.bucket})! Starting CPU reset routine.`);
                Memory.resetBucket = true;
                Memory.haltTick = Game.time + 1; // reset global next tick
            }
            else {
                log.info(`CPU bucket is too low (${Game.cpu.bucket}). Postponing operation until bucket reaches 500.`);
            }
            shouldRun = false;
        }
        if (Memory.resetBucket) {
            if (Game.cpu.bucket < MAX_BUCKET - Game.cpu.limit) {
                log.info(`Operation suspended until bucket recovery. Bucket: ${Game.cpu.bucket}/${MAX_BUCKET}`);
                shouldRun = false;
            }
            else {
                delete Memory.resetBucket;
            }
        }
        if (Memory.haltTick) {
            if (Memory.haltTick == Game.time) {
                if (Game.cpu.halt) {
                    // this is undefined on non-IVM
                    Memory.build--; // don't count this reset as a build
                    Game.cpu.halt();
                }
                shouldRun = false;
            }
            else if (Memory.haltTick < Game.time) {
                delete Memory.haltTick;
            }
        }
        return shouldRun;
    }
    static didRun() {
        var _a, _b, _c;
        Memory.tick++;
        Memory.stats.persistent.time = Game.time;
        // Update bucket delta tracking
        const bucket = Game.cpu.bucket;
        const lastBucket = Memory.stats.persistent.lastBucket;
        if (lastBucket !== undefined) {
            const used = Game.cpu.getUsed();
            const limit = (_b = (_a = Game.cpu.shardLimits) === null || _a === void 0 ? void 0 : _a[Game.shard.name]) !== null && _b !== void 0 ? _b : 500;
            // Since that (realistic) calculation will cap once the bucket is full
            // switch to an estimate based on CPU usage instead
            const delta = bucket - lastBucket;
            const deltaEstimate = Math.ceil(limit - used);
            const lastAvgDelta = (_c = Memory.stats.persistent.avgBucketDelta) !== null && _c !== void 0 ? _c : bucket;
            const avgDelta = Math.min(ema(delta === 0 ? deltaEstimate : delta, lastAvgDelta, 10), limit);
            log.info(`CPU: used: ${used.toFixed(3)}, bucket: ${bucket} (delta: ${delta}, est: ${deltaEstimate}, avg: ${avgDelta.toFixed(0)}), tick limit: ${Game.cpu.tickLimit}`);
            Memory.stats.persistent.avgBucketDelta = avgDelta;
        }
        Memory.stats.persistent.lastBucket = bucket;
    }
    /**
     * Attempt to load the parsed memory from a previous tick to avoid parsing costs
     */
    static load() {
        if (lastTime && lastMemory && Game.time == lastTime + 1) {
            // @ts-expect-error global shenanigans
            delete global.Memory;
            global.Memory = lastMemory;
            RawMemory._parsed = lastMemory;
        }
        else {
            // eslint-disable-next-line
            Memory.rooms; // forces parsing
            // eslint-disable-next-line
            lastMemory = RawMemory._parsed;
            Memory.stats.persistent.lastMemoryReset = Game.time;
        }
        lastTime = Game.time;
        // Handle global time
        if (!global.GLOBAL_AGE) {
            global.GLOBAL_AGE = 0;
        }
        global.GLOBAL_AGE++;
        Memory.stats.persistent.globalAge = global.GLOBAL_AGE;
    }
    static garbageCollect(quick) {
        if (global.gc) {
            // sometimes garbage collection isn't available
            const start = Game.cpu.getUsed();
            global.gc(quick);
            log.debug(`Running ${quick ? "quick" : "FULL"} garbage collection. ` +
                `Elapsed time: ${Game.cpu.getUsed() - start}.`);
        }
        else {
            log.debug(`Manual garbage collection is unavailable on this server.`);
        }
    }
    /**
     * Wrap a parent memory object with a key name and set the default properties for the child memory object if needed
     */
    static wrap(memory, memName, getDefaults = () => ({})) {
        if (memory[memName] === undefined) {
            memory[memName] = getDefaults();
        }
        else if (Game.time == LATEST_GLOBAL_RESET_TICK) {
            // mem defaults would only change with a global reset
            memory[memName] = _.defaultsDeep({}, memory[memName], getDefaults());
        }
        return memory[memName];
    }
    static _setDeep(object, keys, value) {
        const key = _.first(keys);
        keys = _.drop(keys);
        if (keys.length == 0) {
            // at the end of the recursion
            // eslint-disable-next-line
            object[key] = value;
            return;
        }
        else {
            if (!object[key]) {
                object[key] = {};
            }
            return Mem_1._setDeep(object[key], keys, value);
        }
    }
    /**
     * Recursively set a value of an object given a dot-separated key, adding intermediate properties as necessary
     * Ex: Mem.setDeep(Memory.colonies, 'E1S1.miningSites.siteID.stats.uptime', 0.5)
     */
    static setDeep(object, keyString, value) {
        const keys = keyString.split(".");
        return Mem_1._setDeep(object, keys, value);
    }
    static getDefaultMemory() {
        return {
            tick: Game.time,
            build: 0,
            Overmind: {},
            combatPlanner: {},
            profiler: {},
            overseer: {},
            segmenter: {},
            roomIntel: {},
            colonies: {},
            rooms: {},
            creeps: {},
            powerCreeps: {},
            flags: {},
            spawns: {},
            pathing: { distances: {} },
            constructionSites: {},
            stats: { persistent: {} },
            playerCreepTracker: {},
            remoteDebugger: {},
            nukePlanner: {},
            expansionPlanner: {},
            settings: {
                signature: DEFAULT_OVERMIND_SIGNATURE,
                operationMode: "automatic",
                log: {},
                enableVisuals: true,
                resourceCollectionMode: 0,
                allies: [],
                powerCollection: {
                    enabled: false,
                    maxRange: 5,
                    minPower: 5000,
                },
                autoPoison: {
                    enabled: false,
                    maxRange: 4,
                    maxConcurrent: 1,
                },
                pixelGeneration: {
                    enabled: false,
                },
                roomPlanner: {
                    allowDestroy: false,
                },
                colonization: {
                    maxRooms: undefined,
                    safeZone: 1,
                },
                intelVisuals: {},
                attitude: {
                    brazenness: 0.5,
                },
            },
        };
    }
    static format() {
        // Format the memory as needed, done once every global reset
        _.defaultsDeep(Memory, { settings: DEFAULT_SETTINGS }, Mem_1.getDefaultMemory());
        // Increment build counter (if global reset is due to CPU halt, the count will have been decremented)
        Memory.build++;
        // Make global memory
        this.initGlobalMemory();
    }
    static initGlobalMemory() {
        const defaultGlobalCache = {
            accessed: {},
            expiration: {},
            structures: {},
            numbers: {},
            lists: {},
            costMatrices: {},
            roomPositions: {},
            things: {},
            objects: {},
        };
        global._cache = defaultGlobalCache;
    }
    static clean() {
        // Clean the memory of non-existent objects every tick
        this.cleanHeap();
        this.cleanCreeps();
        this.cleanFlags();
        this.cleanColonies();
        this.cleanPathingMemory();
        this.cleanConstructionSites();
        Stats.clean();
    }
    /**
     * Attempt to clear some things out of the global heap to prevent increasing CPU usage
     */
    static cleanHeap() {
        if (Game.time % HEAP_CLEAN_FREQUENCY == HEAP_CLEAN_FREQUENCY - 3) {
            if (Game.cpu.bucket < BUCKET_CPU_HALT &&
                Game.cpu.halt !== undefined) {
                Memory.build--; // don't count this reset as a build
                Game.cpu.halt();
            }
            else if (Game.cpu.bucket < BUCKET_CLEAR_CACHE) {
                // @ts-expect-error global shenanigans
                delete global._cache;
                this.initGlobalMemory();
            }
        }
    }
    static cleanCreeps() {
        // Clear memory for non-existent creeps
        for (const name in Memory.creeps) {
            if (!Game.creeps[name]) {
                delete Memory.creeps[name];
                // @ts-expect-error global shenanigans
                delete global[name];
            }
        }
    }
    static cleanFlags() {
        // Clear memory for non-existent flags
        for (const name in Memory.flags) {
            if (!Game.flags[name]) {
                delete Memory.flags[name];
                // @ts-expect-error global shenanigans
                delete global[name];
            }
        }
    }
    static cleanColonies() {
        // Clear memory of dead colonies
        for (const name in Memory.colonies) {
            const room = Game.rooms[name];
            if (!(room && room.my)) {
                // Delete only if "persistent" is not set - use case: praise rooms
                if (!Memory.colonies[name].persistent) {
                    delete Memory.colonies[name];
                    // @ts-expect-error global shenanigans
                    delete global[name];
                }
            }
        }
    }
    static cleanConstructionSites() {
        // Remove ancient construction sites
        if (Game.time % 20 == 0) {
            const CONSTRUCTION_SITE_TIMEOUT = 100000; // sites time out after this long
            const UNBUILT_CONSTRUCTION_SITE_TIMEOUT = 1000; // sites that haven't made any progress time out
            // Add constructionSites to memory and remove really old ones
            for (const id in Game.constructionSites) {
                const site = Game.constructionSites[id];
                if (!Memory.constructionSites[id]) {
                    Memory.constructionSites[id] = Game.time;
                }
                else if (Game.time - Memory.constructionSites[id] >=
                    CONSTRUCTION_SITE_TIMEOUT) {
                    site.remove();
                }
                else if (site.progress == 0 &&
                    Game.time - Memory.constructionSites[id] >=
                        UNBUILT_CONSTRUCTION_SITE_TIMEOUT) {
                    site.remove();
                }
                // Remove duplicate construction sites that get placed on top of existing structures due to caching
                if (site &&
                    site.pos.isVisible &&
                    site.pos.lookForStructure(site.structureType)) {
                    site.remove();
                }
            }
            // Remove dead constructionSites from memory
            for (const id in Memory.constructionSites) {
                if (!Game.constructionSites[id]) {
                    delete Memory.constructionSites[id];
                }
            }
        }
    }
    static cleanPathingMemory() {
        const CLEAN_FREQUENCY = 5;
        if (Game.time % CLEAN_FREQUENCY == 0) {
            const distanceCleanProbability = 0.001 * CLEAN_FREQUENCY;
            // Randomly clear some cached path lengths
            for (const pos1Name in Memory.pathing.distances) {
                if (_.isEmpty(Memory.pathing.distances[pos1Name])) {
                    delete Memory.pathing.distances[pos1Name];
                }
                else {
                    for (const pos2Name in Memory.pathing.distances[pos1Name]) {
                        if (Math.random() < distanceCleanProbability) {
                            delete Memory.pathing.distances[pos1Name][pos2Name];
                        }
                    }
                }
            }
            // // Randomly clear weighted distances
            // for (const pos1Name in Memory.pathing.weightedDistances) {
            // 	if (_.isEmpty(Memory.pathing.weightedDistances[pos1Name])) {
            // 		delete Memory.pathing.weightedDistances[pos1Name];
            // 	} else {
            // 		for (const pos2Name in Memory.pathing.weightedDistances[pos1Name]) {
            // 			if (Math.random() < weightedDistanceCleanProbability) {
            // 				delete Memory.pathing.weightedDistances[pos1Name][pos2Name];
            // 			}
            // 		}
            // 	}
            // }
        }
    }
};
Mem = Mem_1 = __decorate$1([
    profile
], Mem);

function applyDistanceTransform(foregroundPixels, oob = 255) {
    const dist = foregroundPixels;
    // Variables to represent the 3x3 neighborhood of a pixel.
    let UL, U, UR;
    let L, mid, R;
    let BL, B, BR;
    let x, y, value;
    for (y = 0; y < 50; ++y) {
        for (x = 0; x < 50; ++x) {
            if (foregroundPixels.get(x, y) !== 0) {
                UL = dist.get(x - 1, y - 1);
                U = dist.get(x, y - 1);
                UR = dist.get(x + 1, y - 1);
                L = dist.get(x - 1, y);
                if (y == 0) {
                    UL = oob;
                    U = oob;
                    UR = oob;
                }
                if (x == 0) {
                    UL = oob;
                    L = oob;
                }
                if (x == 49) {
                    UR = oob;
                }
                dist.set(x, y, Math.min(UL, U, UR, L, 254) + 1);
            }
        }
    }
    for (y = 49; y >= 0; --y) {
        for (x = 49; x >= 0; --x) {
            mid = dist.get(x, y);
            R = dist.get(x + 1, y);
            BL = dist.get(x - 1, y + 1);
            B = dist.get(x, y + 1);
            BR = dist.get(x + 1, y + 1);
            if (y == 49) {
                BL = oob;
                B = oob;
                BR = oob;
            }
            if (x == 49) {
                R = oob;
                BR = oob;
            }
            if (x == 0) {
                BL = oob;
            }
            value = Math.min(mid, R + 1, BL + 1, B + 1, BR + 1);
            dist.set(x, y, value);
        }
    }
    return dist;
}
// Compute a cost matrix for walkable pixels in a room
function walkablePixelsForRoom(roomName) {
    const costMatrix = new PathFinder.CostMatrix();
    const terrain = Game.map.getRoomTerrain(roomName);
    for (let y = 0; y < 50; ++y) {
        for (let x = 0; x < 50; ++x) {
            if (terrain.get(x, y) != TERRAIN_MASK_WALL) {
                costMatrix.set(x, y, 1);
            }
        }
    }
    return costMatrix;
}
function distanceTransform(roomName) {
    return applyDistanceTransform(walkablePixelsForRoom(roomName));
}

/**
 * screeps-packrat
 * ---------------
 * Lightning-fast and memory-efficient serialization of Screeps IDs, Coords, and RoomPositions
 * Code written by Muon as part of Overmind Screeps AI. Feel free to adapt as desired.
 * Package repository: https://github.com/bencbartlett/screeps-packrat
 *
 * Plain JS version is available in the #share-thy-code channel on the Screeps Slack.
 *
 * To use: import desired functions from module, or import entire module on main and use functions from global.
 * To benchmark: import tests file, PackratTests.run()
 *
 * Exported functions (available on global):
 *
 * +--------------------------+------------------------------------------------+-----------------+--------------------+
 * |         function         |                  description                   | execution time* | memory reduction** |
 * +--------------------------+------------------------------------------------+-----------------+--------------------+
 * | packId                   | packs a game object id into 6 chars            | 500ns           | -75%               |
 * | unpackId                 | unpacks 6 chars into original format           | 1.3us           |                    |
 * | packIdList               | packs a list of ids into a single string       | 500ns/id        | -81%               |
 * | unpackIdList             | unpacks a string into a list of ids            | 1.2us/id        |                    |
 * | packPos                  | packs a room position into 2 chars             | 150ns           | -90%               |
 * | unpackPos                | unpacks 2 chars into a room position           | 600ns           |                    |
 * | packPosList              | packs a list of room positions into a string   | 150ns/pos       | -95%               |
 * | unpackPosList            | unpacks a string into a list of room positions | 1.5us/pos       |                    |
 * | packCoord                | packs a coord (e.g. {x:25,y:25}) as a string   | 150ns           | -80%               |
 * | unpackCoord              | unpacks a string into a coord                  | 60-150ns        |                    |
 * | packCoordList            | packs a list of coords as a string             | 120ns/coord     | -94%               |
 * | unpackCoordList          | unpacks a string into a list of coords         | 100ns/coord     |                    |
 * | unpackCoordAsPos         | unpacks string + room name into a pos          | 500ns           |                    |
 * | unpackCoordListAsPosList | unpacks string + room name into a list of pos  | 500ns/coord     |                    |
 * +--------------------------+------------------------------------------------+-----------------+--------------------+
 *
 *  * Execution time measured on shard2 public servers and may vary on different machines or shards.
 * ** Memory reduction for list functions is the asymptotic limit of lists containing many entries. Lower reductions
 *    can be expected for smaller lists.
 *
 */
/**
 * Convert a standard 24-character hex id in screeps to a compressed UTF-16 encoded string of length 6.
 *
 * Benchmarking: average of 500ns to execute on shard2 public server, reduce stringified size by 75%
 */
function packId(id) {
    return (String.fromCharCode(parseInt(id.substr(0, 4), 16)) +
        String.fromCharCode(parseInt(id.substr(4, 4), 16)) +
        String.fromCharCode(parseInt(id.substr(8, 4), 16)) +
        String.fromCharCode(parseInt(id.substr(12, 4), 16)) +
        String.fromCharCode(parseInt(id.substr(16, 4), 16)) +
        String.fromCharCode(parseInt(id.substr(20, 4), 16)));
}
/**
 * Convert a compressed six-character UTF-encoded id back into the original 24-character format.
 *
 * Benchmarking: average of 1.3us to execute on shard2 public server
 */
function unpackId(packedId) {
    let id = "";
    let current;
    for (let i = 0; i < 6; ++i) {
        current = packedId.charCodeAt(i);
        id += (current >>> 8).toString(16).padStart(2, "0");
        id += (current & 0xff).toString(16).padStart(2, "0");
    }
    return id;
}
/**
 * Packs a list of ids as a utf-16 string. This is better than having a list of packed coords, as it avoids
 * extra commas and "" when memroy gets stringified.
 *
 * Benchmarking: average of 500ns per id to execute on shard2 public server, reduce stringified size by 81%
 */
function packIdList(ids) {
    let str = "";
    for (let i = 0; i < ids.length; ++i) {
        str += packId(ids[i]);
    }
    return str;
}
/**
 * Unpacks a list of ids stored as a utf-16 string.
 *
 * Benchmarking: average of 1.2us per id to execute on shard2 public server.
 */
function unpackIdList(packedIds) {
    const ids = [];
    for (let i = 0; i < packedIds.length; i += 6) {
        ids.push(unpackId(packedIds.substr(i, 6)));
    }
    return ids;
}
/**
 * Packs a coord as a single utf-16 character. The seemingly strange choice of encoding value ((x << 6) | y) + 65 was
 * chosen to be fast to compute (x << 6 | y is significantly faster than 50 * x + y) and to avoid control characters,
 * as "A" starts at character code 65.
 *
 * Benchmarking: average of 150ns to execute on shard2 public server, reduce stringified size by 80%
 */
function packCoord(coord) {
    return String.fromCharCode(((coord.x << 6) | coord.y) + 65);
}
/**
 * Unpacks a coord stored as a single utf-16 character
 *
 * Benchmarking: average of 60ns-100ns to execute on shard2 public server
 */
function unpackCoord(char) {
    const xShiftedSixOrY = char.charCodeAt(0) - 65;
    return {
        x: (xShiftedSixOrY & 0b111111000000) >>> 6,
        y: xShiftedSixOrY & 0b000000111111,
    };
}
/**
 * Unpacks a coordinate and creates a RoomPosition object from a specified roomName
 *
 * Benchmarking: average of 500ns to execute on shard2 public server
 */
function unpackCoordAsPos(packedCoord, roomName) {
    const coord = unpackCoord(packedCoord);
    return new RoomPosition(coord.x, coord.y, roomName);
}
/**
 * Packs a list of coords as a utf-16 string. This is better than having a list of packed coords, as it avoids
 * extra commas and "" when memroy gets stringified.
 *
 * Benchmarking: average of 120ns per coord to execute on shard2 public server, reduce stringified size by 94%
 */
function packCoordList(coords) {
    let str = "";
    for (let i = 0; i < coords.length; ++i) {
        str += String.fromCharCode(((coords[i].x << 6) | coords[i].y) + 65);
    }
    return str;
}
/**
 * Unpacks a list of coords stored as a utf-16 string
 *
 * Benchmarking: average of 100ns per coord to execute on shard2 public server
 */
function unpackCoordList(chars) {
    const coords = [];
    let xShiftedSixOrY;
    for (let i = 0; i < chars.length; ++i) {
        xShiftedSixOrY = chars.charCodeAt(i) - 65;
        coords.push({
            x: (xShiftedSixOrY & 0b111111000000) >>> 6,
            y: xShiftedSixOrY & 0b000000111111,
        });
    }
    return coords;
}
/**
 * Unpacks a list of coordinates and creates a list of RoomPositions from a specified roomName
 *
 * Benchmarking: average of 500ns per coord to execute on shard2 public server
 */
function unpackCoordListAsPosList(packedCoords, roomName) {
    const positions = [];
    let coord;
    for (let i = 0; i < packedCoords.length; ++i) {
        // Each coord is saved as a single character; unpack each and insert the room name to get the positions list
        coord = unpackCoord(packedCoords[i]);
        positions.push(new RoomPosition(coord.x, coord.y, roomName));
    }
    return positions;
}
PERMACACHE._packedRoomNames = PERMACACHE._packedRoomNames || {};
PERMACACHE._unpackedRoomNames = PERMACACHE._unpackedRoomNames || {};
/**
 * Packs a roomName as a single utf-16 character. Character values are stored on permacache.
 */
function packRoomName(roomName) {
    if (PERMACACHE._packedRoomNames[roomName] === undefined) {
        const coordinateRegex = /(E|W)(\d+)(N|S)(\d+)/g;
        const match = coordinateRegex.exec(roomName);
        const xDir = match[1];
        const x = Number(match[2]);
        const yDir = match[3];
        const y = Number(match[4]);
        let quadrant;
        if (xDir == "W") {
            if (yDir == "N") {
                quadrant = 0;
            }
            else {
                quadrant = 1;
            }
        }
        else {
            if (yDir == "N") {
                quadrant = 2;
            }
            else {
                quadrant = 3;
            }
        }
        // y is 6 bits, x is 6 bits, quadrant is 2 bits
        const num = ((quadrant << 12) | (x << 6) | y) + 65;
        const char = String.fromCharCode(num);
        PERMACACHE._packedRoomNames[roomName] = char;
        PERMACACHE._unpackedRoomNames[char] = roomName;
    }
    return PERMACACHE._packedRoomNames[roomName];
}
/**
 * Packs a roomName as a single utf-16 character. Character values are stored on permacache.
 */
function unpackRoomName(char) {
    if (PERMACACHE._unpackedRoomNames[char] === undefined) {
        const num = char.charCodeAt(0) - 65;
        const { q, x, y } = {
            q: (num & 0b11000000111111) >>> 12,
            x: (num & 0b00111111000000) >>> 6,
            y: num & 0b00000000111111,
        };
        let roomName;
        switch (q) {
            case 0:
                roomName = "W" + x + "N" + y;
                break;
            case 1:
                roomName = "W" + x + "S" + y;
                break;
            case 2:
                roomName = "E" + x + "N" + y;
                break;
            case 3:
                roomName = "E" + x + "S" + y;
                break;
            default:
                roomName = "ERROR";
        }
        PERMACACHE._packedRoomNames[roomName] = char;
        PERMACACHE._unpackedRoomNames[char] = roomName;
    }
    return PERMACACHE._unpackedRoomNames[char];
}
/**
 * Packs a RoomPosition as a pair utf-16 characters. The seemingly strange choice of encoding value ((x << 6) | y) + 65
 * was chosen to be fast to compute (x << 6 | y is significantly faster than 50 * x + y) and to avoid control
 * characters, as "A" starts at character code 65.
 *
 * Benchmarking: average of 150ns to execute on shard2 public server, reduce stringified size by 90%
 */
function packPos(pos) {
    return packCoord(pos) + packRoomName(pos.roomName);
}
/**
 * Unpacks a RoomPosition stored as a pair of utf-16 characters.
 *
 * Benchmarking: average of 600ns to execute on shard2 public server.
 */
function unpackPos(chars) {
    const { x, y } = unpackCoord(chars[0]);
    return new RoomPosition(x, y, unpackRoomName(chars[1]));
}
/**
 * Packs a list of RoomPositions as a utf-16 string. This is better than having a list of packed RoomPositions, as it
 * avoids extra commas and "" when memroy gets stringified.
 *
 * Benchmarking: average of 150ns per position to execute on shard2 public server, reduce stringified size by 95%
 */
function packPosList(posList) {
    let str = "";
    for (let i = 0; i < posList.length; ++i) {
        str += packPos(posList[i]);
    }
    return str;
}
/**
 * Unpacks a list of RoomPositions stored as a utf-16 string.
 *
 * Benchmarking: average of 1.5us per position to execute on shard2 public server.
 */
function unpackPosList(chars) {
    const posList = [];
    for (let i = 0; i < chars.length; i += 2) {
        posList.push(unpackPos(chars.substr(i, 2)));
    }
    return posList;
}
// Useful to register these functions on global
const globalFuncs = [
    packId,
    unpackId,
    packIdList,
    unpackIdList,
    packCoord,
    unpackCoord,
    unpackCoordAsPos,
    packCoordList,
    unpackCoordList,
    unpackCoordListAsPosList,
    packPos,
    unpackPos,
    packPosList,
    unpackPosList,
];
for (const func of globalFuncs) {
    // @ts-expect-error global definition
    global[func.name] = func;
}
class PackratTests {
    static testIdPacker() {
        const ogStart = Game.cpu.getUsed();
        let start, elapsed;
        console.log(`Collecting ids...`);
        start = Game.cpu.getUsed();
        const allIds = [];
        for (const name in Game.creeps) {
            const id = Game.creeps[name].id;
            if (!id) {
                console.log(`Game.creeps.${name} has no id: ${id}! wtf`);
            }
            else {
                allIds.push();
            }
        }
        for (const id in Game.structures) {
            if (!id) {
                console.log(`Game.structures has an undefined id: ${id}! wtf`);
            }
            else {
                allIds.push(id);
            }
        }
        console.log(`Time elapsed: ${Game.cpu.getUsed() - start}`);
        console.log(`Testing id encoding...`);
        start = Game.cpu.getUsed();
        const idsPacked = [];
        for (let i = 0, len = allIds.length; i < len; ++i) {
            idsPacked.push(packId(allIds[i]));
        }
        elapsed = Game.cpu.getUsed() - start;
        console.log(`Time elapsed: ${elapsed}; avg: ${elapsed / idsPacked.length}`);
        console.log(`Unpacked len: ${JSON.stringify(allIds).length} | Packed len: ${JSON.stringify(idsPacked).length}`);
        console.log(`Testing listId encoding...`);
        start = Game.cpu.getUsed();
        const idsListPacked = packIdList(allIds);
        elapsed = Game.cpu.getUsed() - start;
        console.log(`Time elapsed: ${elapsed}; avg: ${elapsed / (idsListPacked.length / 6)}`);
        console.log(`List-packed len: ${JSON.stringify(idsListPacked).length}`);
        console.log(`Testing id decoding...`);
        start = Game.cpu.getUsed();
        const idsUnpacked = [];
        for (let i = 0, len = idsPacked.length; i < len; ++i) {
            idsUnpacked.push(unpackId(idsPacked[i]));
        }
        elapsed = Game.cpu.getUsed() - start;
        console.log(`Time elapsed: ${elapsed}; avg: ${elapsed / idsUnpacked.length}`);
        console.log(`Testing id list-decoding...`);
        start = Game.cpu.getUsed();
        const idsListUnpacked = unpackIdList(idsListPacked);
        elapsed = Game.cpu.getUsed() - start;
        console.log(`Time elapsed: ${elapsed}; avg: ${elapsed / idsListUnpacked.length}`);
        console.log(`Verifying equality...`);
        let idsEqual = true;
        for (let i = 0; i < allIds.length; i++) {
            if (idsUnpacked[i] != allIds[i]) {
                console.log(`Unpacked id not equal! orig: ${allIds[i]}; unpacked: ${idsUnpacked[i]}`);
                idsEqual = false;
                break;
            }
            if (idsListUnpacked[i] != allIds[i]) {
                console.log(`Unpacked id not equal! orig: ${allIds[i]}; listUnpacked: ${idsListUnpacked[i]}`);
                idsEqual = false;
                break;
            }
        }
        console.log(`Retrieved ids are equal: ${idsEqual}`);
        console.log(`Total time elapsed: ${Game.cpu.getUsed() - ogStart}`);
    }
    static testCoordPacker() {
        const ogStart = Game.cpu.getUsed();
        let start, elapsed;
        console.log(`Collecting positions...`);
        start = Game.cpu.getUsed();
        const allCoord = [];
        for (const name in Game.creeps) {
            const pos = Game.creeps[name].pos;
            allCoord.push({ x: pos.x, y: pos.y });
        }
        for (const id in Game.structures) {
            const pos = Game.structures[id].pos;
            allCoord.push({ x: pos.x, y: pos.y });
        }
        console.log(`Time elapsed: ${Game.cpu.getUsed() - start}`);
        console.log(`Testing coord encoding...`);
        start = Game.cpu.getUsed();
        const coordPacked = [];
        for (let i = 0, len = allCoord.length; i < len; ++i) {
            coordPacked.push(packCoord(allCoord[i]));
        }
        elapsed = Game.cpu.getUsed() - start;
        console.log(`Time elapsed: ${elapsed}; avg: ${elapsed / coordPacked.length}`);
        console.log(`Unpacked len: ${JSON.stringify(allCoord).length}`);
        console.log(`Packed len: ${JSON.stringify(coordPacked).length}`);
        console.log(`Testing listCoord encoding...`);
        start = Game.cpu.getUsed();
        const coordListPacked = packCoordList(allCoord);
        elapsed = Game.cpu.getUsed() - start;
        console.log(`Time elapsed: ${elapsed}; avg: ${elapsed / coordListPacked.length}`);
        console.log(`List-packed len: ${JSON.stringify(coordListPacked).length}`);
        console.log(`Testing coord decoding...`);
        start = Game.cpu.getUsed();
        const coordUnpacked = [];
        for (let i = 0, len = coordPacked.length; i < len; ++i) {
            coordUnpacked.push(unpackCoord(coordPacked[i]));
        }
        elapsed = Game.cpu.getUsed() - start;
        console.log(`Time elapsed: ${elapsed}; avg: ${elapsed / coordUnpacked.length}`);
        console.log(`Testing listCoord decoding...`);
        start = Game.cpu.getUsed();
        const coordListUnpacked = unpackCoordList(coordListPacked);
        elapsed = Game.cpu.getUsed() - start;
        console.log(`Time elapsed: ${elapsed}; avg: ${elapsed / coordListUnpacked.length}`);
        console.log(`Testing coord to pos decoding...`);
        start = Game.cpu.getUsed();
        const coordAsPosUnpacked = [];
        for (let i = 0, len = coordPacked.length; i < len; ++i) {
            coordAsPosUnpacked.push(unpackCoordAsPos(coordPacked[i], "W10N10"));
        }
        elapsed = Game.cpu.getUsed() - start;
        console.log(`Time elapsed: ${elapsed}; avg: ${elapsed / coordAsPosUnpacked.length}`);
        console.log(`Testing listCoord to posList decoding...`);
        start = Game.cpu.getUsed();
        const coordListAsPosListUnpacked = unpackCoordListAsPosList(coordListPacked, "W10N10");
        elapsed = Game.cpu.getUsed() - start;
        console.log(`Time elapsed: ${elapsed}; avg: ${elapsed / coordListAsPosListUnpacked.length}`);
        let posEqual = true;
        for (let i = 0; i < allCoord.length; i++) {
            if (!(allCoord[i].x == coordAsPosUnpacked[i].x &&
                allCoord[i].y == coordAsPosUnpacked[i].y)) {
                console.log(`Unpacked pos not equal! orig: ${JSON.stringify(allCoord[i])}; ` + `unpacked: ${JSON.stringify(coordAsPosUnpacked[i])}`);
                posEqual = false;
                break;
            }
            if (!(allCoord[i].x == coordListAsPosListUnpacked[i].x &&
                allCoord[i].y == coordListAsPosListUnpacked[i].y)) {
                console.log(`Unpacked pos not equal! orig: ${JSON.stringify(allCoord[i])}; ` +
                    `unpacked: ${JSON.stringify(coordListAsPosListUnpacked[i])}`);
                posEqual = false;
                break;
            }
        }
        console.log(`Retrieved coords are equal: ${posEqual}`);
        console.log(`Total time elapsed: ${Game.cpu.getUsed() - ogStart}`);
    }
    static testPosPacker() {
        const ogStart = Game.cpu.getUsed();
        let start, elapsed;
        console.log(`Collecting positions...`);
        start = Game.cpu.getUsed();
        const allPos = [];
        for (const name in Game.creeps) {
            allPos.push(Game.creeps[name].pos);
        }
        for (const id in Game.structures) {
            allPos.push(Game.structures[id].pos);
        }
        console.log(`Time elapsed: ${Game.cpu.getUsed() - start}`);
        console.log(`Testing pos encoding...`);
        start = Game.cpu.getUsed();
        const posPacked = [];
        for (let i = 0, len = allPos.length; i < len; ++i) {
            posPacked.push(packPos(allPos[i]));
        }
        elapsed = Game.cpu.getUsed() - start;
        console.log(`Time elapsed: ${elapsed}; avg: ${elapsed / posPacked.length}`);
        console.log(`Unpacked len: ${JSON.stringify(allPos).length}`);
        console.log(`Packed len: ${JSON.stringify(posPacked).length}`);
        console.log(`Testing listPos encoding...`);
        start = Game.cpu.getUsed();
        const posListPacked = packPosList(allPos);
        elapsed = Game.cpu.getUsed() - start;
        console.log(`Time elapsed: ${elapsed}; avg: ${elapsed / (posListPacked.length / 2)}`);
        console.log(`List-packed len: ${JSON.stringify(posListPacked).length}`);
        console.log(`Testing pos decoding...`);
        start = Game.cpu.getUsed();
        const posUnpacked = [];
        for (let i = 0, len = posPacked.length; i < len; ++i) {
            posUnpacked.push(unpackPos(posPacked[i]));
        }
        elapsed = Game.cpu.getUsed() - start;
        console.log(`Time elapsed: ${elapsed}; avg: ${elapsed / posUnpacked.length}`);
        console.log(`Testing listPos decoding...`);
        start = Game.cpu.getUsed();
        const posListUnpacked = unpackPosList(posListPacked);
        elapsed = Game.cpu.getUsed() - start;
        console.log(`Time elapsed: ${elapsed}; avg: ${elapsed / posListUnpacked.length}`);
        let posEqual = true;
        for (let i = 0; i < allPos.length; i++) {
            if (!allPos[i].isEqualTo(posUnpacked[i])) {
                console.log(`Unpacked pos not equal! orig: ${allPos[i]}; unpacked: ${posUnpacked[i]}`);
                posEqual = false;
                break;
            }
            if (!allPos[i].isEqualTo(posListUnpacked[i])) {
                console.log(`Unpacked pos not equal! orig: ${allPos[i]}; unpacked: ${posListUnpacked[i]}`);
                posEqual = false;
                break;
            }
        }
        console.log(`Retrieved pos are equal: ${posEqual}`);
        console.log(`Total time elapsed: ${Game.cpu.getUsed() - ogStart}`);
    }
    static run() {
        PackratTests.testIdPacker();
        PackratTests.testCoordPacker();
        PackratTests.testPosPacker();
    }
}
global.PackratTests = PackratTests;

const CACHE_TIMEOUT = 50;
const SHORT_CACHE_TIMEOUT = 10;
const COSTMATRIX_TIMEOUT = 20;
// const PATH_TIMEOUT = 1000;
const STRUCTURE_KEY = "s";
const NUMBER_KEY = "#";
const POSITION_KEY = "p";
const LIST_KEY = "l";
const OBJECT_KEY = "o";
const COSTMATRIX_KEY = "m";
const ID_KEY = "$";
/**
 * The GlobalCache ($) module saves frequently accessed deserialized objects in temporary, volatile global memory
 */
let $ = class $ {
    // $ = cash = cache... get it? :D
    static structures(saver, key, callback, timeout = CACHE_TIMEOUT) {
        const cacheKey = saver.ref + STRUCTURE_KEY + key;
        if (!_cache.structures[cacheKey] ||
            Game.time > _cache.expiration[cacheKey]) {
            // Recache if new entry or entry is expired
            _cache.structures[cacheKey] = callback();
            _cache.expiration[cacheKey] = getCacheExpiration(timeout, Math.ceil(timeout / 10));
        }
        else {
            // Refresh structure list by ID if not already done on current tick
            if ((_cache.accessed[cacheKey] || 0) < Game.time) {
                _cache.structures[cacheKey] = _.compact(_.map(_cache.structures[cacheKey] || [], (s) => Game.getObjectById(s.id)));
                _cache.accessed[cacheKey] = Game.time;
            }
        }
        return _cache.structures[cacheKey];
    }
    // eslint-disable-next-line id-denylist
    static number(saver, key, callback, timeout = SHORT_CACHE_TIMEOUT) {
        const cacheKey = saver.ref + NUMBER_KEY + key;
        if (_cache.numbers[cacheKey] == undefined ||
            Game.time > _cache.expiration[cacheKey]) {
            // Recache if new entry or entry is expired
            _cache.numbers[cacheKey] = callback();
            _cache.expiration[cacheKey] = getCacheExpiration(timeout, Math.ceil(timeout / 10));
        }
        return _cache.numbers[cacheKey];
    }
    static numberRecall(saver, key) {
        const cacheKey = saver.ref + NUMBER_KEY + key;
        return _cache.numbers[cacheKey];
    }
    // static pos(saver: { ref: string }, key: string, callback: () => RoomPosition, timeout ?: number): RoomPosition;
    static pos(saver, key, callback, timeout) {
        const cacheKey = saver.ref + POSITION_KEY + key;
        if (_cache.roomPositions[cacheKey] == undefined ||
            Game.time > _cache.expiration[cacheKey]) {
            // Recache if new entry or entry is expired
            _cache.roomPositions[cacheKey] = callback();
            timeout !== null && timeout !== void 0 ? timeout : (timeout = CACHE_TIMEOUT);
            _cache.expiration[cacheKey] = getCacheExpiration(timeout, Math.ceil(timeout / 10));
        }
        return _cache.roomPositions[cacheKey];
    }
    static list(saver, key, callback, timeout = CACHE_TIMEOUT) {
        const cacheKey = saver.ref + LIST_KEY + key;
        if (_cache.lists[cacheKey] == undefined ||
            Game.time > _cache.expiration[cacheKey]) {
            // Recache if new entry or entry is expired
            _cache.lists[cacheKey] = callback();
            _cache.expiration[cacheKey] = getCacheExpiration(timeout, Math.ceil(timeout / 10));
        }
        return _cache.lists[cacheKey];
    }
    static object(saver, key, callback, timeout = CACHE_TIMEOUT) {
        const cacheKey = saver.ref + OBJECT_KEY + key;
        if (_cache.objects[cacheKey] == undefined ||
            Game.time > _cache.expiration[cacheKey]) {
            // Recache if new entry or entry is expired
            _cache.objects[cacheKey] = callback();
            _cache.expiration[cacheKey] = getCacheExpiration(timeout, Math.ceil(timeout / 10));
        }
        return _cache.objects[cacheKey];
    }
    /**
     * Caches a CostMatrix computation. Times out quickly, but you can use $.costMatrixRecall() to pull the value for
     * an invisible room without triggering a recalc
     */
    static costMatrix(roomName, key, callback, timeout = COSTMATRIX_TIMEOUT) {
        const cacheKey = roomName + COSTMATRIX_KEY + key;
        if (_cache.costMatrices[cacheKey] == undefined ||
            Game.time > _cache.expiration[cacheKey]) {
            // Recache if new entry or entry is expired
            _cache.costMatrices[cacheKey] = callback();
            _cache.expiration[cacheKey] = getCacheExpiration(timeout, Math.ceil(timeout / 10));
        }
        return _cache.costMatrices[cacheKey];
    }
    /**
     * Returns the value of a previously cached CostMatrix without triggering a cache expiration and recalc
     */
    static costMatrixRecall(roomName, key) {
        const cacheKey = roomName + COSTMATRIX_KEY + key;
        return _cache.costMatrices[cacheKey];
    }
    // static path(fromPos: RoomPosition, toPos: RoomPosition, opts: any /*todo*/): RoomPosition[] {
    // 	// TODO
    // 	return [];
    // }
    static set(thing, key, callback, timeout = CACHE_TIMEOUT) {
        const cacheKey = thing.ref + ID_KEY + key;
        if (!_cache.things[cacheKey] ||
            Game.time > _cache.expiration[cacheKey]) {
            // Recache if new entry or entry is expired
            _cache.things[cacheKey] = callback();
            _cache.expiration[cacheKey] = getCacheExpiration(timeout, Math.ceil(timeout / 10));
        }
        else {
            // Refresh structure list by ID if not already done on current tick
            if ((_cache.accessed[cacheKey] || 0) < Game.time) {
                if (_.isArray(_cache.things[cacheKey])) {
                    _cache.things[cacheKey] = _.compact(_.map(_cache.things[cacheKey], (s) => Game.getObjectById(s.id)));
                }
                else {
                    _cache.things[cacheKey] = Game.getObjectById(_cache.things[cacheKey].id);
                }
                _cache.accessed[cacheKey] = Game.time;
            }
        }
        thing[key] = _cache.things[cacheKey];
    }
    static refresh(thing, ...keys) {
        _.forEach(keys, function (key) {
            if (thing[key]) {
                if (_.isArray(thing[key])) {
                    thing[key] = _.compact(_.map(thing[key], (s) => Game.getObjectById(s.id)));
                }
                else {
                    thing[key] = Game.getObjectById(thing[key].id);
                }
            }
        });
    }
    static refreshObject(thing, ...keys) {
        _.forEach(keys, function (key) {
            if (_.isObject(thing[key])) {
                for (const prop in thing[key]) {
                    if (_.isArray(thing[key][prop])) {
                        // @ts-expect-error type mismatch
                        thing[key][prop] = (_.compact(_.map(thing[key][prop], (s) => Game.getObjectById(s.id))));
                    }
                    else {
                        // @ts-expect-error type mismatch somewhere
                        thing[key][prop] = (Game.getObjectById(thing[key][prop].id));
                    }
                }
            }
        });
    }
    static refreshRoom(thing) {
        thing.room = Game.rooms[thing.room.name];
    }
};
$ = __decorate$1([
    profile
], $);

/**
 * Abstract class for a hive cluster. Hive clusters group structures with related functionalities together in a
 * single cohesive object
 */
let HiveCluster = class HiveCluster {
    constructor(colony, instantiationObject, name) {
        this.colony = colony;
        this.room = instantiationObject.room;
        this.pos = instantiationObject.pos;
        this.ref = name + "@" + this.colony.name;
        this.colony.hiveClusters.push(this);
    }
    get print() {
        return ('<a href="#!/room/' +
            Game.shard.name +
            "/" +
            this.pos.roomName +
            '">[' +
            this.ref +
            "]</a>");
    }
    debug(...args) {
        var _a;
        if ((_a = this.memory) === null || _a === void 0 ? void 0 : _a.debug) {
            log.alert(this.print, ...args);
        }
    }
};
HiveCluster = __decorate$1([
    profile
], HiveCluster);

var Priority;
(function (Priority) {
    Priority[Priority["Critical"] = 0] = "Critical";
    Priority[Priority["High"] = 1] = "High";
    Priority[Priority["NormalHigh"] = 2] = "NormalHigh";
    Priority[Priority["Normal"] = 3] = "Normal";
    Priority[Priority["NormalLow"] = 4] = "NormalLow";
    Priority[Priority["Low"] = 5] = "Low";
})(Priority || (Priority = {}));
const priorityLevels = {
    [Priority.Critical]: "critical",
    [Priority.High]: "high",
    [Priority.NormalHigh]: "normal-high",
    [Priority.Normal]: "normal",
    [Priority.NormalLow]: "normal-low",
    [Priority.Low]: "low",
};
function priorityToString(priority) {
    var _a;
    return (_a = priorityLevels[priority]) !== null && _a !== void 0 ? _a : `unknown ${priority}`;
}
function blankPriorityQueue() {
    const queue = {};
    for (const priority in Priority) {
        queue[priority] = [];
    }
    return queue;
}

var InfestedFactory_1;
const FACTORY_USAGE_WINDOW = 100;
var FactoryStatus;
(function (FactoryStatus) {
    FactoryStatus[FactoryStatus["Idle"] = 0] = "Idle";
    FactoryStatus[FactoryStatus["AcquiringComponents"] = 1] = "AcquiringComponents";
    FactoryStatus[FactoryStatus["LoadingFactory"] = 2] = "LoadingFactory";
    FactoryStatus[FactoryStatus["Producing"] = 3] = "Producing";
    FactoryStatus[FactoryStatus["UnloadingFactory"] = 4] = "UnloadingFactory";
})(FactoryStatus || (FactoryStatus = {}));
const FactoryStageTimeouts = {
    [FactoryStatus.Idle]: Infinity,
    [FactoryStatus.AcquiringComponents]: 50,
    [FactoryStatus.LoadingFactory]: 50,
    [FactoryStatus.Producing]: 10000,
    [FactoryStatus.UnloadingFactory]: 50,
};
const getDefaultFactoryMemory = () => ({
    enabled: true,
    status: FactoryStatus.Idle,
    statusTick: 0,
    activeProduction: undefined,
    produced: 0,
    suspendProductionUntil: 0,
    stats: {
        totalProduction: {},
        avgUsage: 1,
    },
});
let InfestedFactory = InfestedFactory_1 = class InfestedFactory extends HiveCluster {
    constructor(colony, factory) {
        super(colony, factory, "infestedFactory");
        this.memory = Mem.wrap(this.colony.memory, "infestedFactory", getDefaultFactoryMemory);
        this.factory = factory;
        this.terminal = colony.terminal;
        this.terminalNetwork = Overmind.terminalNetwork;
        this.transportRequests = this.colony.commandCenter.transportRequests;
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, "infestedFactory", getDefaultFactoryMemory);
        $.refreshRoom(this);
        $.refresh(this, "terminal", "factory");
    }
    spawnMoarOverlords() {
        // Infested Factory is attended by managers
    }
    getProductionRecipe(commodityType) {
        return entries(COMMODITIES[commodityType].components);
    }
    initFactoryStatus() {
        const product = this.memory.activeProduction;
        if (!product && this.memory.status !== FactoryStatus.Idle) {
            log.warning(`Unexpected lack of active production at ${this.print}! Reverting to idle state.`);
            this.memory.status = FactoryStatus.Idle;
        }
        if (!product) {
            return;
        }
        const components = this.getProductionRecipe(product.commodityType);
        const produced = this.memory.produced;
        switch (this.memory.status) {
            case FactoryStatus.Idle:
                log.info(`${this.print}: starting production of ${components
                    .map(([res, amount]) => `${amount * product.requested} of ${res}`)
                    .join(", ")} ` +
                    `${rightArrow} ${product.requested} ${product.commodityType}`);
                this.memory.status = FactoryStatus.AcquiringComponents;
                this.memory.statusTick = Game.time;
                break;
            case FactoryStatus.AcquiringComponents:
                this.debug(() => `aquiring components for ${product.requested} of ${product.commodityType}`);
                if (_.all(components, ([component, amount]) => this.colony.assets[component] >=
                    amount * (product.requested - produced))) {
                    this.debug(() => `components acquired, loading`);
                    this.memory.status = FactoryStatus.LoadingFactory;
                    this.memory.statusTick = Game.time;
                }
                break;
            case FactoryStatus.LoadingFactory:
                this.debug(() => `loading components for ${product.requested - produced} of ${product.commodityType}`);
                if (_.all(components, ([component, amount]) => this.factory.store[component] >= amount)) {
                    this.debug(() => `loading complete, producing`);
                    this.memory.status = FactoryStatus.Producing;
                    this.memory.statusTick = Game.time;
                }
                break;
            case FactoryStatus.Producing:
                this.debug(() => `producing ${product.requested} of ${product.commodityType}, ${product.requested - produced} remaining`);
                if (product.requested - this.memory.produced <= 0) {
                    this.debug(() => `production complete, unloading`);
                    this.memory.status = FactoryStatus.UnloadingFactory;
                    this.memory.statusTick = Game.time;
                }
                break;
            case FactoryStatus.UnloadingFactory:
                this.debug(() => `unloading components for ${product.requested} of ${product.commodityType}`);
                if (this.factory.store[product.commodityType] - produced <= 0) {
                    this.debug(() => `unloading complete, idling`);
                    this.memory.status = FactoryStatus.Idle;
                    delete this.memory.activeProduction;
                    this.memory.statusTick = Game.time;
                }
                break;
            default:
                log.error(`Bad factory state at ${this.print}! State: ${this.memory.status}`);
                this.memory.status = FactoryStatus.Idle;
                this.memory.statusTick = Game.time;
                break;
        }
        this.statusTimeoutCheck();
    }
    statusTimeoutCheck() {
        const ticksInStatus = Game.time - this.memory.statusTick;
        const timedOut = ticksInStatus > FactoryStageTimeouts[this.memory.status];
        if (timedOut) {
            log.warning(`${this.print}: stuck in state ${this.memory.status} for ${ticksInStatus} ticks, reverting to idle state!`);
            this.memory.status = FactoryStatus.Idle;
            this.memory.statusTick = Game.time;
            this.memory.activeProduction = undefined;
        }
    }
    registerRequests() {
        // Don't care about the factory if you can't spawn any creeps!
        if (this.colony.state.bootstrapping) {
            return;
        }
        if (this.memory.status === FactoryStatus.Idle &&
            Game.time - this.memory.statusTick >
                InfestedFactory_1.settings.dumpDelay) {
            // Idle for a while, dump everything out
            for (const [resourceType, amount] of this.factory.store.contents) {
                this.debug(() => `requesting output of ${amount} of ${resourceType}`);
                this.transportRequests.requestOutput(this.factory, Priority.Low, { resourceType, amount });
            }
        }
        // Forcibly request output if there's not enough free space
        if (this.factory.store.getFreeCapacity() <
            InfestedFactory_1.settings.buffer) {
            this.transportRequests.requestOutput(this.factory, Priority.Critical);
        }
        const product = this.memory.activeProduction;
        if (!product) {
            return;
        }
        const contents = Object.assign({}, this.factory.store);
        const produced = this.memory.produced;
        const recipe = this.getProductionRecipe(product.commodityType);
        for (const [component, amount] of recipe) {
            const neededTotal = amount * (product.requested - produced);
            const neededAmount = neededTotal - this.factory.store[component];
            // Subtract from our current contents the quantity we're about to need of that component
            contents[component] -= Math.max(neededTotal, 0);
            this.debug(() => `production of ${product.commodityType} needs ${amount} of ${component}, network: ${neededTotal}, transport: ${neededAmount}, in colony: ${this.colony.assets[component]}`);
            if (this.colony.assets[component] < neededTotal) {
                this.debug(() => `requesting ${neededTotal} of ${component} through terminal network`);
                this.terminalNetwork.requestResource(this.colony, component, neededTotal, 0);
            }
            this.debug(() => `locking ${neededTotal} of ${component}`);
            this.terminalNetwork.lockResource(this.colony, component, neededTotal);
            if (neededAmount <= 0) {
                continue;
            }
            const cappedAmount = minMax(neededAmount, 0, this.factory.store.getFreeCapacity() -
                InfestedFactory_1.settings.buffer);
            this.debug(() => `requesting transport of ${neededAmount} of ${component}, capped at ${cappedAmount}`);
            this.transportRequests.requestInput(this.factory, Priority.High, {
                resourceType: component,
                amount: cappedAmount,
            });
        }
        this.debug(() => `contents: ${dump(contents)}`);
        for (const [component, amount] of entries(contents)) {
            this.debug(() => `requesting removal of ${amount} of ${component}`);
            this.transportRequests.requestOutput(this.factory, Priority.Normal, { resourceType: component, amount: amount });
        }
    }
    init() {
        this.initFactoryStatus();
        this.registerRequests();
    }
    produce(commodity, amount = 1) {
        if (this.memory.status !== FactoryStatus.Idle) {
            log.warning(`${this.print} is currently producing, ignoring request`);
            return false;
        }
        this.memory.activeProduction = {
            commodityType: commodity,
            requested: amount,
            size: COMMODITIES[commodity].amount,
        };
        this.memory.produced = 0;
        return true;
    }
    get canProduce() {
        return (this.memory.status === FactoryStatus.Producing &&
            this.factory.cooldown === 0);
    }
    runProduction() {
        this.debug(`run: status: ${this.memory.status}, suspended until: ${this.memory.suspendProductionUntil}, cooldown: ${this.factory.cooldown}`);
        if (this.memory.suspendProductionUntil &&
            Game.time > this.memory.suspendProductionUntil) {
            delete this.memory.suspendProductionUntil;
        }
        let product = this.memory.activeProduction;
        if (!product && !this.memory.suspendProductionUntil) {
            const nextProduction = Abathur.getNextProduction(this.colony);
            // const nextProduction = ((): Production | undefined => undefined)();
            this.debug(() => `next production: ${JSON.stringify(nextProduction)}`);
            if (nextProduction) {
                product = this.memory.activeProduction = nextProduction;
                this.memory.produced = 0;
            }
            else {
                // We don't have anything to produce, go to sleep
                const sleepTime = getCacheExpiration(InfestedFactory_1.settings.sleepDelay, 10);
                log.info(`${this.print}: no production available; sleeping until ${sleepTime}.`);
                this.memory.suspendProductionUntil = sleepTime;
            }
        }
        if (!product) {
            return;
        }
        this.debug(`run: ${JSON.stringify(product)}, produced: ${this.memory.produced}`);
        if (this.canProduce) {
            this.debug(() => `producing: ${JSON.stringify(product)}`);
            const result = this.factory.produce(product.commodityType);
            if (result === OK) {
                const energyAmount = COMMODITIES[product.commodityType].components.energy;
                if (energyAmount > 0) {
                    this.colony.trackEnergyUse(EnergyUse.FACTORY, -energyAmount);
                }
                this.memory.produced += 1;
                if (!this.memory.stats.totalProduction[product.commodityType]) {
                    this.memory.stats.totalProduction[product.commodityType] =
                        0;
                }
                this.memory.stats.totalProduction[product.commodityType] +=
                    product.size;
            }
            else {
                log.warning(`${this.print}: couldn't run production: ${errorForCode(result)}!`);
            }
        }
    }
    run() {
        if (this.memory.enabled) {
            this.runProduction();
        }
        this.stats();
    }
    stats() {
        const labUsage = this.factory.cooldown > 0 ? 1 : 0;
        this.memory.stats.avgUsage = ema(labUsage, this.memory.stats.avgUsage, FACTORY_USAGE_WINDOW);
        Stats.log(`colonies.${this.colony.name}.infestedFactory.avgUsage`, this.memory.stats.avgUsage);
    }
};
InfestedFactory.settings = {
    /** How many ticks to sleep when no production is requested */
    sleepDelay: 100,
    /** How many ticks to wait when idle before requesting to be completely unloaded */
    dumpDelay: 10,
    /** How much free space to keep when requesting inputs */
    buffer: 1000,
};
InfestedFactory = InfestedFactory_1 = __decorate$1([
    profile
], InfestedFactory);

// Compute a hash of a block of code and register with Overmind
function assimilationLocked(code) {
    Assimilator.validate(code);
}

const REACTION_PRIORITIES = [
    // T1 Boosts
    BOOST_TIERS.attack.T1,
    BOOST_TIERS.heal.T1,
    BOOST_TIERS.ranged_attack.T1,
    BOOST_TIERS.move.T1,
    BOOST_TIERS.construct.T1,
    BOOST_TIERS.dismantle.T1,
    // BOOST_TIERS.carry.T1,
    // BOOST_TIERS.harvest.T1, // not used yet
    BOOST_TIERS.tough.T1,
    // BOOST_TIERS.upgrade.T1,
    // Reaction intermediates + ghodium
    RESOURCE_GHODIUM,
    RESOURCE_ZYNTHIUM_KEANITE,
    RESOURCE_UTRIUM_LEMERGITE,
    RESOURCE_HYDROXIDE,
    // T2 Boosts
    BOOST_TIERS.attack.T2,
    BOOST_TIERS.heal.T2,
    BOOST_TIERS.ranged_attack.T2,
    BOOST_TIERS.move.T2,
    // BOOST_TIERS.construct.T2,
    BOOST_TIERS.dismantle.T2,
    // BOOST_TIERS.carry.T2,
    // BOOST_TIERS.harvest.T2, // not used yet
    BOOST_TIERS.tough.T2,
    // BOOST_TIERS.upgrade.T2,
    // T3 Boosts
    BOOST_TIERS.attack.T3,
    BOOST_TIERS.heal.T3,
    BOOST_TIERS.ranged_attack.T3,
    BOOST_TIERS.move.T3,
    // BOOST_TIERS.construct.T3,
    BOOST_TIERS.dismantle.T3,
    // BOOST_TIERS.carry.T3,
    // BOOST_TIERS.harvest.T3, // not used yet
    BOOST_TIERS.tough.T3,
    // BOOST_TIERS.upgrade.T3,
    // Other boosts I don't use as much
    BOOST_TIERS.construct.T2,
    BOOST_TIERS.construct.T3,
    BOOST_TIERS.carry.T1,
    BOOST_TIERS.carry.T2,
    BOOST_TIERS.carry.T3,
    BOOST_TIERS.upgrade.T1,
    BOOST_TIERS.upgrade.T2,
    BOOST_TIERS.upgrade.T3,
];
const priorityStockAmounts = {
    XGHO2: 1000, // (-70 % dmg taken)
    XLHO2: 1000, // (+300 % heal)
    XZHO2: 1000, // (+300 % fat decr - speed)
    XZH2O: 1000, // (+300 % dismantle)
    XKHO2: 1000, // (+300 % ranged attack)
    XUH2O: 1000, // (+300 % attack)
    GHO2: 8000, // (-50 % dmg taken)
    LHO2: 8000, // (+200 % heal)
    ZHO2: 8000, // (+200 % fat decr - speed)
    ZH2O: 8000, // (+200 % dismantle)
    UH2O: 8000, // (+200 % attack)
    KHO2: 8000, // (+200 % ranged attack)
    GO: 1000, // (-30 % dmg taken)
    LO: 1000, // (+100 % heal)
    ZO: 1000, // (+100 % fat decr - speed)
    ZH: 1000, // (+100 % dismantle)
    UH: 1000, // (+100 % attack)
    KO: 1000, // (+100 % ranged attack)
    G: 2000, // For nukes and common compounds
};
const wantedStockAmounts = {
    UH: 3000, // (+100 % attack)
    KO: 3000, // (+100 % ranged attack)
    XGHO2: 10000, // (-70 % dmg taken)
    XLHO2: 20000, // (+300 % heal)
    XZHO2: 6000, // (+300 % fat decr - speed)
    XZH2O: 6000, // (+300 % dismantle)
    XKHO2: 20000, // (+300 % ranged attack)
    XUH2O: 20000, // (+300 % attack)
    G: 5000, // For nukes
    XLH2O: 8000, // (+100 % build and repair)
    LH: 3000, // (+50 % build and repair)
    XUHO2: 3000, // (+600 % harvest)
    XKH2O: 3000, // (+300 % carry)
    ZK: 800, // intermediate
    UL: 800, // intermediate
    GH: 800, // (+50 % upgrade)
    KH: 800, // (+100 % carry)
    OH: 800, // intermediate
    GH2O: 800, // (+80 % upgrade)
    LH2O: 800, // (+80 % build and repair)
    KH2O: 800, // (+200 % carry)
    XGH2O: 12000, // (+100 % upgrade)
};
const baseStockAmounts = {
    [RESOURCE_CATALYST]: 5000,
    [RESOURCE_ZYNTHIUM]: 5000,
    [RESOURCE_LEMERGIUM]: 5000,
    [RESOURCE_KEANIUM]: 5000,
    [RESOURCE_UTRIUM]: 5000,
    [RESOURCE_OXYGEN]: 5000,
    [RESOURCE_HYDROGEN]: 5000,
};
/** Priorities for commodity production */
const COMMODITY_PRIORITIES = [
    // Energy
    RESOURCE_BATTERY,
    // Base resources
    RESOURCE_OXIDANT,
    RESOURCE_REDUCTANT,
    RESOURCE_PURIFIER,
    RESOURCE_UTRIUM_BAR,
    RESOURCE_LEMERGIUM_BAR,
    RESOURCE_ZYNTHIUM_BAR,
    RESOURCE_KEANIUM_BAR,
    RESOURCE_GHODIUM_MELT,
    // Reverse commodities
    // FIXME: Disable reverse productions for those so that we don't cycle back and forth
    // RESOURCE_ENERGY,
    // RESOURCE_OXYGEN,
    // RESOURCE_HYDROGEN,
    // RESOURCE_CATALYST,
    // RESOURCE_UTRIUM,
    // RESOURCE_LEMERGIUM,
    // RESOURCE_ZYNTHIUM,
    // RESOURCE_KEANIUM,
    // RESOURCE_GHODIUM,
    // Higher commodities
    RESOURCE_COMPOSITE,
    RESOURCE_CRYSTAL,
    RESOURCE_LIQUID,
    // Electronics/Silicon chain
    RESOURCE_DEVICE,
    RESOURCE_CIRCUIT,
    RESOURCE_MICROCHIP,
    RESOURCE_TRANSISTOR,
    RESOURCE_SWITCH,
    RESOURCE_WIRE,
    // Biological/Biomass chain
    RESOURCE_ORGANISM,
    RESOURCE_ORGANOID,
    RESOURCE_MUSCLE,
    RESOURCE_TISSUE,
    RESOURCE_PHLEGM,
    RESOURCE_CELL,
    // Mechanical/Metal chain
    RESOURCE_MACHINE,
    RESOURCE_HYDRAULICS,
    RESOURCE_FRAME,
    RESOURCE_FIXTURES,
    RESOURCE_TUBE,
    RESOURCE_ALLOY,
    // Mystical/Mist chain
    RESOURCE_ESSENCE,
    RESOURCE_EMANATION,
    RESOURCE_SPIRIT,
    RESOURCE_EXTRACT,
    RESOURCE_CONCENTRATE,
    RESOURCE_CONDENSATE,
];
const PRIORITIZED_COMMODITIES = entries(COMMODITIES)
    .filter((c) => COMMODITY_PRIORITIES.includes(c[0]))
    .sort(([a], [b]) => COMMODITY_PRIORITIES.indexOf(a) - COMMODITY_PRIORITIES.indexOf(b));
/**
 * Abathur is responsible for the evolution of the swarm and directs global production of minerals. Abathur likes
 * efficiency, XGHO2, and high lab uptime, and dislikes pronouns.
 */
let _Abathur = class _Abathur {
    constructor() {
        this.memory = { debug: false };
        this.settings = {
            batchSize: 1600,
        };
    }
    get print() {
        return "Abathur";
    }
    debug(...args) {
        if (this.memory.debug) {
            log.alert(this.print, ...args);
        }
    }
    // Helper methods for identifying different types of resources
    isMineralOrCompound(resource) {
        return !!_mineralCompoundsAllLookup[resource];
    }
    isBaseMineral(resource) {
        return !!_baseResourcesLookup[resource];
    }
    isIntermediateReactant(resource) {
        return INTERMEDIATE_REACTANTS.includes(resource);
    }
    isBoost(resource) {
        return !!BOOST_PARTS[resource];
    }
    isAttackBoost(resource) {
        return !!_boostTypesTierLookup.attack[resource];
    }
    isRangedBoost(resource) {
        return !!_boostTypesTierLookup.ranged_attack[resource];
    }
    isHealBoost(resource) {
        return !!_boostTypesTierLookup.heal[resource];
    }
    isToughBoost(resource) {
        return !!_boostTypesTierLookup.tough[resource];
    }
    isMoveBoost(resource) {
        return !!_boostTypesTierLookup.move[resource];
    }
    isDismantleBoost(resource) {
        return !!_boostTypesTierLookup.dismantle[resource];
    }
    isConstructBoost(resource) {
        return !!_boostTypesTierLookup.construct[resource];
    }
    isUpgradeBoost(resource) {
        return !!_boostTypesTierLookup.upgrade[resource];
    }
    isHarvestBoost(resource) {
        return !!_boostTypesTierLookup.harvest[resource];
    }
    isCarryBoost(resource) {
        return !!_boostTypesTierLookup.carry[resource];
    }
    isRawCommodity(resource) {
        return DEPOSITS_ALL.includes(resource);
    }
    isCommodity(resource) {
        return resource in COMMODITIES_DATA;
    }
    getCommodityChain(resource, chain) {
        var _a;
        const resourceChain = (_a = COMMODITIES_DATA[resource]) === null || _a === void 0 ? void 0 : _a.chain;
        if (!resourceChain) {
            return undefined;
        }
        return chain && chain === resourceChain ? chain : resourceChain;
    }
    getCommodityTier(resource) {
        var _a;
        return (_a = COMMODITIES_DATA[resource].lvl) !== null && _a !== void 0 ? _a : undefined;
    }
    getBoostTier(boost) {
        var _a;
        return (_a = _boostTierLookupAllTypes[boost]) !== null && _a !== void 0 ? _a : undefined;
    }
    /**
     * Recursively enumerate the base ingredients required to synthesize a unit of the specified compound,
     * e.g. Abathur.enumerateReactionBaseIngredients("XGH2O") = Z,K,U,L,H,O,H,X
     */
    enumerateReactionBaseIngredients(mineral) {
        if (BASE_RESOURCES.includes(mineral)) {
            return [mineral];
        }
        else if (REAGENTS[mineral]) {
            return Abathur$1.enumerateReactionBaseIngredients(REAGENTS[mineral][0]).concat(Abathur$1.enumerateReactionBaseIngredients(REAGENTS[mineral][1]));
        }
        else {
            return [];
        }
    }
    // Reaction scheduling =============================================================================================
    /**
     * Compute the next reaction that a colony should undertake based on local and global stockpiles of all target
     * compounds.
     */
    getNextReaction(colony) {
        const BATCH_SIZE = Abathur$1.settings.batchSize;
        const globalAssets = Overmind.terminalNetwork.getAssets();
        const numColonies = _.filter(getAllColonies(), (colony) => !!colony.terminal).length;
        let possibleReactions = REACTION_PRIORITIES;
        if (colony.labs.length < 10) {
            // don't make the really long cooldown stuff if you don't have all labs
            possibleReactions = _.filter(possibleReactions, (resource) => (REACTION_TIME[resource] || Infinity) <= 30);
        }
        // Want to build up a stockpile of high tier boosts, but also to maintain and utilize a stockpile of the
        // cheaper stuff before we start building up higher tier boosts, which have declining returns
        let nextTargetResource;
        const ingredientsUnavailable = {}; // track what we can't make to save CPU
        const maxAmountOfEachBoostPerColony = 50000;
        const maxBatches = Math.ceil(maxAmountOfEachBoostPerColony / BATCH_SIZE);
        for (const batchNum of _.range(1, maxBatches)) {
            nextTargetResource = _.find(possibleReactions, (resource) => {
                // If we've already figured out we can't make this in a previous pass then skip it
                if (ingredientsUnavailable[resource]) {
                    return false;
                }
                const tier = Abathur$1.getBoostTier(resource);
                // Get 2 labs' worth of a stockpile before you start making T2 boosts
                if (tier == "T2" &&
                    batchNum * BATCH_SIZE < 2 * LAB_MINERAL_CAPACITY) {
                    return false;
                }
                // Get 3 labs' worth of a stockpile before you start making T3 boosts
                if (tier == "T3" &&
                    batchNum * BATCH_SIZE < 3 * LAB_MINERAL_CAPACITY) {
                    return false;
                }
                // Don't need to stockpile a ton of reaction intermediates or ghodium
                if (resource == RESOURCE_GHODIUM ||
                    Abathur$1.isIntermediateReactant(resource)) {
                    // If the colony already has more of this this intermediate than it wants, skip it
                    if (colony.assets[resource] >
                        Overmind.terminalNetwork.thresholds(colony, resource)
                            .target) {
                        return false;
                    }
                }
                // Otherwise, we're allowed to make more of this, so figure out what we should and can make
                const globalShortage = globalAssets[resource] / numColonies <
                    (batchNum - 3) * BATCH_SIZE;
                const localShortage = colony.assets[resource] < batchNum * BATCH_SIZE;
                if (globalShortage || localShortage) {
                    // Do we have enough ingredients (or can we obtain enough) to make this step of the reaction?
                    const [reagent1, reagent2] = REAGENTS[resource];
                    const reagent1Available = colony.assets[reagent1] >= BATCH_SIZE ||
                        Overmind.terminalNetwork.canObtainResource(colony, reagent1, BATCH_SIZE);
                    const reagent2Available = colony.assets[reagent2] >= BATCH_SIZE ||
                        Overmind.terminalNetwork.canObtainResource(colony, reagent2, BATCH_SIZE);
                    if (reagent1Available && reagent2Available) {
                        return true;
                    }
                    else {
                        ingredientsUnavailable[resource] = true; // canObtainResource() is expensive; cache it
                    }
                }
                // We can't make this thing :(
                return false;
            });
            if (nextTargetResource) {
                break;
            }
        }
        if (nextTargetResource) {
            return { mineralType: nextTargetResource, amount: BATCH_SIZE };
        }
    }
    canReceiveBasicMineralsForReaction(mineralQuantities, _amount) {
        for (const mineral in mineralQuantities) {
            if (!Abathur$1.someColonyHasExcess(mineral, mineralQuantities[mineral])) {
                return false;
            }
        }
        return true;
    }
    canBuyBasicMineralsForReaction(mineralQuantities) {
        if (Game.market.credits < TraderJoe.settings.market.credits.canBuyAbove) {
            return false;
        }
        for (const mineral in mineralQuantities) {
            let maxPrice = maxMarketPrices[mineral] || maxMarketPrices.default;
            if (!onPublicServer()) {
                maxPrice = Infinity;
            }
            if (Overmind.tradeNetwork.priceOf(mineral) >
                maxPrice) {
                return false;
            }
        }
        return true;
    }
    stockAmount(resource) {
        return (wantedStockAmounts[resource] ||
            priorityStockAmounts[resource] ||
            baseStockAmounts[resource] ||
            0);
    }
    hasExcess(colony, mineralType, excessAmount = 0) {
        return (colony.assets[mineralType] - excessAmount >
            Abathur$1.stockAmount(mineralType));
    }
    someColonyHasExcess(mineralType, excessAmount = 0) {
        return _.any(getAllColonies(), (colony) => Abathur$1.hasExcess(colony, mineralType, excessAmount));
    }
    /**
     * Build a reaction queue for a target compound
     */
    buildReactionQueue(colony, mineral, amount, verbose = false) {
        // amount = minMax(amount, Abathur.settings.minBatchSize, Abathur.settings.maxBatchSize);
        amount = Abathur$1.settings.batchSize;
        if (verbose) {
            console.log(`Abathur@${colony.room.print}: building reaction queue for ${amount} ${mineral}`);
        }
        let reactionQueue = [];
        for (const ingredient of Abathur$1.enumerateReactionProducts(mineral)) {
            let productionAmount = amount;
            if (ingredient != mineral) {
                if (verbose) {
                    console.log(`productionAmount: ${productionAmount}, assets: ${colony.assets[ingredient]}`);
                }
                productionAmount = Math.max(productionAmount - colony.assets[ingredient], 0);
            }
            productionAmount = Math.min(productionAmount, Abathur$1.settings.batchSize);
            reactionQueue.push({
                mineralType: ingredient,
                amount: productionAmount,
            });
        }
        if (verbose) {
            console.log(`Pre-trim queue: ${JSON.stringify(reactionQueue)}`);
        }
        reactionQueue = Abathur$1.trimReactionQueue(reactionQueue);
        if (verbose) {
            console.log(`Post-trim queue: ${JSON.stringify(reactionQueue)}`);
        }
        reactionQueue = _.filter(reactionQueue, (rxn) => rxn.amount > 0);
        if (verbose) {
            console.log(`Final queue: ${JSON.stringify(reactionQueue)}`);
        }
        return reactionQueue;
    }
    /**
     * Trim a reaction queue, reducing the amounts of precursor compounds which need to be produced
     */
    trimReactionQueue(reactionQueue) {
        // Scan backwards through the queue and reduce the production amount of subsequently baser resources as needed
        reactionQueue.reverse();
        for (const reaction of reactionQueue) {
            const [ing1, ing2] = REAGENTS[reaction.mineralType];
            const precursor1 = _.findIndex(reactionQueue, (rxn) => rxn.mineralType == ing1);
            const precursor2 = _.findIndex(reactionQueue, (rxn) => rxn.mineralType == ing2);
            for (const index of [precursor1, precursor2]) {
                if (index != -1) {
                    if (reactionQueue[index].amount == 0) {
                        reactionQueue[index].amount = 0;
                    }
                    else {
                        reactionQueue[index].amount = Math.min(reaction.amount, reactionQueue[index].amount);
                    }
                }
            }
        }
        reactionQueue.reverse();
        return reactionQueue;
    }
    /**
     * Figure out which basic minerals are missing and how much
     */
    getMissingBasicMinerals(colony, reactionQueue, verbose = false) {
        const requiredBasicMinerals = Abathur$1.getRequiredBasicMinerals(reactionQueue);
        if (verbose) {
            console.log(`Required basic minerals: ${JSON.stringify(requiredBasicMinerals)}`);
        }
        if (verbose) {
            console.log(`assets: ${JSON.stringify(colony.assets)}`);
        }
        const missingBasicMinerals = {};
        for (const mineralType of (Object.keys(requiredBasicMinerals))) {
            const amountMissing = requiredBasicMinerals[mineralType] - colony.assets[mineralType];
            if (amountMissing > 0) {
                missingBasicMinerals[mineralType] = amountMissing;
            }
        }
        if (verbose) {
            console.log(`Missing basic minerals: ${JSON.stringify(missingBasicMinerals)}`);
        }
        return missingBasicMinerals;
    }
    /**
     * Get the required amount of basic minerals for a reaction queue
     */
    getRequiredBasicMinerals(reactionQueue) {
        const requiredBasicMinerals = {
            [RESOURCE_HYDROGEN]: 0,
            [RESOURCE_OXYGEN]: 0,
            [RESOURCE_UTRIUM]: 0,
            [RESOURCE_KEANIUM]: 0,
            [RESOURCE_LEMERGIUM]: 0,
            [RESOURCE_ZYNTHIUM]: 0,
            [RESOURCE_CATALYST]: 0,
        };
        for (const reaction of reactionQueue) {
            const ingredients = REAGENTS[reaction.mineralType];
            for (const ingredient of ingredients) {
                if (!REAGENTS[ingredient]) {
                    // resource is base mineral
                    requiredBasicMinerals[ingredient] += reaction.amount;
                }
            }
        }
        return requiredBasicMinerals;
    }
    /**
     * Recursively generate a list of outputs from reactions required to generate a compound
     */
    enumerateReactionProducts(mineral) {
        if (!REAGENTS[mineral] || _.isEmpty(mineral)) {
            return [];
        }
        else {
            return Abathur$1.enumerateReactionProducts(REAGENTS[mineral][0]).concat(Abathur$1.enumerateReactionProducts(REAGENTS[mineral][1]), mineral);
        }
    }
    // Production scheduling =========================================================================================
    /**
     * Compute the next production that a colony should undertake based on local and global stockpiles of
     * all target compounds.
     */
    getNextProduction(colony) {
        if (!colony.factory) {
            return undefined;
        }
        const globalAssets = Overmind.terminalNetwork.getAssets();
        const numColonies = _.filter(getAllColonies(), (colony) => !!colony.terminal).length;
        /** How much of a product we can make given its components' availability */
        let batchAmount = Infinity;
        let possibleProductions = PRIORITIZED_COMMODITIES;
        // The factory can only produce commodities of exactly the same level, or "any level" commodities.
        possibleProductions = possibleProductions.filter(([_prod, data]) => data.level === undefined || data.level === colony.factory.level);
        this.debug(() => `${colony.print}, possibleProductions: ${possibleProductions
            .map((p) => p[0])
            .join(", ")}`);
        // Want to build up a stockpile of high tier commodities, but also to maintain and utilize a stockpile of the
        // cheaper stuff before we start building up higher commodities, which have declining returns
        const ingredientsUnavailable = {}; // track what we can't make to save CPU
        const nextTargetProduction = _.find(possibleProductions, ([prodStr, data]) => {
            const product = prodStr;
            const productThreshold = Overmind.terminalNetwork.thresholds(colony, product);
            if (colony.assets[product] >= productThreshold.target) {
                this.debug(() => `${colony.print}, checking ${product}: more than enough (stored: ${colony.assets[product]}, threshold: ${JSON.stringify(productThreshold)})`);
                return false;
            }
            batchAmount = Infinity;
            this.debug(() => `${colony.print}, checking ${product}: threshold: ${JSON.stringify(productThreshold)}, components: ${JSON.stringify(data.components)}`);
            return entries(data.components).every(([resource, amount]) => {
                // If we've already figured out we can't make this in a previous pass then skip it
                if (ingredientsUnavailable[resource]) {
                    return false;
                }
                // Check if the colony already has more of this resource than it needs
                const resourceThreshold = Overmind.terminalNetwork.thresholds(colony, resource);
                const cutoff = resourceThreshold.target - resourceThreshold.tolerance;
                if (colony.assets[resource] < cutoff) {
                    this.debug(() => `${colony.print}, checking ${product}>${resource}, not enough in stock (stored: ${colony.assets[resource]}, threshold: ${JSON.stringify(resourceThreshold)})`);
                    return false;
                }
                // Otherwise, we're allowed to make more of this, so figure out what we should and can make
                const globalShortage = globalAssets[resource] / numColonies < amount;
                const localShortage = colony.assets[resource] -
                    Overmind.terminalNetwork.lockedAmount(colony, resource) <
                    amount;
                if (globalShortage || localShortage) {
                    // Do we have enough ingredients (or can we obtain enough) to make this step of the reaction?
                    if (!Overmind.terminalNetwork.canObtainResource(colony, resource, amount)) {
                        this.debug(`${colony.print}, checking ${product}>${resource} for ${amount}, shortage`);
                        ingredientsUnavailable[resource] = true; // canObtainResource() is expensive; cache it
                        return false;
                    }
                }
                const maxBatch = Math.floor((globalAssets[resource] - cutoff) / amount);
                batchAmount = Math.max(Math.min(maxBatch, batchAmount), 0);
                this.debug(() => `${colony.print}, checking ${product}>${resource}, good to go for ${batchAmount} (${maxBatch}) batches, (local: ${colony.assets[resource]}, network: ${globalAssets[resource]}, threshold: ${JSON.stringify(resourceThreshold)})`);
                return batchAmount > 0;
            });
        });
        this.debug(() => `${colony.print}: possible production ${JSON.stringify(nextTargetProduction)}, batch amount: ${batchAmount}`);
        if (nextTargetProduction && batchAmount > 0) {
            // Cap batches at 10 so we have a chance to switch production
            batchAmount = Math.min(batchAmount, 10);
            return {
                commodityType: nextTargetProduction[0],
                requested: batchAmount,
                size: nextTargetProduction[1].amount,
            };
        }
    }
};
_Abathur = __decorate$1([
    profile
], _Abathur);
const Abathur$1 = new _Abathur();
global.Abathur = Abathur$1;

var TraderJoe_1;
const MAX_CANCELLED_ORDER_BACKLOG = 100;
const getDefaultTraderMemory = () => ({
    cache: {
        sell: {},
        buy: {},
        energyPrice: {
            sell: 0.1,
            buy: 0.1,
        },
        history: {},
        tick: 0,
    },
    canceledOrders: [],
});
const getDefaultTraderStats = () => ({
    credits: 0,
    bought: {},
    sold: {},
    prices: {},
});
// Maximum prices I'm willing to pay to buy various resources - based on shard2 market data in June 2018
// (might not always be up to date)
const maxMarketPrices = {
    default: 5.0,
    [RESOURCE_HYDROGEN]: 0.3,
    [RESOURCE_OXYGEN]: 0.25,
    [RESOURCE_UTRIUM]: 0.3,
    [RESOURCE_LEMERGIUM]: 0.25,
    [RESOURCE_KEANIUM]: 0.25,
    [RESOURCE_ZYNTHIUM]: 0.25,
    [RESOURCE_CATALYST]: 0.5,
    [RESOURCE_ENERGY]: 0.05,
    [RESOURCE_CATALYZED_GHODIUM_ACID]: 1.2,
};
const defaultTradeOpts = {
    preferDirect: false,
    flexibleAmount: true,
    ignoreMinAmounts: false,
    ignorePriceChecksForDirect: false,
    dryRun: false,
};
/**
 * The trade network controls resource acquisition and disposal on the player market.
 */
let TraderJoe = TraderJoe_1 = class TraderJoe {
    constructor() {
        this.name = "TradeNetwork";
        this.refresh();
    }
    refresh() {
        this.memory = Mem.wrap(Memory.Overmind, "trader", getDefaultTraderMemory);
        this.stats = Mem.wrap(Memory.stats.persistent, "trader", getDefaultTraderStats);
        this.notifications = [];
        this.ordersPlacedThisTick = 0;
    }
    debug(...args) {
        if (this.memory.debug) {
            log.alert("TradeNetwork:", ...args);
        }
    }
    notify(msg) {
        this.notifications.push(bullet + msg);
        Game.notify(msg);
    }
    /**
     * Returns the approximate price of a mineral - shouldn't be used for optimizing prices, just as a ballpark
     * feasibility estimate
     */
    priceOf(mineralType) {
        if (this.memory.cache.history[mineralType]) {
            return this.memory.cache.history[mineralType].avg;
        }
        else {
            return Infinity;
        }
    }
    /**
     * Builds a cache for market - this is very expensive; use infrequently
     */
    buildMarketCache(verbose = false, orderThreshold = 1000) {
        this.debug("Building market cache");
        this.invalidateMarketCache();
        const myActiveOrderIDs = _.map(_.filter(Game.market.orders, (order) => order.active), (order) => order.id);
        // don't include tiny orders
        const allOrders = Game.market.getAllOrders((order) => !myActiveOrderIDs.includes(order.id) &&
            order.amount >= orderThreshold);
        const groupedBuyOrders = _.groupBy(_.filter(allOrders, (o) => o.type == ORDER_BUY), (o) => o.resourceType);
        const groupedSellOrders = _.groupBy(_.filter(allOrders, (o) => o.type == ORDER_SELL), (o) => o.resourceType);
        for (const resourceType in groupedBuyOrders) {
            // Store buy order with maximum price in cache
            const prices = _.map(groupedBuyOrders[resourceType], (o) => o.price);
            const high = _.max(prices);
            const low = _.min(prices);
            if (verbose) {
                console.log(`${resourceType} BUY: high: ${high}  low: ${low}`);
            }
            // this.memory.cache.buy[resourceType] = minBy(groupedBuyOrders[resourceType], (o:Order) => -1 * o.price);
            this.memory.cache.buy[resourceType] = { high: high, low: low };
        }
        for (const resourceType in groupedSellOrders) {
            // Store sell order with minimum price in cache
            const prices = _.map(groupedSellOrders[resourceType], (o) => o.price);
            const high = _.max(prices);
            const low = _.min(prices);
            if (verbose) {
                console.log(`${resourceType} SELL: high: ${high}  low: ${low}`);
            }
            // this.memory.cache.sell[resourceType] = minBy(groupedSellOrders[resourceType], (o:Order) => o.price);
            this.memory.cache.sell[resourceType] = { high: high, low: low };
        }
        this.memory.cache.tick = Game.time;
    }
    /**
     * Builds a cache for market - this is very expensive; use infrequently
     */
    buildMarketHistoryCache() {
        this.debug("Building market history cache");
        const history = Game.market.getHistory();
        const historyByResource = _.groupBy(history, (hist) => hist.resourceType);
        // Compute stats for each resource
        for (const resource in historyByResource) {
            const resourceHistory = _.sortBy(historyByResource[resource], (hist) => hist.date); // oldest to newest
            _.map(resourceHistory, (hist) => hist.avgPrice);
            // Get average price and standard deviation for today
            const avg = _.last(resourceHistory).avgPrice;
            const std = _.last(resourceHistory).stddevPrice;
            // Compute average price over last 14 days
            const avg14 = _.sum(resourceHistory, (hist) => hist.avgPrice * hist.volume) /
                _.sum(resourceHistory, (hist) => hist.volume); // this could be Infinity
            // Compute average standard deviation over last 14 days using Bessel-corrected variance summation
            const std14 = Math.sqrt(_.sum(resourceHistory, (h) => h.volume * (h.avgPrice - avg14) ** 2 +
                h.stddevPrice ** 2) / _.sum(resourceHistory, (h) => h.volume)); // this could be Infinity
            this.memory.cache.history[resource] = {
                avg,
                std,
                avg14,
                std14,
            };
        }
    }
    /**
     * Computes the effective price of energy accounting for transfer costs
     */
    computeEffectiveEnergyPrices() {
        const energyOrders = _(Game.market.getAllOrders({ resourceType: RESOURCE_ENERGY }))
            .filter((order) => order.amount >= 5000)
            .groupBy((order) => order.type)
            .value();
        const sellOrders = energyOrders[ORDER_SELL];
        const buyOrders = energyOrders[ORDER_BUY];
        for (const colony of _.sample(getAllColonies(), 5)) {
            const room = colony.room.name;
            maxBy(buyOrders, (order) => order.price - this.marginalTransactionPrice(order, room));
            minBy(sellOrders, (order) => order.price + this.marginalTransactionPrice(order, room));
            this.computeCompetitivePrice(ORDER_SELL, RESOURCE_ENERGY, room);
            this.computeCompetitivePrice(ORDER_BUY, RESOURCE_ENERGY, room);
        }
        // TODO: this implicitly requires knonwledge of energy price for this.marginalTransactionPrice() -> problematic?
    }
    invalidateMarketCache() {
        this.memory.cache = getDefaultTraderMemory().cache;
    }
    // /**
    //  * Pretty-prints transaction information in the console
    //  */
    // private logTransaction(order: Order, terminalRoomName: string, amount: number, response: number): void {
    // 	const cost = (order.price * amount).toFixed(0);
    // 	const fee = order.roomName ? Game.market.calcTransactionCost(amount, order.roomName, terminalRoomName) : 0;
    // 	const roomName = printRoomName(terminalRoomName, true);
    // 	let msg: string;
    // 	if (order.type == ORDER_SELL) { // I am buying
    // 		msg = `Direct: ${roomName} ${leftArrow} ${Math.round(amount)} ${order.resourceType} ${leftArrow} ` +
    // 			  `${printRoomName(order.roomName!)} (-${cost}c)`;
    // 		if (response != OK) {
    // 			msg += ` (ERROR: ${response})`;
    // 		}
    // 	} else { // I am selling
    // 		msg = `Direct: ${roomName} ${rightArrow} ${Math.round(amount)} ${order.resourceType} ${rightArrow} ` +
    // 			  `${printRoomName(order.roomName!)} (+${cost}c)`;
    // 		if (response != OK) {
    // 			msg += ` (ERROR: ${response})`;
    // 		}
    // 	}
    // 	// this.notify(msg); // use the transactions from the ledger instead
    // }
    /**
     * Returns a list of orders you have already placed for this type for this resource.
     * If roomName is undefined, count any of your orders; if roomName is specified, only return if order is in room
     */
    getExistingOrders(type, resource, roomName) {
        let orders;
        if (roomName) {
            orders = _.filter(Game.market.orders, (order) => order.type == type &&
                (order.resourceType == resource || resource == "any") &&
                order.roomName == roomName);
            if (orders.length > 1 && resource != "any") {
                log.error(`Multiple orders for ${resource} detected in ${printRoomName(roomName)}!`);
            }
        }
        else {
            orders = _.filter(Game.market.orders, (order) => order.type == type &&
                (order.resourceType == resource || resource == "any"));
        }
        return orders;
    }
    /**
     * Returns whether an order is yours
     */
    isOrderMine(order) {
        return Game.rooms[order.roomName] && Game.rooms[order.roomName].my;
    }
    /**
     * The effective cost in credits of the energy transfer cost per unit to deal to a given order
     */
    marginalTransactionPrice(order, dealerRoomName) {
        var _a, _b, _c;
        if (order.roomName) {
            const transferCost = Game.market.calcTransactionCost(10000, order.roomName, dealerRoomName) / 10000;
            // Average distance between any two rooms is 25 since the map wraps, which has 56% transaction price, so
            // energy is 44% what is is normally. This is a bit pessimistic, so let's bump it to 55%, which currently
            // is what computeCompetitivePrice(sell, energy) is telling me it should be around...
            const energyPriceGuess = 0.55 * ((_c = (_b = (_a = this.memory.cache.history) === null || _a === void 0 ? void 0 : _a.energy) === null || _b === void 0 ? void 0 : _b.avg14) !== null && _c !== void 0 ? _c : Infinity);
            const energyToCreditMultiplier = Math.min(energyPriceGuess, 0.1);
            return transferCost * energyToCreditMultiplier;
        }
        else {
            // no order.roomName means subscription token, and I don't trade these so this should never get used
            log.error(`order.roomName is unspecified!`);
            return Infinity;
        }
    }
    /**
     * Computes the **approximate** cost to obtain the base resources needed to synthesize a compound.
     * Could be more optimized to include stuff like energy transfer cost, etc.
     * Returns Infinity if insufficient market data is present.
     */
    getPriceForBaseIngredients(resource) {
        const ingredients = Abathur$1.enumerateReactionBaseIngredients(resource);
        if (ingredients.length > 0) {
            // a synthesizeable compound
            return _.sum(ingredients, (res) => { var _a, _b; return (_b = (_a = this.memory.cache.history[res]) === null || _a === void 0 ? void 0 : _a.avg14) !== null && _b !== void 0 ? _b : Infinity; });
        }
        else {
            // not synthesizeable
            if (this.memory.cache.history[resource]) {
                return this.memory.cache.history[resource].avg14;
            }
            else {
                return Infinity;
            }
        }
    }
    /**
     * Computes a competitive market price to buy or sell resources at or to adjust existing orders to.
     * Returns Infinity if sanity checks are not passed or if there is insufficient data to generate a buy price,
     * in which case the items should not be sold.
     */
    computeCompetitivePrice(type, resource, room) {
        var _a, _b;
        // Find out how much all the ingredients to make this should cost
        const priceForBaseResources = this.getPriceForBaseIngredients(resource);
        if (priceForBaseResources == 0 || priceForBaseResources == Infinity) {
            log.error(`Cannot get base ingredient price for ${resource}!`);
            return Infinity;
        }
        // Get all orders for this resource and group by type
        const allOrdersOfResource = _.groupBy(Game.market.getAllOrders({ resourceType: resource }), "type");
        const allBuyOrders = (_a = allOrdersOfResource[ORDER_BUY]) !== null && _a !== void 0 ? _a : [];
        const allSellOrders = (_b = allOrdersOfResource[ORDER_SELL]) !== null && _b !== void 0 ? _b : [];
        // Find most competitive orders, ignoring small orders and orders which are mine
        const highestBuyOrder = maxBy(allBuyOrders, (o) => o.amount < 100 || this.isOrderMine(o) ?
            false
            : o.price - this.marginalTransactionPrice(o, room));
        const lowestSellOrder = minBy(allSellOrders, (o) => o.amount < 100 || this.isOrderMine(o) ?
            false
            : o.price + this.marginalTransactionPrice(o, room));
        if (!highestBuyOrder || !lowestSellOrder) {
            log.error(`No buy orders or no sell orders for ${resource}!`);
            return Infinity;
        }
        // Compute an adjustment factor based on how long it's been sitting on the market
        const adjustMagnitude = 0.1;
        let adjustment = 1;
        const existingOrder = _.first(this.getExistingOrders(ORDER_SELL, resource, room));
        if (existingOrder) {
            const timeOnMarket = Game.time - existingOrder.created;
            const orderDiscountTimescale = 50000; // order will change by adjustMagnitude percent every this many ticks
            adjustment =
                (adjustment + timeOnMarket / orderDiscountTimescale) / 2;
        }
        // Compute the price, returning Infinity if sanity checks are not passed
        if (type == ORDER_SELL) {
            // if you are trying to sell a resource to buyers, undercut their prices a bit
            const discountFactor = 1 - adjustment * adjustMagnitude;
            const marketRate = Math.max(lowestSellOrder.price, highestBuyOrder.price);
            const price = marketRate * discountFactor;
            this.debug(`Candidate price to ${type} ${resource} in ${printRoomName(room)}: ${price}`);
            // If the sell price is greater than the lowestSell order price, it might mean an opportunity for arbitrage
            if (price > lowestSellOrder.price) ;
            // It's not sensible to sell at a lower cost than what you paid to make it
            if ((!Abathur$1.isBaseMineral(resource) &&
                price < priceForBaseResources) ||
                (Abathur$1.isBaseMineral(resource) &&
                    price < priceForBaseResources / 2) || // can sell base below market
                price < 0) {
                return Infinity;
            }
            else {
                return price;
            }
        }
        else {
            // if you are trying to buy a resource from sellers, offer a little bit more than market rate
            const outbidFactor = 1 + adjustment * adjustMagnitude;
            const marketRate = Math.min(highestBuyOrder.price, lowestSellOrder.price);
            const price = marketRate * outbidFactor;
            this.debug(`Candidate price to ${type} ${resource} in ${printRoomName(room)}: ${price}`);
            // If the buy price is less than the highestBuy order price, it might mean an opportunity for arbitrage
            if (price < highestBuyOrder.price) ;
            // Don't pay >10x what ingredients cost - about 3.0c for XGHO2 based on March 2020 data
            const maxMarkupWillingToBuyFrom = 3;
            if (price > priceForBaseResources * maxMarkupWillingToBuyFrom) {
                return Infinity;
            }
            else {
                return price;
            }
        }
    }
    ordersProcessedThisTick() {
        return Game.time % 10 == 5;
    }
    /**
     * Create or maintain an order, extending and repricing as needed
     */
    maintainOrder(terminal, type, resource, amount, opts) {
        this.debug(`maintain ${type} order for ${terminal.room.print}: ${amount} ${resource}`);
        // This is all somewhat expensive so only do this occasionally
        if (!this.ordersProcessedThisTick()) {
            return OK; // No action needed on these ticks; we'll pretend this works OK
        }
        // Cap the amount based on the maximum you can make a buy/sell order with
        if (type == ORDER_SELL) {
            amount = Math.min(amount, TraderJoe_1.settings.market.orders.maxBuyOrderAmount);
        }
        else {
            amount = Math.min(amount, TraderJoe_1.settings.market.orders.maxSellOrderAmount);
        }
        // Wait until you accumulate more of the resource to order with bigger transactions
        const minAmount = type == ORDER_BUY ?
            TraderJoe_1.settings.market.orders.minBuyOrderAmount
            : TraderJoe_1.settings.market.orders.minSellOrderAmount;
        if (amount < minAmount && !opts.ignoreMinAmounts) {
            this.debug(`amount ${amount} less than min amount ${minAmount}; no action taken`);
            return NO_ACTION;
        }
        const existingOrder = _.first(this.getExistingOrders(type, resource, terminal.room.name));
        // Maintain an existing order
        if (existingOrder) {
            // Figure out if price should be changed - if the competitive price is now significantly different
            const price = +this.computeCompetitivePrice(type, resource, terminal.room.name).toFixed(3); // market only allows for 3 decimal places of precision
            if (price == Infinity || price == 0) {
                log.warning(`TradeNetwork: sanity checks not passed to handle existing ${type} order ${resource} ` +
                    `in ${printRoomName(terminal.room.name)}!`);
                return ERR_NOT_ENOUGH_MARKET_DATA;
            }
            const ratio = existingOrder.price / price;
            const tolerance = 0.03; // might need to tune this, we'll see
            const normalFluctuation = 1 + tolerance > ratio && ratio > 1 - tolerance;
            // Extend the order if you need to sell more of the resource
            if (amount > existingOrder.remainingAmount && normalFluctuation) {
                const addAmount = amount - existingOrder.remainingAmount;
                const ret = Game.market.extendOrder(existingOrder.id, addAmount);
                this.notify(`${terminal.room.print}: extending ${type} order for ${resource} by ${addAmount}.` +
                    ` Response: ${errorForCode(ret)}`);
                return ret;
            }
            // Small chance of changing the price if it's not competitive; don't do too often or you are high risk
            if (!normalFluctuation && Math.random() < 1 / 2000) {
                const ret = Game.market.changeOrderPrice(existingOrder.id, price);
                this.notify(`${terminal.room.print}: changing ${type} order price for ${resource} from ` +
                    `${existingOrder.price} to ${price}. Response: ${errorForCode(ret)}`);
                return ret;
            }
            // No action needed
            return OK;
        }
        else {
            // Create a new order
            // Put a cap on the number of orders you can create per tick
            if (this.ordersPlacedThisTick >
                TraderJoe_1.settings.market.orders.maxOrdersPlacedPerTick) {
                return NO_ACTION;
            }
            // Only place up to a certain amount of orders
            const existingOrdersForThis = this.getExistingOrders(type, resource);
            if (existingOrdersForThis.length >
                TraderJoe_1.settings.market.orders.maxOrdersForResource) {
                this.notify(`${printRoomName(terminal.room.name, true)}: could not create ${type} order for ` +
                    `${Math.round(amount)} ${resource} - too many existing!`);
                return ERR_TOO_MANY_ORDERS_OF_TYPE;
            }
            // Compute the buy or sell price
            const price = +this.computeCompetitivePrice(type, resource, terminal.room.name).toFixed(3); // market only allows for 3 decimal places of precision
            if (price == Infinity || price == 0) {
                log.warning(`TradeNetwork: sanity checks not passed to create ${type} order ${resource} in ` +
                    `${printRoomName(terminal.room.name)}!`);
                return ERR_NOT_ENOUGH_MARKET_DATA;
            }
            // adjust the amount to only immediately list what you can afford; it can be extended later
            const brokersFee = price * amount * MARKET_FEE;
            if (Game.market.credits < brokersFee) {
                amount = ((amount * Game.market.credits) / brokersFee) * 0.9;
            }
            // Create the order
            const params = {
                type: type,
                resourceType: resource,
                price: price,
                totalAmount: amount,
                roomName: terminal.room.name,
            };
            const ret = Game.market.createOrder(params);
            let msg = "";
            if (type == ORDER_BUY) {
                msg +=
                    `${printRoomName(terminal.room.name, true)} creating buy order:  ` +
                        `${Math.round(amount)} ${resource} at price ${price.toFixed(4)}`;
            }
            else {
                msg +=
                    `${printRoomName(terminal.room.name, true)} creating sell order: ` +
                        `${Math.round(amount)} ${resource} at price ${price.toFixed(4)}`;
            }
            if (ret == OK) {
                this.ordersPlacedThisTick++;
            }
            else {
                msg += ` ERROR: ${errorForCode(ret)}`;
            }
            this.debug(msg);
            this.notify(msg);
            return ret;
        }
    }
    cleanOrders() {
        const ordersToClean = _.filter(Game.market.orders, (order) => {
            // Clean up inactive orders where you've bought/sold everything
            if (order.active == false && order.remainingAmount == 0) {
                return true;
            }
            // Clean up very old orders which are almost completed but which have some small amount remaining
            if (Game.time - order.created >
                TraderJoe_1.settings.market.orders.timeout &&
                order.remainingAmount <
                    TraderJoe_1.settings.market.orders.cleanupAmount) {
                return true;
            }
            // Clean up orders placed in colonies which are no longer with us :(
            if (order.roomName && !Overmind.colonies[order.roomName]) {
                return true;
            }
        });
        for (const order of ordersToClean) {
            const ret = Game.market.cancelOrder(order.id);
            if (ret == OK) {
                // Add to canceled orders for tracking
                this.notify(`Cleaning ${order.type} order for ${order.totalAmount} ${order.resourceType}. ` +
                    `Order lifetime: ${Game.time - order.created}`);
                order.lifetime = Game.time - order.created;
                this.memory.canceledOrders.push(order);
                // only keep this many orders in memory
                while (this.memory.canceledOrders.length >
                    MAX_CANCELLED_ORDER_BACKLOG) {
                    this.memory.canceledOrders.shift();
                }
            }
        }
    }
    /**
     * Buy resources directly from a seller using Game.market.deal() rather than making a buy order
     */
    buyDirect(terminal, resource, amount, opts) {
        this.debug(`buyDirect for ${terminal.room.print}: ${amount} ${resource}`);
        // If terminal is on cooldown or just did something then skip
        if (!terminal.isReady && !opts.dryRun) {
            return NO_ACTION; // don't return ERR_TIRED here because it doesn't signal an inability to buy
        }
        // Wait until you accumulate more of the resource to buy with bigger transactions
        if (amount < TraderJoe_1.settings.market.orders.minBuyDirectAmount &&
            !opts.ignoreMinAmounts &&
            !opts.dryRun) {
            return NO_ACTION;
        }
        // Can only buy what you are allowed to and have space for
        amount = Math.min(amount, terminal.store.getFreeCapacity(), TraderJoe_1.settings.market.orders.maxBuyDirectAmount);
        // If flexibleAmount is allowed, consider buying from orders which don't need the full amount
        const minAmount = opts.flexibleAmount ?
            Math.min(TraderJoe_1.settings.market.orders.minBuyDirectAmount, amount)
            : amount;
        const validOrders = _.filter(Game.market.getAllOrders({
            resourceType: resource,
            type: ORDER_SELL,
        }), (order) => order.amount >= minAmount);
        // Find the cheapest order, minimizing by (buying price + marginal cost of transaction)
        const order = minBy(validOrders, (order) => order.price +
            this.marginalTransactionPrice(order, terminal.room.name) -
            order.amount / 1000000000); // last bit prioritizes biggest orders
        // If no valid order, notify a warning and return an error so it can be handled in .buy()
        if (!order) {
            if (!opts.dryRun) {
                this.notify(`No valid market order to buy from! Buy request: ${amount} ${resource} to ` +
                    `${printRoomName(terminal.room.name)}`);
            }
            return ERR_NO_ORDER_TO_BUY_FROM;
        }
        // Check that the buy price isn't too expensive
        const adjustedPrice = order.price +
            this.marginalTransactionPrice(order, terminal.room.name);
        const priceForBaseIngredients = this.getPriceForBaseIngredients(resource);
        const maxPriceWillingToPay = priceForBaseIngredients * (1.5 + Game.market.credits / 2e6);
        this.debug(`Resource: ${resource}, price: ${order.price}, adjusted: ${adjustedPrice}, base cost: ${priceForBaseIngredients}, ` +
            `max: ${maxPriceWillingToPay}`);
        if (priceForBaseIngredients == Infinity ||
            (adjustedPrice > maxPriceWillingToPay &&
                !opts.ignorePriceChecksForDirect) ||
            adjustedPrice > 100) {
            // never buy above an absurd threshold, regardless of opts.ignorePriceChecks
            if (!opts.dryRun) {
                this.notify(`Buy direct call is too expenisive! Buy request: ${amount} ${resource} to ` +
                    `${printRoomName(terminal.room.name)}, adjusted price of best order: ` +
                    `${adjustedPrice.toFixed(4)}`);
            }
            return ERR_BUY_DIRECT_PRICE_TOO_HIGH;
        }
        // Do the deal
        const buyAmount = Math.min(order.amount, amount);
        const transactionCost = Game.market.calcTransactionCost(buyAmount, terminal.room.name, order.roomName);
        if (terminal.store[RESOURCE_ENERGY] >= transactionCost) {
            // If this is a dry run just check that you have enough credits
            if (opts.dryRun) {
                const haveEnoughCredits = Game.market.credits >= buyAmount * order.price;
                return haveEnoughCredits ? OK : ERR_NOT_ENOUGH_RESOURCES;
            }
            // Otherwise make the deal
            const response = Game.market.deal(order.id, buyAmount, terminal.room.name);
            this.debug(`buyDirect executed for ${terminal.room.print}: ${buyAmount} ${resource} (${response})`);
            // this.logTransaction(order, terminal.room.name, amount, response);
            return response;
        }
        else {
            return ERR_INSUFFICIENT_ENERGY_IN_TERMINAL;
        }
    }
    /**
     * Sell resources directly to a buyer using Game.market.deal() rather than making a sell order
     */
    sellDirect(terminal, resource, amount, opts) {
        this.debug(`sellDirect for ${terminal.room.print}: ${amount} ${resource}`);
        // If terminal is on cooldown or just did something then skip
        if (!terminal.isReady && !opts.dryRun) {
            return NO_ACTION; // don't return ERR_TIRED here because it doesn't signal an inability to sell
        }
        // Wait until you accumulate more of the resource to sell with bigger transactions
        if (amount < TraderJoe_1.settings.market.orders.minSellDirectAmount &&
            !opts.ignoreMinAmounts &&
            !opts.dryRun) {
            return NO_ACTION;
        }
        // Can only sell what you have in store and are allowed to sell
        amount = Math.min(amount, terminal.store[resource], TraderJoe_1.settings.market.orders.maxSellDirectAmount);
        // If flexibleAmount is allowed, consider selling to orders which don't need the full amount
        const minAmount = opts.flexibleAmount ?
            Math.min(amount, TraderJoe_1.settings.market.orders.minSellDirectAmount)
            : amount;
        const validOrders = _.filter(Game.market.getAllOrders({
            resourceType: resource,
            type: ORDER_BUY,
        }), (order) => order.amount >= minAmount);
        // Find the best order, maximizing by (buying price - marginal loss from transaction)
        const order = maxBy(validOrders, (order) => order.price -
            this.marginalTransactionPrice(order, terminal.room.name) +
            order.amount / 1000000000); // last bit prioritizes biggest orders
        // If no order found, notify a warning and return an error so it can be handled in .sell()
        if (!order) {
            if (!opts.dryRun) {
                this.notify(`No valid market order to sell to! Sell request: ${amount} ${resource} from ` +
                    `${printRoomName(terminal.room.name)}`);
            }
            return ERR_NO_ORDER_TO_SELL_TO;
        }
        // Check that the sell price isn't too expensive
        const adjustedPrice = order.price -
            this.marginalTransactionPrice(order, terminal.room.name);
        const priceForBaseIngredients = this.getPriceForBaseIngredients(resource);
        const minPriceWillingToSell = 0.5 * priceForBaseIngredients;
        this.debug(`Price: ${order.price}, Adjusted: ${adjustedPrice}, BaseCost: ${priceForBaseIngredients}, ` +
            `Min: ${minPriceWillingToSell}`);
        if (priceForBaseIngredients == Infinity ||
            (adjustedPrice < minPriceWillingToSell &&
                !opts.ignorePriceChecksForDirect) ||
            adjustedPrice < 0) {
            // never sell if it will be a net negative, regardless of opts.ignorePriceChecks
            if (!opts.dryRun) {
                this.notify(`Sell direct call is too cheap! Sell request: ${amount} ${resource} from ` +
                    `${printRoomName(terminal.room.name)}, adjusted price of best order: ` +
                    `${adjustedPrice}`);
            }
            return ERR_SELL_DIRECT_PRICE_TOO_LOW;
        }
        let sellAmount = Math.min(order.amount, amount);
        const transactionCost = Game.market.calcTransactionCost(sellAmount, terminal.room.name, order.roomName);
        if (resource == RESOURCE_ENERGY) {
            // if we're selling energy, make sure we have amount + cost
            if (amount + transactionCost > terminal.store[RESOURCE_ENERGY]) {
                sellAmount -= transactionCost;
                if (sellAmount <= 0) {
                    return ERR_INSUFFICIENT_ENERGY_IN_TERMINAL;
                }
            }
        }
        if (terminal.store[RESOURCE_ENERGY] >= transactionCost) {
            // If this is a dry run we should be able to execute the deal by now, so just return OK
            if (opts.dryRun) {
                return OK;
            }
            // Otherwise do the deal
            const response = Game.market.deal(order.id, sellAmount, terminal.room.name);
            this.debug(`sellDirect executed for ${terminal.room.print}: ${sellAmount} ${resource} (${response})`);
            // this.logTransaction(order, terminal.room.name, amount, response);
            return response;
        }
        else {
            return ERR_INSUFFICIENT_ENERGY_IN_TERMINAL;
        }
    }
    /**
     * Buy a resource on the market, either through a buy order or directly (usually direct=true will be used)
     */
    buy(terminal, resource, amount, opts = {}) {
        _.defaults(opts, defaultTradeOpts);
        if (Game.market.credits < TraderJoe_1.settings.market.credits.canBuyAbove) {
            log.error(`Credits insufficient to buy resource ${amount} ${resource} to ${terminal.room.print}; ` +
                `shouldn't be making this TradeNetwork.buy() request!`);
            return ERR_CREDIT_THRESHOLDS;
        }
        if (Game.market.credits <
            TraderJoe_1.settings.market.credits.canBuyBoostsAbove &&
            Abathur$1.isBoost(resource)) {
            log.error(`Credits insufficient to buy boost ${amount} ${resource} to ${terminal.room.print}; ` +
                `shouldn't be making this TradeNetwork.buy() request!`);
            return ERR_CREDIT_THRESHOLDS;
        }
        if (Game.market.credits <
            TraderJoe_1.settings.market.credits.canBuyEnergyAbove &&
            resource == RESOURCE_ENERGY) {
            log.error(`Credits insufficient to buy ${amount} energy to ${terminal.room.print}; ` +
                `shouldn't be making this TradeNetwork.buy() request!`);
            return ERR_CREDIT_THRESHOLDS;
        }
        if (Abathur$1.isIntermediateReactant(resource) ||
            resource == RESOURCE_GHODIUM) {
            log.error(`Shouldn't request reaction intermediate ${amount} ${resource} to ${terminal.room.print}!`);
            return ERR_DONT_BUY_REACTION_INTERMEDIATES;
        }
        // If you don't have a lot of credits or preferDirect==true, try to sell directly to an existing buy order
        if (opts.preferDirect &&
            this.getExistingOrders(ORDER_BUY, resource, terminal.room.name)
                .length == 0) {
            const result = this.buyDirect(terminal, resource, amount, opts);
            if (result != ERR_NO_ORDER_TO_BUY_FROM &&
                result != ERR_BUY_DIRECT_PRICE_TOO_HIGH) {
                return result;
            }
            this.notify(`Buy direct request: ${amount} ${resource} to ${printRoomName(terminal.room.name)} ` +
                `was unsuccessful (${errorForCode(result)}); allowing fallthrough to TradeNetwork.maintainOrder()`);
        }
        if (opts.dryRun) {
            return ERR_DRY_RUN_ONLY_SUPPORTS_DIRECT_TRANSACTIONS;
        }
        // Fallthrough - if not preferDirect or if existing order or if there's no orders to buy from then make order
        const result = this.maintainOrder(terminal, ORDER_BUY, resource, amount, opts);
        return result;
    }
    /**
     * Sell a resource on the market, either through a sell order or directly
     */
    sell(terminal, resource, amount, opts = {}) {
        _.defaults(opts, defaultTradeOpts);
        // If you don't have a lot of credits or preferDirect==true, try to sell directly to an existing buy order
        if (opts.preferDirect ||
            Game.market.credits <
                TraderJoe_1.settings.market.credits.mustSellDirectBelow) {
            if (this.getExistingOrders(ORDER_SELL, resource, terminal.room.name)
                .length == 0) {
                const result = this.sellDirect(terminal, resource, amount, opts);
                if (result != ERR_NO_ORDER_TO_SELL_TO &&
                    result != ERR_SELL_DIRECT_PRICE_TOO_LOW) {
                    return result; // if there's nowhere to sensibly sell, allow creating an order
                }
                this.notify(`Sell direct request: ${amount} ${resource} from ${printRoomName(terminal.room.name)} ` +
                    `was unsuccessful (${errorForCode(result)}); allowing fallthrough to TradeNetwork.maintainOrder()`);
            }
        }
        if (opts.dryRun) {
            return ERR_DRY_RUN_ONLY_SUPPORTS_DIRECT_TRANSACTIONS;
        }
        // If you have enough credits or if there are no buy orders to sell to, create / maintain a sell order
        if (Game.market.credits >=
            TraderJoe_1.settings.market.credits.canPlaceSellOrdersAbove) {
            const result = this.maintainOrder(terminal, ORDER_SELL, resource, amount, opts);
            return result;
        }
        else {
            return ERR_CREDIT_THRESHOLDS;
        }
    }
    init() {
        if (Game.time - (this.memory.cache.tick || 0) >
            TraderJoe_1.settings.cache.timeout) {
            this.buildMarketCache();
            this.buildMarketHistoryCache();
        }
    }
    run() {
        if (Game.time % 10 == 0) {
            this.cleanOrders();
        }
        this.notifyLastTickTransactions();
        if (this.notifications.length > 0) {
            this.notifications.sort();
            log.info(`Trade network activity: ` +
                alignedNewline +
                this.notifications.join(alignedNewline));
        }
        this.recordStats();
    }
    notifyLastTickTransactions() {
        // Outgoing transactions are where I sent the resource
        for (const transaction of Game.market.outgoingTransactions) {
            // list is ordered by descending time
            if (transaction.time < Game.time - 1) {
                break;
            }
            if (transaction.order) {
                // if it was sold on the market
                let msg;
                const cost = (transaction.amount * transaction.order.price).toFixed(2);
                // I am selling to another person's buy order
                if (transaction.order.type == ORDER_BUY) {
                    const coststr = `[+${cost}c]`.padEnd("[-10000.00c]".length);
                    msg =
                        coststr +
                            ` sell direct: ${printRoomName(transaction.to, true)} ${leftArrow} ` +
                            `${transaction.amount} ${transaction.resourceType} ${leftArrow} ` +
                            `${printRoomName(transaction.from, true)} `;
                    if (transaction.sender && transaction.recipient) {
                        // const sender = transaction.sender.username; // should be me
                        const recipient = transaction.recipient.username;
                        msg += `(sold to: ${recipient})`;
                    }
                    else {
                        msg += `(sold to: ???)`;
                    }
                }
                else {
                    // Someone else is buying from by sell order
                    const coststr = `[+${cost}c]`.padEnd("[-10000.00c]".length);
                    msg =
                        coststr +
                            ` sell order: ${printRoomName(transaction.from, true)} ${rightArrow} ` +
                            `${transaction.amount} ${transaction.resourceType} ${rightArrow} ` +
                            `${printRoomName(transaction.to, true)} `;
                    if (transaction.sender && transaction.recipient) {
                        // const sender = transaction.sender.username; // should be me
                        const recipient = transaction.recipient.username;
                        msg += `(buyer: ${recipient})`;
                    }
                    else {
                        msg += `(buyer: ???)`;
                    }
                }
                this.notify(msg);
            }
        }
        // Incoming transactions are where I received the resource
        for (const transaction of Game.market.incomingTransactions) {
            // list is ordered by descending time
            if (transaction.time < Game.time - 1) {
                break;
            }
            if (transaction.order) {
                // if it was sold on the market
                let msg;
                const cost = (transaction.amount * transaction.order.price).toFixed(2);
                // I am receiving resources from a direct purchase of someone else's sell order
                if (transaction.order.type == ORDER_SELL) {
                    const coststr = `[-${cost}c]`.padEnd("[-10000.00c]".length);
                    msg =
                        coststr +
                            ` buy direct: ${printRoomName(transaction.to, true)} ${leftArrow} ` +
                            `${transaction.amount} ${transaction.resourceType} ${leftArrow} ` +
                            `${printRoomName(transaction.from, true)} `;
                    if (transaction.sender && transaction.recipient) {
                        const sender = transaction.sender.username;
                        // const recipient = transaction.recipient.username; // should be me
                        msg += `(bought from: ${sender})`;
                    }
                    else {
                        msg += `(bought from: ???)`;
                    }
                }
                else {
                    // Another person is selling to my buy order
                    const coststr = `[-${cost}c]`.padEnd("[-10000.00c]".length);
                    msg =
                        coststr +
                            ` buy order: ${printRoomName(transaction.from, true)} ${rightArrow} ` +
                            `${transaction.amount} ${transaction.resourceType} ${rightArrow} ` +
                            `${printRoomName(transaction.to, true)} `;
                    if (transaction.sender && transaction.recipient) {
                        const sender = transaction.sender.username;
                        // const recipient = transaction.recipient.username; // should be me
                        msg += `(seller: ${sender})`;
                    }
                    else {
                        msg += `(seller: ???)`;
                    }
                }
                this.notify(msg);
            }
        }
    }
    /**
     * Look through transactions happening on the previous tick and record stats
     */
    recordStats() {
        var _a;
        this.stats.credits = Game.market.credits;
        const lastTick = Game.time - 1;
        // Incoming transactions
        for (const transaction of Game.market.incomingTransactions) {
            if (transaction.time < lastTick) {
                break; // only look at things from last tick
            }
            else {
                if (transaction.order) {
                    const resourceType = transaction.resourceType;
                    const amount = transaction.amount;
                    const price = transaction.order.price;
                    this.stats.bought[resourceType] = this.stats.bought[resourceType] || { amount: 0, credits: 0 };
                    this.stats.bought[resourceType].amount += amount;
                    this.stats.bought[resourceType].credits += amount * price;
                }
            }
        }
        // Outgoing transactions
        for (const transaction of Game.market.outgoingTransactions) {
            if (transaction.time < lastTick) {
                break; // only look at things from last tick
            }
            else {
                if (transaction.order) {
                    const resourceType = transaction.resourceType;
                    const amount = transaction.amount;
                    const price = transaction.order.price;
                    this.stats.sold[resourceType] = this.stats.sold[resourceType] || { amount: 0, credits: 0 };
                    this.stats.sold[resourceType].amount += amount;
                    this.stats.sold[resourceType].credits += amount * price;
                }
            }
        }
        // Market prices
        for (const [resourceType, { avg }] of entries(this.memory.cache.history)) {
            (_a = this.stats.prices)[resourceType] || (_a[resourceType] = { avg: 0 });
            this.stats.prices[resourceType].avg = avg;
        }
    }
};
TraderJoe.settings = {
    cache: {
        timeout: 250,
    },
    market: {
        resources: {
            /** the market for T1/T2 boosts is unstable; disallow buying this by default */
            allowBuyT1T2boosts: false,
        },
        credits: {
            mustSellDirectBelow: 5000,
            canPlaceSellOrdersAbove: 2000,
            canBuyAbove: 10000,
            canBuyPassivelyAbove: 50000,
            canBuyBoostsAbove: 5 * Math.max(RESERVE_CREDITS, 1e5),
            canBuyEnergyAbove: 10 * Math.max(RESERVE_CREDITS, 1e5),
        },
        orders: {
            /** Remove orders after this many ticks if remaining amount < cleanupAmount */
            timeout: 500000,
            /** RemainingAmount threshold to remove expiring orders */
            cleanupAmount: 100,
            maxEnergySellOrders: 5,
            maxEnergyBuyOrders: 5,
            maxOrdersPlacedPerTick: 7,
            maxOrdersForResource: 20,
            minSellOrderAmount: 1000,
            maxSellOrderAmount: 25000,
            minSellDirectAmount: 250,
            maxSellDirectAmount: 10000,
            minBuyOrderAmount: 250,
            maxBuyOrderAmount: 25000,
            minBuyDirectAmount: 500,
            maxBuyDirectAmount: 10000,
        },
    },
};
TraderJoe = TraderJoe_1 = __decorate$1([
    profile,
    assimilationLocked
], TraderJoe);

// A stripped-down version of the logistics network intended for local deliveries
/**
 * Transport request groups handle close-range prioritized resource requests, in contrast to the logistics network,
 * which handles longer-ranged requests
 */
let TransportRequestGroup = class TransportRequestGroup {
    static logRequest(request) {
        if (!request) {
            return `not a request`;
        }
        return `${request.amount} of ${request.resourceType} in ${request.target.print} at ${priorityToString(request.priority)} priority`;
    }
    constructor(name) {
        this.name = name;
        this.refresh();
    }
    refresh() {
        this.supply = blankPriorityQueue();
        this.withdraw = blankPriorityQueue();
        this.supplyByID = {};
        this.withdrawByID = {};
    }
    needsSupplying(priorityThreshold) {
        for (const priority in this.supply) {
            if (priorityThreshold != undefined &&
                parseInt(priority, 10) > priorityThreshold) {
                continue; // lower numerical priority values are more important; if priority > threshold then ignore it
            }
            if (this.supply[priority].length > 0) {
                return true;
            }
        }
        return false;
    }
    needsWithdrawing(priorityThreshold) {
        for (const priority in this.withdraw) {
            if (priorityThreshold != undefined &&
                parseInt(priority, 10) > priorityThreshold) {
                continue; // lower numerical priority values are more important; if priority > threshold then ignore it
            }
            if (this.withdraw[priority].length > 0) {
                return true;
            }
        }
        return false;
    }
    getPrioritizedClosestRequest(pos, type, filter) {
        const requests = type == "withdraw" ? this.withdraw : this.supply;
        for (const priority in requests) {
            const targets = _.map(requests[priority], (request) => request.target);
            const target = pos.findClosestByRangeThenPath(targets);
            if (target) {
                const searchRequests = filter ?
                    _.filter(requests[priority], (req) => filter(req))
                    : requests[priority];
                const request = _.find(searchRequests, (request) => request.target.ref == target.ref);
                // If this isn't a specific search, we don't fall through to lower priorities
                if (!filter || request) {
                    return request;
                }
            }
        }
    }
    isTargetValid(target) {
        if (target.pos.availableNeighbors(true).length === 0) {
            return false;
        }
        return true;
    }
    /**
     * Request for resources to be deposited into this target
     */
    requestInput(target, priority = Priority.Normal, opts = {}) {
        var _a, _b;
        var _c, _d;
        _.defaults(opts, {
            resourceType: RESOURCE_ENERGY,
        });
        if (!this.isTargetValid(target)) {
            log.warning(`Transport request error: target input ${target.print} is invalid`);
            return;
        }
        (_a = opts.amount) !== null && _a !== void 0 ? _a : (opts.amount = this.getInputAmount(target, opts.resourceType));
        // Register the request
        const req = {
            target: target,
            resourceType: opts.resourceType,
            amount: opts.amount,
            priority: priority,
        };
        if (opts.amount > 0) {
            this.supply[priority].push(req);
            (_b = (_c = this.supplyByID)[_d = target.id]) !== null && _b !== void 0 ? _b : (_c[_d] = []);
            this.supplyByID[target.id].push(req);
        }
    }
    /**
     * Request for resources to be withdrawn from this target
     */
    requestOutput(target, priority = Priority.Normal, opts = {}) {
        var _a, _b;
        var _c, _d;
        _.defaults(opts, {
            resourceType: RESOURCE_ENERGY,
        });
        if (!this.isTargetValid(target)) {
            log.warning(`Transport request error: target output ${target.print} is invalid`);
            return;
        }
        (_a = opts.amount) !== null && _a !== void 0 ? _a : (opts.amount = this.getOutputAmount(target, opts.resourceType));
        // Register the request
        const req = {
            target: target,
            resourceType: opts.resourceType,
            amount: opts.amount,
            priority: priority,
        };
        if (opts.amount > 0) {
            this.withdraw[priority].push(req);
            (_b = (_c = this.withdrawByID)[_d = target.id]) !== null && _b !== void 0 ? _b : (_c[_d] = []);
            this.withdrawByID[target.id].push(req);
        }
    }
    // /* Makes a provide for every resourceType in a requestor object */
    // requestOutputAll(target: StoreStructure,
    //	priority = Priority.Normal, opts = {} as TransportRequestOptions): void {
    // 	for (let resourceType in target.store) {
    // 		let amount = target.store[<ResourceConstant>resourceType] || 0;
    // 		if (amount > 0) {
    // 			opts.resourceType = <ResourceConstant>resourceType;
    // 			this.requestOutput(target, priority, opts);
    // 		}
    // 	}
    // }
    getInputAmount(target, resourceType) {
        return target.store.getFreeCapacity(resourceType) || 0;
    }
    getOutputAmount(target, resourceType) {
        return target.store.getUsedCapacity(resourceType) || 0;
    }
    /**
     * Summarize the state of the transport request group to the console; useful for debugging.
     */
    summarize(ignoreEnergy = false) {
        console.log(`TransportRequestGroup #${this.name}`);
        console.log(`Supply requests ==========================`);
        for (const priority in this.supply) {
            if (this.supply[priority].length > 0) {
                console.log(`Priority: ${priorityToString(priority)}`);
            }
            for (const request of this.supply[priority]) {
                if (ignoreEnergy && request.resourceType == RESOURCE_ENERGY) {
                    continue;
                }
                console.log(`    target: ${request.target.structureType}@${request.target.pos.print} ` +
                    `(${request.target.ref})  ` +
                    `amount: ${request.amount}  ` +
                    `resourceType: ${request.resourceType}`);
            }
        }
        console.log(`Withdraw requests ========================`);
        for (const priority in this.withdraw) {
            if (this.withdraw[priority].length > 0) {
                console.log(`Priority: ${priorityToString(priority)}`);
            }
            for (const request of this.withdraw[priority]) {
                if (ignoreEnergy && request.resourceType == RESOURCE_ENERGY) {
                    continue;
                }
                console.log(`    target: ${request.target.structureType}@${request.target.pos.print} ` +
                    `(${request.target.ref})  ` +
                    `amount: ${request.amount}  ` +
                    `resourceType: ${request.resourceType}`);
            }
        }
    }
};
TransportRequestGroup = __decorate$1([
    profile
], TransportRequestGroup);

/**
 * Default ordering for processing spawning requests and prioritizing overlords
 */
const OverlordPriority = {
    emergency: {
        // Colony-wide emergencies such as a catastrohic crash
        bootstrap: 0,
    },
    core: {
        // Functionality related to spawning more creeps
        queen: 100,
        manager: 101,
    },
    powerCreeps: {
        default: 150,
    },
    defense: {
        // Defense of local and remote rooms
        meleeDefense: 200,
        rangedDefense: 201,
    },
    outpostDefense: {
        outpostDefense: 250,
        guard: 251,
        reserve: 252,
    },
    scouting: {
        stationary: 290,
        randomWalker: 291,
    },
    warSpawnCutoff: 299, // Everything past this is non-critical and won't be spawned in case of emergency
    offense: {
        // Offensive operations like raids or sieges
        destroy: 300,
        healPoint: 301,
        siege: 302,
        controllerAttack: 399,
    },
    priorityOwnedRoom: {
        // Situationally prioritized in-room operations
        priorityUpgrade: 450,
        priorityTransport: 451,
        prioritySKReaper: 452,
    },
    ownedRoom: {
        // Operation of an owned room
        firstTransport: 500, // High priority to spawn the first transporter
        mine: 501,
        work: 502,
        mineralRCL8: 503,
        transport: 504, // Spawn the rest of the transporters
        mineral: 505,
    },
    /**
     * Operation of a remote room. Allows colonies to restart one room at a time.
     * The increment is such that 510 + 2 * (number of rooms at range 2 = 24) = 558
     */
    remoteRoom: {
        mine: 510,
        reserve: 511,
        transport: 513,
        roomIncrement: 2,
    },
    /** Everything past this will be ignored when incubating another colony */
    incubationThreshold: 550,
    /** Spawning upgraders */
    upgrading: {
        upgrade: 506,
        additional: 560,
    },
    throttleThreshold: 599, // Everything past this may be throttled in the event of low CPU
    outpostOffense: {
        harass: 600,
        roomPoisoner: 601,
    },
    collectionUrgent: {
        // Collecting resources that are time sensitive, like decaying resources on ground
        haul: 700,
    },
    colonization: {
        // Colonizing new rooms
        claim: 850,
        pioneer: 851,
        remoteUpgrading: 860,
    },
    remoteSKRoom: {
        sourceReaper: 1000,
        mineral: 1001,
        mine: 1002,
        roomIncrement: 5,
    },
    powerMine: {
        cool: 1050,
        drill: 1051,
        roomIncrement: 2,
    },
    deposit: {
        gatherer: 1080,
    },
    tasks: {
        // Non-urgent tasks, such as collection from a deserted storage
        haul: 1100,
        dismantle: 1101,
    },
    default: 99999, // Default overlord priority to ensure it gets run last
};

/**
 * Tasks class provides conveient wrappers for dispensing new Task instances
 */
let Tasks$1 = class Tasks {
    static chain(tasks, setNextPos = true) {
        if (tasks.length == 0) {
            // log.error(`Tasks.chain was passed an empty array of tasks!`);
            return null;
        }
        if (setNextPos) {
            for (let i = 0; i < tasks.length - 1; i++) {
                tasks[i].data.nextPos = tasks[i + 1].targetPos;
            }
        }
        // Make the accumulator task from the end and iteratively fork it
        let task = _.last(tasks); // start with last task
        tasks = _.dropRight(tasks); // remove it from the list
        for (let i = tasks.length - 1; i >= 0; i--) {
            // iterate over the remaining tasks
            task = task.fork(tasks[i]);
        }
        return task;
    }
    static attack(target, options = {}) {
        return new TaskAttack(target, options);
    }
    static build(target, options = {}) {
        return new TaskBuild(target, options);
    }
    static claim(target, options = {}) {
        return new TaskClaim(target, options);
    }
    static dismantle(target, options = {}) {
        return new TaskDismantle(target, options);
    }
    static drop(target, resourceType = RESOURCE_ENERGY, amount, options = {}) {
        return new TaskDrop(target, resourceType, amount, options);
    }
    // static flee(target: fleeTargetType, options: TaskOptions = {}) {
    // 	return new TaskFlee(target, options);
    // }
    static fortify(target, hitsMax, options = {}) {
        return new TaskFortify(target, hitsMax, options);
    }
    static getBoosted(target, boostType, amount, options = {}) {
        return new TaskGetBoosted(target, boostType, amount, options);
    }
    static getRenewed(target, options = {}) {
        return new TaskGetRenewed(target, options);
    }
    static goTo(target, options = {}) {
        return new TaskGoTo(target, options);
    }
    static goToRoom(target, options = {}) {
        return new TaskGoToRoom(target, options);
    }
    static harvest(target, options = {}) {
        return new TaskHarvest(target, options);
    }
    static heal(target, options = {}) {
        return new TaskHeal(target, options);
    }
    static meleeAttack(target, options = {}) {
        return new TaskMeleeAttack(target, options);
    }
    static pickup(target, options = {}) {
        return new TaskPickup(target, options);
    }
    static rangedAttack(target, options = {}) {
        return new TaskRangedAttack(target, options);
    }
    static recharge(minEnergy = 0, options = {}) {
        return new TaskRecharge(minEnergy, options);
    }
    static repair(target, options = {}) {
        return new TaskRepair(target, options);
    }
    static reserve(target, options = {}) {
        return new TaskReserve(target, options);
    }
    static signController(target, options = {}) {
        return new TaskSignController(target, options);
    }
    static transfer(target, resourceType = RESOURCE_ENERGY, amount, options = {}) {
        return new TaskTransfer(target, resourceType, amount, options);
    }
    static transferAll(target, skipEnergy = false, options = {}) {
        return new TaskTransferAll(target, skipEnergy, options);
    }
    static upgrade(target, options = {}) {
        return new TaskUpgrade(target, options);
    }
    static withdraw(target, resourceType = RESOURCE_ENERGY, amount, options = {}) {
        return new TaskWithdraw(target, resourceType, amount, options);
    }
    static withdrawAll(target, options = {}) {
        return new TaskWithdrawAll(target, options);
    }
    static generateSafeMode(target, options = {}) {
        return new TaskGenerateSafeMode(target, options);
    }
    static retire(target, options = {}) {
        return new TaskRetire(target, options);
    }
};
Tasks$1 = __decorate$1([
    profile
], Tasks$1);
global.Tasks = Tasks$1;

const SUSPENSION_OVERFILL_DEFAULT_DURATION = 50;
const SUSPENSION_STRONGHOLD_DEFAULT_DURATION = 5000;
var SuspensionReason;
(function (SuspensionReason) {
    /** CPU is too limited */
    SuspensionReason["cpu"] = "cpu";
    /** Colony can't sustain this remote because rebooting, spawn pressure, etc */
    SuspensionReason["upkeep"] = "upkeep";
    SuspensionReason["harassment"] = "harassment";
    /** Controller has been reserved/claimed from us */
    SuspensionReason["reserved"] = "reserved";
    /** A stronghold had popped up in the room */
    SuspensionReason["stronghold"] = "stronghold";
    /** Colony is currently overfilled */
    SuspensionReason["overfilled"] = "overfilled";
})(SuspensionReason || (SuspensionReason = {}));
/**
 * Get the suspension reason
 *
 * If the object is undefined, or marked as active, return false.
 * If the object has a reason for being suspended, return that reason.
 * Otherwise, the object has been manually suspended, return true.
 */
function suspensionReason(obj) {
    // Consider the overlord active if the room it's in isn't part of a colony
    if (!obj || obj.active) {
        return false;
    }
    if (obj.suspendReason) {
        return obj.suspendReason;
    }
    return true;
}
/**
 * Mark the given object for suspension
 */
function suspend(obj, opts) {
    if (!obj) {
        return;
    }
    obj.active = false;
    if (opts === null || opts === void 0 ? void 0 : opts.reason) {
        obj.suspendReason = opts.reason;
    }
    if (opts === null || opts === void 0 ? void 0 : opts.until) {
        obj["X" /* MEM.EXPIRATION */] = opts.until;
    }
    else if (opts === null || opts === void 0 ? void 0 : opts.duration) {
        obj["X" /* MEM.EXPIRATION */] = Game.time + opts.duration;
    }
}
/**
 * Unsuspend the object
 */
function unsuspend(obj) {
    if (!obj) {
        return;
    }
    obj.active = true;
    delete obj.suspendReason;
    delete obj["X" /* MEM.EXPIRATION */];
}
/**
 * Check the suspension expiration
 *
 * If the object is not active, has a suspension reason and it's expired, unsuspend it and return true.
 * Otherwise, return false
 *
 */
function expireSuspension(obj, force = false) {
    var _a;
    if ((obj &&
        !obj.active &&
        obj.suspendReason &&
        Game.time >= ((_a = obj["X" /* MEM.EXPIRATION */]) !== null && _a !== void 0 ? _a : Infinity)) ||
        force) {
        unsuspend(obj);
        return true;
    }
    return false;
}

const FIND_EXIT_PORTAL = 42;
const TERRAIN_PLAIN_DEFAULT_COST = 1;
const TERRAIN_SWAMP_DEFAULT_COST = 5;
const MatrixTypes = {
    direct: "dir",
    default: "def",
    sk: "sk",
    obstacle: "obst",
    preferRampart: "preframp",
    nearRampart: "nearRamp",
};

/**
 * Returns destination.pos if destination has a position, or destination if destination is a RoomPosition
 */
function normalizePos(destination) {
    return destination.pos || destination;
}
/**
 * Returns if the coordinate is at the edge of a room. Does not explicitly check if the position is an exit tile.
 */
function isExit(pos) {
    return pos.x == 0 || pos.y == 0 || pos.x == 49 || pos.y == 49;
}
/**
 * Checks if the coordinates of two room positions are the same
 */
function sameCoord(pos1, pos2) {
    return pos1.x == pos2.x && pos1.y == pos2.y;
}
/**
 * Returns the number of move parts and number of weight-generating parts in a creep
 */
function getCreepWeightInfo(creep, analyzeCarry = true, fullCarry = false) {
    // Compute number of weighted and unweighted bodyparts
    const unweightedParts = analyzeCarry ? [MOVE, CARRY] : [MOVE];
    const bodyParts = _.countBy(creep.body, (p) => _.contains(unweightedParts, p.type) ? p.type : "weighted");
    bodyParts.move = bodyParts.move || 0;
    bodyParts.weighted = bodyParts.weighted || 0;
    if (analyzeCarry && bodyParts[CARRY]) {
        bodyParts.weighted += Math.ceil(bodyParts[CARRY] *
            (fullCarry ? 1 : (creep.store.getUsedCapacity() / creep.store.getCapacity())));
    }
    // Account for boosts
    for (const part of creep.body) {
        if (part.type == MOVE && part.boost) {
            bodyParts.move += BOOSTS.move[part.boost].fatigue - 1;
        }
    }
    return bodyParts;
}
const getDefaultTerrainCosts = () => ({
    plainCost: TERRAIN_PLAIN_DEFAULT_COST,
    swampCost: TERRAIN_SWAMP_DEFAULT_COST,
    roadCost: "auto",
});
/**
 * Get terrain costs which take into account a creep's individual fatigue stats
 */
function getTerrainCosts(creep, fullCarry = false) {
    if (isStandardZerg(creep)) {
        const data = getCreepWeightInfo(creep.creep, true, fullCarry);
        const fatigueRatio = data.weighted / data.move;
        const costs = {
            plainCost: Math.max(Math.ceil(fatigueRatio), 1),
            swampCost: Math.max(Math.ceil(5 * fatigueRatio), 1),
        };
        // If there's a disadvantage in swamps over plains, or creep is combat-creep, allow road usage
        if (costs.plainCost !== costs.swampCost || isCombatZerg(creep)) {
            costs.roadCost = "auto";
        }
        return costs;
    }
    else if (isPowerZerg(creep)) {
        return { plainCost: 1, swampCost: 1 };
    }
    return getDefaultTerrainCosts();
}
// @ts-expect-error global
global.getTerrainCosts = getTerrainCosts;

/* tslint:disable: max-line-length */
const asciiLogo = [
    "___________________________________________________________",
    "",
    " _____  _    _ _______  ______ _______ _____ __   _ ______ ",
    "|     |  \\  /  |______ |_____/ |  |  |   |   | \\  | |     \\",
    "|_____|   \\/   |______ |    \\_ |  |  | __|__ |  \\_| |_____/",
    "",
    "_______________________ Screeps AI ________________________",
];
const asciiLogoSmall = [
    " _____  _    _ _______  ______ _______ _____ __   _ ______ ",
    "|     |  \\  /  |______ |_____/ |  |  |   |   | \\  | |     \\",
    "|_____|   \\/   |______ |    \\_ |  |  | __|__ |  \\_| |_____/",
];
const asciiLogoRL = [
    " _____  _    _ _______  ______ _______ _____ __   _ ______ ",
    "|     |  \\  /  |______ |_____/ |  |  |   |   | \\  | |     \\",
    "|_____|   \\/   |______ |    \\_ |  |  | __|__ |  \\_| |_____/",
    "....... R E I N F O R C E M E N T   L E A R N I N G .......",
];
const _logoComponents = {
    black: {
        style: { fill: "#000000", stroke: "#000000", strokeWidth: 0 },
        points: [
            [-4.4, -0.34],
            [-3.44, -1.04],
            [-3.08, -1.04],
            [-2.78, -0.82],
            [-2.7, -0.6],
            [-2.92, -0.24],
            [-3.36, -0.24],
            [-3.58, -0.5],
            [-3.8, -0.28],
            [-4.14, 0.42],
            [-4.22, 1.24],
            [-3.6, 0.42],
            [-2.98, 0.46],
            [-2.84, 0.72],
            [-2.9, 1.02],
            [-3.26, 1.22],
            [-3.68, 1.12],
            [-3.72, 1.22],
            [-3.76, 2.18],
            [-3.58, 2.9],
            [-3.22, 1.8],
            [-2.72, 1.66],
            [-2.4, 2.08],
            [-2.64, 2.44],
            [-3.1, 2.42],
            [-3.1, 2.86],
            [-2.86, 3.4],
            [-2.52, 3.74],
            [-2.58, 3.08],
            [-2.34, 2.86],
            [-1.98, 2.82],
            [-1.48, 3.12],
            [-1.34, 3.72],
            [-1.64, 4.16],
            [-2.08, 4.32],
            [-2.78, 4.24],
            [-3.4, 3.84],
            [-3.02, 4.34],
            [-2.56, 4.6],
            [-0.94, 4.78],
            [4.0e-2, 4.5],
            [0.86, 3.9],
            [-0.44, 3.18],
            [-0.46, 2.86],
            [0.88, 2.84],
            [2.02, 3.2],
            [3.1, 2.22],
            [4.18, 0.6],
            [4.54, -1],
            [3.84, 0],
            [3.5, 0.12],
            [3.18, 2.0e-2],
            [3.14, -0.46],
            [3.38, -0.6],
            [3.82, -0.5],
            [4, -0.94],
            [4.08, -1.88],
            [3.96, -2.6],
            [3.56, -1.54],
            [3.16, -1.22],
            [2.78, -1.28],
            [2.6, -1.6],
            [2.7, -1.88],
            [2.96, -2.02],
            [3.4, -1.92],
            [3.46, -2.12],
            [3.38, -2.98],
            [2.9, -3.98],
            [2.52, -4.32],
            [2.7, -3.58],
            [2.54, -2.82],
            [2.22, -2.38],
            [1.7, -2.36],
            [1.48, -2.64],
            [1.56, -3.1],
            [2.18, -3.24],
            [1.94, -3.9],
            [1.2, -4.62],
            [0.14, -5.14],
            [0.88, -4.18],
            [0.9, -3.54],
            [0.66, -3.04],
            [0.3, -2.82],
            [-0.14, -2.9],
            [-0.2, -3.42],
            [0.28, -3.66],
            [-0.38, -4.16],
            [-1.26, -4.32],
            [-2.4, -4.22],
            [-1.64, -4.02],
            [-1.08, -3.64],
            [-0.82, -3.04],
            [-0.88, -2.56],
            [-1.12, -2.4],
            [-1.5, -2.44],
            [-1.68, -2.7],
            [-1.56, -3.12],
            [-1.84, -3.2],
            [-2.72, -3.16],
            [-3.44, -2.84],
            [-3.98, -2.34],
            [-3.38, -2.5],
            [-2.48, -2.36],
            [-2.12, -2.12],
            [-2.06, -1.7],
            [-2.18, -1.52],
            [-2.56, -1.44],
            [-2.82, -1.6],
            [-2.84, -2.06],
            [-3.38, -1.84],
            [-4.06, -1.18],
            [-4.4, -0.36],
        ],
    },
    blue: {
        style: { fill: "#6482B0", stroke: "#6482B0", strokeWidth: 0 },
        points: [
            [-2.48, -0.72],
            [-1.5, -0.34],
            [-1.18, -0.88],
            [-0.74, -1.24],
            [-6.0e-2, -1.46],
            [0.54, -1.44],
            [0.94, -1.34],
            [1.82, -0.46],
            [2.74, -0.9],
            [2.92, -0.42],
            [3.02, 0.32],
            [2.9, 1.02],
            [2.52, 1.86],
            [1.94, 2.5],
            [1.2, 2.94],
            [0.82, 2.02],
            [1.32, 1.72],
            [1.56, 1.48],
            [1.8, 1.1],
            [1.98, 0.44],
            [1.94, 0],
            [1.8, -0.46],
            [0.94, -1.36],
            [1.34, -2.3],
            [0.5, -2.54],
            [-0.12, -2.54],
            [-0.86, -2.36],
            [-1.38, -2.1],
            [-1.82, -1.76],
            [-2.26, -1.22],
            [-2.48, -0.74],
        ],
    },
    red: {
        style: { fill: "#EA3747", stroke: "#EA3747", strokeWidth: 0 },
        points: [
            [0.94, -1.3],
            [1.28, -1.08],
            [1.58, -0.78],
            [1.78, -0.46],
            [2.7, -0.92],
            [2.72, -1],
            [2.44, -1.46],
            [2.02, -1.9],
            [1.42, -2.28],
            [0.94, -1.32],
        ],
    },
    pink: {
        style: { fill: "#FF0080", stroke: "#FF0080", strokeWidth: 0 },
        points: [
            [-1.4, 0.32],
            [-0.92, 0.2],
            [-0.46, -6.0e-2],
            [-8.0e-2, -0.5],
            [0.12, -0.98],
            [0.14, -1.18],
            [0.2, -1.18],
            [0.22, -0.98],
            [0.4, -0.54],
            [0.8, -6.0e-2],
            [1.26, 0.2],
            [1.74, 0.32],
            [1.62, 0.3],
            [1.62, 0.36],
            [1.26, 0.44],
            [0.78, 0.72],
            [0.38, 1.22],
            [0.18, 1.84],
            [-6.0e-2, 1.18],
            [-0.46, 0.7],
            [-0.92, 0.44],
            [-1.38, 0.34],
        ],
    },
    lgray: {
        style: { fill: "#ABB7C5", stroke: "#ABB7C5", strokeWidth: 0 },
        points: [
            [-2.64, 1.04],
            [-2.34, 1.78],
            [-2.06, 2.18],
            [-1.56, 2.64],
            [-0.98, 2.96],
            [-0.62, 3.08],
            [-0.52, 3.06],
            [-0.28, 2.06],
            [-0.72, 1.88],
            [-1.06, 1.62],
            [-1.36, 1.26],
            [-1.58, 0.76],
            [-2.56, 0.94],
            [-2.64, 1.02],
        ],
    },
    purple: {
        style: { fill: "#2F0092", stroke: "#2F0092", strokeWidth: 0 },
        points: [
            [-1.48, 0.4],
            [-1.38, -0.24],
            [-1.04, -0.8],
            [-0.46, -1.2],
            [0.22, -1.32],
            [0.14, -1.24],
            [0.1, -0.94],
            [-8.0e-2, -0.52],
            [-0.42, -0.1],
            [-0.84, 0.16],
            [-1.4, 0.3],
            [-0.94, 0.44],
            [-0.34, 0.82],
            [4.0e-2, 1.4],
            [0.18, 1.88],
            [0.32, 1.36],
            [0.72, 0.78],
            [1.28, 0.44],
            [1.74, 0.34],
            [1.06, 0.1],
            [0.6, -0.26],
            [0.24, -0.94],
            [0.2, -1.24],
            [0.28, -1.32],
            [0.74, -1.22],
            [1.18, -0.98],
            [1.46, -0.7],
            [1.72, -0.24],
            [1.82, 0.26],
            [1.78, 0.68],
            [1.6, 1.14],
            [1.28, 1.54],
            [0.84, 1.82],
            [0.46, 1.94],
            [0.18, 1.98],
            [-0.46, 1.84],
            [-0.82, 1.64],
            [-1.22, 1.2],
            [-1.4, 0.82],
            [-1.46, 0.4],
        ],
    },
    dgray: {
        style: { fill: "#303030", stroke: "#303030", strokeWidth: 0 },
        points: [
            [-2.42, 0.52],
            [-2.4, -8.0e-2],
            [-2.28, -0.56],
            [-1.52, -0.3],
            [-1.62, 0.24],
            [-1.58, 0.7],
            [-0.2, 2.06],
            [0.34, 2.1],
            [0.8, 2.02],
            [1.06, 2.7],
            [1.04, 2.78],
            [0.54, 2.92],
            [6.0e-2, 2.94],
            [-0.42, 2.86],
            [-0.22, 2.06],
            [-0.26, 2.08],
            [-1.6, 0.7],
            [-2.36, 0.86],
            [-2.4, 0.52],
        ],
    },
};
const _logoText = {
    V: {
        coords: [75, 500],
        style: { fill: "#6b6b6b", stroke: "#6b6b6b", strokeWidth: 0 },
        points: [
            [-3.94, -3.7],
            [-3.72, -3.86],
            [-3.58, -3.68],
            [-1, 2.54],
            [-0.62, 2.9],
            [-0.16, 2.96],
            [0.46, 2.6],
            [3.1, -3.72],
            [3.38, -3.82],
            [3.4, -3.56],
            [0.86, 2.52],
            [0.48, 3.04],
            [0, 3.26],
            [-0.66, 3.22],
            [-1.26, 2.72],
            [-3.92, -3.68],
        ],
    },
    E: {
        coords: [500, 880],
        style: { fill: "#6b6b6b", stroke: "#6b6b6b", strokeWidth: 0 },
        points: [
            [-4.28, 0.52],
            [-4.1, 1.3],
            [-3.7, 2.04],
            [-3.12, 2.64],
            [-2.4, 3.06],
            [-1.64, 3.26],
            [1.4, 3.2],
            [1.4, 3],
            [1.16, 2.9],
            [-1.5, 2.92],
            [-2.2, 2.76],
            [-3.14, 2.16],
            [-3.76, 1.2],
            [-3.92, 0.52],
            [-3.84, -0.12],
            [0.84, -0.12],
            [0.96, -0.24],
            [0.78, -0.48],
            [-3.9, -0.48],
            [-3.92, -1.12],
            [-3.7, -1.94],
            [-3.26, -2.62],
            [-2.6, -3.16],
            [-1.46, -3.52],
            [1.38, -3.56],
            [1.4, -3.8],
            [1.2, -3.88],
            [-1.42, -3.88],
            [-2.82, -3.44],
            [-3.88, -2.36],
            [-4.28, -1.12],
            [-4.26, 0.52],
        ],
    },
    R1: {
        coords: [850, 1000],
        style: { fill: "#6b6b6b", stroke: "#6b6b6b", strokeWidth: 0 },
        points: [
            [-4.36, 3.1],
            [-4.36, -2.56],
            [-4.26, -2.96],
            [-3.82, -3.56],
            [-3.38, -3.8],
            [-1.88, -3.88],
            [-1.78, -3.5],
            [-3.2, -3.48],
            [-3.58, -3.3],
            [-3.88, -2.94],
            [-4, -2.54],
            [-4, 0.3],
            [-1.78, 0.36],
            [-1.9, 0.38],
            [-1.96, 0.72],
            [-1.78, 0.74],
            [-3.98, 0.74],
            [-3.98, 3.06],
            [-4.1, 3.26],
            [-4.3, 3.24],
            [-4.34, 3.1],
        ],
    },
    R2: {
        coords: [1000, 1200],
        style: { fill: "#6b6b6b", stroke: "#6b6b6b", strokeWidth: 0 },
        points: [
            [-4.78, 0.74],
            [-4.78, 0.36],
            [-3.1, 0.36],
            [-2.22, -2.0e-2],
            [-1.62, -0.78],
            [-1.46, -1.78],
            [-1.74, -2.58],
            [-2.38, -3.22],
            [-3.28, -3.52],
            [-4.78, -3.5],
            [-4.7, -3.86],
            [-4.78, -3.88],
            [-3.12, -3.86],
            [-2.12, -3.48],
            [-1.62, -3.02],
            [-1.26, -2.42],
            [-1.1, -1.78],
            [-1.2, -0.88],
            [-1.56, -0.18],
            [-2.04, 0.3],
            [-2.64, 0.62],
            [-3.4, 0.8],
            [-1.22, 2.96],
            [-1.22, 3.24],
            [-1.44, 3.26],
            [-3.94, 0.74],
            [-4.76, 0.72],
        ],
    },
    M: {
        coords: [1200, 1799],
        style: { fill: "#6b6b6b", stroke: "#6b6b6b", strokeWidth: 0 },
        points: [
            [-3.82, 3.14],
            [-3.6, 3.28],
            [-3.48, 3.08],
            [-2.52, -3.48],
            [-2.26, -3.52],
            [-2.1, -3.34],
            [0.28, 3.04],
            [0.56, 3.26],
            [0.9, 3.28],
            [1.3, 2.92],
            [3.62, -3.34],
            [3.88, -3.54],
            [4.14, -3.3],
            [5.02, 3.16],
            [5.28, 3.26],
            [4.44, -3.4],
            [4.28, -3.7],
            [3.98, -3.84],
            [3.56, -3.76],
            [3.34, -3.48],
            [1.02, 2.78],
            [0.78, 2.98],
            [0.52, 2.82],
            [-1.88, -3.6],
            [-2.24, -3.84],
            [-2.78, -3.68],
            [-3.8, 3.12],
        ],
    },
    I: {
        coords: [1750, 1850],
        style: { fill: "#6b6b6b", stroke: "#6b6b6b", strokeWidth: 0 },
        points: [
            [-4.58, 3.1],
            [-4.32, 3.26],
            [-4.2, 3.06],
            [-4.2, -3.66],
            [-4.46, -3.86],
            [-4.58, -3.7],
            [-4.56, 3.1],
        ],
    },
    N: {
        coords: [1850, 2250],
        style: { fill: "#6b6b6b", stroke: "#6b6b6b", strokeWidth: 0 },
        points: [
            [-4.46, 3.16],
            [-4.46, -3.4],
            [-4.34, -3.66],
            [-3.88, -3.88],
            [-3.4, -3.64],
            [1.52, 2.74],
            [1.84, 2.96],
            [2.12, 2.64],
            [2.12, -3.76],
            [2.36, -3.82],
            [2.42, 2.8],
            [2.28, 3.08],
            [1.66, 3.26],
            [1.38, 3.08],
            [-3.62, -3.4],
            [-3.96, -3.54],
            [-4.16, -3.28],
            [-4.16, 3.16],
            [-4.44, 3.18],
        ],
    },
    D: {
        coords: [2250, 2700],
        style: { fill: "#6b6b6b", stroke: "#6b6b6b", strokeWidth: 0 },
        points: [
            [-4.12, 1.82],
            [-3.76, 2.78],
            [-2.8, 3.28],
            [-0.36, 3.24],
            [0.3, 3.04],
            [1.14, 2.5],
            [1.78, 1.68],
            [2.08, 0.84],
            [2.04, -1.6],
            [1.68, -2.44],
            [1.06, -3.16],
            [0.28, -3.64],
            [-0.56, -3.86],
            [-2.88, -3.86],
            [-3, -3.82],
            [-2.92, -3.48],
            [-0.32, -3.46],
            [0.52, -3.12],
            [1.2, -2.52],
            [1.6, -1.84],
            [1.78, -1.1],
            [1.78, 0.54],
            [1.38, 1.68],
            [0.68, 2.42],
            [-0.38, 2.88],
            [-2.78, 2.92],
            [-3.5, 2.54],
            [-3.74, 1.98],
            [-3.74, -2.58],
            [-3.46, -3.18],
            [-2.94, -3.48],
            [-3.06, -3.82],
            [-3.72, -3.42],
            [-4.08, -2.72],
            [-4.1, 1.8],
        ],
    },
};
const logoX = 2.5; // x-position of logo
const logoY = 3.0; // y position of logo
const logoScale = 0.6;
const logoComponents = _.mapValues(_logoComponents, (c) => ({
    style: c.style,
    points: _.map(c.points, (xy) => [
        logoX + logoScale * xy[0],
        logoY + logoScale * xy[1],
    ]),
}));
const textX = logoX + 5.6 * logoScale; // x-position of logo
const textY = logoY + 0.5 * logoScale; // y position of logo
const textScale = 0.6 * logoScale;
const charScale = 0.052 * textScale;
let offset = 0;
const logoText = _.mapValues(_logoText, function (c) {
    const ret = {
        style: c.style,
        points: _.map(c.points, (xy) => [
            textX + textScale * (offset + xy[0]),
            textY + textScale * xy[1],
        ]),
    };
    offset += charScale * (c.coords[1] - c.coords[0]);
    return ret;
});

var Visualizer_1;
const TEXT_COLOR = "#c9c9c9";
const TEXT_SIZE = 0.8;
const CHAR_WIDTH = TEXT_SIZE * 0.4;
const CHAR_HEIGHT = TEXT_SIZE * 0.9;
/**
 * The Visualizer contains many static methods for drawing room visuals and displaying information through a GUI
 */
let Visualizer = Visualizer_1 = class Visualizer {
    static get enabled() {
        return Memory.settings.enableVisuals;
    }
    static textStyle(size = 1, style = {}) {
        return _.defaults(style, {
            color: TEXT_COLOR,
            align: "left",
            font: `${size * TEXT_SIZE} Trebuchet MS`,
            opacity: 0.8,
        });
    }
    static circle(pos, color = "red", opts = {}) {
        _.defaults(opts, {
            fill: color,
            radius: 0.35,
            opacity: 0.5,
        });
        return new RoomVisual(pos.roomName).circle(pos.x, pos.y, opts);
    }
    static rect(pos, color = "red", opts = {}) {
        _.defaults(opts, {
            fill: color,
            opacity: 0.5,
        });
        return new RoomVisual(pos.roomName).rect(pos.x, pos.y, 1, 1, opts);
    }
    static marker(pos, opts = {}) {
        return new RoomVisual(pos.roomName).animatedPosition(pos.x, pos.y, opts);
    }
    static drawStructureMap(structureMap) {
        if (!this.enabled) {
            return;
        }
        const vis = {};
        for (const structureType in structureMap) {
            for (const pos of structureMap[structureType]) {
                if (!vis[pos.roomName]) {
                    vis[pos.roomName] = new RoomVisual(pos.roomName);
                }
                vis[pos.roomName].structure(pos.x, pos.y, structureType);
            }
        }
        for (const roomName in vis) {
            vis[roomName].connectRoads();
        }
    }
    static drawLayout(layout, anchor, opts = {}) {
        if (!this.enabled) {
            return;
        }
        _.defaults(opts, { opacity: 0.5 });
        const vis = new RoomVisual(anchor.roomName);
        for (const structureType in layout[8].buildings) {
            for (const pos of layout[8].buildings[structureType].pos) {
                const dx = pos.x - layout.data.anchor.x;
                const dy = pos.y - layout.data.anchor.y;
                vis.structure(anchor.x + dx, anchor.y + dy, structureType, opts);
            }
        }
        vis.connectRoads(opts);
    }
    static drawRoads(positoins) {
        const pointsByRoom = _.groupBy(positoins, (pos) => pos.roomName);
        for (const roomName in pointsByRoom) {
            const vis = new RoomVisual(roomName);
            for (const pos of pointsByRoom[roomName]) {
                vis.structure(pos.x, pos.y, STRUCTURE_ROAD);
            }
            vis.connectRoads();
        }
    }
    static drawPath(path, style) {
        var _a, _b;
        for (let i = 0; i < path.length; i++) {
            const nextPos = path[i + 1];
            if (!nextPos) {
                break;
            }
            const pos = path[i];
            if (nextPos.roomName !== pos.roomName) {
                continue;
            }
            new RoomVisual(pos.roomName).line(pos, nextPos, {
                color: style === null || style === void 0 ? void 0 : style.fill,
                opacity: (_a = style === null || style === void 0 ? void 0 : style.opacity) !== null && _a !== void 0 ? _a : 0.2,
                lineStyle: (_b = style === null || style === void 0 ? void 0 : style.lineStyle) !== null && _b !== void 0 ? _b : "dashed",
            });
        }
    }
    static displayCostMatrix(matrix, roomName, opts = { dots: true, displayZero: true }) {
        opts = _.defaults(opts, { dots: true, displayZero: true });
        const vis = new RoomVisual(roomName);
        let x, y, cost, percentOfMax;
        let color;
        const maxVal = MatrixLib.getMaxValue(matrix) + 1;
        if (opts.dots) {
            for (y = 0; y < 50; ++y) {
                for (x = 0; x < 50; ++x) {
                    cost = matrix.get(x, y);
                    if (cost > 0) {
                        percentOfMax = Math.round((255 * cost) / maxVal);
                        color = rgbToHex(255, 255 - percentOfMax, 255 - percentOfMax);
                        vis.circle(x, y, {
                            radius: matrix.get(x, y) / maxVal / 2,
                            fill: color,
                        });
                    }
                }
            }
        }
        else {
            for (y = 0; y < 50; ++y) {
                for (x = 0; x < 50; ++x) {
                    cost = matrix.get(x, y);
                    if (opts.displayZero || cost != 0) {
                        percentOfMax = Math.round((255 * cost) / maxVal);
                        color = rgbToHex(255, 255 - percentOfMax, 255 - percentOfMax);
                        vis.text(matrix.get(x, y).toString(16).toUpperCase(), x, y + 0.3, { color: color });
                    }
                }
            }
        }
    }
    static showInfo(info, calledFrom, opts = {}) {
        if (calledFrom.room) {
            return calledFrom.room.visual.infoBox(info, calledFrom.pos.x, calledFrom.pos.y, opts);
        }
        else {
            return new RoomVisual(calledFrom.pos.roomName).infoBox(info, calledFrom.pos.x, calledFrom.pos.y, opts);
        }
    }
    static section(title, pos, width, height) {
        const vis = new RoomVisual(pos.roomName);
        vis.rect(pos.x, pos.y - CHAR_HEIGHT, width, 1.1 * CHAR_HEIGHT, {
            opacity: 0.15,
        });
        vis.box(pos.x, pos.y - CHAR_HEIGHT, width, height + (1.1 + 0.25) * CHAR_HEIGHT, { color: TEXT_COLOR });
        vis.text(title, pos.x + 0.25, pos.y - 0.05, this.textStyle());
        return { x: pos.x + 0.25, y: pos.y + 1.1 * CHAR_HEIGHT };
    }
    static infoBox(header, content, pos, width) {
        // const vis = new RoomVisual(pos.roomName);
        // vis.rect(pos.x, pos.y - charHeight, width, 1.1 * charHeight, {opacity: 0.15});
        // vis.box(pos.x, pos.y - charHeight, width, ((content.length || 1) + 1.1 + .25) * charHeight,
        // 		{color: textColor});
        // vis.text(header, pos.x + .25, pos.y - .05, this.textStyle());
        const height = CHAR_HEIGHT * (content.length || 1);
        const { x, y } = this.section(header, pos, width, height);
        if (content.length > 0) {
            if (_.isArray(content[0])) {
                this.table(content, {
                    x: x,
                    y: y,
                    roomName: pos.roomName,
                });
            }
            else {
                this.multitext(content, {
                    x: x,
                    y: y,
                    roomName: pos.roomName,
                });
            }
        }
        // return pos.y - charHeight + ((content.length || 1) + 1.1 + .25) * charHeight + 0.1;
        const spaceBuffer = 0.5;
        return y + height + spaceBuffer;
    }
    static text(text, pos, size = 1, style = {}) {
        new RoomVisual(pos.roomName).text(text, pos.x, pos.y, this.textStyle(size, style));
    }
    static barGraph(progress, pos, width = 7, scale = 1, fmt) {
        const vis = new RoomVisual(pos.roomName);
        let percent;
        let mode;
        if (typeof progress === "number") {
            percent = progress;
            mode = "percent";
        }
        else {
            percent = progress[0] / progress[1];
            mode = "fraction";
        }
        // Draw frame
        vis.box(pos.x, pos.y - CHAR_HEIGHT * scale, width, 1.1 * scale * CHAR_HEIGHT, { color: TEXT_COLOR });
        vis.rect(pos.x, pos.y - CHAR_HEIGHT * scale, percent * width, 1.1 * scale * CHAR_HEIGHT, {
            fill: TEXT_COLOR,
            opacity: 0.4,
            strokeWidth: 0,
        });
        // Draw text
        if (mode == "percent") {
            const str = fmt ? fmt(percent) : `${Math.round(100 * percent)}%`;
            vis.text(str, pos.x + width / 2, pos.y - 0.1 * CHAR_HEIGHT, this.textStyle(1, { align: "center" }));
        }
        else {
            const [num, den] = progress;
            const nStr = fmt ? fmt(num) : `${num}`;
            const dStr = fmt ? fmt(den) : `${den}`;
            vis.text(`${nStr}/${dStr}`, pos.x + width / 2, pos.y - 0.1 * CHAR_HEIGHT, this.textStyle(1, { align: "center" }));
        }
    }
    static table(data, pos) {
        if (data.length == 0) {
            return;
        }
        const colPadding = 4;
        const vis = new RoomVisual(pos.roomName);
        const style = this.textStyle();
        // Determine column locations
        const columns = Array(_.first(data).length).fill(0);
        for (const entries of data) {
            for (let i = 0; i < entries.length - 1; i++) {
                columns[i] = Math.max(columns[i], entries[i].length);
            }
        }
        // // Draw header and underline
        // vis.text(header, pos.x, pos.y, style);
        // vis.line(pos.x, pos.y + .3 * charHeight,
        // 	pos.x + charWidth * _.sum(columns) + colPadding * columns.length, pos.y + .25 * charHeight, {
        // 			 color: textColor
        // 		 });
        // Draw text
        // let dy = 1.5 * charHeight;
        let dy = 0;
        for (const entries of data) {
            let dx = 0;
            for (let i = 0; i < entries.length; i++) {
                vis.text(entries[i], pos.x + dx, pos.y + dy, style);
                dx += CHAR_WIDTH * (columns[i] + colPadding);
            }
            dy += CHAR_HEIGHT;
        }
    }
    static multitext(lines, pos) {
        if (lines.length == 0) {
            return;
        }
        const vis = new RoomVisual(pos.roomName);
        const style = this.textStyle();
        // Draw text
        let dy = 0;
        for (const line of lines) {
            vis.text(line, pos.x, pos.y + dy, style);
            dy += CHAR_HEIGHT;
        }
    }
    static drawHUD() {
        // Draw Overmind logo
        new RoomVisual().multitext(asciiLogo, 0, 0, { textfont: "monospace" });
        // // Display CPU Information
        // new RoomVisual().text('CPU:' + ' bucket:' + Game.cpu.bucket +
        // 					  ' tickLimit:' + Game.cpu.tickLimit, column, row, style);
    }
    /* Draws the Overmind logo using component coordinates extracted with Mathematica. This  uses about 0.2 CPU/tick */
    static drawLogo() {
        new RoomVisual()
            .poly(logoComponents.black.points, logoComponents.black.style)
            .poly(logoComponents.dgray.points, logoComponents.dgray.style)
            .poly(logoComponents.lgray.points, logoComponents.lgray.style)
            .poly(logoComponents.blue.points, logoComponents.blue.style)
            .poly(logoComponents.red.points, logoComponents.red.style)
            .poly(logoComponents.purple.points, logoComponents.purple.style)
            .poly(logoComponents.pink.points, logoComponents.pink.style)
            .poly(logoText.V.points, logoText.V.style)
            .poly(logoText.E.points, logoText.E.style)
            .poly(logoText.R1.points, logoText.R1.style)
            .poly(logoText.R2.points, logoText.R2.style)
            .poly(logoText.M.points, logoText.M.style)
            .poly(logoText.I.points, logoText.I.style)
            .poly(logoText.N.points, logoText.N.style)
            .poly(logoText.D.points, logoText.D.style);
        Visualizer_1.text(`Colonies: ${_.keys(Overmind.colonies).length} | Creeps: ${_.keys(Game.creeps).length}`, { x: 1, y: 10 }, 0.93);
    }
    static drawNotifications(notificationMessages) {
        // const vis = new RoomVisual();
        const x = 10.5;
        const y = 7;
        if (notificationMessages.length == 0) {
            notificationMessages = ["No notifications"];
        }
        const maxStringLength = _.max(_.map(notificationMessages, (msg) => msg.length));
        const width = Math.max(16, 1.2 * CHAR_WIDTH * maxStringLength);
        this.infoBox("Notifications", notificationMessages, { x, y }, width);
    }
    // static colonyReport(colonyName: string, text: string[]) {
    // 	if (!this.enabled) return;
    // 	new RoomVisual(colonyName).multitext(text, 0, 4, {textfont: 'monospace', textsize: 0.75});
    // }
    static drawGraphs() {
        var _a;
        this.text(`CPU`, { x: 1, y: 7 });
        this.barGraph(((_a = Memory.stats.persistent.avgCPU) !== null && _a !== void 0 ? _a : 0) / Game.cpu.limit, {
            x: 2.75,
            y: 7,
        });
        this.text(`BKT`, { x: 1, y: 8 });
        this.barGraph(Game.cpu.bucket / 10000, { x: 2.75, y: 8 });
        this.text(`GCL`, { x: 1, y: 9 });
        this.barGraph(Game.gcl.progress / Game.gcl.progressTotal, {
            x: 2.75,
            y: 9,
        });
    }
    // This typically takes about 0.3-0.6 CPU in total
    static visuals() {
        this.drawLogo();
        this.drawGraphs();
        // this.drawNotifications();
    }
};
Visualizer = Visualizer_1 = __decorate$1([
    profile
], Visualizer);

/* eslint no-bitwise: "off" */
/* eslint @typescript-eslint/prefer-for-of: "off" */
var MatrixLib_1;
const getDefaultMatrixOptions = () => ({
    roomName: "none",
    roomVisible: false,
    explicitTerrainCosts: false,
    terrainCosts: {
        plainCost: 1,
        swampCost: 5,
        roadCost: undefined,
    },
    blockExits: false,
    avoidSK: true,
    allowPortals: false,
    ignoreStructures: false,
    swarmWidth: 1,
    swarmHeight: 1,
});
/** How old must a SK outpost be before we ignore SK creeps in it completely */
const AVOID_SKROOM_OUTPOST_AGE_THRESHOLD = 2500;
const AVOID_SPAWNING_KEEPER_LAIR_THRESHOLD = 50;
PERMACACHE.terrainMatrices = PERMACACHE.terrainMatrices || {};
const MatrixCache = {};
/**
 * MatrixLib contains an assortment of CostMatrix-related manipulation functions. I use C-style loops in most of this
 * library because even though they are ugly af, they are significantly (~20x!) faster than _.forEach or
 * for (const thing of things) { } loops.
 */
let MatrixLib = MatrixLib_1 = class MatrixLib {
    static getMatrix(roomName, opts, volatileOpts = {}) {
        // Copy the opts objects because we don't want to back-modify it
        opts = _.defaults(_.cloneDeep(opts), getDefaultMatrixOptions());
        volatileOpts = _.clone(volatileOpts);
        // Populate roomName and roomVisible properties
        const room = Game.rooms[roomName];
        opts.roomName = roomName;
        opts.roomVisible = !!room;
        // Generate a hash to look up any previously cached matrices
        const hash = MatrixLib_1.generateMatrixOptionsHash(opts);
        // Volatile hash gets added to hash; if no volatile options are specified; use empty string to not change hash
        const volatileHash = _.isEmpty(volatileOpts) ? "" : (MatrixLib_1.generateMatrixOptionsHash(volatileOpts));
        // If you have previously cached this matrix with volatile properties and it's still valid, return that
        // If no volatile opts are specified; the method will usually return from this block of code
        if (MatrixCache[hash + volatileHash]) {
            const expiration = MatrixCache[hash + volatileHash].expiration || Infinity;
            const invalidateCondition = MatrixCache[hash + volatileHash].invalidateCondition ||
                (() => false);
            if (Game.time >= expiration || invalidateCondition()) {
                delete MatrixCache[hash + volatileHash];
            }
            else {
                return MatrixCache[hash + volatileHash].matrix;
            }
        }
        let matrix;
        let expiration;
        let invalidateCondition;
        // If you've previously cached a matrix with the same non-volatile opts; start from there and then modify it
        if (MatrixCache[hash]) {
            expiration = MatrixCache[hash].expiration || Infinity;
            invalidateCondition =
                MatrixCache[hash].invalidateCondition || (() => false);
            if (Game.time >= expiration || invalidateCondition()) {
                delete MatrixCache[hash];
                matrix = undefined;
            }
            else {
                matrix = MatrixCache[hash].matrix;
            }
        }
        // Otherwise we'll build a base matrix for the non-volatile options, cache it, then modify it for volatile opts
        if (matrix === undefined) {
            matrix = MatrixLib_1.generateCostMatrixForRoom(room, opts);
            const roomOwner = RoomIntel$1.roomOwnedBy(roomName);
            if (Cartographer.roomType(roomName) == ROOMTYPE_SOURCEKEEPER) {
                expiration = Game.time + 10;
            }
            else if (roomOwner && !isAlly(roomOwner)) {
                expiration = Game.time + 25;
            }
            else {
                expiration = Game.time + 100;
            }
            if (opts.ignoreStructures) {
                invalidateCondition = () => false;
            }
            else {
                // Invalidate the path if the number of structures in the room changes
                let numStructures;
                if (room) {
                    numStructures = room.structures.length;
                }
                else {
                    const info = RoomIntel$1.getImportantStructureInfo(roomName);
                    if (!info) {
                        numStructures = 0;
                    }
                    else {
                        numStructures =
                            info.rampartPositions.length +
                                info.spawnPositions.length +
                                info.towerPositions.length +
                                info.wallPositions.length +
                                (info.storagePos ? 1 : 0) +
                                (info.terminalPos ? 1 : 0);
                    }
                }
                const wasHidden = !room;
                invalidateCondition = () => Game.rooms[roomName] &&
                    (wasHidden ||
                        Game.rooms[roomName].structures.length !=
                            numStructures);
            }
            // Cache the results for the non-volatile options
            MatrixCache[hash] = {
                matrix: matrix,
                generated: Game.time,
                expiration: expiration,
                invalidateCondition: invalidateCondition,
            };
        }
        // If there's no modifications we need to make, we're done, so return the matrix
        if (_.isEmpty(volatileOpts)) {
            return MatrixCache[hash].matrix;
        }
        // Otherwise, clone the matrix and apply volatile modifications, then cache it for this tick
        const clonedMatrix = matrix.clone();
        MatrixLib_1.applyVolatileModifications(clonedMatrix, opts, volatileOpts);
        // Cache the results for the non-volatile options
        MatrixCache[hash + volatileHash] = {
            matrix: clonedMatrix,
            generated: Game.time,
            expiration: Game.time + 1, // only sits around for this tick
            invalidateCondition: () => false, // invalidated next tick so we don't need an invalidation condition
        };
        return MatrixCache[hash + volatileHash].matrix;
    }
    /**
     * Generate a deterministic string hash that you can store a costmatrix with
     */
    static generateMatrixOptionsHash(opts) {
        return JSON.stringify(opts, Object.keys(opts).sort());
    }
    /**
     * Applies modificaitons to account for volatile options. Make sure to clone the matrix before passing it to this!
     */
    static applyVolatileModifications(clonedMatrix, opts, volatileOpts) {
        const room = Game.rooms[opts.roomName];
        // Block creep positions
        if (volatileOpts.blockCreeps) {
            if (room) {
                if (opts.swarmWidth > 1 || opts.swarmHeight > 1) {
                    MatrixLib_1.blockAfterMaxPooling(clonedMatrix, room.find(FIND_CREEPS), opts.swarmWidth, opts.swarmHeight);
                }
                else {
                    // use soft-block to avoid creeps but not result in unpathable errors
                    MatrixLib_1.softBlock(clonedMatrix, room.find(FIND_CREEPS), opts.roomName, 100);
                }
            }
        }
        // Block any other obstacles that might be specified
        if (volatileOpts.obstacles) {
            const obstacles = _.filter(volatileOpts.obstacles, (pos) => normalizePos(pos).roomName === opts.roomName);
            if (opts.swarmWidth > 1 || opts.swarmHeight > 1) {
                MatrixLib_1.blockAfterMaxPooling(clonedMatrix, obstacles, opts.swarmWidth, opts.swarmHeight);
            }
            else {
                MatrixLib_1.softBlock(clonedMatrix, obstacles, opts.roomName, 0xff);
            }
        }
        return clonedMatrix;
    }
    /**
     * Generates a cost matrix for a room based on the fully-specified matrix options
     */
    static generateCostMatrixForRoom(room, opts) {
        var _a;
        opts = _.defaults(opts, getDefaultMatrixOptions());
        const matrix = new PathFinder.CostMatrix();
        const roomName = opts.roomName;
        // Set road costs, usually to plainCost / 2
        if (opts.terrainCosts.roadCost) {
            if (opts.terrainCosts.roadCost == "auto") {
                opts.terrainCosts.roadCost = Math.ceil(opts.terrainCosts.plainCost / 2);
                const { plainCost: p, swampCost: s, roadCost: r, } = opts.terrainCosts;
                if ((r === p && r === s) ||
                    (r === p && p + 1 === s) ||
                    (r === s && p === s + 1)) {
                    opts.terrainCosts.plainCost++;
                    opts.terrainCosts.swampCost++;
                }
                else if (r === p) {
                    opts.terrainCosts.plainCost++;
                }
                else if (r === s) {
                    opts.terrainCosts.swampCost++;
                }
            }
        }
        // Explicitly specify the terrain costs if needed
        if (opts.explicitTerrainCosts) {
            MatrixLib_1.addTerrainCosts(matrix, roomName, opts.terrainCosts);
        }
        const tunnels = Cartographer.tunnelLocations(roomName);
        for (const pos of tunnels) {
            matrix.set(pos.x, pos.y, (_a = opts.terrainCosts.roadCost) !== null && _a !== void 0 ? _a : opts.terrainCosts.plainCost);
        }
        if (opts.terrainCosts.roadCost) {
            if (room) {
                for (const road of room.roads) {
                    matrix.set(road.pos.x, road.pos.y, opts.terrainCosts.roadCost);
                }
            }
        }
        // Mark the exits as unpathable
        if (opts.blockExits) {
            MatrixLib_1.blockExits(matrix);
        }
        // Avoid source keepers
        if (opts.avoidSK &&
            Cartographer.roomType(roomName) == ROOMTYPE_SOURCEKEEPER) {
            // Skip this step if we've been harvesting from the room for a while
            const skDirective = _.find(Overmind.overseer.getDirectivesInRoom(roomName), (dir) => dir.directiveName == "outpostSK"); // had to do this ungly thing due to circular dependency problems :(
            // const skDirective = _.first(DirectiveSKOutpost.findInRoom(roomName));
            const isOldOutpost = !!(skDirective &&
                skDirective.age > AVOID_SKROOM_OUTPOST_AGE_THRESHOLD);
            if (!isOldOutpost || !(room && room.sourceKeepers.length === 0)) {
                let avoidPositions = [];
                if (room) {
                    avoidPositions = avoidPositions.concat(..._.map(room.sourceKeepers, (keeper) => keeper.pos), ..._.map(room.keeperLairs.filter((lair) => (lair.ticksToSpawn || Infinity) <
                        AVOID_SPAWNING_KEEPER_LAIR_THRESHOLD), (lair) => lair.pos));
                }
                else {
                    const keeperLairInfo = RoomIntel$1.getKeeperLairInfo(roomName);
                    avoidPositions = _.compact(_.map(keeperLairInfo || [], (info) => info.chillPos));
                }
                MatrixLib_1.blockWithinRange(matrix, avoidPositions, 3);
            }
        }
        // Block or soft-block portals
        const portalPositions = room ?
            room.portals
            : _.map(RoomIntel$1.getPortalInfo(roomName), (portalInfo) => portalInfo.pos);
        if (opts.allowPortals) {
            MatrixLib_1.softBlock(matrix, portalPositions, roomName, MatrixLib_1.settings.portalCost);
        }
        else {
            MatrixLib_1.block(matrix, portalPositions);
        }
        // Block structure positions
        if (!opts.ignoreStructures) {
            if (room) {
                const impassibleStructures = _.filter(room.structures, (s) => !s.isWalkable);
                const impassibleConstructionSites = _.filter(room.constructionSites, (c) => !c.isWalkable);
                const alliedConstructionSites = _.filter(room.hostileConstructionSites, (c) => isAlly(c.owner.username));
                const blockPositions = _.map([
                    ...impassibleStructures,
                    ...impassibleConstructionSites,
                    ...alliedConstructionSites,
                ], (s) => s.pos);
                MatrixLib_1.block(matrix, blockPositions);
            }
            else {
                const owner = RoomIntel$1.roomOwnedBy(roomName) || "_noOwner_";
                const info = RoomIntel$1.getImportantStructureInfo(roomName);
                if (info) {
                    if (!isAlly(owner)) {
                        MatrixLib_1.block(matrix, info.rampartPositions);
                    }
                    MatrixLib_1.block(matrix, info.wallPositions);
                    MatrixLib_1.block(matrix, info.towerPositions);
                    MatrixLib_1.block(matrix, info.spawnPositions);
                    if (info.storagePos) {
                        MatrixLib_1.block(matrix, [info.storagePos]);
                    }
                    if (info.terminalPos) {
                        MatrixLib_1.block(matrix, [info.terminalPos]);
                    }
                }
            }
        }
        // Finally, as the very last step, we apply a smear to account for swarm size if greater than 1x1
        if (opts.swarmWidth > 1 || opts.swarmHeight > 1) {
            if (!opts.explicitTerrainCosts) {
                log.error(`Swarm matrix generation requires opts.explicitTerrainCosts! opts: ${JSON.stringify(opts)}`);
            }
            MatrixLib_1.applyMovingMaxPool(matrix, opts.swarmWidth, opts.swarmHeight);
        }
        // Tada!
        return matrix;
    }
    /**
     * Adds two matrices in-place on the first matrix. This method modifies the first matrix and does not modify the
     * second matrix. This method accesses the non-api CostMatrix._bits property so it may break in the future if they
     * modify the mechanics of cost matrices. See this file for details:
     * https://github.com/screeps/engine/blob/master/src/game/path-finder.js
     */
    static addMatrices(matrixToModify, addCosts) {
        for (let i = 0; i < 2500; i++) {
            matrixToModify._bits[i] = Math.min(Math.max(0, matrixToModify._bits[i] + addCosts._bits[i]), 255);
        }
        return matrixToModify;
    }
    /**
     * Quickly fills an entire matrix with a value. This method accesses the non-api CostMatrix._bits property so
     * it may break in the future if they modify the mechanics of cost matrices. See this file for details:
     * https://github.com/screeps/engine/blob/master/src/game/path-finder.js
     */
    static fillMatrix(matrixToModify, value) {
        value = Math.min(Math.max(0, value), 255);
        matrixToModify._bits.fill(value);
        return matrixToModify;
    }
    /**
     * Blocks all specified positions, setting their cost to 0xff
     */
    static block(matrix, positions) {
        let pos;
        for (let i = 0; i < positions.length; i++) {
            pos = normalizePos(positions[i]);
            matrix.set(pos.x, pos.y, 0xff);
        }
        return matrix;
    }
    /**
     * Sets the cost of all positions to a value if walls are not present and if the value is above the current value
     */
    static softBlock(matrix, positions, roomName, cost) {
        let pos;
        const terrain = Game.map.getRoomTerrain(roomName);
        for (let i = 0; i < positions.length; i++) {
            pos = normalizePos(positions[i]);
            if (terrain.get(pos.x, pos.y) & TERRAIN_MASK_WALL) {
                continue;
            }
            matrix.set(pos.x, pos.y, Math.max(cost, matrix.get(pos.x, pos.y)));
        }
        return matrix;
    }
    /**
     * Blocks all squares within a range (inclusive) of a list of positions, setting their cost to 0xff
     */
    static blockWithinRange(matrix, positions, range) {
        let x, y;
        let pos;
        for (let i = 0; i < positions.length; i++) {
            pos = positions[i];
            for (let dx = -range; dx <= range; dx++) {
                x = pos.x + dx;
                if (x < 0 || x > 49) {
                    continue;
                }
                for (let dy = -range; dy <= range; dy++) {
                    y = pos.y + dy;
                    if (y < 0 || y > 49) {
                        continue;
                    }
                    matrix.set(x, y, 0xff);
                }
            }
        }
        return matrix;
    }
    /**
     * Sets impassible structure positions to 0xff
     */
    static blockImpassibleStructures(matrix, room) {
        const impassibleStuctures = _.filter(room.find(FIND_STRUCTURES), (s) => !s.isWalkable);
        const blockPositions = _.map(impassibleStuctures, (s) => s.pos);
        MatrixLib_1.block(matrix, blockPositions);
        return matrix;
    }
    /**
     * Adds a pyramid-shaped potential to the cost matrix centered around the target position and extending to a
     * specified range with a maximum cost. MaxCost must be divisible by range+1 or an error is thrown. If
     * includeTerrainCosts=true (by default) then if the cost for a square is zero, the terrain cost of the tile is
     * added using default costs of {plain: 1, swamp: 5}. For example, the relevant portion of the return matrix of
     * MatrixLib.addPyramidPotential(zeroMatrix, pos, range=2, maxCost=6) is:
     *
     *     0 0 0 0 0 0 0
     *     0 2 2 2 2 2 0
     *     0 2 4 4 4 2 0
     *     0 2 4 6 4 2 0
     *     0 2 4 4 4 2 0
     *     0 2 2 2 2 2 0
     *     0 0 0 0 0 0 0
     */
    static addPyramidPotential(matrix, pos, range, maxCost, includeTerrain = true, // don't use includeTerrain with explicitTerrainCosts!
    terrainCosts = { plainCost: 1, swampCost: 5 }) {
        if (Math.floor(maxCost / range) != maxCost / range) {
            log.error(`MatrixLib.addPyramidPotential: maxCost must be divisible by (range+1)!`);
            return matrix;
        }
        pos = normalizePos(pos);
        const terrain = Game.map.getRoomTerrain(pos.roomName);
        const slope = maxCost / (range + 1);
        let x, y, dx, dy, r, cost;
        for (dx = -range; dx <= range; dx++) {
            x = pos.x + dx;
            if (x < 0 || x > 49) {
                continue;
            }
            for (dy = -range; dy <= range; dy++) {
                y = pos.y + dy;
                if (y < 0 || y > 49) {
                    continue;
                }
                cost = matrix.get(x, y);
                if (includeTerrain) {
                    if (cost === 0) {
                        if (terrain.get(x, y) & TERRAIN_MASK_SWAMP) {
                            cost += terrainCosts.swampCost;
                        }
                        else {
                            cost += terrainCosts.plainCost;
                        }
                    }
                }
                r = Math.max(Math.abs(dx), Math.abs(dy));
                cost += slope * (range + 1 - r);
                matrix.set(x, y, cost); // cost can exceed 0xff since it is min-maxed in backend
            }
        }
        return matrix;
    }
    /**
     * Adds a square potential with a specified center and range. If includeTerrainCosts=true (by default) then if the
     * cost for a square is zero, the terrain cost of the tile is added using default costs of {plain: 1, swamp: 5}.
     */
    static addSquarePotential(matrix, pos, range, addCost, includeTerrain = true, // don't use includeTerrain with explicitTerrainCosts!
    terrainCosts = { plainCost: 1, swampCost: 5 }) {
        pos = normalizePos(pos);
        const terrain = Game.map.getRoomTerrain(pos.roomName);
        let x, y, dx, dy, cost;
        for (dx = -range; dx <= range; dx++) {
            x = pos.x + dx;
            if (x < 0 || x > 49) {
                continue;
            }
            for (dy = -range; dy <= range; dy++) {
                y = pos.y + dy;
                if (y < 0 || y > 49) {
                    continue;
                }
                if (terrain.get(x, y) & TERRAIN_MASK_WALL) {
                    continue;
                }
                cost = matrix.get(x, y);
                if (includeTerrain) {
                    if (cost === 0) {
                        if (terrain.get(x, y) & TERRAIN_MASK_SWAMP) {
                            cost += terrainCosts.swampCost;
                        }
                        else {
                            cost += terrainCosts.plainCost;
                        }
                    }
                }
                matrix.set(x, y, addCost + cost); // cost can exceed 0xff since it is min-maxed in backend
            }
        }
        return matrix;
    }
    /**
     * Transform a CostMatrix such that the cost at each point is transformed to the max of costs in a width x height
     * window (indexed from upper left corner). This is basically a 2D max-pool operation except that the pooling
     * window moves with the max-kernel.
     * -> This method requires that terrain be explicitly specified in the matrix!
     */
    static applyMovingMaxPool(matrix, width, height) {
        // Since we're moving in increasing order of x, y, we don't need to clone the matrix
        let x, y, dx, dy;
        let maxCost, cost;
        for (x = 0; x <= 50 - width; x++) {
            for (y = 0; y <= 50 - height; y++) {
                maxCost = matrix.get(x, y);
                for (dx = 0; dx < width; dx++) {
                    for (dy = 0; dy < height; dy++) {
                        // Don't need 0 <= x,y <= 49 safety checks here since 0 <= x <= (50 - w + (w-1)) = 49
                        cost = matrix.get(x + dx, y + dy);
                        if (cost > maxCost) {
                            maxCost = cost;
                        }
                    }
                }
                matrix.set(x, y, maxCost);
            }
        }
        return matrix;
    }
    /**
     * Blocks all specified positions for a swarm cost matrix that has already been "smeared" by
     * {@link MatrixLib.applyMovingMaxPool}.
     * -> Do not run additional passes of applyMovingMaxPool after doing this!
     * -> This method assumes that you have already added explicit terrian costs.
     */
    static blockAfterMaxPooling(matrix, positions, width, height) {
        let pos;
        let x, y, dx, dy;
        for (let i = 0; i < positions.length; ++i) {
            pos = normalizePos(positions[i]);
            for (dx = 0; dx > -width; dx--) {
                x = pos.x + dx;
                if (x < 0 || x > 49) {
                    continue;
                }
                for (dy = 0; dy > -height; dy--) {
                    y = pos.y + dy;
                    if (y < 0 || y > 49) {
                        continue;
                    }
                    matrix.set(x, y, 0xff);
                }
            }
        }
        return matrix;
    }
    /**
     * Sets the effective cost of all specified positions for a swarm cost matrix that has already been "smeared" by
     * MatrixLib.applyMovingMaxPool(). The cost for each tile is the maximum of the set cost and the current cost.
     * -> Do not run additional passes of applyMovingMaxPool after doing this!
     * -> This method assumes that you have already added explicit terrain costs.
     * Example -----------------------------------------------------------------------------------------------------
     * Start       SetCost     MaxPool    |    Start       MaxPool     SetToMaxCostAfterMaxPooling
     * 0 0 0 0     0 0 0 0     1 5 5 0    |    0 0 0 0     1 2 2 0     1 5 5 0
     * 0 1 2 0     0 1 5 0     9 9 5 0    |    0 1 2 0     9 9 2 0     9 9 5 0
     * 0 9 0 0     0 9 5 0     9 9 5 1    |    0 9 0 0     9 9 1 1     9 9 5 1
     * 0 0 0 1     0 0 0 1     0 0 1 1    |    0 0 0 1     0 0 1 1     0 0 1 1
     */
    static setToMaxCostAfterMaxPooling(matrix, positions, width, height, cost) {
        let pos;
        let x, y, dx, dy;
        for (let i = 0; i < positions.length; ++i) {
            pos = normalizePos(positions[i]);
            for (dx = 0; dx > -width; dx--) {
                x = pos.x + dx;
                if (x < 0 || x > 49) {
                    continue;
                }
                for (dy = 0; dy > -height; dy--) {
                    y = pos.y + dy;
                    if (y < 0 || y > 49) {
                        continue;
                    }
                    if (matrix.get(x, y) < cost) {
                        matrix.set(x, y, cost);
                    }
                }
            }
        }
        return matrix;
    }
    /**
     * Adds an extra cost to the effective specified positions for a swarm cost matrix that has already been "smeared"
     * by MatrixLib.applyMovingMaxPool(). The cost is added on top of what is already there to any tiles which have a
     * lower existing cost than the new value. Tiles in overlapping cost-adding windows will have the maximum of the
     * costs added to their value, not the total of the costs.
     * -> This method will not always produce the same results as setting the cost first and then smearing!
     * -> Do not run additional passes of applyMovingMaxPool after doing this!
     * -> This method assumes that you have already added explicit terrain costs.
     * Example -----------------------------------------------------------------------------------------------------
     * Start       AddCost     MaxPool    |    Start       MaxPool     AddCostAfterMaxPooling
     * 0 0 0 0     0 0 0 0     1 7 7 0    |    0 0 0 0     1 2 2 0     1 7 7 0
     * 0 1 2 0     0 1 7 0     9 9 7 0    |    0 1 2 0     9 9 2 0     9 9 7 0
     * 0 9 0 0     0 9 5 0     9 9 5 1    |    0 9 0 0     9 9 1 1     9 9 6 1
     * 0 0 0 1     0 0 0 1     0 0 1 1    |    0 0 0 1     0 0 1 1     0 0 1 1
     */
    static addCostAfterMaxPooling(matrix, positions, width, height, cost) {
        const addMatrix = new PathFinder.CostMatrix();
        MatrixLib_1.setToMaxCostAfterMaxPooling(addMatrix, positions, width, height, cost);
        MatrixLib_1.addMatrices(matrix, addMatrix);
        return matrix;
    }
    /**
     * Sets the cost of all walkable positions within range of a target position or object. If add=true, adds the cost
     * to the existing cost of the tile. If the cost for a square is zero, the terrain cost of the tile is added
     * using implicit costs of {plain: 1, swamp: 5}
     */
    static setInRange(matrix, pos, range, cost, addDefaultTerrainCosts = false) {
        pos = normalizePos(pos);
        const terrain = Game.map.getRoomTerrain(pos.roomName);
        let x, y, dx, dy, currentCost;
        for (dx = -range; dx <= range; dx++) {
            x = pos.x + dx;
            if (x < 0 || x > 49) {
                continue;
            }
            for (dy = -range; dy <= range; dy++) {
                y = pos.y + dy;
                if (y < 0 || y > 49) {
                    continue;
                }
                if (terrain.get(x, y) & TERRAIN_MASK_WALL) {
                    continue;
                }
                currentCost = matrix.get(x, y);
                if (currentCost === 0) {
                    if (terrain.get(x, y) & TERRAIN_MASK_SWAMP) {
                        currentCost += 10;
                    }
                    else {
                        currentCost += 2;
                    }
                }
                // if (currentCost >= 0xff || currentCost > cost) continue; // not necessary, done in backend
                matrix.set(x, y, addDefaultTerrainCosts ? cost + currentCost : cost);
            }
        }
        return matrix;
    }
    /**
     * Get a matrix of explicit terrain cost values for a room given specified movement costs. The matrix is stored
     * in the permacache. By default, a cloned matrix is returned which you may safely modify, but if you know what
     * you are doing, you can set skipClone=true.
     */
    static getTerrainMatrix(roomName, terrainCosts, skipClone = false) {
        const key = `${roomName}_${terrainCosts.plainCost}_${terrainCosts.swampCost}_${terrainCosts.roadCost}`;
        if (PERMACACHE.terrainMatrices[key] === undefined) {
            // This takes about 0.2 to 0.4 CPU to generate
            const matrix = new PathFinder.CostMatrix();
            const terrain = Game.map.getRoomTerrain(roomName);
            for (let y = 0; y < 50; ++y) {
                for (let x = 0; x < 50; ++x) {
                    switch (terrain.get(x, y)) {
                        case TERRAIN_MASK_SWAMP:
                            matrix.set(x, y, terrainCosts.swampCost);
                            break;
                        case TERRAIN_MASK_WALL:
                            matrix.set(x, y, 0xff);
                            break;
                        default: // plain
                            matrix.set(x, y, terrainCosts.plainCost);
                            break;
                    }
                }
            }
            PERMACACHE.terrainMatrices[key] = matrix;
        }
        if (skipClone) {
            // be careful with this!
            return PERMACACHE.terrainMatrices[key];
        }
        return PERMACACHE.terrainMatrices[key].clone();
    }
    /**
     * Get a cloned copy of the cost matrix for a room with specified options
     */
    static getSwarmTerrainMatrix(roomName, terrainCosts, width, height, exitCost = 10, skipClone = false) {
        const key = `s_${roomName}_${terrainCosts.plainCost}_${terrainCosts.swampCost}_${width}_${height}_${exitCost}`;
        if (PERMACACHE.terrainMatrices[key] === undefined) {
            const terrainMatrix = MatrixLib_1.getTerrainMatrix(roomName, terrainCosts);
            MatrixLib_1.setExitCosts(terrainMatrix, roomName, exitCost);
            MatrixLib_1.applyMovingMaxPool(terrainMatrix, width, height);
            PERMACACHE.terrainMatrices[key] = terrainMatrix;
        }
        if (skipClone) {
            return PERMACACHE.terrainMatrices[key];
        }
        return PERMACACHE.terrainMatrices[key].clone();
    }
    /**
     * Adds the terrain costs to an existing cost matrix
     */
    static addTerrainCosts(matrix, roomName, terrainCosts) {
        const terrainMatrix = MatrixLib_1.getTerrainMatrix(roomName, terrainCosts, true);
        MatrixLib_1.addMatrices(matrix, terrainMatrix);
        return matrix;
    }
    /**
     * Blocks all tiles at the edge of the room. If rangeToEdge is specified, block all tiles within that range of
     * the edge.
     */
    static blockExits(matrix, rangeToEdge = 0) {
        for (let x = rangeToEdge; x < 50 - rangeToEdge; x += 49 - rangeToEdge * 2) {
            for (let y = rangeToEdge; y < 50 - rangeToEdge; y++) {
                matrix.set(x, y, 0xff);
            }
        }
        for (let x = rangeToEdge; x < 50 - rangeToEdge; x++) {
            for (let y = rangeToEdge; y < 50 - rangeToEdge; y += 49 - rangeToEdge * 2) {
                matrix.set(x, y, 0xff);
            }
        }
        return matrix;
    }
    /**
     * Sets the cost of all walkable tiles at the edge of the room. If rangeToEdge is specified, set the cost of
     * all walkable terrain tiles within that range of the edge.
     */
    static setExitCosts(matrix, roomName, cost, rangeToEdge = 0) {
        const terrain = Game.map.getRoomTerrain(roomName);
        for (let x = rangeToEdge; x < 50 - rangeToEdge; x += 49 - rangeToEdge * 2) {
            for (let y = rangeToEdge; y < 50 - rangeToEdge; y++) {
                if (terrain.get(x, y) & TERRAIN_MASK_WALL) {
                    continue;
                }
                matrix.set(x, y, cost);
            }
        }
        for (let x = rangeToEdge; x < 50 - rangeToEdge; x++) {
            for (let y = rangeToEdge; y < 50 - rangeToEdge; y += 49 - rangeToEdge * 2) {
                if (terrain.get(x, y) & TERRAIN_MASK_WALL) {
                    continue;
                }
                matrix.set(x, y, cost);
            }
        }
        return matrix;
    }
    /**
     * Sets all creep positions to impassible
     */
    static blockMyCreeps(matrix, room) {
        _.forEach(room.creeps, (creep) => {
            matrix.set(creep.pos.x, creep.pos.y, 0xff);
        });
    }
    /**
     * Sets hostile creep positions to impassible
     */
    static blockHostileCreeps(matrix, room) {
        _.forEach(room.hostiles, (hostile) => {
            matrix.set(hostile.pos.x, hostile.pos.y, 0xff);
        });
    }
    /**
     * Sets allied creep positions to impassible
     */
    static blockAlliedCreeps(matrix, room) {
        _.forEach(room.friendlies, (hostile) => {
            matrix.set(hostile.pos.x, hostile.pos.y, 0xff);
        });
    }
    /**
     * Sets all creep positions to impassible
     */
    static blockAllCreeps(matrix, room) {
        _.forEach(room.find(FIND_CREEPS), (creep) => {
            matrix.set(creep.pos.x, creep.pos.y, 0xff);
        });
    }
    /**
     * Sets road positions to 1 if cost is less than 0xfe
     */
    static preferRoads(matrix, room) {
        _.forEach(room.roads, (road) => {
            if (matrix.get(road.pos.x, road.pos.y) < 0xfe) {
                matrix.set(road.pos.x, road.pos.y, 1);
            }
        });
    }
    /**
     * Generates and caches a rampart mask for the room with 0x00 where there are ramparts and 0xff everywhere else.
     * If onlyMy=true, then only ramparts that are owned by me are counted.
     * -> This method does not take rampart walkability into account (if there are structures under the rampart)
     */
    static getRampartMask(room, onlyMy = true, value = 0xff) {
        const key = `rampartMask_${room.name}_onlymy_${onlyMy}`;
        let matrix;
        let expiration;
        let invalidateCondition;
        if (MatrixCache[key]) {
            expiration = MatrixCache[key].expiration || Infinity;
            invalidateCondition =
                MatrixCache[key].invalidateCondition || (() => false);
            if (Game.time >= expiration || invalidateCondition()) {
                delete MatrixCache[key];
                matrix = undefined;
            }
            else {
                matrix = MatrixCache[key].matrix;
            }
        }
        if (!matrix) {
            matrix = new PathFinder.CostMatrix();
            MatrixLib_1.fillMatrix(matrix, value);
            const ramparts = onlyMy ?
                _.filter(room.ramparts, (rampart) => rampart.my)
                : room.ramparts;
            for (const rampart of ramparts) {
                matrix.set(rampart.pos.x, rampart.pos.y, 0);
            }
        }
        const numRamparts = room.ramparts.length; // this doesn't account for onlyMy option but I think this is okay
        MatrixCache[key] = {
            matrix: matrix,
            generated: Game.time,
            expiration: Game.time + 100,
            invalidateCondition: () => Game.rooms[room.name] &&
                Game.rooms[room.name].ramparts.length != numRamparts,
        };
        return MatrixCache[key].matrix;
    }
    /**
     * Sets walkable rampart positions to 1 if cost is less than 0xfe
     * TODO: maybe increasing cost elsewhere would be better than decreasing cost in ramparts
     */
    static setWalkableRampartCostToOne(matrix, room) {
        _.forEach(room.walkableRamparts, (rampart) => {
            if (matrix.get(rampart.pos.x, rampart.pos.y) < 0xfe) {
                matrix.set(rampart.pos.x, rampart.pos.y, 1);
            }
        });
    }
    /**
     * Blocks all non-rampart positions in the room. If onlyMy=true, then only my rampart positions are blocked
     */
    static blockNonRamparts(matrix, room, onlyMy = true) {
        const mask = MatrixLib_1.getRampartMask(room, onlyMy);
        MatrixLib_1.addMatrices(matrix, mask);
    }
    /**
     * Gets the rows of a CostMatrix and returns as a list of 50 Uint8Arrays
     */
    static getRows(matrix) {
        const rows = [];
        for (let y = 0; y < 50; ++y) {
            rows.push(new Uint8Array(50));
            for (let x = 0; x < 50; ++x) {
                rows[y][x] = matrix.get(x, y);
            }
        }
        return rows;
    }
    /**
     * Gets the columns of a CostMatrix and returns as a list of 50 Uint8Arrays
     */
    static getColumns(matrix) {
        const columns = [];
        for (let x = 0; x < 50; ++x) {
            columns.push(new Uint8Array(50));
            for (let y = 0; y < 50; ++y) {
                columns[x][y] = matrix.get(x, y);
            }
        }
        return columns;
    }
    /**
     * Returns the maximum value of any matrix element
     */
    static getMaxValue(matrix) {
        return _.max(matrix._bits);
    }
    /**
     * Prints the values of a CostMatrix to the console. This is pretty expensive!
     */
    static print(matrix, opts = { equalSpacing: true, useColorMap: true }) {
        // Figure out how big the largest value in a column is so we can align them right
        const longestNumPerColumn = _.map(MatrixLib_1.getColumns(matrix), (column) => _.max(_.map(column, (n) => n.toString().length)));
        if (opts.equalSpacing) {
            const longestNum = _.max(longestNumPerColumn);
            for (let i = 0; i < longestNumPerColumn.length; ++i) {
                longestNumPerColumn[i] = longestNum;
            }
        }
        const maxVal = MatrixLib_1.getMaxValue(matrix);
        let msg = "";
        let num, percentOfMax, numAsStr;
        for (let y = 0; y < 50; ++y) {
            for (let x = 0; x < 50; ++x) {
                num = matrix.get(x, y);
                numAsStr = matrix
                    .get(x, y)
                    .toString()
                    .padEnd(longestNumPerColumn[x] + 1);
                if (opts.useColorMap && maxVal > 0) {
                    percentOfMax = Math.round((255 * num) / maxVal);
                    msg += color(numAsStr, rgbToHex(255, 255 - percentOfMax, 255 - percentOfMax));
                }
                else {
                    msg += numAsStr;
                }
            }
            msg += "\n";
        }
        console.log(msg);
    }
    /**
     * Visualizes the cost matrix as a room visual. Shortcut to Visualizer.displayCostMatrix()
     */
    static visualize(matrix, roomName) {
        Visualizer.displayCostMatrix(matrix, roomName);
    }
};
MatrixLib.settings = {
    portalCost: 20, // if portals are not blocked, we still want to avoid accidentally stepping on them
};
MatrixLib.testMatrices = {
    checkerboard: () => {
        const matrix = new PathFinder.CostMatrix();
        for (let y = 0; y < 50; ++y) {
            for (let x = 0; x < 50; ++x) {
                matrix.set(x, y, (x + y) % 2);
            }
        }
        return matrix;
    },
    checkerboard2: () => {
        const matrix = new PathFinder.CostMatrix();
        for (let y = 0; y < 50; ++y) {
            for (let x = 0; x < 50; ++x) {
                matrix.set(x, y, (x + y + 1) % 2);
            }
        }
        return matrix;
    },
    xIncreasing: () => {
        const matrix = new PathFinder.CostMatrix();
        for (let y = 0; y < 50; ++y) {
            for (let x = 0; x < 50; ++x) {
                matrix.set(x, y, x);
            }
        }
        return matrix;
    },
    yIncreasing: () => {
        const matrix = new PathFinder.CostMatrix();
        for (let y = 0; y < 50; ++y) {
            for (let x = 0; x < 50; ++x) {
                matrix.set(x, y, y);
            }
        }
        return matrix;
    },
    diagonalIncreasing: () => {
        const matrix = new PathFinder.CostMatrix();
        for (let y = 0; y < 50; ++y) {
            for (let x = 0; x < 50; ++x) {
                matrix.set(x, y, x + y);
            }
        }
        return matrix;
    },
};
MatrixLib = MatrixLib_1 = __decorate$1([
    profile
], MatrixLib);
global.MatrixCache = MatrixCache;
global.MatrixLib = MatrixLib;

var Movement_1;
const REPORT_CPU_THRESHOLD = 750; // Report when creep uses more than this amount of CPU over lifetime
const REPORT_SWARM_CPU_THRESHOLD = 1500;
const DEFAULT_STUCK_VALUE = 2; // Marked as stuck after this many ticks
const STATE_PREV_X = 0;
const STATE_PREV_Y = 1;
const STATE_STUCK = 2;
const STATE_CPU = 3;
const STATE_DEST_X = 4;
const STATE_DEST_Y = 5;
const STATE_DEST_ROOMNAME = 6;
const STATE_CURRENT_X = 7;
const STATE_CURRENT_Y = 8;
const MovePriorities = {
    [Roles.manager]: 0, // movement priority 0 means you will never get pushed
    [Roles.queen]: 2,
    [Roles.bunkerDefender]: 3,
    [Roles.melee]: 3,
    powerCreep: 3,
    [Roles.dismantler]: 4,
    [Roles.ranged]: 4,
    [Roles.guardMelee]: 5,
    [Roles.drone]: 7,
    [Roles.gatherer]: 7,
    [Roles.transport]: 8,
    [Roles.worker]: 9,
    default: 10,
};
const getDefaultMoveOptions = () => ({
    stuckValue: DEFAULT_STUCK_VALUE,
    pathOpts: {},
});
/**
 * This is the movement library for Overmind. It was originally based on BonzAI's Traveler library, but it has been
 * extensively modified to integrate more tightly with the Overmind framework and add additional functionality.
 */
let Movement = Movement_1 = class Movement {
    // Core creep movement functions ===================================================================================
    /**
     * Move a creep to a destination
     */
    static goTo(creep, destination, moveOpts = {}) {
        var _a;
        if (creep.blockMovement && !moveOpts.force) {
            return ERR_BUSY;
        }
        if (isStandardZerg(creep)) {
            if (creep.spawning) {
                return NO_ACTION;
            }
            if (creep.fatigue > 0) {
                Movement_1.circle(creep.pos, "aqua", 0.3);
                return ERR_TIRED;
            }
        }
        // Set default options
        const opts = _.defaultsDeep({}, moveOpts, getDefaultMoveOptions());
        const pathOpts = (_a = _.cloneDeep(opts.pathOpts)) !== null && _a !== void 0 ? _a : {};
        // Compute terrain costs
        pathOpts.terrainCosts = getTerrainCosts(creep);
        pathOpts.debug = opts.debug;
        if (opts.movingTarget) {
            opts.range = 0;
        }
        // initialize data object
        if (!creep.memory._go) {
            creep.memory._go = {};
        }
        const moveData = creep.memory._go;
        // set destination according to waypoint specifications; finalDestination is the true destination
        destination = normalizePos(destination);
        // const finalDestination = destination;
        // if (opts.waypoints) {
        // 	destination = this.getDestination(destination, opts.waypoints, moveData);
        // }
        // Fixes bug that causes creeps to idle on the other side of a room
        if (opts.range != undefined && destination.rangeToEdge <= opts.range) {
            opts.range = Math.min(Math.abs(destination.rangeToEdge - 1), 0);
        }
        // Take care of properties which exist on both moveOpts and pathOpts: if they are specified on both moveOpts
        // and moveOpts.pathOpts then the value of range or fleeRange on moveOpts takes precedence.
        // -> This must be done after the last modification to opts.range and opts.fleeRange!
        if (opts.range != undefined) {
            pathOpts.range = opts.range;
        }
        if (opts.fleeRange != undefined) {
            pathOpts.fleeRange = opts.fleeRange;
        }
        // manage case where creep is nearby destination
        const rangeToDestination = creep.pos.getRangeTo(destination);
        if (opts.range != undefined && rangeToDestination <= opts.range) {
            // if (destination.isEqualTo(finalDestination)) {
            if (creep.pos.isEdge) {
                // move the creep off the edge tiles to prevent it bouncing
                return creep.moveOffExit(destination);
            }
            else {
                log.debugCreep(creep, `near destination`);
                delete creep.memory._go;
                return NO_ACTION;
            }
            // } else {
            // 	// debug
            // 	console.log(`Destination ${destination} not equal to final destination ${finalDestination}!`);
            // 	if (!moveData.waypointsVisited) {
            // 		moveData.waypointsVisited = [];
            // 	}
            // 	moveData.waypointsVisited.push(destination.name);
            //
            // 	// call goTo again to path to the final destination
            // 	return this.goTo(creep, finalDestination, opts);
            // }
        }
        else if (rangeToDestination <= 1) {
            // move onto destination
            if (rangeToDestination == 1 && !opts.range) {
                const direction = creep.pos.getDirectionTo(destination);
                if (destination.isWalkable(opts.ignoreCreepsOnDestination)) {
                    return creep.move(direction, !!opts.force);
                }
            }
            else {
                // at destination
                if (!moveData.fleeWait) {
                    delete creep.memory._go;
                }
                return NO_ACTION;
            }
        }
        // // traverse through a portal waypoint or check that has just been traversed
        // if (opts.waypoints && !destination.isEqualTo(finalDestination) && (moveData.portaling == true
        // 																   || creep.pos.getRangeTo(destination) < 2)) {
        // 	const portalTraversed = this.traversePortalWaypoint(creep, destination);
        // 	if (portalTraversed) {
        // 		return this.goTo(creep, finalDestination, opts);
        // 	} else {
        // 		return CROSSING_PORTAL;
        // 	}
        // }
        // handle delay
        if (moveData.delay != undefined) {
            if (moveData.delay <= 0) {
                delete moveData.delay;
            }
            else {
                moveData.delay--;
                return OK;
            }
        }
        let shouldRepath = false;
        const state = this.deserializeState(moveData, destination);
        // // verify creep is in the location it thinks it should be in
        // if (state.currentXY) {
        // 	const {x, y} = state.currentXY;
        // 	if (!(creep.pos.x == x && creep.pos.y == y)) { // creep thought it would move last tick but didn't
        // 		log.debug(`${creep.print} has gotten off track; deleting path!`);
        // 		shouldRepath = true;
        // 	}
        // }
        // uncomment to visualize destination
        this.circle(destination, "orange");
        if (creep.memory.debug) {
            new RoomVisual(destination.roomName).infoBox([creep.name], destination.x, destination.y, {
                color: "orange",
                opacity: 0.8,
            });
        }
        // check if creep is stuck
        if (this.isStuck(creep, state)) {
            state.stuckCount++;
            this.circle(creep.pos, "magenta", state.stuckCount * 0.3);
            // pushedCreep = this.pushCreep(creep);
        }
        else {
            state.stuckCount = 0;
        }
        // handle case where creep is stuck
        if (state.stuckCount >= opts.stuckValue) {
            log.debugCreep(creep, `stuck for too long trying to get to ${destination.print}, repathing`);
            pathOpts.blockCreeps = true;
            shouldRepath = true;
        }
        // delete path cache if destination is different
        if (!destination.isEqualTo(state.destination)) {
            if (opts.movingTarget && state.destination.isNearTo(destination)) {
                moveData.path += state.destination.getDirectionTo(destination);
                state.destination = destination;
            }
            else {
                log.debugCreep(creep, `destination mismatch: ` +
                    `${destination.print} != ${state.destination.print}, repathing`);
                shouldRepath = true;
            }
        }
        // randomly repath with specified probability
        if (opts.repathChance && Math.random() < opts.repathChance) {
            log.debugCreep(creep, `random repathing`);
            shouldRepath = true;
        }
        // TODO: repath if you are not on expected next position
        // pathfinding
        let newPath = false;
        if (shouldRepath || !moveData.path || moveData.path.length == 0) {
            if (!moveData.path || moveData.path.length === 0) ;
            newPath = true;
            if (isStandardZerg(creep) && creep.spawning) {
                return ERR_BUSY;
            }
            state.destination = destination;
            const cpu = Game.cpu.getUsed();
            // creep.debug(`Pathfinding from ${creep.pos} to ${destination} with opts ${JSON.stringify(pathOpts)}`);
            // Pathfinding call ------------------------------------------
            const ret = Pathing.findPath(creep.pos, destination, pathOpts);
            // -----------------------------------------------------------
            // creep.debug(`Pathfinding return: ${print(ret)}`);
            const cpuUsed = Game.cpu.getUsed() - cpu;
            state.cpu = _.round(cpuUsed + state.cpu);
            if (Game.time % 10 == 0 && state.cpu > REPORT_CPU_THRESHOLD) {
                log.alert(`Movement: heavy cpu use: ${creep.name}, cpu: ${state.cpu}. ` +
                    `(${creep.pos.print} ${rightArrow} ${destination.print})`);
            }
            let color = "orange";
            if (ret.incomplete) {
                // uncommenting this is a great way to diagnose creep behavior issues
                const e = new Error();
                log.debug(`Movement: incomplete path for ${creep.print}! ` +
                    `(${creep.pos.print} ${rightArrow} ${destination.print}): ${JSON.stringify(opts)}\n${e.stack}`);
                color = "red";
            }
            this.circle(creep.pos, color);
            moveData.path = Pathing.serializePath(creep.pos, ret.path, color);
            const roomsVisited = _.unique(_.map(ret.path, (pos) => pos.roomName));
            if (!moveData.roomVisibility) {
                moveData.roomVisibility = {};
            }
            for (const roomName of roomsVisited) {
                moveData.roomVisibility[roomName] = !!Game.rooms[roomName];
            }
            state.stuckCount = 0;
        }
        if (!moveData.path || moveData.path.length == 0) {
            this.serializeState(creep, destination, state, moveData);
            return ERR_NO_PATH;
        }
        // push creeps out of the way if needed
        if (!opts.noPush) {
            const obstructingCreep = this.findBlockingCreep(creep);
            if (obstructingCreep && this.shouldPush(creep, obstructingCreep)) {
                const pushedCreep = this.pushCreep(creep, obstructingCreep);
                if (!pushedCreep) {
                    this.serializeState(creep, destination, state, moveData);
                    return ERR_CANNOT_PUSH_CREEP;
                }
            }
        }
        // consume path
        if (state.stuckCount == 0 && !newPath) {
            moveData.path = moveData.path.substr(1);
        }
        const nextDirection = parseInt(moveData.path[0], 10);
        // predict next coordinate (for verification)
        const nextPos = creep.pos.getPositionAtDirection(nextDirection);
        this.serializeState(creep, destination, state, moveData, {
            x: nextPos.x,
            y: nextPos.y,
        });
        return creep.move(nextDirection, !!opts.force);
    }
    // /**
    //  * Gets the effective destination based on the waypoints to travel over and the creep.memory._go object.
    //  * Finds the next waypoint which has not been marked as visited in moveData.
    //  */
    // private static getDestination(destination: RoomPosition, waypoints: RoomPosition[],
    // 							  moveData: MoveData): RoomPosition {
    //
    // 	const waypointsVisited = _.compact(_.map(moveData.waypointsVisited || [],
    // 											 posName => getPosFromString(posName))) as RoomPosition[];
    // 	const nextWaypoint = _.find(waypoints, waypoint => !_.any(waypointsVisited,
    // 															  visited => waypoint.isEqualTo(visited)));
    //
    // 	if (nextWaypoint) {
    // 		return nextWaypoint;
    // 	} else {
    // 		return destination;
    // 	}
    //
    // }
    // /**
    //  * Navigate a creep through a portal
    //  */
    // private static traversePortalWaypoint(creep: AnyZerg, portalPos: RoomPosition): boolean {
    // 	if (creep.pos.roomName == portalPos.roomName && creep.pos.getRangeTo(portalPos) > 1) {
    // 		log.error(`Movement.travelPortalWaypoint() should only be called in range 1 of portal!`);
    // 	}
    //
    // 	const moveData = creep.memory._go || {} as MoveData;
    //
    // 	if (portalPos.room && !portalPos.lookForStructure(STRUCTURE_PORTAL)) {
    // 		log.error(`Portal not found at ${portalPos.print}!`);
    // 		return false;
    // 	}
    //
    // 	moveData.portaling = true;
    // 	const crossed = this.crossPortal(creep, portalPos);
    //
    // 	if (crossed) {
    // 		moveData.portaling = false;
    // 		if (!moveData.waypointsVisited) {
    // 			moveData.waypointsVisited = [];
    // 		}
    // 		moveData.waypointsVisited.push(portalPos.name);
    //
    // 		return true; // done crossing portal
    // 	} else {
    // 		return false; // still trying to cross portal
    // 	}
    //
    // }
    // /**
    //  * Cross a portal that is within range 1 and then step off of the exit portal. Returns true when creep is on the
    //  * other side of the portal and no longer standing on a portal.
    //  */
    // private static crossPortal(creep: AnyZerg, portalPos: RoomPosition): boolean {
    // 	if (Game.map.getRoomLinearDistance(creep.pos.roomName, portalPos.roomName) > 5) {
    // 		// if you're on the other side of the portal
    // 		const creepOnPortal = !!creep.pos.lookForStructure(STRUCTURE_PORTAL);
    // 		if (!creepOnPortal) {
    // 			return true;
    // 		} else {
    // 			creep.moveOffCurrentPos();
    // 			return false;
    // 		}
    // 		// console.log(agent.name + " waiting on other side");
    // 	} else {
    // 		if (creep.pos.getRangeTo(portalPos) > 1) {
    // 			log.error(`Movement.crossPortal() should only be called in range 1 of portal!`);
    // 		} else {
    // 			const dir = creep.pos.getDirectionTo(portalPos);
    // 			creep.move(dir);
    // 		}
    // 		// console.log(agent.name + " traveling to waypoint");
    // 		return false;
    // 	}
    // }
    static getPushPriority(creep) {
        if (!creep.memory) {
            return MovePriorities.default;
        }
        if (creep.memory._go && creep.memory._go.priority) {
            return creep.memory._go.priority;
        }
        else {
            if (isPowerZerg(creep)) {
                return MovePriorities.powerCreep;
            }
            else if (creep.memory.role in MovePriorities) {
                return MovePriorities[creep.memory.role];
            }
            else {
                return MovePriorities.default;
            }
        }
    }
    static shouldPush(pusher, pushee) {
        if (this.getPushPriority(pusher) < this.getPushPriority(pushee)) {
            // pushee less important than pusher
            return true;
        }
        else if (this.getPushPriority(pushee) == 0) {
            return false;
        }
        else {
            pushee = normalizeAnyZerg(pushee);
            if (isAnyZerg(pushee)) {
                if (isStandardZerg(pushee)) {
                    // pushee is equal or more important than pusher
                    if (pushee.task && pushee.task.isWorking) {
                        // If creep is doing a task, only push out of way if it can go somewhere else in range
                        const targetPos = pushee.task.targetPos;
                        const targetRange = pushee.task.settings.targetRange;
                        return (_.filter(pushee.pos
                            .availableNeighbors()
                            .concat(pusher.pos), (pos) => pos.getRangeTo(targetPos) <= targetRange).length > 0);
                    }
                    else if (!pushee.isMoving) {
                        // push creeps out of the way if they're idling
                        return true;
                    }
                }
                else if (isPowerZerg(pushee)) {
                    if (!pushee.isMoving) {
                        // push creeps out of the way if they're idling
                        return true;
                    }
                }
            }
            else {
                return pushee.my;
            }
        }
        return false;
    }
    static getPushDirection(pusher, pushee) {
        const possiblePositions = pushee.pos.availableNeighbors();
        pushee = normalizeAnyZerg(pushee);
        if (isStandardZerg(pushee)) {
            let preferredPositions = [];
            if (pushee.task && pushee.task.isWorking) {
                // push creeps out of the way when they're doing task
                const targetPos = pushee.task.targetPos;
                const targetRange = pushee.task.settings.targetRange;
                preferredPositions = _.filter(possiblePositions, (pos) => pos.getRangeTo(targetPos) <= targetRange);
            }
            if (preferredPositions[0]) {
                return pushee.pos.getDirectionTo(preferredPositions[0]);
            }
        }
        else {
            log.debug(`${pushee.name}@${pushee.pos.print} is not Zerg! (Why?)`);
        }
        return pushee.pos.getDirectionTo(pusher);
    }
    static findBlockingCreep(creep) {
        const nextDir = Pathing.nextDirectionInPath(creep);
        if (nextDir == undefined) {
            return;
        }
        const nextPos = Pathing.positionAtDirection(creep.pos, nextDir);
        if (!nextPos) {
            return;
        }
        return nextPos.room ? nextPos.lookFor(LOOK_CREEPS)[0] : undefined;
    }
    /* Push a blocking creep out of the way */
    static pushCreep(creep, otherCreep) {
        if (!otherCreep.memory) {
            return false;
        }
        otherCreep = normalizeAnyZerg(otherCreep);
        const pushDirection = this.getPushDirection(creep, otherCreep);
        const otherData = otherCreep.memory._go;
        // Push the creep and update the state
        const outcome = otherCreep.move(pushDirection);
        const otherNextPos = otherCreep.pos.getPositionAtDirection(pushDirection);
        if (isStandardZerg(otherCreep)) {
            if (outcome == OK) {
                if (otherData && otherData.path && !otherCreep.blockMovement) {
                    // don't add to path unless you moved
                    otherData.path =
                        Pathing.oppositeDirection(pushDirection) +
                            otherData.path;
                    this.updateStateNextCoord(otherData, otherNextPos);
                }
                otherCreep.blockMovement = true; // TODO: <-- movement bug? what if cmds are procesed in wrong order?
                return true;
            }
            else {
                return false;
            }
        }
        else {
            // Shouldn't reach here ideally
            log.warning(`${otherCreep.name}@${otherCreep.pos.print} is not Zerg! (Why?)`);
            if (outcome == OK) {
                if (otherData && otherData.path) {
                    otherData.path =
                        Pathing.oppositeDirection(pushDirection) +
                            otherData.path;
                    this.updateStateNextCoord(otherData, otherNextPos);
                }
                return true;
            }
            else {
                return false;
            }
        }
    }
    /**
     * Recursively moves creeps out of the way of a position to make room for something, such as a spawning creep.
     * If suicide is specified and there is no series of move commands that can move a block of creeps out of the way,
     * the lead blocking creep will suicide. Returns whether the position has been vacated.
     */
    static vacatePos(pos, suicide = false) {
        // prevent creeps from moving onto pos
        const nearbyCreeps = _.compact(_.map(pos.findInRange(FIND_MY_CREEPS, 2), (creep) => Overmind.zerg[creep.name]));
        _.forEach(nearbyCreeps, (creep) => (creep.blockMovement = true));
        // recurively move creeps off of the position
        const creep = pos.lookFor(LOOK_CREEPS)[0];
        if (!creep) {
            return true;
        }
        const blockingCreep = Overmind.zerg[creep.name];
        if (!blockingCreep) {
            return true;
        }
        const moved = !!this.recursivePush(blockingCreep);
        if (moved) {
            log.debug(`Moved creep ${blockingCreep.name} off of ${blockingCreep.pos.print}.`);
            return true;
        }
        else {
            if (suicide) {
                log.debug(`Could not move creep ${blockingCreep.name} off of ${blockingCreep.pos.print}! ` +
                    `Suiciding creep! (RIP)`);
                blockingCreep.suicide();
                return true;
            }
            else {
                log.debug(`Could not move creep ${blockingCreep.name} off of ${blockingCreep.pos.print}!`);
                return false;
            }
        }
    }
    /**
     * Recursively pushes creeps out of the way of a root position.
     */
    static recursivePush(creep, excludePos = []) {
        const creepPos = creep.pos;
        let movePos = _.find(creepPos.availableNeighbors(), (neighbor) => !_.any(excludePos, (pos) => pos.isEqualTo(neighbor)));
        if (movePos) {
            log.debug(`Moving ${creep.name} to ${JSON.stringify(movePos)}`);
            this.goTo(creep, movePos, { force: true });
            creep.blockMovement = true;
            return creepPos;
        }
        else {
            // Every position is occupied by a creep
            const availablePositions = _.filter(creepPos.availableNeighbors(true), (neighbor) => !_.any(excludePos, (pos) => pos.isEqualTo(neighbor)));
            for (const otherPos of availablePositions) {
                const otherCreep = otherPos.lookFor(LOOK_CREEPS)[0];
                if (!otherCreep) {
                    continue;
                }
                const otherZerg = Overmind.zerg[otherCreep.name];
                if (!otherZerg) {
                    continue;
                }
                movePos = this.recursivePush(otherZerg, excludePos.concat(creepPos));
                if (movePos) {
                    this.goTo(creep, movePos, { range: 0, force: true });
                    creep.blockMovement = true;
                    return creepPos;
                }
            }
        }
    }
    /**
     * Travel to a room
     */
    static goToRoom(creep, roomName, options = {}) {
        options.range = 20;
        return this.goTo(creep, new RoomPosition(25, 25, roomName), options);
    }
    /**
     * Travel to a room
     */
    static goToRoom_swarm(swarm, roomName, options = {}) {
        options.range = 24 - Math.max(swarm.width, swarm.height);
        return this.swarmMove(swarm, new RoomPosition(25, 25, roomName), options);
    }
    /**
     * Park a creep off-roads
     */
    static park(creep, pos = creep.pos, maintainDistance = false) {
        const road = creep.pos.lookForStructure(STRUCTURE_ROAD);
        if (!road) {
            return OK;
        }
        // Move out of the bunker if you're in it
        if (!maintainDistance &&
            creep.colony &&
            creep.colony.bunker &&
            insideBunkerBounds(creep.pos, creep.colony)) {
            return this.goTo(creep, creep.colony.controller.pos);
        }
        let positions = _.sortBy(creep.pos.availableNeighbors(), (p) => p.getRangeTo(pos));
        if (maintainDistance) {
            const currentRange = creep.pos.getRangeTo(pos);
            positions = _.filter(positions, (p) => p.getRangeTo(pos) <= currentRange);
        }
        let swampPosition;
        for (const position of positions) {
            if (position.lookForStructure(STRUCTURE_ROAD)) {
                continue;
            }
            const terrain = position.lookFor(LOOK_TERRAIN)[0];
            if (terrain === "swamp") {
                swampPosition = position;
            }
            else {
                return creep.move(creep.pos.getDirectionTo(position));
            }
        }
        if (swampPosition) {
            return creep.move(creep.pos.getDirectionTo(swampPosition));
        }
        return this.goTo(creep, pos);
    }
    /**
     * Moves a creep off of the current tile to the first available neighbor
     */
    static moveOffCurrentPos(creep) {
        const destinationPos = _.first(creep.pos.availableNeighbors());
        if (destinationPos) {
            const direction = creep.pos.getDirectionTo(destinationPos);
            return creep.move(direction);
        }
        else {
            log.debug(`${creep.print} can't move off current pos!`);
            return ERR_NO_PATH;
        }
    }
    /**
     * Moves onto an exit tile
     */
    static moveOnExit(creep) {
        if (creep.pos.rangeToEdge > 0) {
            if (isStandardZerg(creep) && creep.fatigue > 0) {
                return ERR_TIRED;
            }
            const directions = [1, 3, 5, 7, 2, 4, 6, 8];
            for (const direction of directions) {
                const position = creep.pos.getPositionAtDirection(direction);
                const terrain = position.lookFor(LOOK_TERRAIN)[0];
                if (terrain != "wall" && position.rangeToEdge == 0) {
                    const outcome = creep.move(direction);
                    return outcome;
                }
            }
            log.warning(`moveOnExit() assumes nearby exit tile, position: ${creep.pos}`);
            return ERR_NO_PATH;
        }
        return ERR_NOT_IN_RANGE;
    }
    /**
     * Moves off of an exit tile
     */
    static moveOffExit(creep, towardPos, avoidSwamp = true) {
        if (!creep.pos.isEdge) {
            return NO_ACTION;
        }
        const terrain = creep.room.getTerrain();
        const pos = minBy(creep.pos.neighbors, (pos) => {
            if (pos.isEdge || !pos.isWalkable()) {
                return false;
            }
            let penalty = 0;
            if (avoidSwamp && terrain.get(pos.x, pos.y) == TERRAIN_MASK_SWAMP) {
                penalty += 10;
            }
            if (towardPos) {
                penalty += pos.getRangeTo(towardPos);
            }
            return penalty;
        });
        if (pos) {
            const direction = creep.pos.getDirectionTo(pos);
            creep.debug(`moving off exit toward ${pos.print}, direction ${direction}`);
            return creep.move(direction);
        }
        else {
            log.warning(`${creep.print}: cannot move off exit!`);
            return ERR_NO_PATH;
        }
    }
    /**
     * Moves a pair of creeps; the follower will always attempt to be in the last position of the leader
     */
    static pairwiseMove(leader, follower, target, opts = {}, allowedRange = 1) {
        let outcome = ERR_SWARM_BUSY;
        if (leader.room != follower.room) {
            if (leader.pos.rangeToEdge == 0) {
                // Leader should move off of exit tiles while waiting for follower
                outcome = leader.goTo(target, opts);
            }
            follower.goTo(leader);
            return outcome;
        }
        const range = leader.pos.getRangeTo(follower);
        if (range > allowedRange) {
            // If leader is farther than max allowed range, allow follower to catch up
            if (follower.pos.isEdge && follower.room == leader.room) {
                const goToPos = _.find(follower.pos.availableNeighbors(), (pos) => pos.isNearTo(leader));
                if (goToPos) {
                    follower.goTo(goToPos);
                }
                else {
                    follower.goTo(leader, {
                        pathOpts: { debug: opts.debug, blockCreeps: true },
                    });
                }
            }
            else {
                follower.goTo(leader, { stuckValue: 1 });
            }
        }
        else if (isStandardZerg(follower) && follower.fatigue == 0) {
            // Leader should move if follower can also move this tick
            outcome = leader.goTo(target, opts);
            if (range == 1) {
                follower.move(follower.pos.getDirectionTo(leader));
            }
            else {
                follower.goTo(leader, { stuckValue: 1 });
            }
        }
        return outcome;
    }
    /**
     * Moves a swarm to a destination, accounting for group pathfinding
     */
    static swarmMove(swarm, destination, opts = {}) {
        if (swarm.fatigue > 0) {
            Movement_1.circle(swarm.anchor, "aqua", 0.3);
            console.log("tired");
            return ERR_TIRED;
        }
        // Set default options
        _.defaultsDeep(opts, {
            range: 1, // Math.max(swarm.width, swarm.height),
            blockCreeps: false,
            exitCost: 10,
            pathOpts: { debug: opts.debug },
        });
        // if (options.range! < Math.max(swarm.width, swarm.height)) {
        // 	log.warning(`Range specified is ${options.range}; not allowable for ${swarm.width}x${swarm.height} swarm!`);
        // }
        destination = normalizePos(destination);
        // initialize data object
        if (!swarm.memory._go) {
            swarm.memory._go = {};
        }
        const moveData = swarm.memory._go;
        // manage case where creep is nearby destination
        if (opts.range != undefined &&
            swarm.minRangeTo(destination) <= opts.range &&
            swarm.maxRangeTo(destination) <=
                opts.range + Math.max(swarm.width, swarm.height)) {
            delete swarm.memory._go;
            console.log("no action");
            return NO_ACTION;
        }
        let shouldRepath = false;
        const state = this.deserializeState(moveData, destination);
        // check if swarm is stuck
        let stuck = false;
        if (state.lastCoord !== undefined) {
            if (sameCoord(swarm.anchor, state.lastCoord)) {
                // didn't move
                stuck = true;
            }
            else if (isExit(swarm.anchor) && isExit(state.lastCoord)) {
                // moved against exit
                stuck = true;
            }
        }
        if (stuck) {
            state.stuckCount++;
            this.circle(swarm.anchor, "magenta", state.stuckCount * 0.3);
        }
        else {
            state.stuckCount = 0;
        }
        // handle case where creep is stuck
        if (state.stuckCount >= opts.stuckValue) {
            opts.pathOpts.blockCreeps = true;
            shouldRepath = true;
        }
        // delete path cache if destination is different
        if (!destination.isEqualTo(state.destination)) {
            shouldRepath = true;
        }
        if (opts.repathChance && Math.random() < opts.repathChance) {
            // randomly repath with some probability
            shouldRepath = true;
        }
        // pathfinding
        let newPath = false;
        if (shouldRepath || !moveData.path) {
            newPath = true;
            state.destination = destination;
            const cpu = Game.cpu.getUsed();
            // (!) Pathfinding is done here
            const ret = Pathing.findSwarmPath(swarm.anchor, destination, swarm.width, swarm.height, opts);
            const cpuUsed = Game.cpu.getUsed() - cpu;
            state.cpu = _.round(cpuUsed + state.cpu);
            if (Game.time % 10 == 0 && state.cpu > REPORT_SWARM_CPU_THRESHOLD) {
                log.alert(`Movement: heavy cpu use for swarm with ${_.first(swarm.creeps).print}, cpu: ${state.cpu}. ` +
                    `(${swarm.anchor.print} ${rightArrow} ${destination.print})`);
            }
            let color = "orange";
            if (ret.incomplete) {
                log.debug(`Movement: incomplete path for swarm with ${_.first(swarm.creeps).print}! ` +
                    `(${swarm.anchor.print} ${rightArrow} ${destination.print})`);
                color = "red";
            }
            this.circle(swarm.anchor, color);
            moveData.path = Pathing.serializePath(swarm.anchor, ret.path, color);
            state.stuckCount = 0;
        }
        // uncomment to visualize destination
        this.circle(destination, "orange");
        // Serialize state for swarm
        moveData.state = [
            swarm.anchor.x,
            swarm.anchor.y,
            state.stuckCount,
            state.cpu,
            destination.x,
            destination.y,
            destination.roomName,
        ];
        if (!moveData.path || moveData.path.length == 0) {
            console.log(`No path from ${swarm.anchor.print} to ${destination.print}!`);
            return ERR_NO_PATH;
        }
        // consume path
        if (state.stuckCount == 0 && !newPath) {
            moveData.path = moveData.path.substr(1);
        }
        const nextDirection = parseInt(moveData.path[0], 10);
        return swarm.move(nextDirection);
    }
    static combatMoveCallbackModifier(room, matrix, approach, avoid, options) {
        // This is only applied once creep is in the target room
        if (!options.allowExit) {
            MatrixLib.blockExits(matrix);
        }
        // Add penalties for things you want to avoid
        _.forEach(avoid, (avoidThis) => {
            let cost;
            let x, y;
            for (let dx = -avoidThis.range; dx <= avoidThis.range; dx++) {
                for (let dy = -avoidThis.range; dy <= avoidThis.range; dy++) {
                    x = avoidThis.pos.x + dx;
                    y = avoidThis.pos.y + dy;
                    cost = matrix.get(x, y);
                    if (cost < 0xff) {
                        cost = Math.min(cost + options.avoidPenalty, 0xfe);
                        matrix.set(x, y, cost);
                    }
                }
            }
        });
        // Add bonuses for things you want to approach
        _.forEach(approach, (approachThis) => {
            let cost;
            let x, y;
            for (let dx = -approachThis.range; dx <= approachThis.range; dx++) {
                for (let dy = -approachThis.range; dy <= approachThis.range; dy++) {
                    x = approachThis.pos.x + dx;
                    y = approachThis.pos.y + dy;
                    cost = matrix.get(x, y);
                    if (cost < 0xff) {
                        // is walkable
                        cost = Math.max(cost - options.approachBonus, 1);
                        matrix.set(x, y, cost);
                    }
                }
            }
        });
        // Prefer to path into open ramparts
        if (options.preferRamparts) {
            MatrixLib.setWalkableRampartCostToOne(matrix, room);
        }
        return matrix;
    }
    static swarmCombatMove(swarm, approach, avoid, options = {}) {
        _.defaultsDeep(options, {
            allowExit: false,
            avoidPenalty: 10,
            approachBonus: 5,
            preferRamparts: true,
            blockMyCreeps: true, // todo: is this necessary?
        });
        const callback = (roomName) => {
            const room = swarm.roomsByName[roomName];
            const matrixOpts = {
                explicitTerrainCosts: true,
                swarmWidth: swarm.width,
                swarmHeight: swarm.height,
                blockExits: !options.allowExit, // todo: maybe refactor allowExit => blockExits
            };
            let matrix = MatrixLib.getMatrix(roomName, matrixOpts).clone();
            if (room) {
                matrix = matrix.clone();
                if (options.blockMyCreeps) {
                    const otherCreeps = _.filter(room.creeps, (creep) => !_.any(swarm.creeps, (c) => c.name == creep.name));
                    MatrixLib.blockAfterMaxPooling(matrix, otherCreeps, swarm.width, swarm.height);
                }
                // Pathing.blockHostileCreeps(matrix, creep.room);
                Movement_1.combatMoveCallbackModifier(room, matrix, approach, avoid, options);
                // TODO: ^ needs to take swarm size into account
            }
            if (options.displayCostMatrix) {
                Visualizer.displayCostMatrix(matrix, roomName);
            }
            return matrix;
        };
        let outcome = NO_ACTION;
        // Flee from bad things that that you're too close to
        if (avoid.length > 0) {
            if (_.any(avoid, (goal) => swarm.minRangeTo(goal) <= goal.range)) {
                const allAvoid = _.flatten(_.map(avoid, (goal) => _.map(Pathing.getPosWindow(goal.pos, -swarm.width, -swarm.height), (pos) => ({
                    pos: pos,
                    range: goal.range,
                }))));
                if (options.displayAvoid) {
                    const room = swarm.rooms[0];
                    for (const avoid of allAvoid) {
                        const { x, y } = avoid.pos;
                        room.visual.text(avoid.range.toString(), x, y, {
                            color: "ff0099",
                        });
                    }
                }
                const avoidRet = PathFinder.search(swarm.anchor, allAvoid, {
                    roomCallback: callback,
                    flee: true,
                    maxRooms: options.allowExit ? 5 : 1,
                    plainCost: 2,
                    swampCost: 10,
                });
                if (avoidRet.path.length > 0) {
                    outcome = swarm.move(swarm.anchor.getDirectionTo(avoidRet.path[0]));
                    if (outcome == OK) {
                        return outcome;
                    }
                }
            }
        }
        // Approach things you want to go to if you're out of range of all the baddies
        if (approach.length > 0) {
            if (!_.any(approach, (goal) => swarm.minRangeTo(goal) <= goal.range)) {
                const allApproach = _.flatten(_.map(approach, (goal) => _.map(Pathing.getPosWindow(goal.pos, -swarm.width, -swarm.height), (pos) => ({
                    pos: pos,
                    range: goal.range,
                }))));
                const approachRet = PathFinder.search(swarm.anchor, allApproach, {
                    roomCallback: callback,
                    maxRooms: 1,
                    plainCost: 2,
                    swampCost: 10,
                });
                if (approachRet.path.length > 0) {
                    outcome = swarm.move(swarm.anchor.getDirectionTo(approachRet.path[0]));
                    if (outcome == OK) {
                        return outcome;
                    }
                }
            }
        }
        return outcome;
    }
    static combatMove(creep, approach, avoid, opts = {}) {
        _.defaultsDeep(opts, {
            allowExit: false,
            avoidPenalty: 10,
            approachBonus: 5,
            preferRamparts: true,
            requireRamparts: false,
            blockMyCreeps: true, // TODO: is this necessary?
            blockHostileCreeps: false,
            blockAlliedCreeps: false,
        });
        const callback = (roomName) => {
            const matrixOpts = {
                blockExits: !opts.allowExit, // todo: maybe refactor allowExit => blockExits
            };
            let matrix = MatrixLib.getMatrix(roomName, matrixOpts);
            if (roomName == creep.room.name) {
                matrix = matrix.clone();
                if (opts.blockMyCreeps) {
                    MatrixLib.blockMyCreeps(matrix, creep.room);
                } // TODO: is this necessary?
                if (opts.blockHostileCreeps) {
                    MatrixLib.blockHostileCreeps(matrix, creep.room);
                }
                if (opts.blockAlliedCreeps) {
                    MatrixLib.blockAlliedCreeps(matrix, creep.room);
                }
                if (opts.preferRamparts) {
                    MatrixLib.setWalkableRampartCostToOne(matrix, creep.room);
                }
                if (opts.requireRamparts) {
                    MatrixLib.blockNonRamparts(matrix, creep.room);
                }
                Movement_1.combatMoveCallbackModifier(creep.room, matrix, approach, avoid, opts);
                if (opts.displayCostMatrix) {
                    Visualizer.displayCostMatrix(matrix, roomName);
                }
                return matrix;
            }
            else {
                if (RoomIntel.isConsideredHostile(roomName)) {
                    return false;
                }
                return matrix;
            }
        };
        let outcome = NO_ACTION;
        // Flee from bad things that that you're too close to
        if (avoid.length > 0) {
            if (_.any(avoid, (goal) => creep.pos.inRangeToXY(goal.pos.x, goal.pos.y, goal.range)) &&
                !creep.inRampart) {
                const avoidRet = PathFinder.search(creep.pos, avoid, {
                    roomCallback: callback,
                    flee: true,
                    maxRooms: opts.allowExit ? 5 : 1,
                    plainCost: 2,
                    swampCost: 10,
                });
                if (avoidRet.path.length > 0) {
                    if (opts.debug) {
                        Pathing.serializePath(creep.pos, avoidRet.path, "magenta");
                    }
                    outcome = creep.move(creep.pos.getDirectionTo(avoidRet.path[0]));
                    if (outcome == OK) {
                        return outcome;
                    }
                }
            }
        }
        // Approach things you want to go to if you're out of range of all the baddies
        if (approach.length > 0) {
            if (!_.any(approach, (goal) => creep.pos.inRangeToXY(goal.pos.x, goal.pos.y, goal.range))) {
                const approachRet = PathFinder.search(creep.pos, approach, {
                    roomCallback: callback,
                    maxRooms: 1,
                    plainCost: 2,
                    swampCost: 10,
                });
                if (approachRet.path.length > 0) {
                    if (opts.debug) {
                        Pathing.serializePath(creep.pos, approachRet.path, "cyan");
                    }
                    outcome = creep.move(creep.pos.getDirectionTo(approachRet.path[0]));
                    if (outcome == OK) {
                        return outcome;
                    }
                }
            }
        }
        // Try to maneuver under ramparts if possible
        if ((opts.preferRamparts || opts.requireRamparts) &&
            !creep.inRampart &&
            approach.length > 0) {
            const openRamparts = _.filter(creep.room.walkableRamparts, (rampart) => _.any(approach, (g) => rampart.pos.inRangeToXY(g.pos.x, g.pos.y, g.range)) && rampart.pos.isWalkable());
            if (openRamparts.length > 0) {
                const ret = PathFinder.search(creep.pos, _.map(openRamparts, (r) => ({ pos: r.pos, range: 0 })), {
                    roomCallback: callback,
                    maxRooms: 1,
                    plainCost: 2,
                    swampCost: 10,
                });
                if (ret.path.length > 0) {
                    if (opts.debug) {
                        Pathing.serializePath(creep.pos, ret.path, "green");
                    }
                    outcome = creep.move(creep.pos.getDirectionTo(ret.path[0]));
                    if (outcome == OK) {
                        return outcome;
                    }
                }
            }
        }
        return outcome;
    }
    static invasionMoveCallbackModifier(roomName, matrix) {
        // This is only applied once creep is in the target room
        const room = Game.rooms[roomName];
        if (!room) {
            return matrix;
        }
        MatrixLib.blockExits(matrix);
        for (const hostile of room.invaders) {
            if (hostile.getActiveBodyparts(RANGED_ATTACK) > 1) {
                MatrixLib.setInRange(matrix, hostile, 3, 1, true);
            }
            else if (hostile.getActiveBodyparts(ATTACK) > 1) {
                MatrixLib.setInRange(matrix, hostile, 1, 1, true);
            }
        }
        for (const keeper of room.sourceKeepers) {
            MatrixLib.setInRange(matrix, keeper, 3, 10, true);
        }
        for (const lair of room.keeperLairs) {
            if ((lair.ticksToSpawn || Infinity) < 25) {
                MatrixLib.setInRange(matrix, lair, 5, 5, true);
            }
        }
        return matrix;
    }
    /**
     * Moving routine for guards or sourceReapers in a room with NPC invaders
     */
    static invasionMove(creep, destination, opts = {}) {
        _.defaultsDeep(opts, getDefaultMoveOptions());
        const dest = normalizePos(destination);
        if (creep.pos.getRangeTo(dest) > 8) {
            opts.repathChance = 0.1;
            opts.movingTarget = true;
        }
        if (creep.room.name == dest.roomName) {
            _.defaultsDeep(opts.pathOpts, {
                maxRooms: 1,
                modifyRoomCallback: (roomName, matrix) => Movement_1.invasionMoveCallbackModifier(roomName, matrix),
            });
        }
        return creep.goTo(dest, opts);
    }
    /**
     * Kite around enemies in a single room, repathing every tick. More expensive than flee().
     */
    static kite(creep, avoidGoals, options = {}) {
        var _a;
        const opts = _.defaultsDeep({}, (_a = options.pathOpts) !== null && _a !== void 0 ? _a : {}, {
            debug: options.debug,
            terrainCosts: getTerrainCosts(creep),
        });
        const nextPos = _.first(Pathing.findKitingPath(creep.pos, avoidGoals, opts).path);
        if (nextPos) {
            return creep.move(creep.pos.getDirectionTo(nextPos));
        }
        return NO_ACTION;
    }
    /**
     * Flee from avoid goals in the room while not re-pathing every tick like kite() does.
     */
    static flee(creep, avoidGoals, dropEnergy = false, opts = {}) {
        if (avoidGoals.length == 0) {
            return NO_ACTION; // nothing to flee from
        }
        const terrainCosts = getTerrainCosts(creep);
        const fleeDefaultOpts = {
            pathOpts: { debug: opts.debug, terrainCosts: terrainCosts },
        };
        _.defaultsDeep(opts, fleeDefaultOpts);
        const fleeRange = opts.fleeRange || (terrainCosts.plainCost > 1 ? 8 : 16);
        if (opts.fleeRange == undefined) {
            opts.fleeRange = fleeRange;
            opts.pathOpts.fleeRange = fleeRange;
        }
        const closest = creep.pos.findClosestByRange(avoidGoals);
        const rangeToClosest = closest ? creep.pos.getRangeTo(closest) : 50;
        if (rangeToClosest > opts.fleeRange) {
            // Out of range of baddies
            if (!creep.memory._go) {
                return NO_ACTION;
            }
            if (creep.pos.isEdge) {
                return creep.moveOffExit();
            }
            // wait until safe
            const moveData = creep.memory._go;
            if (moveData.fleeWait != undefined) {
                if (moveData.fleeWait <= 0) {
                    // you're safe now
                    delete creep.memory._go;
                    return NO_ACTION;
                }
                else {
                    moveData.fleeWait--;
                    return NO_ACTION;
                }
            }
            else {
                // you're safe
                return NO_ACTION;
            }
        }
        else {
            // Still need to run away
            // initialize data object
            if (!creep.memory._go) {
                creep.memory._go = {};
            }
            const moveData = creep.memory._go;
            moveData.fleeWait = 2;
            let shouldRepath = false;
            // Invalidate path if needed
            if (moveData.path) {
                if (moveData.path.length > 0) {
                    const nextDirection = parseInt(moveData.path[0], 10);
                    const pos = creep.pos.getPositionAtDirection(nextDirection);
                    if (!pos.isEdge) {
                        const newClosest = pos.findClosestByRange(avoidGoals);
                        if (newClosest &&
                            normalizePos(newClosest).getRangeTo(pos) <
                                rangeToClosest) {
                            shouldRepath = true;
                        }
                    }
                }
                else {
                    shouldRepath = true;
                }
            }
            // Re-calculate path if needed
            if (shouldRepath || !moveData.path || !moveData.destination) {
                const ret = Pathing.findFleePath(creep.pos, avoidGoals, opts.pathOpts || {});
                if (ret.path.length == 0) {
                    return NO_ACTION;
                }
                moveData.destination = _.last(ret.path);
                moveData.path = Pathing.serializePath(creep.pos, ret.path, "purple");
            }
            // Drop energy if needed
            if (dropEnergy && creep.store.energy > 0) {
                const nearbyContainers = creep.pos.findInRange(creep.room.storageUnits, 1);
                if (nearbyContainers.length > 0) {
                    creep.transfer(_.first(nearbyContainers), RESOURCE_ENERGY);
                }
                else {
                    creep.drop(RESOURCE_ENERGY);
                }
            }
            // Call goTo to the final position in path
            return Movement_1.goTo(creep, derefRoomPosition(moveData.destination), opts);
        }
    }
    static deserializeState(moveData, destination) {
        const state = {};
        if (moveData.state) {
            state.lastCoord = {
                x: moveData.state[STATE_PREV_X],
                y: moveData.state[STATE_PREV_Y],
            };
            state.cpu = moveData.state[STATE_CPU];
            state.stuckCount = moveData.state[STATE_STUCK];
            state.destination = new RoomPosition(moveData.state[STATE_DEST_X], moveData.state[STATE_DEST_Y], moveData.state[STATE_DEST_ROOMNAME]);
            if (moveData.state[STATE_CURRENT_X] &&
                moveData.state[STATE_CURRENT_Y]) {
                state.currentXY = {
                    x: moveData.state[STATE_CURRENT_X],
                    y: moveData.state[STATE_CURRENT_Y],
                };
            }
        }
        else {
            state.cpu = 0;
            state.destination = destination;
        }
        return state;
    }
    static serializeState(creep, destination, state, moveData, nextCoord) {
        if (nextCoord) {
            moveData.state = [
                creep.pos.x,
                creep.pos.y,
                state.stuckCount,
                state.cpu,
                destination.x,
                destination.y,
                destination.roomName,
                nextCoord.x,
                nextCoord.y,
            ];
        }
        else {
            moveData.state = [
                creep.pos.x,
                creep.pos.y,
                state.stuckCount,
                state.cpu,
                destination.x,
                destination.y,
                destination.roomName,
            ];
        }
    }
    /**
     * Update the currentXY property for a move state
     */
    static updateStateNextCoord(moveData, nextCoord) {
        if (moveData.state) {
            if (moveData.state[STATE_CURRENT_X] != undefined &&
                moveData.state[STATE_CURRENT_Y] != undefined) {
                moveData.state[STATE_CURRENT_X] = nextCoord.x;
                moveData.state[STATE_CURRENT_Y] = nextCoord.y;
            }
            else if (moveData.state.length == STATE_CURRENT_X) {
                moveData.state.push(nextCoord.x);
                moveData.state.push(nextCoord.y);
            }
            else {
                // Shouldn't ever reach here
                log.warning(`Invalid moveData.state length!`);
            }
        }
    }
    static isStuck(creep, state) {
        let stuck = false;
        if (state.lastCoord !== undefined) {
            if (sameCoord(creep.pos, state.lastCoord)) {
                // didn't move
                stuck = true;
            }
            else if (isExit(creep.pos) && isExit(state.lastCoord)) {
                // moved against exit
                stuck = true;
            }
        }
        return stuck;
    }
    /**
     * Draw a circle
     */
    static circle(pos, color, opacity) {
        return new RoomVisual(pos.roomName).circle(pos, {
            radius: 0.45,
            fill: "transparent",
            stroke: color,
            strokeWidth: 0.15,
            opacity: opacity,
        });
    }
};
Movement = Movement_1 = __decorate$1([
    profile
], Movement);
// Creep.prototype.goTo = function (destination: RoomPosition | HasPos, options?: MoveOptions) {
// 	return Movement.goTo(this, destination, options);
// };

function normalizeAnyZerg(creep) {
    return Overmind.zerg[creep.name] || Overmind.powerZerg[creep.name] || creep;
}
const FLEE_DEFAULT_TIMER = 10;
const FLEE_DEFAULT_FALLBACK_RANGE = 6;
/**
 * The AnyZerg abstract class contains all of the base methods that are present on both the Zerg and PowerZerg classes.
 * Most of these methods have been moved from the Zerg class.
 */
let AnyZerg = class AnyZerg {
    constructor(creep, notifyWhenAttacked = true) {
        this.isAnyZerg = true;
        // Copy over creep references
        this.creep = creep;
        this.store = creep.store;
        this.effects = creep.effects;
        this.hits = creep.hits;
        this.hitsMax = creep.hitsMax;
        this.id = creep.id;
        this.memory = creep.memory;
        this.name = creep.name;
        this.pos = creep.pos;
        this.nextPos = creep.pos;
        this.ref = creep.ref;
        this.roleName = creep.memory.role;
        this.room = creep.room; // only wrap actively spawned PowerCreeps
        this.saying = creep.saying;
        this.ticksToLive = creep.ticksToLive;
        // Extra properties
        if (isPowerCreep(creep)) {
            this.lifetime = POWER_CREEP_LIFE_TIME;
        }
        else {
            this.lifetime =
                _.filter(creep.body, (part) => part.type == CLAIM).length > 0 ?
                    CREEP_CLAIM_LIFE_TIME
                    : CREEP_LIFE_TIME;
        }
        this.actionLog = {};
        this.blockMovement = false;
        // Register global references
        // @ts-expect-error Global getter for Zergs
        global[this.name] = this;
        // Handle attack notification when at lifetime - 1
        if (!notifyWhenAttacked &&
            (this.ticksToLive || 0) >=
                this.lifetime - (NEW_OVERMIND_INTERVAL + 1)) {
            // creep.notifyWhenAttacked only uses the 0.2CPU intent cost if it changes the intent value
            this.notifyWhenAttacked(notifyWhenAttacked);
        }
    }
    /**
     * Refresh all changeable properties of the creep or delete from Overmind and global when dead
     */
    refresh() {
        const creep = Game.creeps[this.name];
        if (creep) {
            this.creep = creep;
            this.pos = creep.pos;
            this.nextPos = creep.pos;
            this.store = creep.store;
            this.hits = creep.hits;
            this.memory = creep.memory;
            this.room = creep.room;
            this.saying = creep.saying;
            this.ticksToLive = creep.ticksToLive;
            this.actionLog = {};
            this.blockMovement = false;
            this._task = null;
        }
        else {
            log.debug(`Deleting ${this.print} from global`);
            // @ts-expect-error Global getter for Zergs
            delete global[this.name];
        }
    }
    debug(...args) {
        if (this.memory.debug) {
            log.alert(this.print, ...args);
        }
    }
    get print() {
        return ('<a href="#!/room/' +
            Game.shard.name +
            "/" +
            this.pos.roomName +
            '">[' +
            this.name +
            "]</a>");
    }
    // Wrapped creep methods ===========================================================================================
    cancelOrder(methodName) {
        const result = this.creep.cancelOrder(methodName);
        if (result == OK) {
            this.actionLog[methodName] = false;
        }
        return result;
    }
    drop(resourceType, amount) {
        var _a;
        var _b;
        const result = this.creep.drop(resourceType, amount);
        (_a = (_b = this.actionLog).drop) !== null && _a !== void 0 ? _a : (_b.drop = result == OK);
        return result;
    }
    goDrop(pos, resourceType, amount) {
        if (this.pos.inRangeToPos(pos, RANGES.DROP)) {
            return this.drop(resourceType, amount);
        }
        else {
            return this.goTo(pos);
        }
    }
    move(direction, force = false) {
        var _a;
        var _b;
        if (!this.blockMovement || force) {
            const result = this.creep.move(direction);
            (_a = (_b = this.actionLog).move) !== null && _a !== void 0 ? _a : (_b.move = result == OK);
            if (result == OK) {
                this.nextPos = this.pos.getPositionAtDirection(direction);
            }
            return result;
        }
        else {
            return ERR_BUSY;
        }
    }
    notifyWhenAttacked(enabled) {
        return this.creep.notifyWhenAttacked(enabled);
    }
    pickup(resource) {
        const result = this.creep.pickup(resource);
        if (!this.actionLog.pickup) {
            this.actionLog.pickup = result == OK;
        }
        return result;
    }
    goPickup(resource) {
        if (this.pos.inRangeToPos(resource.pos, RANGES.DROP)) {
            return this.pickup(resource);
        }
        else {
            return this.goTo(resource.pos);
        }
    }
    /* Say a message; maximum message length is 10 characters */
    say(message, pub) {
        return this.creep.say(message, pub);
    }
    suicide() {
        this.say("💀 RIP 💀", true);
        return this.creep.suicide();
    }
    transfer(target, resourceType = RESOURCE_ENERGY, amount) {
        var _a;
        var _b;
        let result;
        if (isAnyZerg(target)) {
            result = this.creep.transfer(target.creep, resourceType, amount);
        }
        else {
            result = this.creep.transfer(target, resourceType, amount);
        }
        (_a = (_b = this.actionLog).transfer) !== null && _a !== void 0 ? _a : (_b.transfer = result == OK);
        return result;
    }
    transferAll(target) {
        for (const [resourceType, amount] of this.creep.store.contents) {
            if (amount > 0) {
                return this.transfer(target, resourceType);
            }
        }
    }
    goTransfer(target, resourceType = RESOURCE_ENERGY, amount) {
        if (this.transfer(target, resourceType, amount) == ERR_NOT_IN_RANGE) {
            this.goTo(target);
        }
    }
    withdraw(target, resourceType = RESOURCE_ENERGY, amount) {
        var _a;
        var _b;
        const result = this.creep.withdraw(target, resourceType, amount);
        (_a = (_b = this.actionLog).withdraw) !== null && _a !== void 0 ? _a : (_b.withdraw = result == OK);
        return result;
    }
    goWithdraw(target, resourceType = RESOURCE_ENERGY, amount) {
        if (this.withdraw(target, resourceType, amount) == ERR_NOT_IN_RANGE) {
            this.goTo(target);
        }
    }
    sleep(until) {
        this.memory.sleepUntil = until;
    }
    isSleeping() {
        if (this.memory.sleepUntil) {
            this.debug(`sleeping for ${this.memory.sleepUntil - Game.time}`);
            if (Game.time >= this.memory.sleepUntil) {
                delete this.memory.sleepUntil;
                return false;
            }
            return true;
        }
        return false;
    }
    goHome() {
        return this.goToRoom(this.memory.data.origin);
    }
    // Custom creep methods ============================================================================================
    get isDamaged() {
        return this.hits < this.hitsMax;
    }
    // Carry methods
    get hasMineralsInCarry() {
        for (const [resourceType, amount] of this.store.contents) {
            if (resourceType != RESOURCE_ENERGY && amount > 0) {
                return true;
            }
        }
        return false;
    }
    // Task logic ------------------------------------------------------------------------------------------------------
    /**
     * Wrapper for _task
     */
    get task() {
        if (!this._task) {
            this._task =
                this.memory.task ? initializeTask(this.memory.task) : null;
        }
        return this._task;
    }
    /**
     * Assign the creep a task with the setter, replacing creep.assign(Task)
     */
    set task(task) {
        // Unregister target from old task if applicable
        const oldProtoTask = this.memory.task;
        if (oldProtoTask) {
            const oldRef = oldProtoTask._target.ref;
            if (Overmind.cache.targets[oldRef]) {
                _.remove(Overmind.cache.targets[oldRef], (name) => name == this.name);
            }
        }
        // Set the new task
        this.memory.task = task ? task.proto : null;
        if (task) {
            if (task.target) {
                // Register task target in cache if it is actively targeting something (excludes goTo and similar)
                if (!Overmind.cache.targets[task.target.ref]) {
                    Overmind.cache.targets[task.target.ref] = [];
                }
                Overmind.cache.targets[task.target.ref].push(this.name);
            }
            // Register references to creep
            task.creep = this;
        }
        // Clear cache
        this._task = null;
    }
    /**
     * Does the creep have a valid task at the moment?
     */
    get hasValidTask() {
        return !!this.task && this.task.isValid();
    }
    /**
     * Creeps are idle if they don't have a task.
     */
    get isIdle() {
        return !this.task || !this.task.isValid();
    }
    // Overlord logic --------------------------------------------------------------------------------------------------
    get overlord() {
        if (this.memory["O" /* MEM.OVERLORD */]) {
            return Overmind.overlords[this.memory["O" /* MEM.OVERLORD */]] || null;
        }
        else {
            return null;
        }
    }
    set overlord(newOverlord) {
        // Remove cache references to old assignments
        const roleName = this.memory.role;
        const ref = this.memory["O" /* MEM.OVERLORD */];
        const oldOverlord = ref ? Overmind.overlords[ref] : null;
        if (ref &&
            Overmind.cache.overlords[ref] &&
            Overmind.cache.overlords[ref][roleName]) {
            _.remove(Overmind.cache.overlords[ref][roleName], (name) => name == this.name);
        }
        if (newOverlord) {
            // Change to the new overlord's colony
            this.memory["C" /* MEM.COLONY */] = newOverlord.colony.name;
            // Change assignments in memory
            this.memory["O" /* MEM.OVERLORD */] = newOverlord.ref;
            // Update the cache references
            if (!Overmind.cache.overlords[newOverlord.ref]) {
                Overmind.cache.overlords[newOverlord.ref] = {};
            }
            if (!Overmind.cache.overlords[newOverlord.ref][roleName]) {
                Overmind.cache.overlords[newOverlord.ref][roleName] = [];
            }
            Overmind.cache.overlords[newOverlord.ref][roleName].push(this.name);
        }
        else {
            this.memory["O" /* MEM.OVERLORD */] = null;
        }
        if (oldOverlord) {
            oldOverlord.recalculateCreeps();
        }
        if (newOverlord) {
            newOverlord.recalculateCreeps();
        }
    }
    /**
     * When a zerg has no more use for its current overlord, it will be retired.
     */
    retire() {
        var _a, _b, _c;
        if (this.colony && !isPowerCreep(this.creep)) {
            const colonySpawns = (_c = (_b = (_a = this.colony) === null || _a === void 0 ? void 0 : _a.hatchery) === null || _b === void 0 ? void 0 : _b.spawns) !== null && _c !== void 0 ? _c : [];
            const nearbySpawn = this.pos.findClosestByMultiRoomRange(colonySpawns);
            if (nearbySpawn) {
                log.info(`${this.print} is retiring from duty to ${nearbySpawn.print}`);
                this.overlord = this.colony.overlords.default;
                this.task = Tasks.retire(nearbySpawn);
            }
            return;
        }
        log.warning(`${this.print} is committing suicide!`);
        return this.suicide();
    }
    /**
     * Reassigns the creep to work under a new overlord and as a new role.
     */
    reassign(newOverlord, newRole, invalidateTask = true) {
        this.overlord = newOverlord;
        if (newOverlord &&
            newOverlord.colony &&
            this.colony != newOverlord.colony) {
            this.colony = newOverlord.colony;
        }
        if (newRole) {
            this.roleName = newRole;
            this.memory.role = newRole;
        }
        if (invalidateTask) {
            this.task = null;
        }
    }
    /**
     * Execute the task you currently have.
     */
    run() {
        var _a, _b, _c, _d, _e;
        let res;
        if (this.task) {
            res = this.task.run();
        }
        if (this.memory.debug) {
            const data = [this.name];
            if (this.task) {
                data.push(`task: ${this.task.name}`);
                data.push(`status: ${errorForCode(res !== null && res !== void 0 ? res : OK)}`);
                data.push(`pos: ${this.task.targetPos.printPlain}`);
            }
            else {
                data.push(`idle`);
            }
            new RoomVisual(this.room.name).infoBox(data, this.pos.x, this.pos.y, {
                opacity: 0.9,
            });
            // Current path
            if (this.memory._go && ((_a = this.memory._go) === null || _a === void 0 ? void 0 : _a.path)) {
                // log.debug(`${this.creep}: ${this.nextPos.print} ${this.pos.print}`);
                const serialPath = (_b = this.memory._go) === null || _b === void 0 ? void 0 : _b.path.substring(1);
                const path = Pathing.deserializePath(this.nextPos, serialPath);
                // log.debug(`${this.print} has path: ${path.length}, ${path.map(p => p.print).join(" > ")}`);
                Visualizer.drawPath(path, { fill: "red", lineStyle: "dashed" });
                const lastStep = _.last(path);
                if (lastStep) {
                    if (lastStep.roomName !== this.pos.roomName || true) {
                        const lastData = [
                            this.name,
                            `eta: ${(_e = (_d = (_c = this.task) === null || _c === void 0 ? void 0 : _c.eta) !== null && _d !== void 0 ? _d : this.memory._go.path.length) !== null && _e !== void 0 ? _e : NaN}`,
                        ];
                        new RoomVisual(lastStep.roomName).infoBox(lastData, lastStep.x, lastStep.y, {
                            color: "red",
                            opacity: 0.6,
                        });
                    }
                }
            }
        }
        return res;
    }
    // Colony association ----------------------------------------------------------------------------------------------
    /**
     * Colony that the creep belongs to.
     */
    get colony() {
        if (this.memory["C" /* MEM.COLONY */] != null) {
            return Overmind.colonies[this.memory["C" /* MEM.COLONY */]];
        }
        else {
            return null;
        }
    }
    set colony(newColony) {
        if (newColony != null) {
            this.memory["C" /* MEM.COLONY */] = newColony.name;
        }
        else {
            this.memory["C" /* MEM.COLONY */] = null;
        }
    }
    /**
     * If the creep is in a colony room or outpost
     */
    get inColonyRoom() {
        return Overmind.colonyMap[this.room.name] == this.memory["C" /* MEM.COLONY */];
    }
    // Movement and location -------------------------------------------------------------------------------------------
    goTo(destination, options = {}) {
        return Movement.goTo(this, destination, options);
    }
    goToRoom(roomName, options = {}) {
        return Movement.goToRoom(this, roomName, options);
    }
    inSameRoomAs(target) {
        return this.pos.roomName == target.pos.roomName;
    }
    safelyInRoom(roomName) {
        return this.room.name == roomName && !this.pos.isEdge;
    }
    get inRampart() {
        return this.creep.inRampart;
    }
    get isMoving() {
        const moveData = this.memory._go;
        return ((!!moveData && !!moveData.path && moveData.path.length > 1) ||
            this.actionLog[MOVE]);
    }
    /**
     * Kite around hostiles in the room
     */
    kite(avoidGoals = this.room.hostiles, options = {}) {
        return Movement.kite(this, avoidGoals, options);
    }
    defaultFleeGoals() {
        let fleeGoals = [];
        fleeGoals = fleeGoals
            .concat(this.room.hostiles)
            .concat(_.filter(this.room.keeperLairs, (lair) => (lair.ticksToSpawn || Infinity) < 10));
        return fleeGoals;
    }
    /**
     * Flee from hostiles in the room, while not repathing every tick // TODO: take a look at this
     */
    flee(avoidGoals = this.room
        .fleeDefaults, fleeOptions = {}, moveOptions = {}) {
        if (avoidGoals.length == 0 ||
            this.room.dangerousHostiles.find((creep) => creep.pos.getRangeToXY(this.pos.x, this.pos.y) < 6) == undefined) {
            return false;
        }
        else if (this.room.controller &&
            this.room.controller.my &&
            this.room.controller.safeMode) {
            return false;
        }
        else {
            return (Movement.flee(this, avoidGoals, fleeOptions.dropEnergy, moveOptions) !== NO_ACTION);
        }
    }
    /**
     * Callback that is checked for many civilian roles. Returns true if the civilian zerg is in a dangerous situation
     * and handles the zerg retreating to a fallback room. Acts as a replacement to the current default Zerg.flee()
     * danger avoidance logic
     */
    avoidDanger(opts = {}) {
        var _a;
        // If you're almost expired or you're spawning do nothing - if you get killed you're cheap and faster to replace
        if (((_a = this.ticksToLive) !== null && _a !== void 0 ? _a : 0) < 50) {
            return false; // I just wanna die!!
        }
        _.defaults(opts, {
            timer: FLEE_DEFAULT_TIMER,
            dropEnergy: true,
            fallbackColonyRange: FLEE_DEFAULT_FALLBACK_RANGE,
        });
        const closestHostile = this.pos.findClosestByLimitedRange(this.room.dangerousHostiles, RANGES.RANGED_ATTACK + 2);
        const roomIsSafe = this.room.isSafe || !!closestHostile;
        // If you previously determined you are in danger, wait for timer to expire
        if (this.memory.avoidDanger) {
            if (this.memory.avoidDanger.timer > 0 && !roomIsSafe) {
                if (this.memory.avoidDanger.flee === true) {
                    this.debug(() => `in danger, random flee from ${this.room.dangerousHostiles.map((c) => c.print)}!`);
                    this.flee(this.room.dangerousHostiles, opts);
                    return true;
                }
                this.debug(() => `in danger, fleeing from ${this.room.dangerousHostiles.map((c) => c.print)} toward ${this.memory.avoidDanger.flee}!`);
                this.goToRoom(this.memory.avoidDanger.flee);
                if (opts.dropEnergy && this.store.energy > 0) {
                    this.drop(RESOURCE_ENERGY); // transfer energy to container check is only run on first danger tick
                }
                this.memory.avoidDanger.timer--;
                return true;
            }
            else {
                delete this.memory.avoidDanger;
            }
        }
        if (!roomIsSafe || this.hits < this.hitsMax) {
            this.debug(() => `roomIsSafe: ${roomIsSafe}, damage: ${this.hits}/${this.hitsMax}`);
            if (Cartographer.roomType(this.room.name) == ROOMTYPE_SOURCEKEEPER) {
                // If you're in an SK room, you can skip the danger avoidance as long as you have max hp, there are no
                // player hostiles, no invaders, and you're not in range to any of the sourceKeepers or spawning lairs
                if (this.hits == this.hitsMax &&
                    this.room.dangerousPlayerHostiles.length == 0 &&
                    this.room.invaders.length == 0 &&
                    !_.any(this.room.fleeDefaults, (fleeThing) => this.pos.inRangeTo(fleeThing, 5))) {
                    this.debug(() => `${!roomIsSafe ? "room is unsafe" : `damaged`}, but in SK room, and no hostiles around, ignoring`);
                    // Not actually in danger
                    return false;
                }
            }
            let flee;
            const maxLinearRange = opts.fallbackColonyRange;
            const isInColonyRoom = this.colony ? this.colony.name === this.room.name : false;
            // Like 99.999% of the time this will be the case
            // FIXME: this doesn't handle portals
            if (this.colony &&
                Game.map.getRoomLinearDistance(this.room.name, this.colony.name) <= maxLinearRange &&
                !isInColonyRoom) {
                flee = this.colony.name;
            }
            else {
                // Pick the closest colony we can find, ignoring our own if it's under attack
                const nearbyColonies = _.filter(getAllColonies(), (colony) => {
                    if (isInColonyRoom && colony.name === this.colony.name) {
                        return false;
                    }
                    return (Game.map.getRoomLinearDistance(this.room.name, colony.name) <= maxLinearRange);
                });
                const closestColony = minBy(nearbyColonies, (colony) => {
                    const route = Pathing.findRoute(this.room.name, colony.room.name);
                    if (route == ERR_NO_PATH) {
                        return false;
                    }
                    else {
                        return route.length;
                    }
                });
                if (closestColony) {
                    flee = closestColony.name;
                }
                else {
                    log.error(`${this.print} is all alone in a dangerous place and can't find their way home!`);
                    flee = true;
                }
            }
            this.memory.avoidDanger = {
                start: Game.time,
                timer: opts.timer,
                flee: flee,
            };
            if (flee === true) {
                this.flee(this.room.dangerousHostiles, opts);
                this.debug(() => `random flee from ${this.room.dangerousHostiles.map((c) => c.print)}`);
                return true;
            }
            if (opts.dropEnergy && this.store.energy > 0) {
                const containersInRange = this.pos.findInRange(this.room.containers, 1);
                const adjacentContainer = _.first(containersInRange);
                if (adjacentContainer) {
                    this.transfer(adjacentContainer, RESOURCE_ENERGY);
                }
            }
            this.debug(() => `fleeing toward room ${flee}`);
            this.goToRoom(flee);
            return true;
        }
        return false;
    }
    /**
     * Park the creep off-roads
     */
    park(pos = this.pos, maintainDistance = false) {
        return Movement.park(this, pos, maintainDistance);
    }
    /**
     * Moves a creep off of the current tile to the first available neighbor
     */
    moveOffCurrentPos() {
        return Movement.moveOffCurrentPos(this);
    }
    /**
     * Moves onto an exit tile
     */
    moveOnExit() {
        return Movement.moveOnExit(this);
    }
    /**
     * Moves off of an exit tile
     */
    moveOffExit(towardPos, avoidSwamp = true) {
        return Movement.moveOffExit(this, towardPos, avoidSwamp);
    }
    // Miscellaneous fun stuff -----------------------------------------------------------------------------------------
    sayLoop(messageList, pub) {
        return this.say(messageList[Game.time % messageList.length], pub);
    }
    sayRandom(phrases, pub) {
        return this.say(phrases[Math.floor(Math.random() * phrases.length)], pub);
    }
};
AnyZerg = __decorate$1([
    profile
], AnyZerg);

function toCreep(creep) {
    return isStandardZerg(creep) ? creep.creep : creep;
}
// Last pipeline is more complex because it depends on the energy a creep has; sidelining this for now
const ACTION_PIPELINES = [
    [
        "harvest",
        "attack",
        "build",
        "repair",
        "dismantle",
        "attackController",
        "rangedHeal",
        "heal",
    ],
    ["rangedAttack", "rangedMassAttack", "build", "repair", "rangedHeal"],
    // ['upgradeController', 'build', 'repair', 'withdraw', 'transfer', 'drop'],
];
/**
 * The Zerg class is a wrapper for owned creeps and contains all wrapped creep methods and many additional methods for
 * direct control of a creep. As of April 2020, this class now extends the AnyZerg class to accommodate the introduction
 * of power creeps into the game.
 */
let Zerg = class Zerg extends AnyZerg {
    constructor(creep, notifyWhenAttacked = true) {
        super(creep, notifyWhenAttacked);
        this.isStandardZerg = true;
        // Copy over creep references
        this.body = creep.body;
        this.fatigue = creep.fatigue;
        this.spawning = creep.spawning;
        // Register global references
        Overmind.zerg[this.name] = this;
    }
    /**
     * Refresh all changeable properties of the creep or delete from Overmind and global when dead
     */
    refresh() {
        super.refresh();
        const creep = Game.creeps[this.name];
        if (creep) {
            this.body = creep.body;
            this.fatigue = creep.fatigue;
            this.spawning = creep.spawning;
            this._neededBoosts = undefined;
        }
        else {
            delete Overmind.zerg[this.name];
        }
    }
    get spawnInfo() {
        var _a;
        if (!this.spawning) {
            return undefined;
        }
        if (!this._spawnInfo) {
            const spawner = this.pos.lookForStructure(STRUCTURE_SPAWN);
            if (!spawner) {
                // Shouldn't ever get here
                log.error(`Error determining ticks to spawn for ${this.name} @ ${this.pos.print}!`);
                return undefined;
            }
            this._spawnInfo = (_a = spawner.spawning) !== null && _a !== void 0 ? _a : undefined;
        }
        return this._spawnInfo;
    }
    get spawner() {
        var _a;
        return (_a = this.spawnInfo) === null || _a === void 0 ? void 0 : _a.spawn;
    }
    get ticksUntilSpawned() {
        var _a;
        return (_a = this.spawnInfo) === null || _a === void 0 ? void 0 : _a.remainingTime;
    }
    get spawnPos() {
        const info = this.spawnInfo;
        if (!info) {
            return undefined;
        }
        let directions = info.directions;
        if (!directions) {
            directions = [TOP];
        }
        // Go through the list of directions and rebuild the position
        let pos = info.spawn.pos;
        let dir;
        while ((dir = directions.shift())) {
            pos = pos.getPositionAtDirection(dir);
        }
        return pos;
    }
    // Wrapped creep methods ===========================================================================================
    attack(target) {
        var _a, _b;
        var _c;
        const result = this.creep.attack(target);
        if (result == OK) {
            this.actionLog.attack = true;
            if (isCreep(target) || isPowerCreep(target)) {
                (_a = target.hitsPredicted) !== null && _a !== void 0 ? _a : (target.hitsPredicted = target.hits);
                target.hitsPredicted -= CombatIntel$1.predictedDamageAmount(this.creep, target, "attack");
            }
            if (isCreep(target)) {
                // account for hitback effects
                (_b = (_c = this.creep).hitsPredicted) !== null && _b !== void 0 ? _b : (_c.hitsPredicted = this.creep.hits);
                this.creep.hitsPredicted -= CombatIntel$1.predictedDamageAmount(target, this.creep, "attack");
            }
            if (this.memory.talkative) {
                this.say(`💥`);
            }
        }
        return result;
    }
    attackController(controller) {
        const result = this.creep.attackController(controller);
        if (!this.actionLog.attackController) {
            this.actionLog.attackController = result == OK;
        }
        return result;
    }
    build(target) {
        var _a;
        var _b;
        const result = this.creep.build(target);
        (_a = (_b = this.actionLog).build) !== null && _a !== void 0 ? _a : (_b.build = result == OK);
        return result;
    }
    goBuild(target) {
        if (this.build(target) == ERR_NOT_IN_RANGE) {
            this.goTo(target);
        }
    }
    claimController(controller) {
        const result = this.creep.claimController(controller);
        if (!this.actionLog.claimController) {
            this.actionLog.claimController = result == OK;
        }
        if (result == OK) {
            Overmind.shouldBuild = true; // rebuild the overmind object on the next tick to account for new room
        }
        return result;
    }
    dismantle(target) {
        var _a;
        var _b;
        const result = this.creep.dismantle(target);
        (_a = (_b = this.actionLog).dismantle) !== null && _a !== void 0 ? _a : (_b.dismantle = result == OK);
        return result;
    }
    goDismantle(target) {
        const res = this.dismantle(target);
        if (res == ERR_NOT_IN_RANGE) {
            return this.goTo(target);
        }
        return res;
    }
    generateSafeMode(target) {
        return this.creep.generateSafeMode(target);
    }
    harvest(source) {
        var _a;
        var _b;
        const result = this.creep.harvest(source);
        (_a = (_b = this.actionLog).harvest) !== null && _a !== void 0 ? _a : (_b.harvest = result == OK);
        return result;
    }
    goHarvest(source) {
        if (this.harvest(source) == ERR_NOT_IN_RANGE) {
            this.goTo(source);
        }
    }
    rangedAttack(target) {
        var _a;
        const result = this.creep.rangedAttack(target);
        if (result == OK) {
            this.actionLog.rangedAttack = true;
            if (isCreep(target)) {
                (_a = target.hitsPredicted) !== null && _a !== void 0 ? _a : (target.hitsPredicted = target.hits);
                target.hitsPredicted -= CombatIntel$1.predictedDamageAmount(this, target, "rangedAttack");
            }
            if (this.memory.talkative) {
                this.say(`🔫`);
            }
        }
        return result;
    }
    rangedMassAttack() {
        var _a;
        const result = this.creep.rangedMassAttack();
        if (result == OK) {
            this.actionLog.rangedMassAttack = true;
            for (const target of this.pos.findInRange(this.room.hostiles, 3)) {
                (_a = target.hitsPredicted) !== null && _a !== void 0 ? _a : (target.hitsPredicted = target.hits);
                target.hitsPredicted -= CombatIntel$1.getMassAttackDamageTo(this, target);
            }
            if (this.memory.talkative) {
                this.say(`💣`);
            }
        }
        return result;
    }
    repair(target) {
        var _a, _b;
        var _c;
        const result = this.creep.repair(target);
        (_a = (_c = this.actionLog).repair) !== null && _a !== void 0 ? _a : (_c.repair = result === OK);
        if (result === OK) {
            (_b = this.colony) === null || _b === void 0 ? void 0 : _b.trackEnergyUse(EnergyUse.REPAIR, -this.bodypartCounts[WORK]);
        }
        return result;
    }
    goRepair(target) {
        if (this.repair(target) == ERR_NOT_IN_RANGE) {
            this.goTo(target);
        }
    }
    reserveController(controller) {
        var _a;
        var _b;
        const result = this.creep.reserveController(controller);
        (_a = (_b = this.actionLog).reserveController) !== null && _a !== void 0 ? _a : (_b.reserveController = result == OK);
        return result;
    }
    signController(target, text) {
        var _a;
        var _b;
        const result = this.creep.signController(target, text);
        (_a = (_b = this.actionLog).signController) !== null && _a !== void 0 ? _a : (_b.signController = result == OK);
        return result;
    }
    upgradeController(controller) {
        var _a, _b;
        var _c;
        const result = this.creep.upgradeController(controller);
        (_a = (_c = this.actionLog).upgradeController) !== null && _a !== void 0 ? _a : (_c.upgradeController = result == OK);
        if (result === OK) {
            (_b = this.colony) === null || _b === void 0 ? void 0 : _b.trackEnergyUse(EnergyUse.UPGRADE, -this.bodypartCounts[WORK]);
        }
        return result;
    }
    heal(target, rangedHealInstead = false) {
        var _a;
        if (rangedHealInstead && !this.pos.isNearTo(target)) {
            return this.rangedHeal(target);
        }
        const creep = toCreep(target);
        const result = this.creep.heal(creep);
        if (result == OK) {
            this.actionLog.heal = true;
            (_a = creep.hitsPredicted) !== null && _a !== void 0 ? _a : (creep.hitsPredicted = creep.hits);
            creep.hitsPredicted += CombatIntel$1.getHealAmount(this);
            if (this.memory.talkative) {
                this.say("🚑");
            }
        }
        return result;
    }
    rangedHeal(target) {
        var _a;
        const creep = toCreep(target);
        const result = this.creep.rangedHeal(creep);
        if (result == OK) {
            this.actionLog.rangedHeal = true;
            (_a = creep.hitsPredicted) !== null && _a !== void 0 ? _a : (creep.hitsPredicted = creep.hits);
            creep.hitsPredicted += CombatIntel$1.getRangedHealAmount(this);
            if (this.memory.talkative) {
                this.say(`💉`);
            }
        }
        return result;
    }
    // Simultaneous creep actions --------------------------------------------------------------------------------------
    /**
     * Determine whether the given action will conflict with an action the creep has already taken.
     * See http://docs.screeps.com/simultaneous-actions.html for more details.
     */
    canExecute(actionName) {
        // Only one action can be executed from within a single pipeline
        let conflictingActions = [actionName];
        for (const pipeline of ACTION_PIPELINES) {
            if (pipeline.includes(actionName)) {
                conflictingActions = conflictingActions.concat(pipeline);
            }
        }
        for (const action of conflictingActions) {
            if (this.actionLog[action]) {
                return false;
            }
        }
        return true;
    }
    // Body configuration and related data -----------------------------------------------------------------------------
    getActiveBodyparts(type) {
        return this.creep.getActiveBodyparts(type);
    }
    /**
     * The same as creep.getActiveBodyparts, but just counts bodyparts regardless of condition.
     */
    getBodyparts(partType) {
        return _.filter(this.body, (part) => part.type == partType).length;
    }
    // Custom creep methods ============================================================================================
    // Boosting logic --------------------------------------------------------------------------------------------------
    get boostCounts() {
        return _.countBy(this.body, (bodyPart) => bodyPart.boost);
    }
    get bodypartCounts() {
        return this.creep.bodypartCounts;
    }
    get needsBoosts() {
        if (!this.overlord) {
            return false;
        }
        if ((this.ticksToLive || this.lifetime) <
            MIN_LIFETIME_FOR_BOOST * this.lifetime) {
            return false;
        }
        return !_.isEmpty(this.getNeededBoosts());
    }
    /**
     * Gets an object describing the amount of boosts (in minerals, not bodyparts) this Zerg needs. If the zerg is
     * fully boosted for a given resource type, the entry is removed from memory.needBoosts.
     */
    getNeededBoosts() {
        if (!this._neededBoosts) {
            // this is cleared each tick
            if (this.memory.needBoosts && this.memory.needBoosts.length > 0) {
                const neededBoosts = {};
                const boostCounts = this.boostCounts;
                const bodyCounts = this.bodypartCounts;
                for (const boost of _.cloneDeep(this.memory.needBoosts)) {
                    const bodypartType = BOOST_PARTS[boost];
                    if (!bodypartType) {
                        log.error(`${boost} is not a valid boost!`);
                    }
                    const numParts = bodyCounts[bodypartType] || 0;
                    const numBoostedParts = boostCounts[boost] || 0;
                    if (numBoostedParts < numParts) {
                        neededBoosts[boost] =
                            LAB_BOOST_MINERAL * (numParts - numBoostedParts);
                    }
                    else {
                        _.pull(this.memory.needBoosts, boost);
                    }
                }
                this._neededBoosts = neededBoosts;
            }
            else {
                this._neededBoosts = {};
            }
        }
        return this._neededBoosts;
    }
};
Zerg = __decorate$1([
    profile
], Zerg);

function hasColony(initializer) {
    return initializer.colony != undefined;
}
const DEFAULT_PRESPAWN = 40;
const MAX_SPAWN_REQUESTS = 100; // this stops division by zero or related errors from sending infinite requests
const getDefaultOverlordMemory = () => ({
    active: true,
});
/**
 * An Overlord is roughly analogous to a process in an OS: it is a generalization of a set of related things that need
 * to be done in a colony, like mining from a site, bootstrapping a new colony, guarding against invaders, or building
 * construction sites. Overlords handle spawning or obtaining suitable creeps to do these things and contain the actual
 * implementation of doing them.
 */
let Overlord = class Overlord {
    constructor(initializer, name, priority, memDefaults = getDefaultOverlordMemory) {
        this.initializer = initializer;
        this.memory = Mem.wrap(initializer.memory, name, memDefaults);
        this.room = initializer.room;
        this.priority = priority;
        this.name = name;
        this.ref = initializer.ref + ">" + name;
        this.pos = initializer.pos;
        this.colony = hasColony(initializer) ? initializer.colony : initializer;
        this.spawnGroup = undefined;
        // Calculate the creeps associated with this overlord and group by roles
        this._creeps = {};
        this._zerg = {};
        this._combatZerg = {};
        this.recalculateCreeps();
        this.creepUsageReport = _.mapValues(this._creeps, () => undefined);
        // Register the overlord on the colony overseer and on the overmind
        Overmind.overlords[this.ref] = this;
        Overmind.overseer.registerOverlord(this);
    }
    get print() {
        return ('<a href="#!/room/' +
            Game.shard.name +
            "/" +
            this.pos.roomName +
            '">[' +
            this.ref +
            "]</a>");
    }
    debug(...args) {
        if (this.memory.debug) {
            log.alert(this.print, ...args);
        }
    }
    /**
     * Refreshes overlord, recalculating creeps and refreshing existing Zerg. New creeps are automatically added,
     * and the corresponding role groups (e.g. 'queens') are automatically updated. Child methods do not need to
     * refresh their zerg properties or their memories, only other room objects stored on the Overlord.
     */
    refresh() {
        // Refresh memory
        this.memory = Mem.wrap(this.initializer.memory, this.name);
        // Refresh room
        this.room = Game.rooms[this.pos.roomName];
        // Refresh zerg
        this.recalculateCreeps();
        for (const role in this._creeps) {
            for (const creep of this._creeps[role]) {
                if (Overmind.zerg[creep.name]) {
                    // log.debug(`Refreshing creep ${creep.name}`)
                    Overmind.zerg[creep.name].refresh();
                }
                else {
                    log.warning(`${this.print}: could not find and refresh zerg with name ${creep.name}!`);
                }
            }
        }
        if (expireSuspension(this.memory)) {
            log.info(`${this.print} unsuspended`);
        }
    }
    recalculateCreeps() {
        // Recalculate the sets of creeps for each role in this overlord
        this._creeps = _.mapValues(Overmind.cache.overlords[this.ref], (creepsOfRole) => _.map(creepsOfRole, (creepName) => Game.creeps[creepName]));
        // Update zerg and combatZerg records
        for (const role in this._zerg) {
            this.synchronizeZerg(role);
        }
        for (const role in this._combatZerg) {
            this.synchronizeCombatZerg(role);
        }
    }
    /**
     * A list of suspension reasons that will cause the overlord to deactivate itself.
     *
     * Subclasses should override this.
     */
    get deactivationReasons() {
        return new Set([
            SuspensionReason.cpu,
            SuspensionReason.upkeep,
            SuspensionReason.harassment,
            SuspensionReason.reserved,
            SuspensionReason.stronghold,
        ]);
    }
    get suspensionReason() {
        let reason = suspensionReason(this.memory);
        if (!reason && this.colony instanceof Colony) {
            reason = suspensionReason(this.colony.memory.outposts[this.pos.roomName]);
        }
        return reason;
    }
    get isSuspended() {
        const reason = this.suspensionReason;
        let isSuspended = false;
        if (reason) {
            if (reason === true) {
                isSuspended = true;
            }
            else {
                isSuspended = this.deactivationReasons.has(reason);
            }
        }
        return isSuspended;
    }
    suspend(options) {
        suspend(this.memory, options);
    }
    unsuspend() {
        unsuspend(this.memory);
    }
    /**
     * Check if profiling is active, also shuts it down if it is past end tick
     */
    get profilingActive() {
        if (this.memory["S" /* MEM.STATS */]) {
            if (this.memory["S" /* MEM.STATS */].end) {
                if (Game.time > this.memory["S" /* MEM.STATS */].end) {
                    this.finishProfiling();
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    /**
     * Starts profiling on this overlord and initializes memory to defaults
     */
    startProfiling(ticks) {
        if (!this.memory["S" /* MEM.STATS */]) {
            this.memory["S" /* MEM.STATS */] = {
                start: Game.time,
                cpu: 0,
                spawnCost: 0,
                deaths: 0,
            };
            if (ticks) {
                this.memory["S" /* MEM.STATS */].end = Game.time + ticks;
            }
        }
        else {
            log.alert(`Overlord ${this.print} is already being profiled!`);
        }
    }
    /**
     * Finishes profiling this overlord and deletes the memory objects
     */
    finishProfiling(verbose = true) {
        if (!this.memory["S" /* MEM.STATS */]) {
            log.error(`Overlord ${this.print} is not being profiled, finishProfiling() invalid!`);
            return;
        }
        if (verbose) {
            log.alert(`Profiling finished for overlord ${this.print}. Results:\n` +
                JSON.stringify(this.memory["S" /* MEM.STATS */]));
        }
        delete this.memory["S" /* MEM.STATS */];
    }
    /**
     * Wraps all creeps of a given role to Zerg objects and updates the contents in future ticks to avoid having to
     * explicitly refresh groups of Zerg
     */
    zerg(role, opts = {}) {
        if (!this._zerg[role]) {
            this._zerg[role] = [];
            this.synchronizeZerg(role, opts.notifyWhenAttacked);
        }
        return this._zerg[role];
    }
    synchronizeZerg(role, notifyWhenAttacked) {
        // Synchronize the corresponding sets of Zerg;
        const zergNames = _.zipObject(_.map(this._zerg[role] || [], (zerg) => [zerg.name, true]));
        const creepNames = _.zipObject(_.map(this._creeps[role] || [], (creep) => [creep.name, true]));
        // Add new creeps which aren't in the _zerg record
        for (const creep of this._creeps[role] || []) {
            if (!zergNames[creep.name]) {
                this._zerg[role].push(Overmind.zerg[creep.name] ||
                    new Zerg(creep, notifyWhenAttacked));
            }
        }
        // Remove dead/reassigned creeps from the _zerg record
        const removeZergNames = [];
        for (const zerg of this._zerg[role]) {
            if (!creepNames[zerg.name]) {
                removeZergNames.push(zerg.name);
            }
        }
        _.remove(this._zerg[role], (deadZerg) => removeZergNames.includes(deadZerg.name));
    }
    getAllZerg() {
        const allZerg = [];
        for (const role in this._creeps) {
            for (const zerg of this.zerg(role)) {
                allZerg.push(zerg);
            }
        }
        return allZerg;
    }
    /**
     * Wraps all creeps of a given role to CombatZerg objects and updates the contents in future ticks
     */
    combatZerg(role, opts = {}) {
        if (!this._combatZerg[role]) {
            this._combatZerg[role] = [];
            this.synchronizeCombatZerg(role, opts.notifyWhenAttacked);
        }
        return this._combatZerg[role];
    }
    synchronizeCombatZerg(role, notifyWhenAttacked) {
        // Synchronize the corresponding sets of CombatZerg
        const zergNames = _.zipObject(_.map(this._combatZerg[role] || [], (zerg) => [zerg.name, true]));
        const creepNames = _.zipObject(_.map(this._creeps[role] || [], (creep) => [creep.name, true]));
        // Add new creeps which aren't in the _combatZerg record
        for (const creep of this._creeps[role] || []) {
            if (!zergNames[creep.name]) {
                if (Overmind.zerg[creep.name] &&
                    isCombatZerg(Overmind.zerg[creep.name])) {
                    this._combatZerg[role].push(Overmind.zerg[creep.name]);
                }
                else {
                    this._combatZerg[role].push(new CombatZerg(creep, notifyWhenAttacked));
                }
            }
        }
        // Remove dead/reassigned creeps from the _combatZerg record
        const removeZergNames = [];
        for (const zerg of this._combatZerg[role]) {
            if (!creepNames[zerg.name]) {
                removeZergNames.push(zerg.name);
            }
        }
        _.remove(this._combatZerg[role], (deadZerg) => removeZergNames.includes(deadZerg.name));
    }
    getAllCombatZerg() {
        const allCombatZerg = [];
        for (const role in this._creeps) {
            for (const combatZerg of this.combatZerg(role)) {
                allCombatZerg.push(combatZerg);
            }
        }
        return allCombatZerg;
    }
    /**
     * Gets the "ID" of the outpost this overlord is operating in. 0 for owned rooms, >= 1 for outposts, -1 for other
     */
    get outpostIndex() {
        return _.findIndex(this.colony.roomNames, (roomName) => roomName == this.pos.roomName);
    }
    // TODO: make this potentially colony independent
    reassignIdleCreeps(role, maxPerTick = 1) {
        // Find all creeps without an overlord
        const idleCreeps = _.filter(this.colony.getZergByRole(role), (creep) => !creep.overlord);
        // Reassign them all to this flag
        let reassigned = 0;
        for (const creep of idleCreeps) {
            // TODO: check range of creep from overlord
            creep.overlord = this;
            reassigned++;
            if (reassigned >= maxPerTick) {
                break;
            }
        }
        return reassigned > 0;
    }
    creepReport(role, currentAmt, neededAmt) {
        this.creepUsageReport[role] = [currentAmt, neededAmt];
    }
    get spawner() {
        return (this.spawnGroup || this.colony.spawnGroup || this.colony.hatchery);
    }
    /**
     * Requests a group of (2-3) creeps from a hatchery to be spawned at the same time. Using this with low-priority
     * operations can result in a long time
     */
    requestSquad(setups, opts = {}) {
        log.warning(`Overlord.requestSquad() is not finished yet!`); // TODO: finish
        _.defaults(opts, {
            priority: this.priority,
            prespawn: DEFAULT_PRESPAWN,
        });
        const spawner = this.spawner;
        if (spawner) {
            if (setups.length > 3) {
                log.warning(`Requesting squads of >3 is not advisable`);
            }
            const request = {
                setup: _.head(setups),
                overlord: this,
                priority: opts.priority,
                partners: _.tail(setups),
            };
            if (opts.options) {
                request.options = opts.options;
            }
            spawner.enqueue(request);
        }
        else {
            if (Game.time % 100 == 0) {
                log.warning(`Overlord ${this.ref} @ ${this.pos.print}: no spawner object!`);
            }
        }
    }
    /**
     * Create a creep setup and enqueue it to the Hatchery; does not include automatic reporting
     */
    requestCreep(setup, opts = {}) {
        _.defaults(opts, {
            priority: this.priority,
            prespawn: DEFAULT_PRESPAWN,
        });
        const spawner = this.spawner;
        if (spawner) {
            const request = {
                setup: setup,
                overlord: this,
                priority: opts.priority,
            };
            if (opts.partners) {
                request.partners = opts.partners;
            }
            if (opts.options) {
                request.options = opts.options;
            }
            spawner.enqueue(request);
        }
        else {
            if (Game.time % 100 == 0) {
                log.warning(`Overlord ${this.ref} @ ${this.pos.print}: no spawner object!`);
            }
        }
    }
    // TODO: include creep move speed
    lifetimeFilter(creeps, prespawn = DEFAULT_PRESPAWN, spawnDistance) {
        if (!spawnDistance) {
            spawnDistance = 0;
            if (this.spawnGroup) {
                const distances = _.take(_.sortBy(this.spawnGroup.memory.distances), 2);
                spawnDistance = _.sum(distances) / distances.length || 0;
            }
            else if (this.colony.hatchery) {
                // Use distance or 0 (in case distance returns something undefined due to incomplete pathfinding)
                spawnDistance =
                    Pathing.distance(this.pos, this.colony.hatchery.pos) || 0;
            }
            if (this.colony.state.isIncubating && this.colony.spawnGroup) {
                spawnDistance += this.colony.spawnGroup.stats.avgDistance;
            }
        }
        /* The last condition fixes a bug only present on private servers that took me a fucking week to isolate.
         * At the tick of birth, creep.spawning = false and creep.ticksTolive = undefined
         * See: https://screeps.com/forum/topic/443/creep-spawning-is-not-updated-correctly-after-spawn-process */
        return _.filter(creeps, (creep) => creep.ticksToLive >
            CREEP_SPAWN_TIME * creep.body.length +
                spawnDistance +
                prespawn ||
            creep.spawning ||
            (!creep.spawning && !creep.ticksToLive));
    }
    /**
     * Wishlist of creeps to simplify spawning logic; includes automatic reporting
     */
    wishlist(quantity, setup, opts = {}) {
        var _a;
        this.debug(`wishlisting ${quantity} ${setup.role} to ${(_a = this.spawner) === null || _a === void 0 ? void 0 : _a.print}: ${JSON.stringify(opts)}`);
        _.defaults(opts, {
            priority: this.priority,
            prespawn: DEFAULT_PRESPAWN,
            reassignIdle: false,
        });
        // TODO Don't spawn if spawning is halted
        if (this.shouldSpawnAt && this.shouldSpawnAt > Game.time) {
            log.info(`Disabled spawning for ${this.print} for another ${this.shouldSpawnAt - Game.time} ticks`);
            return;
        }
        let creepQuantity;
        if (opts.noLifetimeFilter) {
            creepQuantity = (this._creeps[setup.role] || []).length;
        }
        else if (_.has(this.initializer, "waypoints")) {
            // TODO: replace hardcoded distance with distance computed through portals
            creepQuantity = this.lifetimeFilter(this._creeps[setup.role] || [], opts.prespawn, 500).length;
        }
        else {
            creepQuantity = this.lifetimeFilter(this._creeps[setup.role] || [], opts.prespawn).length;
        }
        let spawnQuantity = quantity - creepQuantity;
        if (opts.reassignIdle && spawnQuantity > 0) {
            const idleCreeps = _.filter(this.colony.getZergByRole(setup.role), (creep) => !creep.overlord);
            for (let i = 0; i < Math.min(idleCreeps.length, spawnQuantity); i++) {
                idleCreeps[i].overlord = this;
                spawnQuantity--;
            }
        }
        this.debug(`requesting ${quantity} ${setup.role}@${opts.priority}, current: ${creepQuantity}, to spawn: ${spawnQuantity}`);
        // A bug in outpostDefenseOverlord caused infinite requests and cost me two botarena rounds before I found it...
        if (spawnQuantity > MAX_SPAWN_REQUESTS) {
            log.error(`Too many requests (${spawnQuantity}) for ${setup.role}s submitted by ${this.print}! (Check for errors.)`);
        }
        else {
            for (let i = 0; i < spawnQuantity; i++) {
                if (i >= 1 && opts.spawnOneAtATime) {
                    break;
                }
                this.requestCreep(setup, opts);
            }
        }
        this.creepReport(setup.role, creepQuantity, quantity);
    }
    /**
     * Requests that should be handled for all overlords prior to the init() phase
     */
    preInit() {
        // Handle requesting boosts from the evolution chamber
        const allZerg = _.flatten([
            ..._.values(this._zerg),
            ..._.values(this._combatZerg),
        ]);
        for (const zerg of allZerg) {
            if (zerg.needsBoosts) {
                const colony = Overmind.colonies[zerg.room.name];
                const evolutionChamber = colony ? colony.evolutionChamber : undefined;
                if (evolutionChamber) {
                    evolutionChamber.requestBoosts(zerg.getNeededBoosts());
                }
            }
        }
    }
    /**
     * Executes a callback safely by catching any exceptions it might throw
     *
     * Exceptions caught are bubbled up to Overmind so that it knows about potential problems
     *
     * @param callback The callback to execute
     */
    try(callback) {
        {
            try {
                callback();
            }
            catch (e) {
                if (e instanceof Error) {
                    e.name =
                        `Caught unhandled exception at ${callback}: \n` +
                            e.name +
                            "\n" +
                            e.stack;
                    Overmind.exceptions.push(e);
                }
                else {
                    log.error(`Got a non-Error exception`, String(e));
                }
            }
        }
    }
    /**
     * Executes the overlord's init phase code.
     *
     * This is the main entry point for running an overlord's init code,
     * and handles things like suspension and profiling.
     *
     * Most subclasses don't need to override this, unless they have a
     * specific need to *always* run some code in the init phase.
     *
     * @returns {void}
     */
    tryInit() {
        if (this.isSuspended) {
            this.debug(`is suspended because ${this.suspensionReason}, skipping init!`);
            return;
        }
        this.debug(`init`);
        if (this.profilingActive) {
            const start = Game.cpu.getUsed();
            this.preInit();
            this.try(() => this.init());
            this.memory["S" /* MEM.STATS */].cpu += Game.cpu.getUsed() - start;
        }
        else {
            this.preInit();
            this.try(() => this.init());
        }
    }
    /**
     * Executes the overlord's init phase code.
     *
     * This is the main entry point for running an overlord's run code,
     * and handles things like suspension and profiling.
     *
     * Most subclasses don't need to override this, unless they have a
     * specific need to *always* run some code in the run phase.
     *
     * @returns
     */
    tryRun() {
        if (this.isSuspended) {
            this.debug(`is suspended because ${this.suspensionReason}, skipping run!`);
            return;
        }
        this.debug(`run`);
        if (this.profilingActive) {
            const start = Game.cpu.getUsed();
            this.try(() => this.run());
            this.memory["S" /* MEM.STATS */].cpu += Game.cpu.getUsed() - start;
        }
        else {
            this.try(() => this.run());
        }
    }
    /**
     * Contains logic for shutting down the overlord
     */
    finish(_successful) {
        for (const zerg of this.getAllZerg()) {
            zerg.reassign(this.colony.overlords.default);
        }
        // TODO: CombatOverlord
    }
    /**
     * Handle boosting of a creep; should be called during run()
     */
    handleBoosting(zerg) {
        const colony = Overmind.colonies[zerg.room.name];
        const evolutionChamber = colony ? colony.evolutionChamber : undefined;
        if (evolutionChamber) {
            if (!zerg.needsBoosts) {
                log.error(`Overlord.handleBoosting() called for ${zerg.print}, but no boosts needed!`);
            }
            const neededBoosts = zerg.getNeededBoosts();
            const neededBoostResources = _.keys(neededBoosts);
            const [moveBoosts, nonMoveBoosts] = _.partition(neededBoostResources, (resource) => Abathur$1.isMoveBoost(resource));
            // try to get move boosts first if they're available
            for (const boost of [...moveBoosts, ...nonMoveBoosts]) {
                const boostLab = _.find(evolutionChamber.boostingLabs, (lab) => lab.mineralType == boost);
                if (boostLab) {
                    zerg.task = Tasks$1.getBoosted(boostLab, boost);
                    return;
                }
            }
        }
    }
    /**
     * Standard sequence of actions for running task-based creeps
     */
    autoRun(roleCreeps, taskHandler, fleeCallback) {
        for (const creep of roleCreeps) {
            if (creep.spawning) {
                continue;
            }
            if (!!fleeCallback) {
                if (fleeCallback(creep)) {
                    continue;
                }
            }
            if (creep.isIdle) {
                if (creep.needsBoosts) {
                    this.handleBoosting(creep);
                }
                else {
                    if (creep.isSleeping()) {
                        continue;
                    }
                    taskHandler(creep);
                }
            }
            creep.run();
        }
    }
    visuals() { }
};
Overlord = __decorate$1([
    profile
], Overlord);

/**
 * Generates a random integer between [low, high] inclusive
 */
function randint(low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
}
/**
 * Flips a coin with probability p
 */
function p(probability) {
    return Math.random() < probability;
}

var NotifierPriority;
(function (NotifierPriority) {
    NotifierPriority[NotifierPriority["Fatal"] = -1] = "Fatal";
    NotifierPriority[NotifierPriority["Critical"] = 0] = "Critical";
    NotifierPriority[NotifierPriority["High"] = 1] = "High";
    NotifierPriority[NotifierPriority["Normal"] = 2] = "Normal";
    NotifierPriority[NotifierPriority["Low"] = 3] = "Low";
})(NotifierPriority || (NotifierPriority = {}));
/**
 * Records one-time and persistent notifications from various in-game events
 */
class Notifier {
    constructor() {
        this.alerts = [];
        this.notifications = [];
    }
    clear() {
        this.alerts = [];
    }
    alert(message, roomName, priority = NotifierPriority.Normal) {
        // Register an alert to be displayed this in the notifications visual box
        const alert = { message, roomName, priority };
        this.alerts.push(alert);
    }
    // TODO: finish
    // email(message: string, roomName: string, duration = 100, email = false) {
    // 	log.alert(printRoomName(roomName) + ': ' + message);
    // }
    // init() {
    //
    // }
    //
    // run() {
    //
    // }
    generateNotificationsList(links = false) {
        const sortedAlerts = _.sortBy(this.alerts, (alert) => alert.priority);
        return _.map(sortedAlerts, (alert) => {
            if (alert.roomName) {
                return ((links ? printRoomName(alert.roomName) : alert.roomName) +
                    ": " +
                    alert.message);
            }
            else {
                return alert.message;
            }
        });
    }
    visuals() {
        const notificationMessages = this.generateNotificationsList();
        Visualizer.drawNotifications(notificationMessages);
    }
}

const DEFAULT_MAX_PATH_LENGTH = 800;
const DEFAULT_MAX_LINEAR_RANGE = 15;
const DIRECTIVE_PATH_TIMEOUT = 30000;
/**
 * Directives are contextual wrappers for flags and serve as attachment points for Overlords, acting as a sort of
 * "process table" for the bot, with individual processes (Overlords) run by the scheulder (Overseer)
 */
let Directive = class Directive {
    constructor(flag, colonyFilter) {
        this.memory = flag.memory;
        this.name = flag.name;
        this.ref = flag.ref;
        // Register creation tick
        if (!this.memory["T" /* MEM.TICK */]) {
            this.memory["T" /* MEM.TICK */] = Game.time;
        }
        // if (this.memory.waypoints) {
        // 	this.waypoints = _.map(this.memory.waypoints, posName => getPosFromString(posName)!);
        // }
        // Relocate flag if needed; this must be called before the colony calculations
        if (this.memory.setPos) {
            const setPosition = derefRoomPosition(this.memory.setPos);
            if (!this.flag.pos.isEqualTo(setPosition)) {
                this.flag.setPosition(setPosition);
            }
            else {
                delete this.memory.setPos;
            }
            this.pos = setPosition;
            this.room = Game.rooms[setPosition.roomName];
        }
        else {
            this.pos = flag.pos;
            this.room = flag.room;
        }
        // Delete the directive if expired
        if (this.memory["X" /* MEM.EXPIRATION */] &&
            !this.memory.persistent &&
            Game.time > this.memory["X" /* MEM.EXPIRATION */]) {
            log.alert(`Removing expired directive ${this.print}!`);
            flag.remove();
            return;
        }
        // Handle colony assigning
        const forceRecalc = !!this.memory.recalcColonyOnTick &&
            Game.time >= this.memory.recalcColonyOnTick;
        const colony = this.getColony(colonyFilter, forceRecalc);
        // Delete the directive if the colony is dead
        if (!colony) {
            if (Overmind.exceptions.length == 0) {
                log.alert(`Could not get colony for directive ${this.print}; removing flag!`);
                flag.remove();
            }
            else {
                log.alert(`Could not get colony for directive ${this.print}; ` +
                    `exceptions present this tick, so won't remove`);
            }
            return;
        }
        // Register colony and add flags to colony.flags
        this.colony = colony;
        this.colony.flags.push(flag);
        this.overlords = {};
        this._didBecomeVisible = false;
        // Run creation actions if needed
        if (this.age == 0) {
            this.onCreation();
        }
        // Register directive on Overmind
        // @ts-expect-error global shenanigans
        global[this.name] = this;
        Overmind.overseer.registerDirective(this);
        Overmind.directives[this.name] = this;
    }
    get print() {
        return ('<a href="#!/room/' +
            Game.shard.name +
            "/" +
            this.pos.roomName +
            '">[' +
            this.name +
            "]</a>");
    }
    debug(...args) {
        if (this.memory.debug) {
            log.alert(this.print, args);
        }
    }
    get age() {
        return Game.time - this.memory["T" /* MEM.TICK */];
    }
    info() {
        let msg = `Info for ${this.print}: —————————————————————————————————————————————————————————————————————————`;
        const info1 = {
            "Type:": this.directiveName,
            "Name:": this.name,
            "Pos:": this.pos.print,
            "Colony:": this.colony.print,
        };
        msg += toColumns(info1).join("\n");
        msg += `Overlords: \n`;
        const tab = `  `;
        for (const overlordName in this.overlords) {
            msg += tab + `${overlordName}:\n`;
            const olInfo = {};
            const overlord = this.overlords[overlordName];
            olInfo[tab + tab + "Creep usage:"] = JSON.stringify(overlord.creepUsageReport);
            olInfo[tab + tab + "Zerg:"] = overlord
                .getAllZerg()
                .map((z) => z.print)
                .join(", ");
            olInfo[tab + tab + "CombatZerg:"] = overlord
                .getAllCombatZerg()
                .map((z) => z.print)
                .join(", ");
            msg += toColumns(olInfo).join("\n");
        }
        msg += "Memory:\n" + dump(this.memory);
        return msg;
    }
    /**
     * Gets an effective room position for a directive; allows you to reference this.pos in constructor super() without
     * throwing an error
     */
    static getPos(flag) {
        if (flag.memory && flag.memory.setPos) {
            const pos = derefRoomPosition(flag.memory.setPos);
            return pos;
        }
        return flag.pos;
    }
    // Flag must be a getter to avoid caching issues
    get flag() {
        return Game.flags[this.name];
    }
    // This allows you to access static DirectiveClass.directiveName from an instance of DirectiveClass
    get directiveName() {
        return this.constructor.directiveName;
    }
    refresh() {
        const flag = this.flag;
        if (!flag) {
            log.warning(`Missing flag for directive ${this.print}! Removing directive.`);
            this.remove();
            return;
        }
        this.memory = flag.memory;
        this.pos = flag.pos;
        this._didBecomeVisible = Game.rooms[this.pos.roomName] && !this.room;
        this.room = flag.room;
    }
    get didBecomeVisible() {
        return this._didBecomeVisible;
    }
    alert(message, priority = NotifierPriority.Normal) {
        Overmind.overseer.notifier.alert(message, this.pos.roomName, priority);
    }
    /** The origin used for directive distance calculations */
    get POI() {
        return this.colony.pos;
    }
    /**
     * Returns values for weighted and unweighted path length from colony and recomputes if necessary.
     */
    get distanceFromPOI() {
        if (!this.memory["D" /* MEM.DISTANCE */] ||
            Game.time >= this.memory["D" /* MEM.DISTANCE */]["X" /* MEM.EXPIRATION */]) {
            const ret = Pathing.findPath(this.POI, this.pos, {
                maxOps: DIRECTIVE_PATH_TIMEOUT,
                allowHostile: true,
                avoidSK: false,
            });
            this.memory["D" /* MEM.DISTANCE */] = {
                ["u" /* MEM_DISTANCE.UNWEIGHTED */]: ret.path.length,
                ["w" /* MEM_DISTANCE.WEIGHTED */]: ret.cost,
                ["X" /* MEM.EXPIRATION */]: getCacheExpiration(10000, randint(0, 100)),
            };
            if (ret.incomplete) {
                this.memory["D" /* MEM.DISTANCE */].incomplete = true;
            }
        }
        const memDistance = this.memory["D" /* MEM.DISTANCE */];
        if (memDistance.incomplete) {
            log.warning(`${this.print}: distanceFromColony() info incomplete!`);
        }
        return {
            unweighted: memDistance["u" /* MEM_DISTANCE.UNWEIGHTED */],
            terrainWeighted: memDistance["w" /* MEM_DISTANCE.WEIGHTED */],
        };
    }
    handleRelocation() {
        if (this.memory.setPos) {
            const pos = derefRoomPosition(this.memory.setPos);
            if (!this.flag.pos.isEqualTo(pos)) {
                const result = this.flag.setPosition(pos);
                if (result == OK) {
                    log.debug(`Moving ${this.name} from ${this.flag.pos.print} to ${pos.print}.`);
                }
                else {
                    log.warning(`Could not set room position to ${JSON.stringify(this.memory.setPos)}!`);
                }
            }
            else {
                delete this.memory.setPos;
            }
            this.pos = pos;
            this.room = Game.rooms[pos.roomName];
            return true;
        }
        return false;
    }
    /**
     * Computes the parent colony for the directive to be handled by
     */
    getColony(colonyFilter, forceRecalc = false) {
        // If something is written to flag.colony, use that as the colony
        if (this.memory["C" /* MEM.COLONY */] && !forceRecalc) {
            return Overmind.colonies[this.memory["C" /* MEM.COLONY */]];
        }
        else {
            // If flag contains a colony name as a substring, assign to that colony, regardless of RCL
            const colonyNames = _.keys(Overmind.colonies);
            for (const name of colonyNames) {
                if (this.name.includes(name)) {
                    // in case of other substring, e.g. E11S12 and E11S1
                    if (this.name.split(name)[1] != "") {
                        continue;
                    }
                    this.memory["C" /* MEM.COLONY */] = name;
                    return Overmind.colonies[name];
                }
            }
            // If flag is in a room belonging to a colony and the colony has sufficient RCL, assign to there
            const colony = Overmind.colonies[Overmind.colonyMap[this.pos.roomName]];
            if (colony) {
                if (!colonyFilter || colonyFilter(colony)) {
                    this.memory["C" /* MEM.COLONY */] = colony.name;
                    return colony;
                }
            }
            // Otherwise assign to closest colony
            const maxPathLength = this.memory.maxPathLength || DEFAULT_MAX_PATH_LENGTH;
            const maxLinearRange = this.memory.maxLinearRange || DEFAULT_MAX_LINEAR_RANGE;
            this.debug(`Recalculating colony association for ${this.name} in ${this.pos.roomName}`);
            let nearestColony;
            let minDistance = Infinity;
            for (const colony of getAllColonies()) {
                if (Game.map.getRoomLinearDistance(this.pos.roomName, colony.name) > maxLinearRange &&
                    !this.memory.allowPortals) {
                    continue;
                }
                if (!colonyFilter || colonyFilter(colony)) {
                    const ret = Pathing.findPath((colony.hatchery || colony).pos, this.pos, { maxOps: DIRECTIVE_PATH_TIMEOUT });
                    // TODO handle directives that can't find a path at great range
                    if (!ret.incomplete) {
                        if (ret.path.length < maxPathLength &&
                            ret.path.length < minDistance) {
                            nearestColony = colony;
                            minDistance = ret.path.length;
                        }
                        if (ret.portalUsed && ret.portalUsed.expiration) {
                            this.memory.recalcColonyOnTick =
                                ret.portalUsed.expiration + 1;
                        }
                        this.debug(`Path length to ${colony.room.print}: ${ret.path.length}`);
                    }
                    else {
                        this.debug(`Incomplete path from ${colony.room.print}`);
                    }
                }
            }
            if (nearestColony) {
                log.info(`Colony ${nearestColony.room.print} assigned to ${this.print}.`);
                this.memory["C" /* MEM.COLONY */] = nearestColony.room.name;
                return nearestColony;
            }
            else {
                log.error(`Could not find colony match for ${this.name} in ${this.pos.roomName}! ` +
                    `Try setting memory.maxPathLength and memory.maxLinearRange.`);
            }
        }
    }
    // Wrapped flag methods ============================================================================================
    remove(force = false) {
        if (!this.memory.persistent || force) {
            delete Overmind.directives[this.name];
            // @ts-expect-error global shenanigans
            delete global[this];
            Overmind.overseer.removeDirective(this);
            if (this.colony) {
                _.remove(this.colony.flags, (flag) => flag.name == this.name);
            }
            if (this.flag) {
                // check in case flag was removed manually in last build cycle
                return this.flag.remove();
            }
        }
    }
    setColor(color, secondaryColor) {
        if (secondaryColor) {
            return this.flag.setColor(color, secondaryColor);
        }
        else {
            return this.flag.setColor(color);
        }
    }
    setPosition(pos) {
        // Ignore the (x,y) setPosition option since I never use it
        return this.flag.setPosition(pos);
    }
    // Custom directive methods ========================================================================================
    /* Create an appropriate flag to instantiate this directive in the next tick */
    static create(pos, opts = {}) {
        let flagName = opts.name || undefined;
        if (!flagName) {
            flagName = this.directiveName + ":" + randomHex(6);
            if (Game.flags[flagName]) {
                return ERR_NAME_EXISTS;
            }
        }
        if (!opts.quiet) {
            log.alert(`Creating ${this.directiveName} directive at ${pos.print}!`);
        }
        const result = pos.createFlag(flagName, this.color, this.secondaryColor);
        if (result == flagName && opts.memory) {
            Memory.flags[flagName] = opts.memory;
        }
        log.debug(`Result: ${result}, memory: ${JSON.stringify(Memory.flags[result])}`);
        // @ts-expect-error result becomes number
        return result;
    }
    /**
     * Returns whether a directive of this type is present either at this position or within the room of this name
     */
    static isPresent(posOrRoomName) {
        if (PHASE != "run" && PHASE != "init") {
            const e = new Error(`isPresent() will only give correct results in init() and run() phases!`);
            log.trace(e);
            return true; // usually we want to do something if directive isn't present; so this minimizes bad results
        }
        if (typeof posOrRoomName === "string") {
            const roomName = posOrRoomName;
            const directivesInRoom = Overmind.overseer.getDirectivesInRoom(roomName);
            return (_.filter(directivesInRoom, (directive) => this.filter(directive.flag)).length > 0);
        }
        else {
            const pos = posOrRoomName;
            const directivesInRoom = Overmind.overseer.getDirectivesInRoom(pos.roomName);
            return (_.filter(directivesInRoom, (directive) => this.filter(directive.flag) &&
                equalXYR(pos, directive.pos)).length > 0);
        }
    }
    /**
     * Create a directive if one of the same type is not already present (in room | at position).
     * Calling this method on positions in invisible rooms can be expensive and should be used sparingly.
     */
    static createIfNotPresent(pos, scope, opts = {}) {
        if (PHASE != "run") {
            log.error(`Directive.createIfNotPresent() can only be called during the run phase!`);
            return;
        }
        // Do nothing if flag is already here
        if (scope == "pos") {
            if (this.isPresent(pos)) {
                return;
            }
        }
        else {
            if (this.isPresent(pos.roomName)) {
                return;
            }
        }
        const room = Game.rooms[pos.roomName];
        if (!room) {
            if (!opts.memory) {
                opts.memory = {};
            }
            opts.memory.setPos = pos;
        }
        switch (scope) {
            case "room":
                if (room) {
                    return this.create(pos, opts);
                }
                else {
                    log.info(`Creating directive at ${pos.print}... ` +
                        `No visibility in room; directive will be relocated on next tick.`);
                    let createAtPos;
                    if (opts.memory && opts.memory["C" /* MEM.COLONY */]) {
                        createAtPos = Pathing.findPathablePosition(opts.memory["C" /* MEM.COLONY */]);
                    }
                    else {
                        createAtPos = Pathing.findPathablePosition(_.first(getAllColonies()).room.name);
                    }
                    return this.create(createAtPos, opts);
                }
            case "pos":
                if (room) {
                    return this.create(pos, opts);
                }
                else {
                    log.info(`Creating directive at ${pos.print}... ` +
                        `No visibility in room; directive will be relocated on next tick.`);
                    let createAtPos;
                    if (opts.memory && opts.memory["C" /* MEM.COLONY */]) {
                        createAtPos = Pathing.findPathablePosition(opts.memory["C" /* MEM.COLONY */]);
                    }
                    else {
                        createAtPos = Pathing.findPathablePosition(_.first(getAllColonies()).room.name);
                    }
                    return this.create(createAtPos, opts);
                }
        }
    }
    /**
     * Filter for _.filter() that checks if a flag is of the matching type
     */
    static filter(flag) {
        return (flag.color == this.color &&
            flag.secondaryColor == this.secondaryColor);
    }
    /**
     * Map a list of flags to directive using the filter of the subclassed directive
     */
    static find(flags) {
        flags = _.filter(flags, (flag) => this.filter(flag));
        return _.compact(_.map(flags, (flag) => Overmind.directives[flag.name]));
    }
    /**
     * Map a list of flags to directive using the filter of the subclassed directive
     */
    static findInRoom(roomName) {
        const directivesInRoom = Overmind.overseer.getDirectivesInRoom(roomName);
        return _.filter(directivesInRoom, (directive) => this.filter(directive.flag));
    }
    /**
     * Map a list of flags to directive using the filter of the subclassed directive
     */
    static findInColony(colony) {
        const directivesInColony = Overmind.overseer.getDirectivesForColony(colony);
        return _.filter(directivesInColony, (directive) => this.filter(directive.flag));
    }
    // /**
    //  * Directive.creation() should contain any necessary logic for creating the directive (if the directive is
    //  * automatically placeable); this gets called for every type of directive every tick.
    //  */
    // static creation(): void {
    //
    // }
    /**
     * Actions that are performed only once on the tick of the directive creation
     */
    onCreation() { }
    // /**
    //  * Directive.removal() should contain any necessary logic for removing the directive.
    //  */
    // removal(): void {
    //
    // }
    /**
     * Override Directive.visuals() to display any relevant information via room visuals
     */
    visuals() { }
};
Directive = __decorate$1([
    profile
], Directive);

var DirectiveNukeResponse_1;
/**
 * Nuke response: automatically over-fortify ramparts to withstand an incoming nuclear strike
 */
let DirectiveNukeResponse = DirectiveNukeResponse_1 = class DirectiveNukeResponse extends Directive {
    constructor(flag) {
        super(flag, (colony) => colony.name == Directive.getPos(flag).roomName &&
            colony.level >= DirectiveNukeResponse_1.requiredRCL);
        this.refresh();
    }
    refresh() {
        super.refresh();
        this.nukes = this.room.find(FIND_NUKES);
        if (this.nukes.length > 0) {
            this.colony.state.isBeingNuked = true;
        }
    }
    spawnMoarOverlords() { }
    init() {
        for (const nuke of this.nukes) {
            this.alert(`Nuclear impact in ${nuke.timeToLand}`, NotifierPriority.Critical);
        }
    }
    /**
     * Returns whether a position should be reinforced or not
     */
    static shouldReinforceLocation(pos) {
        const dontReinforce = [
            STRUCTURE_ROAD,
            STRUCTURE_RAMPART,
            STRUCTURE_WALL,
        ];
        const colony = Overmind.colonies[pos.roomName];
        if (colony && colony.assets.energy < 200000) {
            dontReinforce.push(STRUCTURE_EXTENSION);
        }
        return (_.filter(pos.lookFor(LOOK_STRUCTURES), (s) => !_.contains(dontReinforce, s.structureType)).length > 0);
    }
    run() {
        // Build ramparts at all positions affected by nukes with structures on them
        if (Game.time % 50 == 0) {
            if (this.nukes.length > 0) {
                for (const nuke of this.nukes) {
                    const rampartPositions = _.filter(nuke.pos.getPositionsInRange(2), (pos) => DirectiveNukeResponse_1.shouldReinforceLocation(pos));
                    for (const pos of rampartPositions) {
                        // Build a rampart if there isn't one already
                        if (!pos.lookForStructure(STRUCTURE_RAMPART)) {
                            const result = pos.createConstructionSite(STRUCTURE_RAMPART);
                            if (result === ERR_FULL) {
                                break;
                            }
                        }
                    }
                    log.alert(`Incoming nuke at ${nuke.pos.print}! Time until impact: ${nuke.timeToLand}`);
                }
            }
            else {
                // Remove once nuke is gone
                this.remove();
            }
        }
    }
};
DirectiveNukeResponse.directiveName = "nukeResponse";
DirectiveNukeResponse.color = COLOR_ORANGE;
DirectiveNukeResponse.secondaryColor = COLOR_BLUE;
DirectiveNukeResponse.requiredRCL = 6;
DirectiveNukeResponse = DirectiveNukeResponse_1 = __decorate$1([
    profile
], DirectiveNukeResponse);

/**
 * Prioritized list of what order structures should be built in
 */
const BuildPriorities = [
    STRUCTURE_SPAWN,
    STRUCTURE_TOWER,
    STRUCTURE_EXTENSION,
    STRUCTURE_STORAGE,
    STRUCTURE_TERMINAL,
    STRUCTURE_FACTORY,
    STRUCTURE_CONTAINER,
    STRUCTURE_LINK,
    STRUCTURE_EXTRACTOR,
    STRUCTURE_LAB,
    STRUCTURE_NUKER,
    STRUCTURE_OBSERVER,
    STRUCTURE_POWER_SPAWN,
    STRUCTURE_WALL,
    STRUCTURE_RAMPART,
    STRUCTURE_ROAD,
];
/**
 * Prioritized list of what order structures should be fortified in case of nuclear strike
 */
const FortifyPriorities = [
    STRUCTURE_TERMINAL,
    STRUCTURE_STORAGE,
    STRUCTURE_SPAWN,
    STRUCTURE_TOWER,
    STRUCTURE_LAB,
    STRUCTURE_FACTORY,
    STRUCTURE_NUKER,
];
/**
 * Prioritized list of what order enemy structures should be attacked in
 */
const AttackStructurePriorities = [
    STRUCTURE_INVADER_CORE,
    STRUCTURE_SPAWN,
    STRUCTURE_TOWER,
    STRUCTURE_EXTENSION,
    STRUCTURE_LINK,
    STRUCTURE_LAB,
    STRUCTURE_NUKER,
    STRUCTURE_OBSERVER,
    STRUCTURE_EXTRACTOR,
    STRUCTURE_POWER_SPAWN,
    STRUCTURE_CONTAINER,
    STRUCTURE_ROAD,
    STRUCTURE_STORAGE,
    STRUCTURE_TERMINAL,
    STRUCTURE_FACTORY,
    STRUCTURE_RAMPART,
    STRUCTURE_WALL,
];
const AttackStructureScores = _.zipObject(_.map(AttackStructurePriorities, (type) => [
    type,
    AttackStructurePriorities.length -
        _.indexOf(AttackStructurePriorities, type),
]));
/**
 * Prioritized list of what order owned structures should be demolished (and then moved) in
 */
const DemolishStructurePriorities = [
    { structureType: STRUCTURE_EXTENSION, maxRemoved: 15 },
    { structureType: STRUCTURE_SPAWN, maxRemoved: 1 },
    { structureType: STRUCTURE_CONTAINER },
    { structureType: STRUCTURE_TOWER, maxRemoved: 1 },
    { structureType: STRUCTURE_LINK },
    { structureType: STRUCTURE_LAB },
    { structureType: STRUCTURE_NUKER },
    { structureType: STRUCTURE_OBSERVER },
    // {structureType: STRUCTURE_EXTRACTOR, maxRemoved: 1}, // skip extractor; doesn't need to be relocated
    { structureType: STRUCTURE_POWER_SPAWN },
    // {structureType: STRUCTURE_ROAD}, // just let roads decay
    { structureType: STRUCTURE_CONTAINER },
    { structureType: STRUCTURE_STORAGE, maxRemoved: 1 },
    { structureType: STRUCTURE_TERMINAL, maxRemoved: 1 },
    { structureType: STRUCTURE_FACTORY, maxRemoved: 1 },
    { structureType: STRUCTURE_WALL },
    { structureType: STRUCTURE_RAMPART },
];

var WorkerOverlord_1;
/** Maximum number of workers to spawn */
const MAX_WORKERS = 10;
/** Average energy per tick when working */
const WORKER_ENERGY_PER_TICK = 1.1;
/** How often are workers working */
const WORKER_AVG_UPTIME = 0.8;
/**
 * Spawns general-purpose workers, which maintain a colony, performing actions such as building, repairing, fortifying,
 * paving, and upgrading, when needed
 */
let WorkerOverlord = WorkerOverlord_1 = class WorkerOverlord extends Overlord {
    constructor(colony, priority = OverlordPriority.ownedRoom.work) {
        super(colony, "worker", priority);
        this.priorityTasks = [];
        // Compute barriers needing fortification or critical attention
        this.fortifyBarriers = $.structures(this, "fortifyBarriers", () => _.sortBy(_.filter(this.room.barriers, (s) => s.hits <
            WorkerOverlord_1.settings.barrierHits[this.colony.level] &&
            this.colony.roomPlanner.barrierPlanner.barrierShouldBeHere(s.pos)), (s) => s.hits), 25);
        this.criticalBarriers = $.structures(this, "criticalBarriers", () => _.filter(this.fortifyBarriers, (barrier) => barrier.hits <
            WorkerOverlord_1.settings.barrierHits.critical), 10);
        // Generate a list of structures needing repairing (different from fortifying except in critical case)
        this.repairStructures = $.structures(this, "repairStructures", () => {
            const miningContainers = _.compact(_.map(this.colony.miningSites, (site) => { var _a, _b; return (_b = (_a = site.overlords.mine) === null || _a === void 0 ? void 0 : _a.container) === null || _b === void 0 ? void 0 : _b.id; }));
            return _.filter(this.colony.repairables, (structure) => {
                if (structure.structureType == STRUCTURE_CONTAINER) {
                    // only repair non-mining containers in owned rooms
                    if (structure.pos.roomName == this.colony.name &&
                        !miningContainers.includes(structure.id)) {
                        return structure.hits < 0.5 * structure.hitsMax;
                    }
                    else {
                        return false;
                    }
                }
                else {
                    return structure.hits < structure.hitsMax;
                }
            });
        });
        this.dismantleStructures = [];
        const homeRoomName = this.colony.room.name;
        const defcon = this.colony.defcon;
        // Filter constructionSites to only build valid ones
        const room = this.colony.room;
        const level = this.colony.controller.level;
        this.constructionSites = _.filter(this.colony.constructionSites, function (site) {
            // If site will be more than max amount of a structure at current level, ignore (happens after downgrade)
            const structureAmount = _.get(room, site.structureType + "s") ?
                _.get(room, site.structureType + "s").length
                : _.get(room, site.structureType) ? 1
                    : 0;
            if (structureAmount >=
                CONTROLLER_STRUCTURES[site.structureType][level]) {
                return false;
            }
            if (defcon > DEFCON.safe) {
                // Only build non-road, non-container sites in the home room if defcon is unsafe
                return (site.pos.roomName == homeRoomName &&
                    site.structureType != STRUCTURE_CONTAINER &&
                    site.structureType != STRUCTURE_ROAD);
            }
            else {
                // Build all non-container sites in outpost and all sites in room if defcon is safe
                if (site.pos.roomName != homeRoomName &&
                    Cartographer.roomType(site.pos.roomName) ==
                        ROOMTYPE_CONTROLLER) {
                    return (site.structureType != STRUCTURE_CONTAINER &&
                        !(site.room &&
                            site.room.dangerousHostiles.length > 0));
                }
                else {
                    return true;
                }
            }
        });
        // Nuke defense ramparts needing fortification
        this.nukeDefenseRamparts = [];
        this.nukeDefenseHitsRemaining = {};
        this.nukeDefenseHitsNeeded = {};
        if (this.room.find(FIND_NUKES).length > 0) {
            for (const rampart of this.colony.room.ramparts) {
                const neededHits = this.neededRampartHits(rampart);
                if (rampart.hits < neededHits &&
                    rampart.pos.findInRange(FIND_NUKES, 2).length > 0 &&
                    DirectiveNukeResponse.shouldReinforceLocation(rampart.pos)) {
                    this.nukeDefenseRamparts.push(rampart);
                    Visualizer.marker(rampart.pos, { color: "gold" });
                    this.nukeDefenseHitsRemaining[rampart.id] = Math.min(neededHits - rampart.hits, 0);
                }
            }
        }
        // Spawn boosted workers if there is significant fortifying which needs to be done
        const totalNukeDefenseHitsRemaining = _.sum(_.values(this.nukeDefenseHitsRemaining));
        const totalFortifyHitsRemaining = _.sum(this.fortifyBarriers, (barrier) => Math.max(WorkerOverlord_1.settings.barrierHits[this.colony.level] -
            barrier.hits, 0));
        const approxRepairAmountPerLifetime = ((REPAIR_POWER * 50) / 3) * CREEP_LIFE_TIME;
        if (totalNukeDefenseHitsRemaining > 3 * approxRepairAmountPerLifetime ||
            totalFortifyHitsRemaining > 5 * approxRepairAmountPerLifetime) {
            this.useBoostedRepair = true;
        }
        // Register workers
        this.workers = this.zerg(Roles.worker);
    }
    neededNukeHits(rampart) {
        if (this.nukeDefenseHitsNeeded[rampart.id] !== undefined) {
            return this.nukeDefenseHitsNeeded[rampart.id];
        }
        let neededHits = 0;
        for (const _nuke of rampart.pos.lookFor(LOOK_NUKES)) {
            neededHits += 10e6;
        }
        for (const nuke of rampart.pos.findInRange(FIND_NUKES, 2)) {
            if (nuke.pos != rampart.pos) {
                neededHits += 5e6;
            }
        }
        this.nukeDefenseHitsNeeded[rampart.id] = neededHits;
        return neededHits;
    }
    neededRampartHits(rampart) {
        let neededHits = WorkerOverlord_1.settings.barrierHits[this.colony.level];
        neededHits = +this.neededNukeHits(rampart);
        return neededHits;
    }
    refresh() {
        super.refresh();
        $.refresh(this, "repairStructures", "dismantleStructures", "fortifyBarriers", "criticalBarriers", "constructionSites", "nukeDefenseRamparts");
        this.priorityTasks = [];
    }
    /**
     * Estimates how many workers we could afford given the current energy input
     */
    maxSustainableWorkers(workPartsPerWorker) {
        const numWorkers = Math.ceil((this.colony.energyMinedPerTick * WORKER_AVG_UPTIME) /
            (workPartsPerWorker * WORKER_ENERGY_PER_TICK));
        return Math.min(numWorkers, MAX_WORKERS);
    }
    /**
     * Estimates how many workers are needed to take care of all tasks
     */
    estimatedWorkerCount(workPartsPerWorker) {
        const maxWorkers = this.maxSustainableWorkers(workPartsPerWorker);
        // We want to rush storage, or we're relocating; maintain a maximum of workers
        if (this.colony.level < 4 ||
            this.colony.roomPlanner.memory.relocating) {
            return maxWorkers;
        }
        // Nuke incoming, spawn as much as possible to fortify as much as possible
        if (this.nukeDefenseRamparts.length > 0) {
            return MAX_WORKERS;
        }
        // At higher levels, spawn workers based on construction and repair that needs to be done
        const buildTicks = _.sum(this.constructionSites, (site) => Math.max(site.progressTotal - site.progress, 0)) / BUILD_POWER;
        const repairTicks = _.sum(this.repairStructures, (structure) => structure.hitsMax - structure.hits) / REPAIR_POWER;
        const activeRooms = _.filter(this.colony.roomNames, (roomName) => this.colony.isRoomActive(roomName));
        const paveTicks = _.sum(activeRooms, (roomName) => this.colony.roadLogistics.energyToRepave(roomName));
        let fortifyTicks = 0;
        const shouldFortify = this.colony.assets.energy >
            WorkerOverlord_1.settings.fortifyDutyThreshold;
        if (shouldFortify) {
            fortifyTicks =
                (0.25 *
                    _.sum(this.fortifyBarriers, (barrier) => Math.max(0, WorkerOverlord_1.settings.barrierHits[this.colony.level] - barrier.hits))) /
                    REPAIR_POWER;
        }
        // max constructionTicks for private server manually setting progress
        let numWorkers = Math.ceil((2 * (5 * buildTicks + repairTicks + paveTicks + fortifyTicks)) /
            (workPartsPerWorker * CREEP_LIFE_TIME));
        const neededUpgraders = this.shouldPreventControllerDowngrade() ? 1 : 0;
        numWorkers = minMax(numWorkers, neededUpgraders, maxWorkers);
        return numWorkers;
    }
    /**
     * Check if the controller is close to downgrading.
     *
     * Handles both natural decay and downgrade attacks
     */
    shouldPreventControllerDowngrade() {
        const downgradeLevel = CONTROLLER_DOWNGRADE[this.colony.controller.level] *
            (this.colony.controller.level < 4 ? 0.3 : 0.7);
        this.debug(() => {
            const cont = this.colony.controller;
            const dbg = {
                downgradeLevel,
                upgradeBlocked: cont.upgradeBlocked,
                ticksToDowngrade: cont.ticksToDowngrade,
                progress: cont.progress,
                progressTotal: cont.progressTotal,
            };
            return `shouldPreventControllerDowngrade: ${JSON.stringify(dbg)}`;
        });
        return ((!this.colony.controller.upgradeBlocked ||
            this.colony.controller.upgradeBlocked < 30) &&
            (this.colony.controller.ticksToDowngrade <= downgradeLevel ||
                this.colony.controller.progress >
                    this.colony.controller.progressTotal));
    }
    init() {
        let setup = this.colony.level == 1 ?
            Setups.workers.early
            : Setups.workers.default;
        const numWorkers = $.number(this, "numWorkers", () => this.estimatedWorkerCount(setup.getBodyPotential(WORK, this.colony)));
        if (this.useBoostedRepair) {
            setup = CreepSetup.boosted(setup, ["construct"]);
        }
        this.wishlist(numWorkers, setup);
    }
    /**
     * Give priority to a worker task at this location
     * Must be called each tick.
     */
    prioritizeTask(flag) {
        this.priorityTasks.push(flag);
    }
    filterPriorityTargets(objects) {
        if (this.priorityTasks.length === 0) {
            return objects;
        }
        return objects.filter((obj) => this.priorityTasks.some((flag) => flag.pos.isEqualTo(obj.pos)));
    }
    repairActions(worker) {
        if (this.rechargeActions(worker)) {
            return true;
        }
        const repairStructures = this.filterPriorityTargets(this.repairStructures);
        const target = worker.pos.findClosestByMultiRoomRange(repairStructures);
        if (target) {
            this.debug(`${worker.print} repairing ${target.print}`);
            worker.task = Tasks$1.repair(target);
            return true;
        }
        else {
            return false;
        }
    }
    buildActions(worker) {
        if (this.rechargeActions(worker)) {
            return true;
        }
        const constructionSites = this.filterPriorityTargets(this.constructionSites);
        const groupedSites = _.groupBy(constructionSites, (site) => site.structureType);
        for (const structureType of BuildPriorities) {
            if (groupedSites[structureType]) {
                const target = worker.pos.findClosestByMultiRoomRange(groupedSites[structureType]);
                if (target) {
                    this.debug(`${worker.print} heading to build ${target.print} from ${this.constructionSites.length} sites`);
                    worker.task = Tasks$1.build(target);
                    return true;
                }
            }
        }
        return false;
    }
    dismantleActions(worker) {
        const targets = _.filter(this.dismantleStructures, (s) => (s.targetedBy || []).length < 3);
        const target = worker.pos.findClosestByMultiRoomRange(targets);
        if (target) {
            _.remove(this.dismantleStructures, (s) => s == target);
            this.debug(`${worker.print} dismantling ${target.print}`);
            worker.task = Tasks$1.dismantle(target);
            return true;
        }
        else {
            return false;
        }
    }
    // Find a suitable repair ordering of roads with a depth first search
    pavingActions(worker) {
        if (this.rechargeActions(worker)) {
            return true;
        }
        const roomToRepave = this.colony.roadLogistics.workerShouldRepave(worker);
        this.colony.roadLogistics.registerWorkerAssignment(worker, roomToRepave);
        // Build a paving manifest
        const pavingManifest = this.colony.roadLogistics.buildPavingManifest(worker, roomToRepave);
        if (pavingManifest) {
            this.debug(`${worker.print} repaving ${roomToRepave.name}`);
            worker.task = pavingManifest;
            return true;
        }
        else {
            return false;
        }
    }
    findLowBarriers(fortifyStructures = this.fortifyBarriers, hitsCallback = (structure) => structure.hits, numBarriersToConsider = 5) {
        let lowBarriers;
        const highestBarrierHits = _.max(_.map(fortifyStructures, (structure) => hitsCallback(structure)));
        if (highestBarrierHits > WorkerOverlord_1.settings.hitTolerance) {
            // At high barrier HP, fortify only structures that are within a threshold of the lowest
            const lowestBarrierHits = _.min(_.map(fortifyStructures, (structure) => hitsCallback(structure)));
            lowBarriers = _.filter(fortifyStructures, (structure) => hitsCallback(structure) <=
                lowestBarrierHits + WorkerOverlord_1.settings.hitTolerance);
        }
        else {
            // Otherwise fortify the lowest N structures
            lowBarriers = _.take(fortifyStructures, numBarriersToConsider);
        }
        return lowBarriers;
    }
    fortifyActions(worker, fortifyStructures = this.fortifyBarriers) {
        if (this.rechargeActions(worker)) {
            return true;
        }
        const lowBarriers = this.findLowBarriers(fortifyStructures);
        const target = worker.pos.findClosestByMultiRoomRange(lowBarriers);
        if (target) {
            this.debug(`${worker.print} fortifying ${target.print}`);
            worker.task = Tasks$1.fortify(target);
            return true;
        }
        else {
            return false;
        }
    }
    nukeFortifyActions(worker, fortifyStructures = this.nukeDefenseRamparts) {
        if (this.rechargeActions(worker)) {
            return true;
        }
        const adaptedHits = _.reduce(fortifyStructures, (obj, structure) => {
            obj[structure.id] =
                structure.hits - this.neededNukeHits(structure);
            return obj;
        }, {});
        const lowBarriers = this.findLowBarriers();
        const minBarrier = lowBarriers[lowBarriers.length - 1].hits;
        const urgent = _.filter(fortifyStructures, (structure) => adaptedHits[structure.id] < minBarrier);
        const target = minBy(urgent, (rampart) => {
            const structuresUnderRampart = rampart.pos.lookFor(LOOK_STRUCTURES);
            return _.min(_.map(structuresUnderRampart, (structure) => {
                const priority = _.findIndex(FortifyPriorities, (sType) => sType == structure.structureType);
                if (priority >= 0) {
                    // if found
                    return priority;
                }
                else {
                    // not found
                    return 999;
                }
            }));
        });
        if (target) {
            this.debug(`${worker.print} fortifying ${target.print} against nukes`);
            worker.task = Tasks$1.fortify(target);
            return true;
        }
        else {
            return this.fortifyActions(worker, fortifyStructures);
        }
    }
    upgradeActions(worker) {
        // Check the upgrade site battery first
        if (worker.store.energy === 0) {
            const battery = this.colony.upgradeSite.battery;
            if (battery && battery.store.energy > 0) {
                worker.task = Tasks$1.withdraw(battery);
                return true;
            }
            if (this.rechargeActions(worker, true)) {
                return true;
            }
        }
        // Sign controller if needed
        if (!this.colony.controller.signedByMe &&
            !this.colony.controller.signedByScreeps) {
            this.debug(`${worker.print} signing controller ${this.colony.controller.ref}`);
            worker.task = Tasks$1.signController(this.colony.controller);
            return true;
        }
        this.debug(`${worker.print} upgrading ${this.colony.controller.ref}`);
        worker.task = Tasks$1.upgrade(this.room.controller);
        return true;
    }
    bootstrapActions(worker) {
        var _a;
        if (this.rechargeActions(worker)) {
            return true;
        }
        // Dump energy into the hatchery
        const target = (_a = this.colony.hatchery) === null || _a === void 0 ? void 0 : _a.energyStructures.find((struct) => struct.store.getFreeCapacity(RESOURCE_ENERGY));
        if (target && this.colony.state.bootstrapping) {
            this.debug(`${worker.print} bootstraping ${target.print}`);
            worker.task = Tasks$1.transfer(target);
            return true;
        }
        return false;
    }
    rechargeActions(worker, upgrading = false) {
        var _a;
        if (worker.store.energy > 0) {
            return false;
        }
        // Acquire more energy
        let workerWithdrawLimit = 100;
        // The minimum is intentionally raised on low-level colonies to keep the hatchery from being starved
        if (this.colony.storage &&
            ((_a = this.colony.hatchery) === null || _a === void 0 ? void 0 : _a.getWaitTimeForPriority(OverlordPriority.throttleThreshold)) !== 0) {
            workerWithdrawLimit = 750;
        }
        if (upgrading) {
            const link = this.colony.upgradeSite.link;
            if (link &&
                this.pos.inRangeTo(link.pos, 3) &&
                link.store[RESOURCE_ENERGY] > 0) {
                this.debug(`${worker.print} refilling from link as upgrader`);
                worker.task = Tasks$1.withdraw(link, RESOURCE_ENERGY);
                return true;
            }
        }
        // this.debug(`${worker.print} going for a refill`);
        worker.task = Tasks$1.recharge(workerWithdrawLimit);
        return true;
    }
    handleWorker(worker) {
        // this.debug(`${worker.print} looking for work`);
        // TODO Add high priority to block controller with ramparts/walls in case of downgrade attack
        // FIXME workers get stalled at controller in case of downgrade attack
        if (this.shouldPreventControllerDowngrade()) {
            this.debug(`${worker.print} emergency upgrade!`);
            if (this.upgradeActions(worker)) {
                return;
            }
        }
        // Turn into queens until the bootstrap situation gets resolved
        const hatcheryIsOverloaded = this.colony.hatchery &&
            this.colony.hatchery.memory.stats.overload >= 0.1;
        if (this.colony.state.bootstrapping || hatcheryIsOverloaded) {
            if (this.bootstrapActions(worker)) {
                return;
            }
        }
        // Repair damaged non-road non-barrier structures
        if (this.repairStructures.length > 0 &&
            this.colony.defcon == DEFCON.safe) {
            if (this.repairActions(worker)) {
                return;
            }
        }
        // Fortify critical barriers
        if (this.criticalBarriers.length > 0) {
            if (this.fortifyActions(worker, this.criticalBarriers)) {
                return;
            }
        }
        // Build new structures
        if (this.constructionSites.length > 0 &&
            this.colony.defcon < DEFCON.playerInvasion) {
            if (this.buildActions(worker)) {
                return;
            }
        }
        // Build ramparts to block incoming nuke
        if (this.nukeDefenseRamparts.length > 0 &&
            !this.colony.state.isRebuilding) {
            if (this.nukeFortifyActions(worker, this.nukeDefenseRamparts)) {
                return;
            }
        }
        // Build and maintain roads
        if (this.colony.roadLogistics.workerShouldRepave(worker) &&
            this.colony.defcon == DEFCON.safe) {
            if (this.pavingActions(worker)) {
                return;
            }
        }
        // Dismantle marked structures
        if (this.dismantleStructures.length > 0 &&
            this.colony.defcon == DEFCON.safe) {
            if (this.dismantleActions(worker)) {
                return;
            }
        }
        // Fortify walls and ramparts
        if (this.fortifyBarriers.length > 0) {
            if (this.fortifyActions(worker, this.fortifyBarriers)) {
                return;
            }
        }
        // Upgrade controller if less than RCL8 or no upgraders
        if ((this.colony.level < 8 ||
            this.colony.upgradeSite.overlord.upgraders.length == 0) &&
            this.colony.defcon == DEFCON.safe) {
            if (this.upgradeActions(worker)) {
                return;
            }
        }
        // this.debug(`${worker.print} no work to do!`);
    }
    run() {
        this.autoRun(this.workers, (worker) => this.handleWorker(worker), (worker) => worker.flee(worker.room.fleeDefaults, { invalidateTask: true }));
    }
};
WorkerOverlord.settings = {
    barrierHits: {
        // What HP to fortify barriers to at each RCL
        critical: 2500,
        1: 3e3,
        2: 3e3,
        3: 1e4,
        4: 5e4,
        5: 1e5,
        6: 5e5,
        7: 2e6,
        8: 2.1e7,
    },
    hitTolerance: 100000, // allowable spread in HP
    fortifyDutyThreshold: 250000, // ignore fortify duties until this amount of energy is present in the room
};
WorkerOverlord = WorkerOverlord_1 = __decorate$1([
    profile
], WorkerOverlord);

/** Thresholds blueprint for storage/terminal balancing */
const TERMINAL_BALANCE_THRESHOLDS = {
    default: {
        target: 1000,
        tolerance: 1000,
    },
    dontCare: {
        target: 1000,
        tolerance: 1000,
    },
    dontWant: {
        target: 0,
        tolerance: 0,
    },
    energy: {
        target: 50000,
        tolerance: 5000,
    },
    power: {
        target: 2500,
        tolerance: 2500,
    },
    ops: {
        target: 2500,
        tolerance: 2500,
    },
    baseMinerals: {
        target: 6500, // 2 * LAB_MINERAL_CAPACITY + 500
        tolerance: 500,
    },
    intermediates: {
        target: 3500, // LAB_MINERAL_CAPACITY + 500
        tolerance: 500,
    },
    boosts: {
        target: 3500, // LAB_MINERAL_CAPACITY + 500
        tolerance: 500,
    },
    commoditiesRaw: {
        target: 5000,
        tolerance: 1000,
    },
    commodities: {
        target: 5000,
        tolerance: 500,
    },
};
/**
 * Returns the threshold for a given resource from a generic threshold repository
 * @param resource The resource
 * @param thresholds The threshold repository
 * @returns
 */
function getThresholds(resource, thresholds) {
    var _a, _b, _c;
    // If we have an explicit threshold for that resource, use it
    if (thresholds[resource]) {
        return thresholds[resource];
    }
    // All mineral compounds below
    if (Abathur.isBaseMineral(resource)) {
        // base minerals get default treatment
        return (_a = thresholds.baseMinerals) !== null && _a !== void 0 ? _a : thresholds.default;
    }
    if (Abathur.isIntermediateReactant(resource)) {
        // reaction intermediates get default
        return (_b = thresholds.intermediates) !== null && _b !== void 0 ? _b : thresholds.default;
    }
    if (Abathur.isBoost(resource)) {
        const tier = Abathur.getBoostTier(resource);
        if (!tier) {
            return thresholds.dontCare;
        }
        const threshold = thresholds[`boosts${tier}`];
        return threshold !== null && threshold !== void 0 ? threshold : thresholds.dontCare;
    }
    if (Abathur.isMineralOrCompound(resource)) {
        // all other boosts and resources are default
        return thresholds.default;
    }
    // Base deposit resources
    if (Abathur.isRawCommodity(resource)) {
        return (_c = thresholds.commoditiesRaw) !== null && _c !== void 0 ? _c : thresholds.dontCare;
    }
    // Everything else should be a commodity
    if (Abathur.isCommodity(resource)) {
        const tier = Abathur.getCommodityTier(resource);
        const threshold = thresholds[`commoditiesT${tier}`];
        return threshold !== null && threshold !== void 0 ? threshold : thresholds.dontCare;
    }
    // Shouldn't reach here since I've handled everything above
    log.error(`Shouldn't reach here! Unhandled resource ${resource} in getThresholds()!`);
    return thresholds.dontCare;
}
/** Per-resource thresholds for storage/terminal balancing */
const TERMINAL_BALANCE_THRESHOLDS_ALL = _.zipObject(RESOURCES_ALL, _.map(RESOURCES_ALL, (resource) => getThresholds(resource, TERMINAL_BALANCE_THRESHOLDS)));
/**
 * Resource manager; makes high-level decisions based on resource amounts & capacity
 */
class ResourceManager {
    /** Returns the maximum capacity considered safe for the structure */
    static getSafeCapacity(store) {
        return (store.store.getCapacity() -
            this.overfillThresholds[store.structureType].overfill);
    }
    /** Check if the given storage structure is getting close to full */
    static isOverCapacity(store) {
        return store.store.getUsedCapacity() > this.getSafeCapacity(store);
    }
    /** Check if we should dump instead of trying to transfer to the given structure */
    static shouldDump(store) {
        return (store.store.getUsedCapacity() >
            store.store.getCapacity() -
                this.overfillThresholds[store.structureType].dump);
    }
    static shouldDumpResource(colony, resource, amount = 0) {
        var _a;
        if (colony.storage && !this.shouldDump(colony.storage)) {
            // No need to dump if our storage isn't full
            return false;
        }
        if (colony.terminal && this.shouldDump(colony.terminal)) {
            // Terminal is over dump threshold, just dump the resource
            return true;
        }
        // Otherwise check the terminal network threshold
        const threshold = Overmind.terminalNetwork.thresholds(colony, resource);
        return (colony.assets[resource] + amount >= ((_a = threshold.surplus) !== null && _a !== void 0 ? _a : Infinity));
    }
    /** Get the next resource that can be dumped from the given structure */
    static getNextResourceToDump(colony, target) {
        // Gather the list of resource that aren't tracked or are over threshold and reverse-sort them by importance
        const contents = target.store.contents
            .filter(([resource, amount]) => {
            return this.shouldDumpResource(colony, resource, !isStructure(target) ? amount : 0);
        })
            .map(([res, amount]) => [
            res,
            amount,
            RESOURCE_IMPORTANCE_ALL.indexOf(res),
        ])
            .sort(([_aRes, _aAmt, aId], [_bRes, _bAmt, bId]) => {
            return bId - aId;
        });
        return contents.length > 0 ? contents[0][0] : undefined;
    }
    static getBalancedThresholdForResource(colony, resource) {
        return TERMINAL_BALANCE_THRESHOLDS_ALL[resource];
    }
    /**
     * Pick a storage target that would not be overflowed by incoming resources
     */
    static targetForResource(colony, resource, amount) {
        let target;
        // Check if the terminal is below its target
        if (colony.terminal) {
            const thresholds = TERMINAL_BALANCE_THRESHOLDS_ALL[resource];
            if (!thresholds) {
                log.warning(`${colony.print}: ${colony.terminal} doesn't want ${resource}!`);
            }
            else if (colony.terminal.store[resource] + amount <=
                thresholds.target) {
                if (colony.terminal &&
                    colony.terminal.store[resource] + amount <=
                        thresholds.target + thresholds.tolerance) {
                    if (colony.memory.debug) {
                        log.alert(`${colony.terminal.print} can't accept ${amount} of ${resource} without exceeding thresholds`);
                    }
                }
                else {
                    if (colony.memory.debug) {
                        log.alert(`${colony.terminal.print} is below target ${thresholds} of ${resource}, accepting ${amount}`);
                    }
                    target = colony.terminal;
                }
            }
            if (this.isOverCapacity(colony.terminal)) {
                if (colony.memory.debug) {
                    log.alert(`${colony.terminal.print} overfilled; can't accept ${amount} of ${resource}`);
                }
                target = undefined;
            }
        }
        // Check storage if it's below the cap
        if (!target && colony.storage) {
            if (this.isOverCapacity(colony.storage)) {
                if (colony.memory.debug) {
                    log.alert(`${colony.storage.print} overfilled; can't accept ${amount} of ${resource}`);
                }
            }
            else {
                if (colony.memory.debug) {
                    log.alert(`${colony.storage.print} accepts ${amount} of ${resource}`);
                }
                target = colony.storage;
            }
        }
        return target;
    }
    /**
     * Returns the remaining amount of capacity in a colony.
     *
     * Optionally takes an additionalAssets argument that asks whether the
     * colony would be near capacity if additionalAssets amount of resources were added.
     */
    static getRemainingSpace(colony, includeFactoryCapacity = false) {
        let totalAssets = _.sum(colony.assets);
        // Overfilled storage gets counted as just 100% full
        if (colony.storage &&
            colony.storage.store.getUsedCapacity() >
                this.getSafeCapacity(colony.storage)) {
            totalAssets -=
                colony.storage.store.getUsedCapacity() -
                    this.getSafeCapacity(colony.storage);
        }
        const roomCapacity = (colony.terminal ? this.getSafeCapacity(colony.terminal) : 0) +
            (colony.storage ? this.getSafeCapacity(colony.storage) : 0) +
            (colony.factory && includeFactoryCapacity ?
                this.getSafeCapacity(colony.factory)
                : 0);
        return roomCapacity - totalAssets;
    }
}
ResourceManager.overfillThresholds = {
    storage: {
        overfill: 100000,
        dump: 5000,
    },
    terminal: {
        overfill: 50000,
        dump: 5000,
    },
    factory: {
        overfill: 2000,
        dump: 500,
    },
};
ResourceManager.settings = {
    /** Won't rebuild terminal until you have this much energy in storage */
    minimumEnergyTerminalRebuilding: 200000,
};
// @ts-expect-error global
global.ResourceManager = ResourceManager;

/**
 * Command center overlord: spawn and run a dediated commandCenter attendant
 */
let CommandCenterOverlord = class CommandCenterOverlord extends Overlord {
    constructor(commandCenter, priority = OverlordPriority.core.manager) {
        super(commandCenter, "manager", priority);
        this.commandCenter = commandCenter;
        this.mode = this.colony.layout;
        this.managers = this.zerg(Roles.manager);
        if (this.colony.bunker) {
            const anchor = this.colony.bunker.anchor;
            $.set(this, "managerRepairTarget", () => minBy(_.filter(anchor.findInRange(anchor.room.barriers, 3), (b) => b.hits <
                WorkerOverlord.settings.barrierHits[this.colony.level]), (b) => b.hits));
        }
    }
    refresh() {
        super.refresh();
        $.refresh(this, "managerRepairTarget");
    }
    init() {
        let setup = Setups.managers.default;
        let spawnRequestOptions = {};
        if (this.colony.layout == "twoPart") {
            setup = Setups.managers.twoPart;
        }
        const needsMobileManager = this.colony.state.isEvacuating || this.colony.state.isRebuilding;
        if (this.colony.bunker &&
            this.colony.bunker.coreSpawn &&
            !needsMobileManager) {
            setup = Setups.managers.stationary;
            // // Spawn a worker manager to repair central tiles
            // if (this.managerRepairTarget &&
            // 	this.managerRepairTarget.hits < WorkerOverlord.settings.barrierHits[this.colony.level] - 1e5 &&
            // 	this.colony.assets.energy > WorkerOverlord.settings.fortifyDutyThreshold) {
            // 	setup = Setups.managers.stationary_work; // use working manager body if you have something to repair
            // }
            spawnRequestOptions = {
                spawn: this.colony.bunker.coreSpawn,
                directions: [
                    this.colony.bunker.coreSpawn.pos.getDirectionTo(this.colony.bunker.anchor),
                ],
            };
        }
        this.wishlist(1, setup, { options: spawnRequestOptions });
    }
    /**
     * Dump anything you are currently holding into terminal or storage
     */
    unloadCarry(manager) {
        // Nothing to do if creep is empty
        if (manager.store.getUsedCapacity() == 0) {
            return false;
        }
        let task;
        for (const [resource, amount] of manager.store.contents) {
            const target = ResourceManager.targetForResource(this.colony, resource, amount);
            if (!target) {
                this.debug(() => `${manager.print} nothing wants to take ${amount} of ${resource}`);
                continue;
            }
            this.debug(() => `${manager.print}: unloading ${amount} of ${resource} to ${target.print}`);
            const transfer = Tasks$1.transfer(target, resource, amount);
            task = task ? task.fork(transfer) : transfer;
        }
        if (!task) {
            log.warning(`${this.print}: ${manager.print} has nowhere to unload carry ${JSON.stringify(manager.store)}`);
            return false;
        }
        manager.task = task;
        return true;
    }
    /**
     * Handle any supply requests from your transport request group
     */
    supplyActions(manager) {
        const request = this.commandCenter.transportRequests.getPrioritizedClosestRequest(manager.pos, "supply");
        if (!request) {
            this.debug(() => `${manager.print} no supply requests`);
            return false;
        }
        this.debug(() => `${manager.print} has a supply request: ${TransportRequestGroup.logRequest(request)}`);
        const amount = Math.min(request.amount, manager.store.getCapacity());
        const resource = request.resourceType;
        // If we have enough to fulfill the request, we're done
        if (manager.store[request.resourceType] >= amount) {
            this.debug(() => `${manager.print} supplying ${request.target.print} with ${amount} of ${resource}`);
            manager.task = Tasks$1.transfer(request.target, resource, amount);
            return true;
        }
        else if (manager.store[request.resourceType] > 0) {
            // Otherwise, if we have any currently in manager's carry, transfer it to the requestor
            this.debug(() => `${manager.print} supplying ${request.target.print} with ${amount} of ${resource}`);
            manager.task = Tasks$1.transfer(request.target, resource, manager.store[request.resourceType]);
            return true;
        }
        else {
            const storage = this.commandCenter.storage;
            const terminal = this.commandCenter.terminal;
            // Otherwise, we don't have any of the resource in the carry
            if (this.unloadCarry(manager)) {
                // if we have other crap, we should unload it
                return true;
            }
            // Otherwise, we have an empty carry; withdraw the right amount of resource and transfer it
            let withdrawFrom;
            let withdrawAmount = amount;
            if (request.target.id !== storage.id &&
                storage.store[resource] > 0) {
                withdrawFrom = storage;
                withdrawAmount = Math.min(amount, storage.store[resource]);
            }
            else if (terminal &&
                request.target.id !== terminal.id &&
                terminal.store[resource] > 0) {
                withdrawFrom = terminal;
                withdrawAmount = Math.min(amount, terminal.store[resource]);
            }
            if (withdrawFrom) {
                this.debug(() => `${manager.print} withdraws from ${withdrawFrom.print}, ${withdrawAmount} to supply ${TransportRequestGroup.logRequest(request)}`);
                manager.task = Tasks$1.chain([
                    Tasks$1.withdraw(withdrawFrom, resource, withdrawAmount),
                    Tasks$1.transfer(request.target, resource, withdrawAmount),
                ]);
                return true;
            }
            else {
                this.debug(() => `${manager.print}: could not fulfill supply request!`);
                return false;
            }
        }
    }
    /**
     * Handle any withdrawal requests from your transport request group
     */
    withdrawActions(manager) {
        const freeCapacity = manager.store.getFreeCapacity();
        if (freeCapacity > 0) {
            const request = this.commandCenter.transportRequests.getPrioritizedClosestRequest(manager.pos, "withdraw");
            if (request) {
                this.debug(() => `${manager.print} has free space and a withdraw request: ${TransportRequestGroup.logRequest(request)}`);
                const amount = Math.min(request.amount, freeCapacity);
                manager.task = Tasks$1.withdraw(request.target, request.resourceType, amount);
                const supplyRequest = this.commandCenter.transportRequests.getPrioritizedClosestRequest(manager.pos, "supply", (req) => req.resourceType === request.resourceType);
                if (supplyRequest) {
                    this.debug(() => `${manager.print} can supply request: ${TransportRequestGroup.logRequest(supplyRequest)}`);
                    manager.task = Tasks$1.transfer(supplyRequest.target, supplyRequest.resourceType, Math.min(supplyRequest.amount, freeCapacity)).fork(manager.task);
                    return true;
                }
                else {
                    this.debug(() => `${manager.print}: cannot fulfill withdraw request!`);
                }
            }
        }
        this.debug(() => `${manager.print} has no free space or no withdraw request`);
        // Try to supply someone with what we have stored/withdrew
        if (this.supplyActions(manager)) {
            return true;
        }
        // Otherwise just try to unload
        if (this.unloadCarry(manager)) {
            return true;
        }
        return false;
    }
    /**
     * Pickup resources dropped on manager position or in tombstones from last manager
     */
    pickupActions(manager, tombstonesOnly = false) {
        // Don't pickup anything if we're over-filled; it's likely we were the one who dropped it
        if (this.colony.state.isOverfilled) {
            return false;
        }
        // Look for tombstones at position
        const tombstones = manager.pos.lookFor(LOOK_TOMBSTONES);
        const tombstone = _.first(tombstones);
        if (tombstone && tombstone.store.getUsedCapacity() > 0) {
            this.debug(`picking up from tombstone ${tombstone.print}`);
            manager.task = Tasks$1.chain([
                Tasks$1.withdrawAll(tombstone),
                Tasks$1.transferAll(this.commandCenter.storage),
            ]);
            return true;
        }
        if (tombstonesOnly) {
            return false; // skip next bit if only looking at tombstones
        }
        // Pickup any resources that happen to be dropped where you are
        const resources = manager.pos.lookFor(LOOK_RESOURCES);
        const resource = _.first(resources);
        if (resource) {
            this.debug(`picking up from resource ${resource.print}`);
            manager.task = Tasks$1.chain([
                Tasks$1.pickup(resource),
                Tasks$1.transferAll(this.commandCenter.storage),
            ]);
            return true;
        }
        return false;
    }
    /**
     * When storage + terminal are critically full, start dumping the least useful stuff on the ground.
     * This should rarely be run; added in Feb 2020 to fix a critical issue where I hadn't added factory code and all
     * my terminals and storage filled up with crap.
     */
    emergencyDumpingActions(manager) {
        // We only need to consider dumping if we're already overfilled
        if (!this.colony.state.isOverfilled) {
            return false;
        }
        const storage = this.commandCenter.storage;
        const terminal = this.commandCenter.terminal;
        if (!storage && !terminal) {
            return false;
        }
        if (terminal && ResourceManager.shouldDump(terminal)) {
            log.alert(`${this.print}: ${manager.print} is currently dumping from ${terminal.print}!`);
            return this.dumpFrom(manager, terminal);
        }
        if (storage && ResourceManager.shouldDump(storage)) {
            log.alert(`${this.print}: ${manager.print} is currently dumping from ${storage.print}!`);
            return this.dumpFrom(manager, storage);
        }
        return false;
    }
    /**
     * Dump resources on ground from a target that is critically full
     */
    dumpFrom(manager, target) {
        // Start by dumping unimportant stuff from the manager
        let resource = ResourceManager.getNextResourceToDump(this.colony, manager);
        if (resource) {
            manager.drop(resource);
            return true;
        }
        // Then go through the target and do the same thing
        resource = ResourceManager.getNextResourceToDump(this.colony, target);
        if (resource) {
            manager.task = Tasks$1.drop(manager.pos, resource).fork(Tasks$1.withdraw(target, resource));
            return true;
        }
        return false;
    }
    /**
     * Suicide once you get old and make sure you don't drop and waste any resources
     */
    deathActions(manager) {
        if (manager.ticksToLive >= 150) {
            return false;
        }
        const nearbyManagers = _.filter(this.managers, (manager) => manager.pos.inRangeTo(this.commandCenter.pos, 3) &&
            (manager.ticksUntilSpawned || 0) <= 10);
        if (nearbyManagers.length > 1) {
            // > 1 including self
            if (manager.store.getUsedCapacity() > 0) {
                this.unloadCarry(manager);
            }
            else {
                manager.retire();
            }
            return true;
        }
        return false;
    }
    handleManager(manager) {
        // Handle switching to next manager
        if (this.deathActions(manager)) {
            return true;
        }
        // Emergency dumping actions for critically clogged terminals and storages
        if (this.emergencyDumpingActions(manager)) {
            return true;
        }
        // Pick up any dropped resources on ground
        if (this.pickupActions(manager)) {
            return true;
        }
        // Fulfill remaining low-priority withdraw requests
        if (this.commandCenter.transportRequests.needsWithdrawing()) {
            if (this.withdrawActions(manager)) {
                return true;
            }
        }
        // Fulfill remaining low-priority supply requests
        if (this.commandCenter.transportRequests.needsSupplying()) {
            if (this.supplyActions(manager)) {
                return true;
            }
        }
        return false;
    }
    repairActions(manager) {
        if (this.mode == "bunker" &&
            this.managerRepairTarget &&
            manager.getActiveBodyparts(WORK) > 0) {
            // Repair ramparts when idle
            if (manager.store.energy > 0) {
                manager.repair(this.managerRepairTarget);
                return true;
            }
            const storage = this.commandCenter.storage;
            const terminal = this.commandCenter.terminal;
            const energyTarget = storage.store[RESOURCE_ENERGY] > 0 ? storage : terminal;
            if (energyTarget) {
                manager.withdraw(energyTarget);
                return true;
            }
        }
        return false;
    }
    /**
     * Handle idle actions if the manager has nothing to do
     */
    idleActions(manager) {
        // Look for something to repair
        if (this.repairActions(manager)) {
            return;
        }
        // Otherwise unload our carry
        if (manager.store.getUsedCapacity() > 0 && this.unloadCarry(manager)) {
            return;
        }
        // Ensure we're at our idling spot
        if (!manager.pos.isEqualTo(this.commandCenter.idlePos)) {
            manager.goTo(this.commandCenter.idlePos);
        }
    }
    run() {
        this.autoRun(this.managers, (manager) => {
            if (!this.handleManager(manager)) {
                this.idleActions(manager);
            }
        });
    }
};
CommandCenterOverlord = __decorate$1([
    profile
], CommandCenterOverlord);

var CommandCenter_1;
const MAX_OBSERVE_DISTANCE = 4;
/**
 * The command center groups the high-level structures at the core of the bunker together, including storage, terminal,
 * link, power spawn, observer, and nuker.
 */
let CommandCenter = CommandCenter_1 = class CommandCenter extends HiveCluster {
    constructor(colony, storage) {
        super(colony, storage, "commandCenter");
        this.memory = Mem.wrap(this.colony.memory, "commandCenter");
        // Register physical components
        this.storage = storage;
        this.terminal = colony.terminal;
        this.powerSpawn = colony.powerSpawn;
        this.nuker = colony.nuker;
        this.observer = colony.observer;
        if (this.colony.bunker) {
            this.link = this.colony.bunker.anchor.findClosestByLimitedRange(colony.availableLinks, 1);
            this.colony.linkNetwork.claimLink(this.link);
            this.towers = this.colony.bunker.anchor.findInRange(colony.towers, 1);
        }
        else {
            this.link = this.pos.findClosestByLimitedRange(colony.availableLinks, 2);
            this.colony.linkNetwork.claimLink(this.link);
            this.towers = this.pos.findInRange(colony.towers, 3);
        }
        this.transportRequests = new TransportRequestGroup("commandCenter"); // commandCenter always gets its own request group
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, "commandCenter");
        $.refreshRoom(this);
        $.refresh(this, "storage", "terminal", "powerSpawn", "nuker", "observer", "link", "towers");
        this.transportRequests.refresh();
    }
    spawnMoarOverlords() {
        if (this.link || this.terminal) {
            this.overlord = new CommandCenterOverlord(this);
        }
    }
    // Idle position
    get idlePos() {
        if (this.colony.bunker) {
            return this.colony.bunker.anchor;
        }
        if (!this.memory.idlePos || Game.time % 25 == 0) {
            this.memory.idlePos = this.findIdlePos();
        }
        return derefRoomPosition(this.memory.idlePos);
    }
    /* Find the best idle position */
    findIdlePos() {
        // Try to match as many other structures as possible
        const proximateStructures = _.compact([
            this.link,
            this.terminal,
            this.powerSpawn,
            this.nuker,
            ...this.towers,
        ]);
        const numNearbyStructures = (pos) => _.filter(proximateStructures, (s) => s.pos.isNearTo(pos) && !s.pos.isEqualTo(pos)).length;
        return _.last(_.sortBy(this.storage.pos.neighbors, (pos) => numNearbyStructures(pos)));
    }
    /* Register a link transfer store if the link is sufficiently full */
    registerLinkTransferRequests() {
        if (this.link) {
            if (this.link.energy > CommandCenter_1.settings.linksTransmitAt) {
                this.colony.linkNetwork.requestTransmit(this.link);
            }
        }
    }
    registerRequests() {
        // Refill core spawn (only applicable to bunker layouts)
        if (this.colony.bunker && this.colony.bunker.coreSpawn) {
            if (this.colony.bunker.coreSpawn.store[RESOURCE_ENERGY] <
                this.colony.bunker.coreSpawn.store.getCapacity(RESOURCE_ENERGY)) {
                this.transportRequests.requestInput(this.colony.bunker.coreSpawn, Priority.Normal);
            }
        }
        // If the link has energy and nothing needs it, empty it
        if (this.link && this.link.store[RESOURCE_ENERGY] > 0) {
            if (this.colony.linkNetwork.receive.length == 0 ||
                this.link.cooldown > 3) {
                this.transportRequests.requestOutput(this.link, Priority.High);
            }
        }
        this.balanceStorageAndTerminal();
        // Nothing else should request if you're trying to start a room back up again
        if (this.colony.state.bootstrapping) {
            return;
        }
        // Supply requests:
        // If the link is empty and can send energy and something needs energy, fill it up
        if (this.link &&
            this.link.store[RESOURCE_ENERGY] <
                0.9 * this.link.store.getCapacity(RESOURCE_ENERGY) &&
            this.link.cooldown <= 1) {
            if (this.colony.linkNetwork.receive.length > 0) {
                // If something wants energy
                this.transportRequests.requestInput(this.link, Priority.Critical);
            }
        }
        // Refill towers as needed with variable priority
        const refillTowers = _.filter(this.towers, (tower) => tower.energy < CommandCenter_1.settings.refillTowersBelow);
        _.forEach(refillTowers, (tower) => this.transportRequests.requestInput(tower, Priority.High));
        // Refill power spawn
        if (this.powerSpawn) {
            if (this.powerSpawn.store[RESOURCE_ENERGY] <
                this.powerSpawn.store.getCapacity(RESOURCE_ENERGY) * 0.5) {
                this.transportRequests.requestInput(this.powerSpawn, Priority.NormalLow);
            }
            else if (this.powerSpawn.store[RESOURCE_POWER] <
                this.powerSpawn.store.getCapacity(RESOURCE_POWER) * 0.5 &&
                this.terminal &&
                this.terminal.store[RESOURCE_POWER] >= 100) {
                this.transportRequests.requestInput(this.powerSpawn, Priority.NormalLow, { resourceType: RESOURCE_POWER });
            }
        }
        // Refill nuker with low priority
        if (this.nuker) {
            if (this.nuker.store[RESOURCE_ENERGY] <
                this.nuker.store.getCapacity(RESOURCE_ENERGY) &&
                ((this.storage.energy > 200000 &&
                    this.nuker.cooldown <= 1000) ||
                    this.storage.energy > 800000)) {
                this.transportRequests.requestInput(this.nuker, Priority.Low);
            }
            if (this.nuker.store[RESOURCE_GHODIUM] <
                this.nuker.store.getCapacity(RESOURCE_GHODIUM) &&
                this.colony.assets[RESOURCE_GHODIUM] >= LAB_MINERAL_CAPACITY) {
                this.transportRequests.requestInput(this.nuker, Priority.Low, {
                    resourceType: RESOURCE_GHODIUM,
                });
            }
        }
        if (this.storage && this.terminal) {
            if (this.storage.store[RESOURCE_OPS] < 3000 &&
                this.terminal.store[RESOURCE_OPS] > 100) {
                this.transportRequests.requestInput(this.storage, Priority.Normal, { resourceType: RESOURCE_OPS });
            }
        }
    }
    /**
     * Move energy into terminal if storage is too full and into storage if storage is too empty
     */
    balanceStorageAndTerminal() {
        this.debug("balancing storage and terminal");
        if (!this.storage || !this.terminal) {
            return false;
        }
        const roomSellOrders = Overmind.tradeNetwork.getExistingOrders(ORDER_SELL, "any", this.colony.name);
        for (const [resource, amount] of entries(this.colony.assets)) {
            // Get target and tolerance for the resource and skip if you don't care about it or have none of it
            const thresholds = ResourceManager.getBalancedThresholdForResource(this.colony, resource);
            if (amount <= 0 || !thresholds) {
                this.debug(() => this.colony.assets[resource] <= 0 ?
                    `no storage of ${resource}, ignoring`
                    : `no threshold for ${resource}, ignoring`);
                continue;
            }
            let { target, tolerance } = thresholds;
            // If you're selling this resource from this room, keep a bunch of it in the terminal
            if (roomSellOrders.length > 0) {
                const sellOrderForResource = _.find(roomSellOrders, (order) => order.resourceType == resource);
                if (sellOrderForResource) {
                    target = Math.max(target, sellOrderForResource.remainingAmount);
                }
            }
            // Special case when we're rebuilding the terminal: we want to safe-guard a lot of energy into the storage
            const isRebuildingTerminal = this.colony.state.isRebuilding && resource === RESOURCE_ENERGY;
            this.debug(`resource ${resource}, target: ${target}, tolerance: ${tolerance}, terminal: ${this.terminal.store[resource]}, storage: ${this.storage.store[resource]}`);
            // Move stuff from terminal into storage
            if (this.terminal.store[resource] > target + tolerance ||
                (isRebuildingTerminal &&
                    this.storage.store[resource] >
                        ResourceManager.settings
                            .minimumEnergyTerminalRebuilding)) {
                const transferAmount = Math.min(this.terminal.store[resource] - target, this.storage.store.getFreeCapacity(resource));
                this.debug(`Moving ${transferAmount} of ${resource} from terminal${isRebuildingTerminal ? " (rebuilding" : ""}`);
                const priority = isRebuildingTerminal ? Priority.Critical : Priority.Low;
                this.transportRequests.requestOutput(this.terminal, priority, {
                    resourceType: resource,
                    amount: transferAmount,
                });
                this.transportRequests.requestInput(this.storage, priority, {
                    resourceType: resource,
                    amount: transferAmount,
                });
            }
            // Move stuff from storage into terminal
            if (this.terminal.store[resource] < target - tolerance &&
                this.storage.store[resource] > 0 &&
                !isRebuildingTerminal) {
                const transferAmount = Math.min(target - this.terminal.store[resource], this.storage.store[resource]);
                this.debug(`Moving ${transferAmount} of ${resource} from storage`);
                this.transportRequests.requestOutput(this.storage, Priority.Low, { resourceType: resource, amount: transferAmount });
                this.transportRequests.requestInput(this.terminal, Priority.Low, { resourceType: resource, amount: transferAmount });
            }
        }
        // Nothing has happened
        return false;
    }
    requestRoomObservation(roomName) {
        log.info(`${this.print} request to observe ${roomName}`);
        this.observeRoom = roomName;
    }
    runObserver() {
        if (this.observer) {
            if (this.observeRoom) {
                const result = this.observer.observeRoom(this.observeRoom);
                log.info(`${this.print} observing ${this.observeRoom}: ${errorForCode(result)}`);
                this.observeRoom = undefined;
            }
            else if (CommandCenter_1.settings.enableIdleObservation &&
                Game.time % 1000 < 100) {
                const axisLength = MAX_OBSERVE_DISTANCE * 2 + 1;
                const dx = (Game.time % axisLength) - MAX_OBSERVE_DISTANCE;
                const dy = Math.floor((Game.time % axisLength ** 2) / axisLength) -
                    MAX_OBSERVE_DISTANCE;
                if (dx == 0 && dy == 0) {
                    return;
                }
                const roomToObserve = Cartographer.findRelativeRoomName(this.pos.roomName, dx, dy);
                // // TODO OBSERVER FIX ONLY LOOK AT southwest corner
                // const dx = Game.time % MAX_OBSERVE_DISTANCE;
                // const dy = Game.time % (MAX_OBSERVE_DISTANCE ** 2);
                // const roomToObserve = Cartographer.findRelativeRoomName(this.pos.roomName, dx, dy);
                const result = this.observer.observeRoom(roomToObserve);
                log.info(`${this.print} observing ${roomToObserve} (idle): ${errorForCode(result)}`);
            }
        }
    }
    runPowerSpawn() {
        if (this.powerSpawn &&
            this.storage &&
            this.colony.assets.energy > 300000 &&
            this.powerSpawn.store.energy >= 50 &&
            this.powerSpawn.store.power > 0) {
            if (Game.market.credits <
                TraderJoe.settings.market.credits.canBuyAbove) {
                // We need to get enough credits that we can start to buy things. Since mineral prices have plunged
                // recently, often the only way to do this without net losing credits (after factoring in the
                // energy -> credits of transaction costs) is to sell excess energy. Power processing eats up a
                // huge amount of energy, so we're going to disable it below a certain threshold.
                return;
            }
            if (Game.time % 20 == 0) {
                log.info(`Processing power in ${this.room.print}`);
            }
            const res = this.powerSpawn.processPower();
            if (res === OK) {
                this.colony.trackEnergyUse(EnergyUse.POWER_SPAWN, -50);
            }
        }
    }
    // Initialization and operation ====================================================================================
    init() {
        this.registerLinkTransferRequests();
        this.registerRequests();
    }
    run() {
        if (this.memory.debug) {
            this.transportRequests.summarize();
        }
        this.runObserver();
        this.runPowerSpawn();
    }
    visuals(coord) {
        let { x, y } = coord;
        const height = this.storage && this.terminal ? 5 : 4;
        const titleCoords = Visualizer.section(`${this.colony.name} Command Center`, { x, y, roomName: this.room.name }, 9.5, height + 0.1);
        const boxX = titleCoords.x;
        y = titleCoords.y + 0.25;
        const c = this.colony;
        const assetStructures = _.compact([
            c.storage,
            c.terminal,
            c.factory,
            ...c.labs,
        ]);
        const assetCreeps = [
            ...c.getCreepsByRole(Roles.queen),
            ...c.getCreepsByRole(Roles.manager),
        ];
        const assetStores = _.map([...assetStructures, ...assetCreeps], (thing) => thing.store);
        const used = _.sum(assetStores, (s) => s.getUsedCapacity(RESOURCE_ENERGY));
        const capacity = _.sum(assetStores, (s) => s.getCapacity(RESOURCE_ENERGY));
        const fmt = (num) => `${Math.floor(num / 1000)}K`;
        Visualizer.text("Energy", { x: boxX, y: y, roomName: this.room.name });
        Visualizer.barGraph([used, capacity], { x: boxX + 4, y: y, roomName: this.room.name }, 5, undefined, fmt);
        y += 1;
        Visualizer.text("Mined", {
            x: boxX,
            y: y,
            roomName: this.room.name,
        });
        const energyPerTick = this.colony.energyMinedPerTick.toFixed(3);
        Visualizer.text(`${energyPerTick} e/t`, {
            x: boxX + 4,
            y,
            roomName: this.room.name,
        });
        y += 1;
        if (this.storage) {
            Visualizer.text("Storage", {
                x: boxX,
                y: y,
                roomName: this.room.name,
            });
            Visualizer.barGraph(this.storage.store.getUsedCapacity() /
                this.storage.store.getCapacity(), { x: boxX + 4, y: y, roomName: this.room.name }, 5);
            y += 1;
        }
        if (this.terminal) {
            Visualizer.text("Terminal", {
                x: boxX,
                y: y,
                roomName: this.room.name,
            });
            Visualizer.barGraph(this.terminal.store.getUsedCapacity() /
                this.terminal.store.getCapacity(), { x: boxX + 4, y: y, roomName: this.room.name }, 5);
            y += 1;
        }
        Visualizer.text("Logistics", {
            x: boxX,
            y: y,
            roomName: this.room.name,
        });
        Visualizer.barGraph(this.colony.overlords.logistics.memory["d" /* TRANSPORT_MEM.DOWNTIME */], { x: boxX + 4, y: y, roomName: this.room.name }, 5);
        y += 1;
        return { x: x, y: y + 0.25 };
    }
};
CommandCenter.settings = {
    enableIdleObservation: true,
    linksTransmitAt: LINK_CAPACITY - 100,
    refillTowersBelow: 750,
};
CommandCenter = CommandCenter_1 = __decorate$1([
    profile
], CommandCenter);

var EvolutionChamber_1;
const LabStatus = {
    Idle: 0,
    AcquiringMinerals: 1,
    LoadingLabs: 2,
    Synthesizing: 3,
    UnloadingLabs: 4,
};
const LabStageTimeouts = {
    Idle: Infinity,
    AcquiringMinerals: 50,
    LoadingLabs: 50,
    Synthesizing: 10000,
    UnloadingLabs: 50,
};
const LAB_USAGE_WINDOW = 100;
const getDefaultEvolutionChamberMemory = () => ({
    status: LabStatus.Idle,
    statusTick: 0,
    activeReaction: undefined,
    stats: {
        totalProduction: {},
        avgUsage: 1,
    },
});
function neighboringLabs(pos) {
    return (_.compact(_.map(pos.neighbors, (neighbor) => neighbor.lookForStructure(STRUCTURE_LAB))));
}
/**
 * The evolution chamber handles mineral production and boosting logic, handling resource supply for labs
 */
let EvolutionChamber = EvolutionChamber_1 = class EvolutionChamber extends HiveCluster {
    constructor(colony, terminal) {
        super(colony, terminal, "evolutionChamber");
        this.memory = Mem.wrap(this.colony.memory, "evolutionChamber", getDefaultEvolutionChamberMemory);
        // Register physical components
        this.terminal = terminal;
        this.terminalNetwork = Overmind.terminalNetwork;
        this.labs = colony.labs;
        // Reserve some easily-accessible labs which are restricted not to be reagent labs
        const restrictedLabs = this.colony.bunker ?
            _.filter(this.labs, (lab) => lab.pos.findInRange(this.colony.spawns, 1).length > 0)
            : _.take(_.sortBy(this.labs, (lab) => Pathing.distance(this.terminal.pos, lab.pos)), 1);
        const getReagentLabs = () => {
            if (this.colony.bunker) {
                const reagentLabPositions = _.map(reagentLabSpots, (coord) => getPosFromBunkerCoord(coord, this.colony));
                const preferredReagentLabs = _.compact(_.map(reagentLabPositions, (pos) => pos.lookForStructure(STRUCTURE_LAB)));
                if (preferredReagentLabs.length == 2) {
                    return preferredReagentLabs;
                }
            }
            // Reagent labs are range=2 from all other labs and are not a boosting lab
            const range2Labs = _.filter(this.labs, (lab) => _.all(this.labs, (otherLab) => lab.pos.inRangeTo(otherLab, 2)));
            const reagentLabCandidates = _.filter(range2Labs, (lab) => !_.any(restrictedLabs, (l) => l.id == lab.id));
            return _.take(_.sortBy(reagentLabCandidates, (lab) => -1 * neighboringLabs(lab.pos).length), 2);
        };
        this.reagentLabs = getReagentLabs();
        // Product labs are everything that isn't a reagent lab. (boostingLab can also be a productLab)
        this.productLabs = _.difference(this.labs, this.reagentLabs);
        // Boosting labs are product labs sorted by distance to terminal
        const unrestrictedBoostingLabs = _.sortBy(_.difference(this.productLabs, restrictedLabs), (lab) => Pathing.distance(this.terminal.pos, lab.pos));
        this.boostingLabs = [...restrictedLabs, ...unrestrictedBoostingLabs];
        // This keeps track of reservations for boosting
        this.labReservations = {};
        // this.boostQueue = {};
        this.neededBoosts = {};
        if (this.colony.commandCenter && this.colony.layout == "twoPart") {
            // TODO: deprecate soon
            // in two-part layout, evolution chamber shares a common request group with command center
            this.transportRequests =
                this.colony.commandCenter.transportRequests;
        }
        else {
            // otherwise (in bunker layout), it uses colony/hatchery transport requests
            this.transportRequests = this.colony.transportRequests;
        }
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, "evolutionChamber", getDefaultEvolutionChamberMemory);
        $.refreshRoom(this);
        $.refresh(this, "terminal", "labs", "boostingLabs", "reagentLabs", "productLabs");
        this.labReservations = {};
        this.neededBoosts = {};
    }
    spawnMoarOverlords() {
        // Evolution chamber is attended to by queens; overlord spawned at Hatchery
    }
    initLabStatus() {
        if (!this.memory.activeReaction &&
            this.memory.status != LabStatus.Idle) {
            log.warning(`Unexpected lack of active reaction at ${this.print}! Reverting to idle state.`);
            this.memory.status = LabStatus.Idle;
        }
        const reagents = this.memory.activeReaction ?
            REAGENTS[this.memory.activeReaction.mineralType]
            : [];
        const amount = this.memory.activeReaction ?
            this.memory.activeReaction.amount
            : Infinity;
        switch (this.memory.status) {
            case LabStatus.Idle:
                if (this.memory.activeReaction) {
                    log.info(`${this.colony.print}: starting synthesis of ${reagents[0]} + ${reagents[1]} ` +
                        `${rightArrow} ${this.memory.activeReaction.mineralType}`);
                    this.memory.status = LabStatus.AcquiringMinerals;
                    this.memory.statusTick = Game.time;
                }
                break;
            case LabStatus.AcquiringMinerals: // "We acquire more mineralzzz"
                if (_.all(reagents, (reagent) => this.colony.assets[reagent] >= amount)) {
                    this.memory.status = LabStatus.LoadingLabs;
                    this.memory.statusTick = Game.time;
                }
                break;
            case LabStatus.LoadingLabs:
                if (_.all(this.reagentLabs, (lab) => lab.mineralAmount >= amount &&
                    _.includes(reagents, lab.mineralType))) {
                    this.memory.status = LabStatus.Synthesizing;
                    this.memory.statusTick = Game.time;
                }
                break;
            case LabStatus.Synthesizing:
                if (_.any(this.reagentLabs, (lab) => lab.mineralAmount < LAB_REACTION_AMOUNT)) {
                    this.memory.status = LabStatus.UnloadingLabs;
                    this.memory.statusTick = Game.time;
                }
                break;
            case LabStatus.UnloadingLabs:
                const unloadLabs = _.filter(this.labs, (lab) => !this.labReservations[lab.id]);
                if (_.all(unloadLabs, (lab) => lab.mineralAmount == 0)) {
                    this.memory.status = LabStatus.Idle;
                    this.memory.statusTick = Game.time;
                }
                break;
            default:
                log.error(`Bad lab state at ${this.print}! State: ${this.memory.status}`);
                this.memory.status = LabStatus.Idle;
                this.memory.statusTick = Game.time;
                break;
        }
        this.statusTimeoutCheck();
    }
    statusTimeoutCheck() {
        const ticksInStatus = Game.time - this.memory.statusTick;
        let timeout = false;
        switch (this.memory.status) {
            case LabStatus.Idle:
                timeout = ticksInStatus > LabStageTimeouts.Idle;
                break;
            case LabStatus.AcquiringMinerals:
                timeout = ticksInStatus > LabStageTimeouts.AcquiringMinerals;
                break;
            case LabStatus.LoadingLabs:
                timeout = ticksInStatus > LabStageTimeouts.LoadingLabs;
                break;
            case LabStatus.Synthesizing:
                timeout = ticksInStatus > LabStageTimeouts.Synthesizing;
                break;
            case LabStatus.UnloadingLabs:
                timeout = ticksInStatus > LabStageTimeouts.UnloadingLabs;
                break;
            default:
                log.error(`Bad lab state at ${this.print}!`);
                this.memory.status = LabStatus.Idle;
                this.memory.statusTick = Game.time;
                break;
        }
        if (timeout) {
            log.warning(`${this.print}: stuck in state ${this.memory.status} for ${ticksInStatus} ticks, ` +
                `rebuilding reaction queue and reverting to idle state!`);
            this.memory.status = LabStatus.Idle;
            this.memory.statusTick = Game.time;
            this.memory.activeReaction = undefined;
            // this.memory.reactionQueue = [];
        }
    }
    registerReagentLabRequests(reagentLabs) {
        if (this.memory.activeReaction) {
            const { mineralType, amount } = this.memory.activeReaction;
            const [ing1, ing2] = REAGENTS[mineralType];
            const [lab1, lab2] = reagentLabs;
            if (!lab1 || !lab2) {
                return;
            }
            // Empty out any incorrect minerals and request the correct reagents
            if (this.memory.status == LabStatus.UnloadingLabs ||
                (lab1.mineralType != ing1 && lab1.mineralAmount > 0)) {
                this.transportRequests.requestOutput(lab1, Priority.Normal, {
                    resourceType: lab1.mineralType,
                });
            }
            else if (this.memory.status == LabStatus.LoadingLabs &&
                lab1.mineralAmount < amount) {
                this.transportRequests.requestInput(lab1, Priority.Normal, {
                    resourceType: ing1,
                    amount: amount - lab1.mineralAmount,
                });
            }
            if (this.memory.status == LabStatus.UnloadingLabs ||
                (lab2.mineralType != ing2 && lab2.mineralAmount > 0)) {
                this.transportRequests.requestOutput(lab2, Priority.Normal, {
                    resourceType: lab2.mineralType,
                });
            }
            else if (this.memory.status == LabStatus.LoadingLabs &&
                lab2.mineralAmount < amount) {
                this.transportRequests.requestInput(lab2, Priority.Normal, {
                    resourceType: ing2,
                    amount: amount - lab2.mineralAmount,
                });
            }
        }
        else {
            // Labs should be empty when no reaction process is currently happening
            for (const lab of reagentLabs) {
                if (lab.mineralType && lab.mineralAmount > 0) {
                    this.transportRequests.requestOutput(lab, Priority.Normal, {
                        resourceType: lab.mineralType,
                    });
                }
            }
        }
    }
    registerProductLabRequests(labs) {
        if (this.memory.activeReaction) {
            const { mineralType, amount: _amount } = this.memory.activeReaction;
            for (const lab of labs) {
                const labHasWrongMineral = lab.mineralType != mineralType && lab.mineralAmount > 0;
                const labIsFull = lab.mineralAmount == lab.mineralCapacity;
                // Empty out incorrect minerals or if it's time to unload or if lab is full
                if ((this.memory.status == LabStatus.UnloadingLabs &&
                    lab.mineralAmount > 0) ||
                    labHasWrongMineral ||
                    labIsFull) {
                    this.transportRequests.requestOutput(lab, Priority.NormalLow, { resourceType: lab.mineralType });
                }
            }
        }
        else {
            // Labs should be empty when no reaction process is currently happening
            for (const lab of labs) {
                if (lab.mineralType && lab.mineralAmount > 0) {
                    this.transportRequests.requestOutput(lab, Priority.NormalLow, { resourceType: lab.mineralType });
                }
            }
        }
    }
    registerBoosterLabRequests(labs) {
        for (const lab of labs) {
            const { mineralType, amount } = this.labReservations[lab.id];
            // Empty out incorrect minerals
            if (lab.mineralType != mineralType && lab.mineralAmount > 0) {
                this.transportRequests.requestOutput(lab, Priority.High, {
                    resourceType: lab.mineralType,
                });
            }
            else {
                this.transportRequests.requestInput(lab, Priority.High, {
                    resourceType: mineralType,
                    amount: amount - lab.mineralAmount,
                });
            }
        }
    }
    registerRequests() {
        // Don't care about labs if you can't spawn any creeps!
        if (this.colony.state.bootstrapping) {
            return;
        }
        // Separate product labs into actively boosting or ready for reaction
        const [boostingProductLabs, reactionProductLabs] = _.partition(this.productLabs, (lab) => this.labReservations[lab.id]);
        // Handle energy requests for labs with different priorities
        const boostingRefillLabs = _.filter(boostingProductLabs, (lab) => lab.energy < lab.energyCapacity);
        _.forEach(boostingRefillLabs, (lab) => this.transportRequests.requestInput(lab, Priority.High));
        const reactionRefillLabs = _.filter(reactionProductLabs, (lab) => lab.energy < lab.energyCapacity);
        _.forEach(reactionRefillLabs, (lab) => this.transportRequests.requestInput(lab, Priority.NormalLow));
        const reagentRefillLabs = _.filter(this.reagentLabs, (lab) => lab.energy < lab.energyCapacity);
        _.forEach(reagentRefillLabs, (lab) => this.transportRequests.requestInput(lab, Priority.NormalLow));
        // Request resources delivered to / withdrawn from each type of lab
        this.registerReagentLabRequests(this.reagentLabs);
        this.registerProductLabRequests(reactionProductLabs);
        this.registerBoosterLabRequests(boostingProductLabs);
    }
    // Lab mineral reservations ========================================================================================
    /* Reserves a product lab for boosting with a compound unrelated to production */
    reserveLab(lab, resourceType, amount) {
        // _.remove(this.productLabs, productLab => productLab.id == lab.id); // This gets excluded in registerRequests
        this.labReservations[lab.id] = {
            mineralType: resourceType,
            amount: Math.min(amount, LAB_MINERAL_CAPACITY),
        };
    }
    /* Return the amount of a given resource necessary to fully boost a creep body */
    static requiredBoostAmount(body, boostType) {
        const existingBoostCounts = _.countBy(body, (part) => part.boost);
        const numPartsToBeBoosted = _.filter(body, (part) => part.type == BOOST_PARTS[boostType]).length;
        return (LAB_BOOST_MINERAL *
            (numPartsToBeBoosted - (existingBoostCounts[boostType] || 0)));
    }
    /**
     * Returns the best boost of a given type (e.g. "tough") that the room can acquire a specified amount of
     */
    bestBoostAvailable(boostType, amount) {
        if (PHASE != "run") {
            log.trace(new Error(`EvolutionChamber.bestBoostAvailable() must be called in the run() phase!`));
        }
        const boosts = BOOST_TIERS[boostType];
        for (const boost of [boosts.T3, boosts.T2, boosts.T1]) {
            if (this.colony.assets[boost] >= amount) {
                return boost;
            }
            else if (this.terminalNetwork.canObtainResource(this.colony, boost, amount)) {
                return boost;
            }
        }
        // If we get to here there's no available boosts of this type
        return undefined;
    }
    /* Request boosts sufficient to fully boost a given creep to be added to the boosting queue */
    requestBoosts(boosts) {
        // Add the required amount to the neededBoosts
        this.debug(`${JSON.stringify(boosts)} boosts requested!`);
        for (const boostResource in boosts) {
            const boostAmount = boosts[boostResource];
            // Here this.neededBoosts is describing what we want, not what we are going to load into labs, so it's okay
            // (and in fact better) to allow this to exceed LAB_MINERAL_CAPACITY so that terminalNetwork knows we
            // want a lot of this
            this.neededBoosts[boostResource] =
                (this.neededBoosts[boostResource] || 0) + boostAmount;
        }
    }
    lockLabFromTerminalNetwork(lab) {
        if (lab.mineralType && lab.store[lab.mineralType]) {
            this.terminalNetwork.lockResource(this.colony, lab.mineralType, lab.store[lab.mineralType]);
        }
    }
    // Initialization and operation ====================================================================================
    init() {
        // This gets called after every Overlord.init() so you should have all your boost requests in already
        // Set boosting lab reservations and compute needed resources; needs to be done BEFORE initLabStatus()!
        for (const boost in this.neededBoosts) {
            if (this.neededBoosts[boost] == 0) {
                continue;
            }
            let boostLab;
            for (const id in this.labReservations) {
                // find a lab already reserved for this mineral type
                if (this.labReservations[id] &&
                    this.labReservations[id].mineralType == boost) {
                    boostLab = deref(id);
                }
            }
            if (!boostLab) {
                // otherwise choose the first unreserved product lab
                boostLab = _.find(this.boostingLabs, (lab) => !this.labReservations[lab.id]);
            }
            if (boostLab) {
                this.reserveLab(boostLab, boost, this.neededBoosts[boost]);
            }
        }
        // Update the evo chamber status
        this.initLabStatus();
        // Register local transport requests
        this.registerRequests();
        // Request resources for boosting and lock them once you have them
        for (const boost in this.neededBoosts) {
            const product = this.memory.activeReaction ?
                this.memory.activeReaction.mineralType
                : undefined;
            const reagents = this.memory.activeReaction ?
                REAGENTS[this.memory.activeReaction.mineralType]
                : [undefined, undefined];
            let amountUnavailable = 0;
            if (boost == product) {
                _.forEach(this.productLabs, (lab) => {
                    if (lab.mineralType == boost &&
                        (!this.labReservations[lab.id] ||
                            this.labReservations[lab.id].mineralType != boost)) {
                        amountUnavailable += lab.mineralAmount;
                    }
                });
            }
            else if (boost == reagents[0]) {
                _.forEach(this.reagentLabs, (lab) => {
                    if (lab.mineralType == boost &&
                        (!this.labReservations[lab.id] ||
                            this.labReservations[lab.id].mineralType != boost)) {
                        amountUnavailable += lab.mineralAmount;
                    }
                });
            }
            else if (boost == reagents[1]) {
                _.forEach(this.reagentLabs, (lab) => {
                    if (lab.mineralType == boost &&
                        (!this.labReservations[lab.id] ||
                            this.labReservations[lab.id].mineralType != boost)) {
                        amountUnavailable += lab.mineralAmount;
                    }
                });
            }
            const amountNeeded = this.neededBoosts[boost] + amountUnavailable;
            if (amountNeeded > this.colony.assets[boost]) {
                this.debug(`Requesting boost from terminal network: ${this.neededBoosts[boost]} ${boost}`);
                this.terminalNetwork.requestResource(this.colony, boost, amountNeeded);
            }
            else {
                this.debug(`Locking boost from terminal network: ${this.neededBoosts[boost]} ${boost}`);
                this.terminalNetwork.lockResource(this.colony, boost, amountNeeded);
            }
        }
        // Request or lock resources from the terminal network
        if (this.memory.activeReaction) {
            const amount = this.memory.activeReaction.amount;
            const product = this.memory.activeReaction.mineralType;
            const reagents = REAGENTS[this.memory.activeReaction.mineralType];
            // Lock resources that are currently being used or produced
            switch (this.memory.status) {
                case LabStatus.Idle:
                    break;
                case LabStatus.AcquiringMinerals:
                    _.forEach(reagents, (reagent) => {
                        if (this.colony.assets[reagent] < amount) {
                            this.terminalNetwork.requestResource(this.colony, reagent, amount);
                        }
                        else {
                            this.terminalNetwork.lockResource(this.colony, reagent, amount);
                        }
                    });
                    break;
                case LabStatus.LoadingLabs:
                    _.forEach(reagents, (reagent) => this.terminalNetwork.lockResource(this.colony, reagent, amount));
                    break;
                case LabStatus.Synthesizing:
                    _.forEach(this.reagentLabs, (lab) => {
                        if (lab.mineralType == reagents[0] ||
                            lab.mineralType == reagents[1]) {
                            this.lockLabFromTerminalNetwork(lab);
                        }
                    });
                    _.forEach(this.productLabs, (lab) => {
                        if (lab.mineralType == product) {
                            this.lockLabFromTerminalNetwork(lab);
                        }
                    });
                    break;
                case LabStatus.UnloadingLabs:
                    _.forEach(this.labs, (lab) => {
                        if (lab.mineralType == product ||
                            lab.mineralType == reagents[0] ||
                            lab.mineralType == reagents[1]) {
                            this.lockLabFromTerminalNetwork(lab);
                        }
                    });
                    break;
            }
        }
    }
    run() {
        if (this.memory.suspendReactionsUntil &&
            Game.time > this.memory.suspendReactionsUntil) {
            delete this.memory.suspendReactionsUntil;
        }
        // Get an active reaction if you don't have one
        if (!this.memory.activeReaction && !this.memory.suspendReactionsUntil) {
            const nextReaction = Abathur$1.getNextReaction(this.colony);
            // There's a 1 tick delay between generating the reaction and being able to request the resources from
            // the terminal network. The reason for this is that this needs to be placed in the run() phase because
            // Abathur.getNextReaction() calls TerminalNetwork.canObtainResource(), which requires that knowledge of
            // the colony request states have already been registered in the init() phase. In any case, this adds an
            // inefficiency of like 1 tick in ~6000 for a T3 compound, so you can just deal with it. :P
            if (nextReaction) {
                this.memory.activeReaction = nextReaction;
            }
            else {
                const sleepTime = EvolutionChamber_1.settings.sleepTime + randint(0, 20);
                log.info(`${this.print}: no reaction available; sleeping for ${sleepTime} ticks.`);
                this.memory.suspendReactionsUntil = Game.time + sleepTime;
            }
        }
        // Run the reactions
        if (this.memory.status == LabStatus.Synthesizing) {
            const [lab1, lab2] = this.reagentLabs;
            for (const lab of this.productLabs) {
                if (lab.cooldown == 0 && !this.labReservations[lab.id]) {
                    const result = lab.runReaction(lab1, lab2);
                    if (result == OK) {
                        // update total production amount in memory
                        const product = this.memory.activeReaction ?
                            this.memory.activeReaction.mineralType
                            : "ERROR";
                        if (!this.memory.stats.totalProduction[product]) {
                            this.memory.stats.totalProduction[product] = 0;
                        }
                        this.memory.stats.totalProduction[product] +=
                            LAB_REACTION_AMOUNT;
                    }
                    else {
                        log.warning(`${this.print}: couldn't run reaction for lab @ ${lab.pos.print}! (${errorForCode(result)})`);
                    }
                }
            }
        }
        // Record stats
        this.stats();
    }
    drawLabReport(coord) {
        let { x, y } = coord;
        const height = 2;
        const titleCoords = Visualizer.section(`${this.colony.name} Evolution Chamber`, { x, y, roomName: this.room.name }, 9.5, height + 0.1);
        const boxX = titleCoords.x;
        y = titleCoords.y + 0.25;
        let status;
        switch (this.memory.status) {
            case LabStatus.Idle:
                status = "IDLE";
                break;
            case LabStatus.AcquiringMinerals:
                status = "acquire minerals";
                break;
            case LabStatus.LoadingLabs:
                status = "loading labs";
                break;
            case LabStatus.Synthesizing:
                status = "synthesizing";
                break;
            case LabStatus.UnloadingLabs:
                status = "unloading labs";
                break;
            default:
                status = "INVALID";
                break;
        }
        const activeReaction = this.memory.activeReaction;
        const mineral = activeReaction ? activeReaction.mineralType : "NONE";
        Visualizer.text(`Status: ${status}`, {
            x: boxX,
            y: y,
            roomName: this.room.name,
        });
        y += 1;
        if (this.memory.status == LabStatus.Synthesizing && activeReaction) {
            const amountDone = _.sum(_.map(this.productLabs, (lab) => lab.mineralType == activeReaction.mineralType ?
                lab.mineralAmount
                : 0));
            Visualizer.text(activeReaction.mineralType, {
                x: boxX,
                y: y,
                roomName: this.room.name,
            });
            Visualizer.barGraph([amountDone, activeReaction.amount], { x: boxX + 4, y: y, roomName: this.room.name }, 5);
            y += 1;
        }
        else {
            Visualizer.text(`Active reaction: ${mineral}`, {
                x: boxX,
                y: y,
                roomName: this.room.name,
            });
            y += 1;
        }
        return { x: x, y: y + 0.25 };
    }
    visuals(coord) {
        const vis = this.room.visual;
        // Lab visuals
        for (const lab of this.labs) {
            if (lab.mineralType) {
                vis.resource(lab.mineralType, lab.pos.x, lab.pos.y);
            }
        }
        // Draw lab report
        return this.drawLabReport(coord);
    }
    stats() {
        const labUsage = _.sum(this.productLabs, (lab) => (lab.cooldown > 0 ? 1 : 0)) /
            this.productLabs.length;
        this.memory.stats.avgUsage = ema(labUsage, this.memory.stats.avgUsage, LAB_USAGE_WINDOW);
        Stats.log(`colonies.${this.colony.name}.evolutionChamber.avgUsage`, this.memory.stats.avgUsage);
    }
};
EvolutionChamber.settings = {
    sleepTime: 100,
};
EvolutionChamber = EvolutionChamber_1 = __decorate$1([
    profile
], EvolutionChamber);

/**
 * Spawns a dedicated hatchery attendant to refill spawns and extensions
 */
let QueenOverlord = class QueenOverlord extends Overlord {
    constructor(hatchery, priority = OverlordPriority.core.queen) {
        super(hatchery, "queen", priority);
        this.hatchery = hatchery;
        this.queenSetup =
            this.colony.storage && !this.colony.state.isRebuilding ?
                Setups.queens.default
                : Setups.queens.early;
        this.queens = this.zerg(Roles.queen);
        this.settings = {
            refillTowersBelow: 500,
        };
    }
    init() {
        const amount = 1;
        const prespawn = this.hatchery.spawns.length <= 1 ? 100 : DEFAULT_PRESPAWN;
        this.wishlist(amount, this.queenSetup, { prespawn: prespawn });
    }
    supplyActions(queen) {
        // Select the closest supply target out of the highest priority and refill it
        const request = this.hatchery.transportRequests.getPrioritizedClosestRequest(queen.pos, "supply");
        if (request) {
            this.debug(`${queen.print} transferring from ${request.target.structureType}@${request.target.pos}`);
            queen.task = Tasks$1.transfer(request.target);
        }
        else {
            this.rechargeActions(queen); // if there are no targets, refill yourself
        }
    }
    rechargeActions(queen) {
        if (this.hatchery.link && !this.hatchery.link.isEmpty) {
            this.debug(`${queen.print} recharging from link`);
            queen.task = Tasks$1.withdraw(this.hatchery.link);
        }
        else if (this.hatchery.batteries.length &&
            this.hatchery.batteries[0].energy > 0) {
            this.debug(`${queen.print} recharging from battery`);
            queen.task = Tasks$1.withdraw(this.hatchery.batteries[0]);
        }
        else {
            this.debug(`${queen.print} recharging`);
            queen.task = Tasks$1.recharge();
        }
    }
    idleActions(queen) {
        if (this.hatchery.link) {
            // Can energy be moved from the link to the battery?
            if (this.hatchery.batteries.length &&
                !this.hatchery.batteries[0].isFull &&
                !this.hatchery.link.isEmpty) {
                // Move energy to battery as needed
                if (queen.store.energy < queen.store.getCapacity()) {
                    queen.task = Tasks$1.withdraw(this.hatchery.link);
                }
                else {
                    queen.task = Tasks$1.transfer(this.hatchery.batteries[0]);
                }
            }
            else {
                if (queen.store.energy < queen.store.getCapacity()) {
                    // make sure you're recharged
                    if (!this.hatchery.link.isEmpty) {
                        queen.task = Tasks$1.withdraw(this.hatchery.link);
                    }
                    else if (this.hatchery.batteries.length &&
                        !this.hatchery.batteries[0].isEmpty) {
                        queen.task = Tasks$1.withdraw(this.hatchery.batteries[0]);
                    }
                }
            }
        }
        else {
            if (this.hatchery.batteries.length &&
                queen.store.energy < queen.store.getCapacity()) {
                queen.task = Tasks$1.withdraw(this.hatchery.batteries[0]);
            }
        }
    }
    handleQueen(queen) {
        if (queen.store.energy > 0) {
            this.supplyActions(queen);
        }
        else {
            this.rechargeActions(queen);
        }
        this.debug(`${queen.print}: isIdle? ${queen.isIdle}, ${queen.task ? queen.task.name : null}`);
        // If there aren't any tasks that need to be done, recharge the battery from link
        if (queen.isIdle) {
            this.idleActions(queen);
        }
        // If all of the above is done and hatchery is not in emergencyMode, move to the idle point and renew as needed
        // if (!this.emergencyMode && queen.isIdle) {
        // 	if (queen.pos.isEqualTo(this.idlePos)) {
        // 		// If queen is at idle position, renew her as needed
        // 		if (queen.ticksToLive < this.settings.renewQueenAt && this.availableSpawns.length > 0) {
        // 			this.availableSpawns[0].renewCreep(queen.creep);
        // 		}
        // 	} else {
        // 		// Otherwise, travel back to idle position
        // 		queen.goTo(this.idlePos);
        // 	}
        // }
    }
    run() {
        for (const queen of this.queens) {
            // Get a task
            this.handleQueen(queen);
            // Run the task if you have one; else move back to idle pos
            if (queen.hasValidTask) {
                queen.run();
            }
            else {
                this.debug(`${queen.print} going back to idling`);
                if (this.queens.length > 1) {
                    queen.goTo(this.hatchery.idlePos, { range: 1 });
                }
                else {
                    queen.goTo(this.hatchery.idlePos);
                }
            }
        }
    }
};
QueenOverlord = __decorate$1([
    profile
], QueenOverlord);

function isSupplyStructure(structure) {
    return (structure.structureType == STRUCTURE_EXTENSION ||
        structure.structureType == STRUCTURE_LAB ||
        structure.structureType == STRUCTURE_TOWER ||
        structure.structureType == STRUCTURE_SPAWN);
}
function computeQuadrant(colony, quadrant) {
    const positions = _.map(quadrant, (coord) => getPosFromBunkerCoord(coord, colony));
    const structures = [];
    for (const pos of positions) {
        const structure = (_.find(pos.lookFor(LOOK_STRUCTURES), (s) => isSupplyStructure(s)));
        if (structure) {
            structures.push(structure);
        }
    }
    return structures;
}
/**
 * A modified version of the queen overlord which contains a number of hard-coded optimization for bunker-type rooms.
 * This overlord supercedes the default queen overlord once the colony has a storage with a minimum amount of energy.
 */
let BunkerQueenOverlord = class BunkerQueenOverlord extends Overlord {
    static canFunction(colony) {
        return (colony.layout === "bunker" &&
            insideBunkerBounds(colony.spawns[0].pos, colony) &&
            (!!colony.storage || !!colony.terminal));
    }
    constructor(hatchery, priority = OverlordPriority.core.queen) {
        super(hatchery, "bunker_queen", priority);
        this.queenSetup = Setups.queens.default;
        this.queens = this.zerg(Roles.queen);
        this.batteries = _.filter(this.room.containers, (container) => insideBunkerBounds(container.pos, this.colony));
        this.links = _.filter(this.room.links, (link) => insideBunkerBounds(link.pos, this.colony));
        this.storeStructures = _.compact([
            this.colony.terminal,
            this.colony.storage,
            ...this.batteries,
            ...this.links,
        ]);
        this.structureQuadrantMapping = {};
        this.quadrants = {
            lowerRight: $.structures(this, "LR", () => computeQuadrant(this.colony, quadrantFillOrder.lowerRight)),
            upperLeft: $.structures(this, "UL", () => computeQuadrant(this.colony, quadrantFillOrder.upperLeft)),
            lowerLeft: $.structures(this, "LL", () => computeQuadrant(this.colony, quadrantFillOrder.lowerLeft)),
            upperRight: $.structures(this, "UR", () => computeQuadrant(this.colony, quadrantFillOrder.upperRight)),
        };
        this.computeQueenAssignments();
        this.computeStructureQuadrantMapping();
    }
    computeStructureQuadrantMapping() {
        var _a, _b;
        for (const structure of (_b = (_a = this.colony.hatchery) === null || _a === void 0 ? void 0 : _a.energyStructures) !== null && _b !== void 0 ? _b : []) {
            const quad = Object.entries(this.quadrants).find(([_q, s]) => s.some((struct) => struct.id === structure.id));
            if (!quad) {
                log.warning(`${this.print}: structure ${structure.print} not in any quadrant!`);
                continue;
            }
            this.structureQuadrantMapping[structure.id] = quad[0];
        }
    }
    computeQueenAssignments() {
        let bunkerChargingPositions = _.flatten(bunkerChargingSpots.map((coord) => getPosFromBunkerCoord(coord, this.colony).availableNeighbors(true)));
        this.assignments = _.zipObject(_.map(this.queens, (queen) => [queen.name, {}]));
        const activeQueens = _.filter(this.queens, (queen) => !queen.spawning);
        this.numActiveQueens = activeQueens.length;
        // Reset idle positions
        this.queens.forEach((q) => delete q.memory.data.idlePos);
        // Assign quadrants to queens
        if (this.numActiveQueens > 0) {
            const quadrantAssignmentOrder = [
                this.quadrants.lowerRight,
                this.quadrants.upperLeft,
                this.quadrants.lowerLeft,
                this.quadrants.upperRight,
            ];
            let i = 0;
            for (const quadrant of quadrantAssignmentOrder) {
                const queen = activeQueens[i % activeQueens.length];
                _.extend(this.assignments[queen.name], _.zipObject(_.map(quadrant, (s) => [s.id, true])));
                if (quadrant[0]) {
                    const chargingSpot = quadrant[0].pos.findClosestByLimitedRange(bunkerChargingPositions, 10);
                    if (chargingSpot) {
                        bunkerChargingPositions =
                            bunkerChargingPositions.filter((pos) => !pos.isEqualTo(chargingSpot.x, chargingSpot.y));
                        queen.memory.data.idlePos = chargingSpot.toCoord();
                    }
                }
                i++;
            }
        }
    }
    refresh() {
        super.refresh();
        $.refresh(this, "batteries", "storeStructures");
        $.refreshObject(this, "quadrants");
        // Re-compute queen assignments if the number of queens has changed
        if (_.filter(this.queens, (queen) => !queen.spawning).length !=
            this.numActiveQueens) {
            this.computeQueenAssignments();
        }
    }
    init() {
        for (const battery of this.batteries) {
            if (hasMinerals(battery.store)) {
                // get rid of any minerals in the container if present
                this.colony.logisticsNetwork.requestOutputMinerals(battery);
            }
        }
        // const amount = this.colony.spawns.length > 1 ? 2 : 1;
        const amount = this.colony.room.energyCapacityAvailable > 2000 ? 2 : 1;
        this.wishlist(amount, this.queenSetup);
    }
    getStructureQuadrant(structure) {
        return this.structureQuadrantMapping[structure.id];
    }
    // Builds a series of tasks to empty unnecessary carry contents, withdraw required resources, and supply structures
    buildSupplyTaskManifest(queen) {
        var _a;
        this.debug(`${queen.print} generating supply tasks`);
        let tasks = [];
        // Step 1: figure out which requests we can supply
        const queenCarry = {};
        const allStore = mergeSum(..._.map(this.storeStructures, (s) => s.store));
        const supplyRequests = [];
        let firstQuadrant;
        for (const priority in this.colony.transportRequests.supply) {
            for (const request of this.colony.transportRequests.supply[priority]) {
                // Check if queen is assigned to this quadrant
                if (!this.assignments[queen.name][request.target.id]) {
                    this.debug(`${queen.print} not assigned there, ignoring`);
                    continue;
                }
                // Check that the requests stay in the same quadrant
                if (!firstQuadrant) {
                    firstQuadrant = this.getStructureQuadrant(request.target);
                    this.debug(`${queen.print} first quadrant is ${firstQuadrant}`);
                }
                else if (firstQuadrant !== this.getStructureQuadrant(request.target)) {
                    this.debug(`${queen.print} quadrant mismatch: ` +
                        `${firstQuadrant} !== ${this.getStructureQuadrant(request.target)}`);
                    continue;
                }
                supplyRequests.push(request);
            }
        }
        this.debug(() => `${queen.print} ${supplyRequests.length} requests to fulfill: \n` +
            columnify$1(supplyRequests));
        // Step 2: calculate the total amount of needed resources to supply
        const supplyTasks = [];
        for (const request of supplyRequests) {
            // stop when carry will be full
            const remainingAmount = queen.store.getCapacity() - _.sum(queenCarry);
            if (remainingAmount == 0) {
                break;
            }
            // figure out how much you can withdraw
            let amount = Math.min(request.amount, remainingAmount, (_a = allStore[request.resourceType]) !== null && _a !== void 0 ? _a : 0);
            if (amount == 0) {
                continue;
            }
            // update the simulated carry
            if (!queenCarry[request.resourceType]) {
                queenCarry[request.resourceType] = 0;
            }
            queenCarry[request.resourceType] += amount;
            // handle spawns natural regen
            if (request.target instanceof StructureSpawn &&
                amount == request.amount) {
                amount = undefined;
            }
            // add a task to supply the target
            supplyTasks.push(Tasks$1.transfer(request.target, request.resourceType, amount));
        }
        // Step 3: account for what we're carrying already and store the excess back
        let queenPos = queen.pos;
        if (queen.store.getUsedCapacity() > 0) {
            this.debug(`${queen.print} not empty, checking for overfill`);
            const overfillTargets = _.sortBy(_.compact([
                this.colony.terminal,
                this.colony.storage,
                ...this.batteries,
            ]), (target) => Pathing.distance(queenPos, target.pos) || Infinity);
            for (const [res] of queen.store.contents) {
                const exceedAmount = queen.store.getUsedCapacity(res) - (queenCarry[res] || 0);
                if (exceedAmount < 0) {
                    queenCarry[res] = -exceedAmount;
                    continue;
                }
                const target = overfillTargets.find((t) => t.store.getFreeCapacity(res) >= exceedAmount);
                if (!target) {
                    log.warning(`No transfer targets for ${queen.print}!`);
                    return null;
                }
                this.debug(`${queen.print} carrying excess ${res}, dropping off at ${target.print}`);
                tasks.push(Tasks$1.transfer(target, res, exceedAmount));
                queenPos = target.pos;
            }
        }
        // Step 4: make withdraw tasks to get the needed resources
        const withdrawTasks = [];
        const neededResources = _.keys(queenCarry);
        const targets = _.filter(this.storeStructures, (s) => _.all(neededResources, (resource) => (s.store[resource] || 0) >= (queenCarry[resource] || 0)));
        const withdrawTarget = minBy(targets, (target) => Pathing.distance(queenPos, target.pos) || Infinity);
        if (withdrawTarget) {
            for (const resourceType of neededResources) {
                this.debug(`${queen.print} ${withdrawTarget.print} contains more than needed ` +
                    `(${queenCarry[resourceType]})`);
                withdrawTasks.push(Tasks$1.withdraw(withdrawTarget, resourceType, queenCarry[resourceType]));
            }
        }
        else {
            const closestTarget = minBy(this.storeStructures, (target) => Pathing.distance(queenPos, target.pos) || Infinity);
            if (!closestTarget) {
                log.error(`Can't seem to find any pathable store structures in ${this.colony.print}`);
            }
            else {
                for (const resourceType of neededResources) {
                    if (closestTarget.store[resourceType] >=
                        queenCarry[resourceType]) {
                        this.debug(`${queen.print} ${closestTarget.print} contains more than needed ` +
                            `(${queenCarry[resourceType]})`);
                        withdrawTasks.push(Tasks$1.withdraw(closestTarget, resourceType, queenCarry[resourceType]));
                    }
                    else {
                        // TODO ordering tasks for fastest route, maybe a sortby for withdraw targets?
                        const hasResource = _.sortBy(_.filter(this.storeStructures, (s) => s.store[resourceType] > 0), (s) => -s.store[resourceType]); // descending sort
                        let collected = 0;
                        for (const storeLoc of hasResource) {
                            // Might be bug in overwithdrawing
                            this.debug(`${queen.print} ${storeLoc.print} has only ${storeLoc.store[resourceType]}`);
                            withdrawTasks.push(Tasks$1.withdraw(storeLoc, resourceType, Math.min(queenCarry[resourceType] - collected, storeLoc.store[resourceType])));
                            collected += storeLoc.store[resourceType];
                            if (collected >= queenCarry[resourceType]) {
                                break;
                            }
                        }
                    }
                }
            }
        }
        if (!withdrawTarget && withdrawTasks.length == 0) {
            log.warning(`Could not find adequate withdraw structure for ${queen.print}! ` +
                `(neededResources: ${neededResources}, queenCarry: ${JSON.stringify(queenCarry)})`);
            return null;
        }
        // Step 4: put all the tasks in the correct order, set nextPos for each, and chain them together
        tasks = tasks.concat(withdrawTasks, supplyTasks);
        this.debug(`${queen.print} complete supply task manifest:\n` +
            columnify$1(tasks.map((t) => {
                return {
                    name: t.name,
                    target: t.target.print,
                    resource: t.data.resourceType,
                    amount: t.data.amount,
                };
            })));
        return Tasks$1.chain(tasks);
    }
    // Builds a series of tasks to withdraw required resources from targets
    buildWithdrawTaskManifest(queen) {
        const tasks = [];
        const transferTarget = this.colony.terminal || this.colony.storage || this.batteries[0];
        // Step 1: empty all contents (this shouldn't be necessary since queen is normally empty at this point)
        if (queen.store.getUsedCapacity() > 0) {
            if (transferTarget) {
                tasks.push(Tasks$1.transferAll(transferTarget));
            }
            else {
                log.warning(`No transfer targets for ${queen.print}!`);
                return null;
            }
        }
        // Step 2: figure out what you need to withdraw from
        const queenCarry = { energy: 0 };
        // let allWithdrawRequests = _.compact(_.flatten(_.map(this.assignments[queen.name],
        // 													struc => this.transportRequests.withdrawByID[struc.id])));
        const withdrawRequests = [];
        for (const priority in this.colony.transportRequests.withdraw) {
            for (const request of this.colony.transportRequests.withdraw[priority]) {
                if (this.assignments[queen.name][request.target.id]) {
                    withdrawRequests.push(request);
                }
            }
        }
        for (const request of withdrawRequests) {
            // stop when carry will be full
            const remainingAmount = queen.store.getCapacity() - _.sum(queenCarry);
            if (remainingAmount == 0) {
                break;
            }
            // figure out how much you can withdraw
            const amount = Math.min(request.amount, remainingAmount);
            if (amount == 0) {
                continue;
            }
            // update the simulated carry
            if (!queenCarry[request.resourceType]) {
                queenCarry[request.resourceType] = 0;
            }
            queenCarry[request.resourceType] += amount;
            // add a task to supply the target
            tasks.push(Tasks$1.withdraw(request.target, request.resourceType, amount));
        }
        // Step 3: put stuff in terminal/storage
        if (transferTarget) {
            tasks.push(Tasks$1.transferAll(transferTarget));
        }
        else {
            log.warning(`No transfer targets for ${queen.print}!`);
            return null;
        }
        // Step 4: return chained task manifest
        return Tasks$1.chain(tasks);
    }
    // private getChargingSpot(queen: Zerg): RoomPosition {
    // 	let chargeSpots = _.map(bunkerChargingSpots, coord => getPosFromBunkerCoord(coord, this.colony));
    // 	let chargeSpot = (_.first(this.assignments[queen.name]) || queen).pos.findClosestByRange(chargeSpots);
    // 	if (chargeSpot) {
    // 		return chargeSpot;
    // 	} else {
    // 		log.warning(`Could not determine charging spot for queen at ${queen.pos.print}!`);
    // 		return queen.pos;
    // 	}
    // }
    //
    // private idleActions(queen: Zerg): void {
    //
    // 	// // Refill any empty batteries
    // 	// for (let battery of this.batteries) {
    // 	// 	if (!battery.isFull) {
    // 	// 		let amount = Math.min(battery.storeCapacity - _.sum(battery.store), queen.carryCapacity);
    // 	// 		let target = this.colony.storage || this.colony.storage;
    // 	// 		if (target) {
    // 	// 			queen.task = Tasks.transfer(battery, RESOURCE_ENERGY, amount)
    // 	// 							  .fork(Tasks.withdraw(target, RESOURCE_ENERGY, amount))
    // 	// 			return;
    // 	// 		}
    // 	// 	}
    // 	// }
    //
    // 	// Go to recharging spot and get recharged
    // 	let chargingSpot = this.getChargingSpot(queen);
    // 	queen.goTo(chargingSpot, {range: 0});
    // 	// // TODO: this will cause oscillating behavior where recharge drains some energy and queen leaves to supply it
    // 	// if (queen.pos.getRangeTo(chargingSpot) == 0) {
    // 	// 	let chargingSpawn = _.first(queen.pos.findInRange(this.colony.spawns, 1));
    // 	// 	if (chargingSpawn && !chargingSpawn.spawning) {
    // 	// 		chargingSpawn.renewCreep(queen.creep);
    // 	// 	}
    // 	// }
    // }
    handleQueen(queen) {
        var _a, _b;
        if (this.colony.transportRequests.needsWithdrawing() &&
            _.any(_.keys(this.assignments[queen.name]), (id) => this.colony.transportRequests.withdrawByID[id])) {
            // Does something need withdrawing?
            this.debug(`${queen.print}: should withdraw`);
            queen.task = this.buildWithdrawTaskManifest(queen);
        }
        else if (this.colony.transportRequests.needsSupplying() &&
            _.any(_.keys(this.assignments[queen.name]), (id) => this.colony.transportRequests.supplyByID[id])) {
            // Does something need supplying?
            this.debug(`${queen.print}: should supply`);
            queen.task = this.buildSupplyTaskManifest(queen);
        }
        else if (this.colony.level > 5 &&
            this.colony.controller.safeModeAvailable < 3 &&
            this.colony.terminal &&
            this.colony.terminal.store[RESOURCE_GHODIUM] >= 1000 &&
            queen.store.getCapacity() >= 1000) {
            // Do we need safemodes?
            this.debug(`${queen.print}: should safemode`);
            // Only use 1 queen to avoid adding 2 safemodes
            if (queen.name == _.first(_.sortBy(this.queens, (q) => q.name)).name) {
                queen.task = Tasks$1.chain([
                    Tasks$1.transferAll(this.colony.terminal),
                    Tasks$1.withdraw(this.colony.terminal, RESOURCE_GHODIUM, 1000),
                    Tasks$1.generateSafeMode(this.colony.controller),
                ]);
                log.alert(`${this.colony.print} has ${this.colony.controller.safeModeAvailable} safemodes available, ` +
                    `generating a new one`);
            }
        }
        // Otherwise do idle actions
        if (queen.isIdle) {
            if (queen.memory.data.idlePos) {
                const idlePos = new RoomPosition((_a = queen.memory.data.idlePos) === null || _a === void 0 ? void 0 : _a.x, (_b = queen.memory.data.idlePos) === null || _b === void 0 ? void 0 : _b.y, this.colony.room.name);
                if (!queen.pos.inRangeToPos(idlePos, 0)) {
                    // Move the queen manually so we stop idling as early as possible
                    queen.goTo(idlePos);
                }
                // log.debug(`${queen.print}: idling on ${idlePos.print}`);
            }
            // this.idleActions(queen);
            delete queen.memory._go;
        }
    }
    run() {
        this.autoRun(this.queens, (queen) => this.handleQueen(queen));
    }
};
BunkerQueenOverlord = __decorate$1([
    profile
], BunkerQueenOverlord);

const getDefaultHatcheryMemory = () => ({
    stats: {
        overload: 0,
        uptime: 0,
        longUptime: 0,
    },
});
/**
 * The hatchery encompasses all spawning-related structures, like spawns, extensions, and some energy buffer containers,
 * and contains logic for spawning the creeps requested by overlords
 */
let Hatchery = class Hatchery extends HiveCluster {
    constructor(colony, headSpawn) {
        super(colony, headSpawn, "hatchery");
        // Register structure components
        this.memory = Mem.wrap(this.colony.memory, "hatchery", getDefaultHatcheryMemory);
        if (this.colony.layout == "twoPart") {
            this.colony.markDestination(this.pos, -1);
        }
        this.spawns = colony.spawns;
        this.availableSpawns = _.filter(this.spawns, (spawn) => !spawn.spawning);
        this.extensions = colony.extensions;
        this.towers =
            colony.commandCenter ?
                _.difference(colony.towers, colony.commandCenter.towers)
                : colony.towers;
        if (this.colony.layout == "bunker") {
            this.batteries = _.filter(this.room.containers, (cont) => insideBunkerBounds(cont.pos, this.colony));
            $.set(this, "energyStructures", () => this.computeEnergyStructures());
        }
        else {
            this.link = this.pos.findClosestByLimitedRange(colony.availableLinks, 2);
            this.colony.linkNetwork.claimLink(this.link);
            this.batteries = [];
            const battery = this.pos.findClosestByLimitedRange(this.room.containers, 2);
            if (battery) {
                this.batteries.push(battery);
            }
            this.energyStructures = [].concat(this.spawns, this.extensions);
        }
        this.productionPriorities = [];
        this.productionQueue = {};
        this.isOverloaded = false;
        this._waitTimes = undefined;
        this.settings = {
            refillTowersBelow: 750,
            linksRequestEnergyBelow: 0,
            suppressSpawning: false,
        };
        this.transportRequests = colony.transportRequests; // hatchery always uses colony transport group
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, "hatchery", getDefaultHatcheryMemory);
        $.refreshRoom(this);
        $.refresh(this, "spawns", "extensions", "energyStructures", "link", "towers", "batteries");
        this.availableSpawns = _.filter(this.spawns, (spawn) => !spawn.spawning);
        this.productionPriorities = [];
        this.productionQueue = {};
        this._spawnRequests = undefined;
        this.isOverloaded = false;
        this._waitTimes = undefined;
    }
    spawnMoarOverlords() {
        const queens = this.colony.getZergByRole("queen");
        if (BunkerQueenOverlord.canFunction(this.colony)) {
            this.overlord = new BunkerQueenOverlord(this); // use bunker queen if has storage and enough energy
        }
        else {
            this.overlord = new QueenOverlord(this);
        }
        // Reassign queens to the correct overlord
        queens
            .filter((queen) => { var _a; return ((_a = queen.overlord) === null || _a === void 0 ? void 0 : _a.name) !== this.overlord.name; })
            .forEach((queen) => queen.reassign(this.overlord));
    }
    /**
     * Returns the approximate aggregated time at which the hatchery will next be available to spawn a creep request
     * with a given priority.
     */
    getWaitTimeForPriority(priority) {
        if (!this._waitTimes) {
            const waitTimes = {};
            // Initialize wait time to what is currently spawning
            let waitTime = _.sum(this.spawns, (spawn) => spawn.spawning ? spawn.spawning.remainingTime : 0) / this.spawns.length;
            // Add in expected time for whatever else needs to be spawned, cumulative up to each priority
            for (const priority of _.sortBy(this.productionPriorities)) {
                for (const request of this.productionQueue[priority]) {
                    // use cached setup as estimate
                    const { body, boosts: _boosts } = request.setup.create(this.colony, true);
                    waitTime +=
                        (CREEP_SPAWN_TIME * body.length) / this.spawns.length;
                }
                waitTimes[priority] = waitTime;
            }
            this._waitTimes = waitTimes;
        }
        if (this._waitTimes[priority] != undefined) {
            return this._waitTimes[priority];
        }
        const priorities = _.sortBy(this.productionPriorities);
        if (priorities.length == 0) {
            return 0;
        }
        if (priority < _.first(priorities)) {
            return 0;
        }
        // each slot represents time to spawn all of priority, so slot-1 puts you at the beginning of this new priority
        const priorityIndex = _.sortedIndex(priorities, priority) - 1;
        const waitTime = this._waitTimes[priorities[priorityIndex]];
        if (waitTime == undefined) {
            log.error(`${this.print}: Undefined wait time in wait times: ${this._waitTimes}!`);
            return 0;
        }
        return waitTime;
    }
    // Idle position for queen
    get idlePos() {
        var _a;
        if ((_a = this.batteries) === null || _a === void 0 ? void 0 : _a.length) {
            return _.first(this.batteries).pos;
        }
        else {
            return this.spawns[0].pos.availableNeighbors(true)[0];
        }
    }
    computeEnergyStructures() {
        if (this.colony.layout == "bunker") {
            const positions = _.map(energyStructureOrder, (coord) => getPosFromBunkerCoord(coord, this.colony));
            let spawnsAndExtensions = [];
            spawnsAndExtensions = spawnsAndExtensions.concat(this.spawns, this.extensions);
            const energyStructures = [];
            for (const pos of positions) {
                const structure = _.find(pos.lookFor(LOOK_STRUCTURES), (s) => s.structureType == STRUCTURE_SPAWN ||
                    s.structureType == STRUCTURE_EXTENSION);
                if (structure) {
                    energyStructures.push(_.remove(spawnsAndExtensions, (s) => s.id == structure.id)[0]);
                }
            }
            return _.compact(energyStructures.concat(spawnsAndExtensions));
        }
        else {
            // Ugly workaround to [].concat() throwing a temper tantrum
            let spawnsAndExtensions = [];
            spawnsAndExtensions = spawnsAndExtensions.concat(this.spawns, this.extensions);
            return _.sortBy(spawnsAndExtensions, (structure) => structure.pos.getRangeTo(this.idlePos));
        }
    }
    /* Request more energy when appropriate either via link or hauler */
    registerEnergyRequests() {
        // Register requests for input into the hatchery (goes on colony store group)
        if (this.link && this.link.isEmpty) {
            this.colony.linkNetwork.requestReceive(this.link);
        }
        if (this.batteries) {
            const threshold = this.colony.storage ? 0.5 : 0.75;
            for (const battery of this.batteries) {
                if (battery.store.getUsedCapacity() <
                    threshold * battery.store.getCapacity()) {
                    this.colony.logisticsNetwork.requestInput(battery, {
                        multiplier: 1.5,
                    });
                }
                // get rid of any minerals in the container if present
                if (hasMinerals(battery.store)) {
                    this.colony.logisticsNetwork.requestOutputMinerals(battery);
                }
            }
        }
        else {
            // We don't have the battery up yet, so we need to also ask for input from the logistic network
            // so that transporters participate as well
            _.forEach(this.energyStructures, (struct) => this.colony.logisticsNetwork.requestInput(struct, {
                multiplier: 1.5,
            }));
        }
        // Register energy transport requests (goes on hatchery store group, which can be colony store group)
        // let refillStructures = this.energyStructures;
        // if (this.colony.defcon > DEFCON.safe) {
        // 	for (let hostile of this.room.dangerousHostiles) {
        // 		// TODO: remove tranport requests if blocked by enemies
        // 	}
        // }
        // if (this.room.defcon > 0) {refillStructures = _.filter()}
        _.forEach(this.energyStructures, (struct) => this.transportRequests.requestInput(struct, Priority.Normal));
        // let refillSpawns = _.filter(this.spawns, spawn => spawn.energy < spawn.energyCapacity);
        // let refillExtensions = _.filter(this.extensions, extension => extension.energy < extension.energyCapacity);
        const refillTowers = _.filter(this.towers, (tower) => tower.energy < this.settings.refillTowersBelow);
        // _.forEach(refillSpawns, spawn => this.transportRequests.requestInput(spawn, Priority.NormalLow));
        // _.forEach(refillExtensions, extension => this.transportRequests.requestInput(extension, Priority.NormalLow));
        _.forEach(refillTowers, (tower) => this.transportRequests.requestInput(tower, Priority.NormalLow));
    }
    // Creep queueing and spawning =====================================================================================
    generateCreepName(roleName) {
        // Generate a creep name based on the role and add a suffix to make it unique
        let i = 0;
        while (Game.creeps[roleName + "_" + i]) {
            i++;
        }
        return roleName + "_" + i;
    }
    spawnCreep(protoCreep, options = {}) {
        // If you can't build it, return this error
        if (protoCreep.body.length === 0) {
            return ERR_INVALID_ARGS;
        }
        const availableEnergy = this.colony.state.bootstrapping ?
            _.sum(this.energyStructures, (s) => s.store.getUsedCapacity(RESOURCE_ENERGY))
            : this.room.energyCapacityAvailable;
        const creepCost = bodyCost(protoCreep.body);
        if (creepCost > availableEnergy) {
            return ERR_ROOM_ENERGY_CAPACITY_NOT_ENOUGH;
        }
        // Get a spawn to use
        let spawnToUse;
        if (options.spawn) {
            spawnToUse = options.spawn;
            if (spawnToUse.spawning) {
                return ERR_SPECIFIED_SPAWN_BUSY;
            }
            else {
                _.remove(this.availableSpawns, (spawn) => spawn.id == spawnToUse.id); // mark as used
            }
        }
        else {
            spawnToUse = this.availableSpawns.shift();
        }
        // If you have a spawn available then spawn the creep
        if (spawnToUse) {
            let directions = options.directions;
            // Safe-guard the specified direction
            if (directions &&
                !directions.reduce((cur, dir) => {
                    if (!cur) {
                        return null;
                    }
                    const pos = cur.getPositionAtDirection(dir);
                    return pos.isWalkable(true) ? pos : null;
                }, spawnToUse.pos)) {
                log.error(`${this.print}: spawning directions "${directions}" from ${spawnToUse.print} not walkable!`);
                directions = undefined;
            }
            if (this.colony.bunker &&
                this.colony.bunker.coreSpawn &&
                spawnToUse.id == this.colony.bunker.coreSpawn.id &&
                !options.directions) {
                // don't spawn into the manager spot
                this.debug(`no directions, and spawn is core spawn, side-stepping center spot`);
                directions = [TOP, RIGHT];
            }
            // modify the creep name to make it unique
            protoCreep.name = this.generateCreepName(protoCreep.name);
            protoCreep.memory.data.origin = spawnToUse.pos.roomName;
            // Spawn the creep
            const result = spawnToUse.spawnCreep(protoCreep.body, protoCreep.name, {
                memory: protoCreep.memory,
                energyStructures: this.energyStructures,
                directions: directions,
            });
            if (result == OK) {
                this.colony.trackEnergyUse(EnergyUse.SPAWN, -creepCost);
                // Creep has been successfully spawned; add cost into profiling
                const overlordRef = protoCreep.memory["O" /* MEM.OVERLORD */];
                const overlord = overlordRef ? Overmind.overlords[overlordRef] : null;
                if (overlord) {
                    overlord.debug(`${this.print} successfully spawned creep ${protoCreep.name} for ${overlord === null || overlord === void 0 ? void 0 : overlord.print}`);
                    if (overlord.memory["S" /* MEM.STATS */]) {
                        overlord.memory["S" /* MEM.STATS */].spawnCost += bodyCost(protoCreep.body);
                    }
                }
                else {
                    // This shouldn't ever happen
                    log.error(`No overlord for protocreep ${protoCreep.name} at hatchery ${this.print}!`);
                }
                return result;
            }
            else {
                this.availableSpawns.unshift(spawnToUse); // return the spawn to the available spawns list
                return result;
            }
        }
        else {
            // otherwise, if there's no spawn to use, return busy
            return ERR_BUSY;
        }
    }
    canSpawn(body) {
        return bodyCost(body) <= this.room.energyCapacityAvailable;
    }
    canSpawnZerg(zerg) {
        return this.canSpawn(_.map(zerg.body, (part) => part.type));
    }
    /* Generate (but not spawn) the largest creep possible, returns the protoCreep as an object */
    generateProtoCreep(setup, overlord) {
        // Generate the creep memory
        const creepMemory = {
            ["C" /* MEM.COLONY */]: overlord.colony.name, // name of the colony the creep is assigned to
            ["O" /* MEM.OVERLORD */]: overlord.ref, // name of the Overlord running this creep
            role: setup.role, // role of the creep
            task: null, // task the creep is performing
            data: {
                // rarely-changed data about the creep
                origin: "", // where it was spawned, filled in at spawn time
            },
        };
        // Generate the creep body
        const { body, boosts } = setup.create(this.colony);
        if (boosts.length > 0) {
            creepMemory.needBoosts = boosts; // tell the creep what boosts it will need to get
        }
        // Create the protocreep and return it
        const protoCreep = {
            // object to add to spawner queue
            body: body, // body array
            name: setup.role, // name of the creep; gets modified by hatchery
            memory: creepMemory, // memory to initialize with
        };
        return protoCreep;
    }
    logRequest(request) {
        return `${request.setup.role}@${request.priority}`;
    }
    /**
     * Enqueues a spawn request to the hatchery production queue
     */
    enqueue(request) {
        const priority = request.priority;
        // Spawn the creep yourself if you can
        this._waitTimes = undefined; // invalidate cache
        if (!this.productionQueue[priority]) {
            this.productionQueue[priority] = [];
            this.productionPriorities.push(priority); // this is necessary because keys interpret number as string
        }
        this.productionQueue[priority].push(request);
    }
    spawnHighestPriorityCreep() {
        while (this.availableSpawns.length > 0 &&
            this.spawnRequests.length > 0) {
            const request = this.spawnRequests.shift();
            // don't spawn non-critical creeps during wartime
            if (this.colony.defcon >= DEFCON.playerInvasion &&
                request.priority > OverlordPriority.warSpawnCutoff) {
                this.debug(`request ${this.logRequest(request)} is over war-time cut-off, ignoring`);
                continue;
            }
            // Generate a protocreep from the request
            const protoCreep = this.generateProtoCreep(request.setup, request.overlord);
            const preLog = `request ${this.logRequest(request)}, needed ${bodyCost(protoCreep.body)}, ` +
                `stored: ${this.room.energyAvailable}, total: ${this.room.energyCapacityAvailable}`;
            // Try to spawn the creep
            const result = this.spawnCreep(protoCreep, request.options);
            if (result == OK) {
                this.debug(`${preLog}: spawn successful`);
                return result;
            }
            else if (result == ERR_SPECIFIED_SPAWN_BUSY) {
                this.debug(`${preLog}: requested spawn is busy`);
                // continue to spawn other things while waiting on specified spawn
                return result;
            }
            else if (result === ERR_INVALID_ARGS) {
                this.debug(`${preLog}: asked to spawn an invalid creep, ignoring`);
            }
            else if (result === ERR_NOT_ENOUGH_ENERGY ||
                result === ERR_ROOM_ENERGY_CAPACITY_NOT_ENOUGH) {
                // If there's not enough energyCapacity to spawn, ignore and move on, otherwise block and wait
                this.debug(`${preLog}: not enough energy, ignoring`);
                return result;
            }
            else {
                this.debug(`${preLog}: failed to spawn, requeuing: ${result}`);
                this.spawnRequests.unshift(request);
                return result;
            }
        }
    }
    // Runtime operation ===============================================================================================
    init() {
        this.registerEnergyRequests();
    }
    run() {
        // Handle spawning
        if (!this.settings.suppressSpawning) {
            const spawningSpawns = this.spawns.filter((s) => s.spawning);
            let requests = this.spawnRequests;
            if ((spawningSpawns.length || requests.length) &&
                Game.time % 5 === 0) {
                this.debug(() => {
                    let msg = "";
                    // Slice out the in-progress requests so they don't show up twice
                    requests = requests.slice(spawningSpawns.length);
                    if (spawningSpawns.length) {
                        msg += `spawning: ${spawningSpawns
                            .map((s) => `${Memory.creeps[s.spawning.name].role} in ${s.spawning.remainingTime} ticks`)
                            .join(", ")}`;
                    }
                    if (spawningSpawns.length && requests.length) {
                        msg += ", ";
                    }
                    if (requests.length) {
                        msg += `queued: ${requests
                            .map((request) => this.logRequest(request))
                            .join(", ")}`;
                    }
                    return msg;
                });
            }
            // We're under attack, go through the list of in-progress spawns and
            // yank anything that's not war-time related and not close to spawning.
            if (this.colony.defcon >= DEFCON.playerInvasion) {
                for (const spawn of this.spawns.filter((s) => s.spawning)) {
                    const spawningCreep = Memory.creeps[spawn.spawning.name];
                    const overlord = spawningCreep["O" /* MEM.OVERLORD */] ?
                        Overmind.overlords[spawningCreep["O" /* MEM.OVERLORD */]]
                        : undefined;
                    if (overlord &&
                        overlord.priority >= OverlordPriority.warSpawnCutoff &&
                        spawn.spawning.remainingTime > 5) {
                        log.warning(`${this.print}: cancelling spawn of ${spawningCreep.role} because of war-time`);
                        spawn.spawning.cancel();
                    }
                }
            }
            // Spawn all queued creeps that you can
            while (this.availableSpawns.length > 0) {
                const result = this.spawnHighestPriorityCreep();
                if (result == ERR_NOT_ENOUGH_ENERGY) {
                    // if you can't spawn something you want to
                    this.isOverloaded = true;
                }
                if (result != OK && result != ERR_SPECIFIED_SPAWN_BUSY) {
                    // Can't spawn creep right now
                    break;
                }
            }
            // Move creeps off of exit position to let the spawning creep out if necessary
            for (const spawn of this.spawns) {
                if (spawn.spawning &&
                    spawn.spawning.remainingTime <= 1 &&
                    spawn.pos.findInRange(FIND_MY_CREEPS, 1).length > 0) {
                    let directions;
                    if (spawn.spawning.directions) {
                        directions = spawn.spawning.directions;
                    }
                    else {
                        directions = _.map(spawn.pos.availableNeighbors(true), (pos) => spawn.pos.getDirectionTo(pos));
                    }
                    const exitPos = Pathing.positionAtDirection(spawn.pos, _.first(directions));
                    Movement.vacatePos(exitPos);
                }
            }
        }
        this.recordStats();
    }
    /** The list of ongoing requests, sorted by priority */
    get spawnRequests() {
        if (!this._spawnRequests) {
            this._spawnRequests = [];
            const sortedKeys = _.sortBy(this.productionPriorities);
            for (const priority of sortedKeys) {
                const requests = this.productionQueue[priority];
                if (requests.length > 0) {
                    this._spawnRequests.push(...requests);
                }
            }
        }
        return this._spawnRequests;
    }
    recordStats() {
        // Compute uptime and overload status
        const spawnUsageThisTick = _.filter(this.spawns, (spawn) => spawn.spawning).length /
            this.spawns.length;
        const uptime = ema(spawnUsageThisTick, this.memory.stats.uptime, CREEP_LIFE_TIME);
        const longUptime = ema(spawnUsageThisTick, this.memory.stats.longUptime, 3 * CREEP_LIFE_TIME);
        const overload = ema(this.isOverloaded ? 1 : 0, this.memory.stats.overload, CREEP_LIFE_TIME);
        Stats.log(`colonies.${this.colony.name}.hatchery.uptime`, uptime);
        Stats.log(`colonies.${this.colony.name}.hatchery.overload`, overload);
        this.memory.stats = { overload, uptime, longUptime };
    }
    visuals(coord) {
        var _a;
        let { x, y } = coord;
        const spawnMap = new Map();
        for (const spawn of this.spawns) {
            if (spawn.spawning) {
                const timeElapsed = spawn.spawning.needTime - spawn.spawning.remainingTime;
                const role = (_a = Memory.creeps[spawn.spawning.name].role) !== null && _a !== void 0 ? _a : "unknown";
                spawnMap.set(spawn.id, [
                    role,
                    timeElapsed,
                    spawn.spawning.needTime,
                ]);
            }
        }
        const boxCoords = Visualizer.section(`${this.colony.name} Hatchery`, { x, y, roomName: this.room.name }, 9.5, 4 + spawnMap.size + 0.1);
        const boxX = boxCoords.x;
        y = boxCoords.y + 0.25;
        // Log energy
        Visualizer.text("Energy", { x: boxX, y: y, roomName: this.room.name });
        Visualizer.barGraph([this.room.energyAvailable, this.room.energyCapacityAvailable], { x: boxX + 4, y: y, roomName: this.room.name }, 5);
        y += 1;
        // Log uptime
        const uptime = this.memory.stats.uptime;
        Visualizer.text("Uptime", { x: boxX, y: y, roomName: this.room.name });
        Visualizer.barGraph(uptime, { x: boxX + 4, y: y, roomName: this.room.name }, 5);
        y += 1;
        // Log overload status
        const overload = this.memory.stats.overload;
        Visualizer.text("Overload", {
            x: boxX,
            y: y,
            roomName: this.room.name,
        });
        Visualizer.barGraph(overload, { x: boxX + 4, y: y, roomName: this.room.name }, 5);
        y += 1;
        const numSpawning = this.spawns.reduce((v, s) => (v += s.spawning ? 1 : 0), 0);
        let queued = this.spawnRequests
            .slice(numSpawning)
            .map((r) => r.setup.role[0])
            .join("");
        if (queued.length > 9) {
            queued = queued.substring(0, 9) + "…";
        }
        if (queued.length > 0) {
            Visualizer.text("Queued", {
                x: boxX,
                y: y,
                roomName: this.room.name,
            });
            Visualizer.text(queued, { x: boxX + 4, y: y, roomName: this.room.name }, undefined, {
                font: `0.8 Courier`,
            });
            y += 1;
        }
        for (const [_id, [name, elapsed, total]] of spawnMap) {
            Visualizer.text(name, { x: boxX, y: y, roomName: this.room.name });
            Visualizer.barGraph([elapsed, total], { x: boxX + 4, y: y, roomName: this.room.name }, 5);
            y += 1;
        }
        return { x: x, y: y + 0.25 };
    }
};
Hatchery.restrictedRange = 6; // Don't stand idly within this range of hatchery
Hatchery = __decorate$1([
    profile
], Hatchery);

let CombatTargeting = class CombatTargeting {
    /**
     * Finds the best target within a given range that a zerg can currently attack
     */
    static findBestCreepTargetInRange(zerg, range, targets = zerg.room.hostiles) {
        const nearbyHostiles = _.filter(targets, (c) => zerg.pos.inRangeToXY(c.pos.x, c.pos.y, range));
        return maxBy(nearbyHostiles, function (hostile) {
            var _a;
            (_a = hostile.hitsPredicted) !== null && _a !== void 0 ? _a : (hostile.hitsPredicted = hostile.hits);
            if (hostile.pos.lookForStructure(STRUCTURE_RAMPART)) {
                return false;
            }
            return (hostile.hitsMax -
                hostile.hitsPredicted +
                CombatIntel$1.getHealPotential(hostile)); // compute score
        });
    }
    /**
     * Finds the best target within a given range that a zerg can currently attack
     */
    static findBestStructureTargetInRange(zerg, range, allowUnowned = true) {
        let nearbyStructures = _.filter(zerg.room.hostileStructures, (s) => zerg.pos.inRangeToXY(s.pos.x, s.pos.y, range));
        // If no owned structures to attack and not in colony room or outpost, target unowned structures
        if (allowUnowned &&
            nearbyStructures.length == 0 &&
            !Overmind.colonyMap[zerg.room.name]) {
            nearbyStructures = _.filter(zerg.room.structures, (s) => zerg.pos.inRangeToXY(s.pos.x, s.pos.y, range));
        }
        return maxBy(nearbyStructures, function (structure) {
            let score = 10 * AttackStructureScores[structure.structureType];
            if (structure.pos.lookForStructure(STRUCTURE_RAMPART)) {
                score *= 0.1;
            }
            return score;
        });
    }
    /**
     * Standard target-finding logic
     */
    static findTarget(zerg, targets) {
        if (!targets) {
            targets = [...zerg.room.hostiles, ...zerg.room.hostileStructures];
        }
        return maxBy(targets, function (hostile) {
            var _a;
            if (hostile.pos.lookForStructure(STRUCTURE_RAMPART)) {
                return false;
            }
            if (isStructure(hostile)) {
                return (hostile.hitsMax -
                    10 * zerg.pos.getMultiRoomRangeTo(hostile.pos));
            }
            else {
                (_a = hostile.hitsPredicted) !== null && _a !== void 0 ? _a : (hostile.hitsPredicted = hostile.hits);
                return (hostile.hitsMax -
                    hostile.hitsPredicted +
                    CombatIntel$1.getHealPotential(hostile) -
                    10 * zerg.pos.getMultiRoomRangeTo(hostile.pos)); // compute score
            }
        });
    }
    /**
     * Finds the best target within a given range that a zerg can currently attack
     */
    static findBestCreepTargetForTowers(room, targets = room.hostiles) {
        return maxBy(targets, function (hostile) {
            var _a;
            (_a = hostile.hitsPredicted) !== null && _a !== void 0 ? _a : (hostile.hitsPredicted = hostile.hits);
            if (hostile.pos.lookForStructure(STRUCTURE_RAMPART)) {
                return false;
            }
            return (hostile.hitsMax -
                hostile.hitsPredicted +
                CombatIntel$1.getHealPotential(hostile) +
                (CombatIntel$1.towerDamageAtPos(hostile.pos) || 0));
        });
    }
    static findClosestHostile(zerg, opts) {
        var _a;
        _.defaults(opts, {
            checkReachable: false,
            ignoreCreepsAtEdge: true,
            playerOnly: false,
            onlyUnramparted: false,
        });
        if (zerg.room.hostiles.length > 0) {
            let targets;
            const potentialTargets = opts.playerOnly ? zerg.room.playerHostiles : zerg.room.hostiles;
            if (opts.ignoreCreepsAtEdge) {
                targets = _.filter(potentialTargets, (hostile) => hostile.pos.rangeToEdge > 0);
            }
            else {
                targets = potentialTargets;
            }
            if (opts.onlyUnramparted) {
                targets = _.filter(targets, (hostile) => !hostile.inRampart);
            }
            if (opts.checkReachable) {
                const targetsByRange = _.sortBy(targets, (target) => zerg.pos.getRangeTo(target));
                return _.find(targetsByRange, (target) => Pathing.isReachable(zerg.pos, target.pos, zerg.room.barriers.filter((barrier) => barrier.structureType == STRUCTURE_WALL ||
                    (barrier.structureType == STRUCTURE_RAMPART &&
                        (barrier.owner.username ==
                            MY_USERNAME ||
                            !barrier.isPublic)))));
            }
            else {
                return (_a = zerg.pos.findClosestByRange(targets)) !== null && _a !== void 0 ? _a : undefined;
            }
        }
    }
    // This method is expensive
    static findClosestReachable(pos, targets) {
        const targetsByRange = _.sortBy(targets, (target) => pos.getRangeTo(target));
        return _.find(targetsByRange, (target) => Pathing.isReachable(pos, target.pos, target.room.barriers));
    }
    static findClosestHurtFriendly(healer) {
        return healer.pos.findClosestByRange(_.filter(healer.room.creeps, (creep) => creep.hits < creep.hitsMax));
    }
    /**
     * Finds the best (friendly) target in range that a zerg can currently heal
     */
    static findBestHealingTargetInRange(healer, range = RANGES.RANGED_HEAL, friendlies) {
        if (!friendlies) {
            friendlies = healer.room.friendlies;
        }
        const tempHitsPredicted = {};
        return maxBy(_.filter(friendlies, (f) => f.hits < f.hitsMax && healer.pos.getRangeTo(f) <= range), (friend) => {
            var _a;
            (_a = friend.hitsPredicted) !== null && _a !== void 0 ? _a : (friend.hitsPredicted = friend.hits);
            const attackProbability = 0.5;
            tempHitsPredicted[friend.id] = friend.hitsPredicted;
            for (const hostile of friend.pos.findInRange(friend.room.hostiles, 3)) {
                if (!friend.inRampart) {
                    if (hostile.pos.isNearTo(friend)) {
                        tempHitsPredicted[friend.id] -=
                            attackProbability *
                                CombatIntel$1.getAttackDamage(hostile);
                    }
                    else {
                        tempHitsPredicted[friend.id] -=
                            attackProbability *
                                CombatIntel$1.getRangedAttackDamage(hostile);
                    }
                }
            }
            const missingHits = friend.hitsMax - tempHitsPredicted[friend.id];
            if (healer.pos.getRangeTo(friend) > 1) {
                return Math.min(missingHits, CombatIntel$1.getRangedHealAmount(healer.creep));
            }
            else {
                return Math.min(missingHits, CombatIntel$1.getHealAmount(healer.creep));
            }
        });
    }
    static findClosestPrioritizedStructure(zerg, checkReachable = false) {
        var _a;
        for (const structureType of AttackStructurePriorities) {
            const structures = _.filter(zerg.room.hostileStructures, (s) => s.structureType == structureType);
            if (structures.length == 0) {
                continue;
            }
            if (checkReachable) {
                const closestReachable = this.findClosestReachable(zerg.pos, structures);
                if (closestReachable) {
                    return closestReachable;
                }
            }
            else {
                return (_a = zerg.pos.findClosestByRange(structures)) !== null && _a !== void 0 ? _a : undefined;
            }
        }
        const core = _.filter(zerg.room.hostileStructures, (s) => s.structureType.toString() == "invaderCore");
        if (core.length != 0) {
            return core[0];
        }
    }
    static findBestStructureTarget(pos) {
        const room = Game.rooms[pos.roomName];
        // Don't accidentally destroy your own shit
        if (!room || room.my || room.reservedByMe) {
            return;
        }
        // Look for any unprotected structures
        const unprotectedRepairables = _.filter(room.repairables, (s) => {
            const rampart = s.pos.lookForStructure(STRUCTURE_RAMPART);
            return !rampart || rampart.hits < 10000;
        });
        let approach = _.map(unprotectedRepairables, (structure) => {
            return { pos: structure.pos, range: 0 };
        });
        if (room.barriers.length == 0 && unprotectedRepairables.length == 0) {
            return; // if there's nothing in the room
        }
        // Try to find a reachable unprotected structure
        if (approach.length > 0) {
            const ret = PathFinder.search(pos, approach, {
                maxRooms: 1,
                maxOps: 2000,
                roomCallback: (roomName) => {
                    if (roomName != room.name) {
                        return false;
                    }
                    const matrix = new PathFinder.CostMatrix();
                    for (const barrier of room.barriers) {
                        matrix.set(barrier.pos.x, barrier.pos.y, 0xff);
                    }
                    return matrix;
                },
            });
            const targetPos = _.last(ret.path);
            if (!ret.incomplete && targetPos) {
                const targetStructure = _.first(_.filter(targetPos.lookFor(LOOK_STRUCTURES), (s) => {
                    return (s.structureType != STRUCTURE_ROAD &&
                        s.structureType != STRUCTURE_CONTAINER);
                }));
                if (targetStructure) {
                    log.debug(`Found unprotected structure target @ ${targetPos.print}`);
                    return targetStructure;
                }
            }
        }
        // Determine a "siege anchor" for what you eventually want to destroy
        let targets = room.spawns;
        if (targets.length == 0) {
            targets = room.repairables;
        }
        if (targets.length == 0) {
            targets = room.barriers;
        }
        if (targets.length == 0) {
            targets = room.structures;
        }
        if (targets.length == 0) {
            return;
        }
        // Recalculate approach targets
        approach = _.map(targets, (s) => {
            return { pos: s.pos, range: 0 };
        });
        const maxWallHits = _.max(_.map(room.barriers, (b) => b.hits)) || 0;
        // Compute path with wall position costs weighted by fraction of highest wall
        const ret = PathFinder.search(pos, approach, {
            maxRooms: 1,
            plainCost: 1,
            swampCost: 2,
            roomCallback: (roomName) => {
                if (roomName != pos.roomName) {
                    return false;
                }
                const matrix = new PathFinder.CostMatrix();
                for (const barrier of room.barriers) {
                    const cost = 100 + Math.round((barrier.hits / maxWallHits) * 100);
                    matrix.set(barrier.pos.x, barrier.pos.y, cost);
                }
                return matrix;
            },
        });
        // Target the first non-road, non-container structure you find along the path
        for (const pos of ret.path) {
            const targetStructure = _.first(_.filter(pos.lookFor(LOOK_STRUCTURES), (s) => {
                return (s.structureType != STRUCTURE_ROAD &&
                    s.structureType != STRUCTURE_CONTAINER);
            }));
            if (targetStructure) {
                log.debug(`Targeting structure @ ${targetStructure.pos.print}`);
                return targetStructure;
            }
        }
    }
    static findBestSwarmStructureTarget(swarm, roomName, randomness = 0, displayCostMatrix = false) {
        const room = Game.rooms[roomName];
        // Don't accidentally destroy your own shit
        if (!room || room.my || room.reservedByMe) {
            return;
        }
        if (swarm.anchor.roomName != roomName) {
            log.warning(`Swarm is not in target room!`);
            return;
        }
        // // Look for any unprotected structures
        // let unprotectedRepairables = _.filter(room.repairables, s => {
        // 	let rampart = s.pos.lookForStructure(STRUCTURE_RAMPART);
        // 	return !rampart || rampart.hits < 10000;
        // });
        // let approach = _.map(unprotectedRepairables, structure => {
        // 	return {pos: structure.pos, range: 0};
        // }) as PathFinderGoal[];
        // // if there's nothing in the room
        // if (room.barriers.length == 0 && unprotectedRepairables.length == 0) return;
        //
        // // Try to find a reachable unprotected structure
        // if (approach.length > 0) {
        // 	let ret = PathFinder.search(swarm.anchor, approach, {
        // 		maxRooms    : 1,
        // 		maxOps      : 2000,
        // 		roomCallback: roomName => {
        // 			if (roomName != room.name) return false;
        // 			let matrix = Pathing.getSwarmTerrainMatrix(roomName, swarm.width, swarm.height).clone();
        // 			for (let barrier of room.barriers) {
        // 				let setPositions = Pathing.getPosWindow(barrier.pos, -swarm.width, -swarm.height);
        // 				for (let pos of setPositions) {
        // 					matrix.set(pos.x, pos.y, 0xff);
        // 				}
        // 			}
        // 			return matrix;
        // 		},
        // 	});
        // 	let targetPos = _.last(ret.path);
        // 	if (!ret.incomplete && targetPos) {
        // 		let targetStructure = _.first(_.filter(targetPos.lookFor(LOOK_STRUCTURES), s => {
        // 			return s.structureType != STRUCTURE_ROAD && s.structureType != STRUCTURE_CONTAINER;
        // 		}));
        // 		if (targetStructure) {
        // 			log.debug(`Found unprotected structure target @ ${targetPos.print}`);
        // 			return targetStructure;
        // 		}
        // 	}
        // }
        // Determine a "siege anchor" for what you eventually want to destroy
        let targets = room.spawns;
        if (targets.length == 0) {
            targets = room.towers;
        }
        if (targets.length == 0) {
            targets = room.repairables;
        }
        if (targets.length == 0) {
            targets = room.barriers;
        }
        if (targets.length == 0) {
            targets = room.structures;
        }
        if (targets.length == 0) {
            return;
        }
        // Recalculate approach targets
        const approach = _.map(targets, (s) => {
            // TODO: might need to Pathing.getPosWindow() this
            return { pos: s.pos, range: 0 };
        });
        const maxWallHits = _.max(_.map(room.barriers, (b) => b.hits)) || 0;
        // Compute path with wall position costs weighted by fraction of highest wall
        const ret = PathFinder.search(swarm.anchor, approach, {
            maxRooms: 1,
            plainCost: 1,
            swampCost: 2,
            roomCallback: (rn) => {
                if (rn != roomName) {
                    return false;
                }
                const matrix = MatrixLib.getSwarmTerrainMatrix(roomName, { plainCost: 1, swampCost: 5 }, swarm.width, swarm.height);
                for (const barrier of room.barriers) {
                    const randomFactor = Math.min(Math.round(randomness * Math.random()), 100);
                    const cost = 100 +
                        Math.round((barrier.hits / maxWallHits) * 100) +
                        randomFactor;
                    MatrixLib.setToMaxCostAfterMaxPooling(matrix, [barrier], swarm.width, swarm.height, cost);
                }
                if (displayCostMatrix) {
                    Visualizer.displayCostMatrix(matrix, roomName);
                }
                return matrix;
            },
        });
        // Target the first non-road, non-container structure you find along the path or neighboring positions
        for (const pos of ret.path) {
            log.debug(`Searching path ${pos.print}...`);
            const searchPositions = Pathing.getPosWindow(pos, swarm.width, swarm.height); // not -1*width
            for (const searchPos of searchPositions) {
                const targetStructure = _.first(_.filter(searchPos.lookFor(LOOK_STRUCTURES), (s) => {
                    return (s.structureType != STRUCTURE_ROAD &&
                        s.structureType != STRUCTURE_CONTAINER);
                }));
                if (targetStructure) {
                    log.debug(`Targeting structure @ ${targetStructure.pos.print}`);
                    return targetStructure;
                }
            }
        }
    }
};
CombatTargeting = __decorate$1([
    profile
], CombatTargeting);

var SporeCrawler_1;
/**
 * The spore crawler is the hive cluster for controlling towers within a room
 */
let SporeCrawler = SporeCrawler_1 = class SporeCrawler extends HiveCluster {
    constructor(colony, tower) {
        super(colony, tower, "sporeCrawler");
        this.memory = Mem.wrap(this.colony.memory, "sporeCrawler");
        // Register structure components
        this.towers = this.colony.towers;
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, "sporeCrawler");
        $.refreshRoom(this);
        $.refresh(this, "towers");
    }
    spawnMoarOverlords() { }
    registerEnergyRequests() {
        // Request energy from transporters if below request threshold
        for (const tower of this.towers) {
            if (tower.store[RESOURCE_ENERGY] <
                SporeCrawler_1.settings.requestThreshold) {
                const multiplier = (tower.store[RESOURCE_ENERGY] <
                    SporeCrawler_1.settings.criticalEnergyThreshold) ?
                    2
                    : 1;
                const dAmountdt = this.room.hostiles.length > 0 ? 10 : 0;
                this.colony.logisticsNetwork.requestInput(tower, {
                    multiplier: multiplier,
                    dAmountdt: dAmountdt,
                });
            }
        }
    }
    init() {
        this.registerEnergyRequests();
    }
    attack(target) {
        var _a;
        for (const tower of this.towers) {
            const predictedDamage = CombatIntel$1.singleTowerDamage(target.pos.getRangeTo(tower));
            this.debug(`${tower.print} attacking ${target} for ${predictedDamage}`);
            const result = tower.attack(target);
            if (result == OK) {
                (_a = target.hitsPredicted) !== null && _a !== void 0 ? _a : (target.hitsPredicted = target.hits);
                target.hitsPredicted -= predictedDamage;
            }
        }
    }
    scatterShot(targets) {
        var _a;
        if (targets.length === 0) {
            return;
        }
        for (const tower of this.towers) {
            const target = _.sample(targets);
            const predictedDamage = CombatIntel$1.singleTowerDamage(target.pos.getRangeTo(tower));
            this.debug(`${tower.print} scattershotting ${target} for ${predictedDamage}`);
            const result = tower.attack(target);
            if (result == OK) {
                (_a = target.hitsPredicted) !== null && _a !== void 0 ? _a : (target.hitsPredicted = target.hits);
                target.hitsPredicted -= predictedDamage;
            }
        }
    }
    // private attackNearestEnemy(prioritizeHealers = false) {
    // 	if (prioritizeHealers) {
    // 		let healers = _.filter(this.room.hostiles, creep => creep.getActiveBodyparts(HEAL) > 0);
    // 		if (healers.length > 0) {
    // 			let healer = this.pos.findClosestByRange(healers);
    // 			if (healer) {
    // 				return this.tower.attack(healer);
    // 			}
    // 		}
    // 	}
    // 	let closestHostile = this.pos.findClosestByRange(FIND_HOSTILE_CREEPS);
    // 	if (closestHostile) {
    // 		return this.tower.attack(closestHostile);
    // 	}
    // }
    // private healNearestAlly() {
    // 	var closestDamagedAlly = this.pos.findClosestByRange(FIND_MY_CREEPS, {
    // 		filter: (c: Creep) => c.hits < c.hitsMax,
    // 	});
    // 	if (closestDamagedAlly) {
    // 		return this.tower.heal(closestDamagedAlly);
    // 	}
    // }
    preventStructureDecay(includeRoads = true) {
        if (this.towers.length > 0) {
            // expensive to check all rampart hits; only run in intermediate RCL
            const dyingRamparts = _.filter(this.room.ramparts, (rampart) => rampart.hits <
                WorkerOverlord.settings.barrierHits.critical &&
                this.colony.roomPlanner.barrierPlanner.barrierShouldBeHere(rampart.pos));
            if (dyingRamparts.length > 0) {
                for (const tower of this.towers) {
                    const rampart = tower.pos.findClosestByRange(dyingRamparts);
                    this.debug(`${tower.print} repairing rampart ${rampart.print}`);
                    tower.repair(rampart);
                    this.colony.trackEnergyUse(EnergyUse.REPAIR, -TOWER_ENERGY_COST);
                }
                return;
            }
            // repair roads
            if (includeRoads) {
                const decayingRoads = _.filter(this.room.roads, (road) => road.hits < 0.2 * road.hitsMax &&
                    this.colony.roomPlanner.roadShouldBeHere(road.pos));
                if (decayingRoads.length > 0) {
                    const roadsToRepair = _.sample(decayingRoads, this.towers.length);
                    // ^ if |towers| > |roads| then this will have length of |roads|
                    for (const [i, road] of roadsToRepair.entries()) {
                        this.debug(`${this.towers[i].print} repairing road ${road.print}`);
                        this.towers[i].repair(road);
                    }
                }
            }
        }
    }
    // private repairNearestStructure() {
    // 	var closestDamagedStructure = this.pos.findClosestByRange(FIND_STRUCTURES, {
    // 		filter: (s: Structure) => s.hits < s.hitsMax &&
    // 								  s.structureType != STRUCTURE_WALL &&
    // 								  s.structureType != STRUCTURE_RAMPART,
    // 	});
    // 	if (closestDamagedStructure) {
    // 		return this.tower.repair(closestDamagedStructure);
    // 	}
    // }
    run() {
        if (this.room.hostiles.length > 0) {
            const myDefenders = _.filter(this.room.creeps, (creep) => creep.getActiveBodyparts(ATTACK) > 1);
            const myRangedDefenders = _.filter(this.room.creeps, (creep) => creep.getActiveBodyparts(RANGED_ATTACK) > 1);
            const myCreepDamage = ATTACK_POWER *
                _.sum(myDefenders, (creep) => CombatIntel$1.getAttackPotential(creep)) +
                RANGED_ATTACK_POWER *
                    _.sum(myRangedDefenders, (creep) => CombatIntel$1.getRangedAttackPotential(creep));
            const HEAL_FUDGE_FACTOR = 1.0;
            const avgHealing = HEAL_FUDGE_FACTOR *
                CombatIntel$1.avgHostileHealingTo(this.room.hostiles);
            let possibleTargets = _.filter(this.room.hostiles, (hostile) => {
                // let healing = HEAL_FUDGE_FACTOR * CombatIntel.maxHostileHealingTo(hostile);
                const damageTaken = CombatIntel$1.towerDamageAtPos(hostile.pos) + myCreepDamage;
                const damageMultiplier = CombatIntel$1.minimumDamageTakenMultiplier(hostile);
                return damageTaken * damageMultiplier > avgHealing;
            });
            this.debug(() => {
                const closestHostile = this.pos.findClosestByRange(this.room.hostiles);
                return (`${this.room.hostiles.length} hostiles detected!\n` +
                    `\tPotential creep damage: ${myCreepDamage}\n` +
                    `\tMaximum tower damage: ${closestHostile ?
                        CombatIntel$1.towerDamageAtPos(closestHostile.pos)
                        : 0}\n` +
                    `\tEnemy healing power: ${avgHealing}\n` +
                    `\tTargets: ${possibleTargets}`);
            });
            // Only attack dancing targets (drain attack) which are far enough in rooms to be killed off by towers
            possibleTargets = _.filter(possibleTargets, (hostile) => {
                if (CombatIntel$1.isEdgeDancing(hostile)) {
                    const netDPS = CombatIntel$1.towerDamageAtPos(hostile.pos) +
                        myCreepDamage -
                        HEAL_FUDGE_FACTOR *
                            CombatIntel$1.maxHostileHealingTo(hostile);
                    const isKillable = netDPS * hostile.pos.rangeToEdge > hostile.hits;
                    if (isKillable) {
                        return true;
                    }
                    else {
                        // Shoot if they get close enough
                        if (this.colony.bunker &&
                            this.colony.bunker.anchor &&
                            hostile.pos.getRangeTo(this.colony.bunker.anchor) <=
                                6 + 2) {
                            return true;
                        }
                    }
                }
                else {
                    // const netDPS = CombatIntel.towerDamageAtPos(hostile.pos)! + myCreepDamage
                    // 	- (HEAL_FUDGE_FACTOR * CombatIntel.maxHostileHealingTo(hostile));
                    // const isKillable = netDPS * hostile.pos.rangeToEdge > hostile.hits/2;
                    // return isKillable;
                    return true;
                }
            });
            if (Game.time % 21 == 0 &&
                _.filter(possibleTargets, (target) => target.hits < target.hitsMax / 2).length == 0) {
                this.debug(`Scattershotting ${possibleTargets}`);
                return this.scatterShot(possibleTargets);
            }
            this.debug(`filtered (range): ${possibleTargets}`);
            // TODO: that's broken since it only checks creeps proximity
            // enemy.hits < enemy.hitsMax / 2
            possibleTargets = _.sortBy(possibleTargets, (enemy) => enemy.pos.findInRange(FIND_MY_CREEPS, RANGES.RANGED_ATTACK)
                .length > 0 ||
                enemy.pos.findInRange(FIND_MY_STRUCTURES, RANGES.RANGED_ATTACK).length > 0);
            this.debug(`filtered (hp): ${possibleTargets}`);
            const target = CombatTargeting.findBestCreepTargetForTowers(this.room, possibleTargets);
            this.debug(`selected target: ${target === null || target === void 0 ? void 0 : target.print}`);
            if (target) {
                return this.attack(target);
            }
        }
        const closestDamagedAlly = this.pos.findClosestByRange(_.filter(this.room.friendlies, (creep) => creep.hits < creep.hitsMax));
        if (closestDamagedAlly) {
            for (const tower of this.towers) {
                tower.heal(closestDamagedAlly);
            }
            return;
        }
        // Towers build nuke response ramparts
        const nearbyNukeRamparts = _.filter(this.colony.overlords.work.nukeDefenseRamparts, (rampart) => this.pos.getRangeTo(rampart) <= TOWER_OPTIMAL_RANGE);
        if (nearbyNukeRamparts.length > 0 &&
            this.colony.terminal &&
            !this.colony.state.isRebuilding) {
            const nukes = this.colony.room.find(FIND_NUKES);
            const timeToImpact = _.min(_.map(nukes, (nuke) => nuke.timeToLand));
            if (timeToImpact) {
                const repairHitsRemaining = _.sum(_.values(this.colony.overlords.work.nukeDefenseHitsRemaining));
                const hitsRepairedPerTick = this.towers.length * TOWER_POWER_REPAIR;
                // Only repair using towers if it looks like you won't finish repairs in time
                if (repairHitsRemaining >
                    0.9 * hitsRepairedPerTick * timeToImpact) {
                    for (const tower of this.towers) {
                        tower.repair(nearbyNukeRamparts[0]);
                    }
                    return;
                }
            }
            else {
                // Shouldn't get here
                log.warning(`No time to impact! (Why?)`);
            }
        }
        // Prevent rampart decay at early RCL
        this.preventStructureDecay();
    }
    visuals() { }
};
SporeCrawler.settings = {
    requestThreshold: 500,
    criticalEnergyThreshold: 250,
};
SporeCrawler = SporeCrawler_1 = __decorate$1([
    profile
], SporeCrawler);

/**
 * Spawns an upgrader to upgrade the room controller
 */
let UpgradingOverlord = class UpgradingOverlord extends Overlord {
    constructor(upgradeSite, priority = OverlordPriority.upgrading.upgrade) {
        super(upgradeSite, "upgrade", priority);
        this.upgradeSite = upgradeSite;
        // If new colony or boosts overflowing to storage
        this.upgraders = this.zerg(Roles.upgrader);
    }
    init() {
        var _a;
        if (this.colony.level < 3) {
            // can't spawn upgraders at early levels
            return;
        }
        let setup = "default";
        let upgradersNeeded = 0;
        if (this.colony.assets.energy > UpgradeSite.settings.energyBuffer ||
            this.upgradeSite.controller.ticksToDowngrade < 500) {
            if (this.colony.level == 8) {
                upgradersNeeded = 1;
                setup = "rcl8";
                if (this.colony.labs.length == 10 &&
                    this.colony.assets[RESOURCE_CATALYZED_GHODIUM_ACID] >=
                        4 * LAB_BOOST_MINERAL) {
                    setup = "rcl8_boosted";
                }
            }
            else {
                const upgradePowerEach = _.get(Setups.upgraders, setup).getBodyPotential(WORK, this.colony);
                upgradersNeeded = Math.ceil(this.upgradeSite.upgradePowerNeeded / upgradePowerEach);
            }
        }
        else {
            this.debug(`no upgraders needed`);
        }
        // Ask for one upgraded at normal priority, and the rest more lazily
        this.debug(`need ${upgradersNeeded} ${setup} upgraders total`);
        const creepSetup = _.get(Setups.upgraders, setup);
        const speedFactor = (_a = this.upgradeSite.memory.speedFactor) !== null && _a !== void 0 ? _a : 1;
        if (this.upgraders.length < speedFactor && upgradersNeeded > 0) {
            this.debug(`wishlisting ${Math.min(speedFactor, upgradersNeeded)} quickly!`);
            this.wishlist(Math.min(speedFactor, upgradersNeeded), creepSetup);
        }
        else if (upgradersNeeded > 0) {
            this.debug(`wishlisting ${upgradersNeeded} later`);
            this.wishlist(upgradersNeeded, creepSetup, {
                priority: OverlordPriority.upgrading.additional,
            });
        }
    }
    handleUpgrader(upgrader) {
        if (upgrader.store.energy > 0) {
            // Repair link
            if (this.upgradeSite.link &&
                this.upgradeSite.link.hits < this.upgradeSite.link.hitsMax) {
                this.debug(`${upgrader.print}: repairing link`);
                upgrader.task = Tasks$1.repair(this.upgradeSite.link);
                return;
            }
            // Repair container
            if (this.upgradeSite.battery &&
                this.upgradeSite.battery.hits < this.upgradeSite.battery.hitsMax) {
                this.debug(`${upgrader.print}: repairing battery`);
                upgrader.task = Tasks$1.repair(this.upgradeSite.battery);
                return;
            }
            // Build construction site
            const inputSite = this.upgradeSite.findInputConstructionSite();
            if (inputSite) {
                this.debug(`${upgrader.print}: building ${inputSite}`);
                upgrader.task = Tasks$1.build(inputSite);
                return;
            }
            // Sign controller if needed
            const controller = this.upgradeSite.controller;
            if (!controller.signedByMe && !controller.signedByScreeps) {
                this.debug(`${upgrader.print}: signing controller`);
                upgrader.task = Tasks$1.signController(controller);
                return;
            }
            // TODO: this should have a colony-level setting for what we
            // should focus on, since that limits GCL growth
            if (controller.level !== 8 ||
                controller.ticksToDowngrade /
                    CONTROLLER_DOWNGRADE[controller.level] <=
                    0.995) {
                this.debug(`${upgrader.print}: upgrading`);
                upgrader.task = Tasks$1.upgrade(controller);
                return;
            }
        }
        else {
            // Try recharging from link first; if the link has no energy,
            // either some will pop up soon, or there is no energy anywhere
            if (this.upgradeSite.link &&
                this.upgradeSite.link.store[RESOURCE_ENERGY] > 0) {
                this.debug(`${upgrader.print}: withdrawing from link`);
                upgrader.task = Tasks$1.withdraw(this.upgradeSite.link);
                return;
            }
            if (this.upgradeSite.battery &&
                this.upgradeSite.battery.energy > 0) {
                this.debug(`${upgrader.print}: withdrawing from battery`);
                upgrader.task = Tasks$1.withdraw(this.upgradeSite.battery);
                return;
            }
            // Find somewhere else to recharge from
            this.debug(`${upgrader.print}: heading off to recharge`);
            upgrader.task = Tasks$1.recharge();
            return;
        }
    }
    run() {
        this.autoRun(this.upgraders, (upgrader) => this.handleUpgrader(upgrader));
    }
};
UpgradingOverlord = __decorate$1([
    profile
], UpgradingOverlord);

var UpgradeSite_1;
const getDefaultUpgradeSiteMemory = () => ({
    stats: { downtime: 0 },
    speedFactor: undefined,
});
/**
 * Upgrade sites group upgrade-related structures around a controller, such as an input link and energy container
 */
let UpgradeSite = UpgradeSite_1 = class UpgradeSite extends HiveCluster {
    constructor(colony, controller) {
        super(colony, controller, "upgradeSite");
        this.controller = controller;
        this.memory = Mem.wrap(this.colony.memory, "upgradeSite", getDefaultUpgradeSiteMemory);
        this.upgradePowerNeeded = this.getUpgradePowerNeeded();
        // Register bettery
        $.set(this, "battery", () => {
            // only count containers that aren't near sources
            const allowableContainers = _.filter(this.room.containers, (container) => {
                var _a;
                return container.pos.findInRange(FIND_SOURCES, 1).length == 0 &&
                    container.pos.findInRange(FIND_MINERALS, 1).length == 0 &&
                    ((_a = this.colony.hatchery) === null || _a === void 0 ? void 0 : _a.batteries.some((b) => !b.pos.isEqualTo(container)));
            });
            return this.pos.findClosestByLimitedRange(allowableContainers, 3);
        });
        this.batteryPos = $.pos(this, "batteryPos", () => {
            if (this.battery) {
                return this.battery.pos;
            }
            const inputSite = this.findInputConstructionSite();
            if (inputSite) {
                return inputSite.pos;
            }
            return (this.calculateBatteryPos() ||
                log.alert(`Upgrade site at ${this.pos.print}: no batteryPos!`));
        });
        if (this.batteryPos) {
            this.colony.markDestination(this.pos, 0);
        }
        // Register link
        $.set(this, "link", () => this.pos.findClosestByLimitedRange(colony.availableLinks, 3));
        this.colony.linkNetwork.claimLink(this.link);
        // // Energy per tick is sum of upgrader body parts and nearby worker body parts
        // this.energyPerTick = $.number(this, 'energyPerTick', () =>
        // 	_.sum(this.overlord.upgraders, upgrader => upgrader.getActiveBodyparts(WORK)) +
        // 	_.sum(_.filter(this.colony.getCreepsByRole(WorkerSetup.role), worker =>
        // 			  worker.pos.inRangeTo((this.link || this.battery || this).pos, 2)),
        // 		  worker => worker.getActiveBodyparts(WORK)));
        // Compute stats
        this.stats();
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, "upgradeSite");
        $.refreshRoom(this);
        $.refresh(this, "controller", "battery", "link");
    }
    spawnMoarOverlords() {
        // Register overlord
        this.overlord = new UpgradingOverlord(this);
    }
    findInputConstructionSite() {
        const nearbyInputSites = this.pos.findInRange(this.room.constructionSites, 4, {
            filter: (s) => s.structureType == STRUCTURE_CONTAINER ||
                s.structureType == STRUCTURE_LINK,
        });
        return _.first(nearbyInputSites);
    }
    getUpgradePowerNeeded() {
        return $.number(this, "upgradePowerNeeded", () => {
            // Workers perform upgrading until storage is set up
            if (!this.room.storage) {
                return 0;
            }
            const amountOver = Math.max(this.colony.assets.energy - UpgradeSite_1.settings.energyBuffer, 0);
            let upgradePower = 1 +
                Math.floor(amountOver / UpgradeSite_1.settings.energyPerBodyUnit);
            if (this.memory.speedFactor !== undefined) {
                upgradePower *= this.memory.speedFactor;
            }
            else if (amountOver > 800000) {
                upgradePower *= 4; // double upgrade power if we have lots of surplus energy
            }
            else if (amountOver > 500000) {
                upgradePower *= 2;
            }
            return upgradePower;
        });
    }
    init() {
        // Register energy requests
        if (this.link &&
            this.link.store[RESOURCE_ENERGY] <
                UpgradeSite_1.settings.linksRequestBelow) {
            this.colony.linkNetwork.requestReceive(this.link);
        }
        const inThreshold = this.colony.storage ? 0.5 : 0.75;
        if (this.battery) {
            if (this.battery.energy <
                inThreshold * this.battery.store.getCapacity()) {
                const energyPerTick = UPGRADE_CONTROLLER_POWER * this.upgradePowerNeeded;
                this.colony.logisticsNetwork.requestInput(this.battery, {
                    dAmountdt: energyPerTick,
                });
            }
            if (hasMinerals(this.battery.store)) {
                // get rid of any minerals in the container if present
                this.colony.logisticsNetwork.requestOutputMinerals(this.battery);
            }
        }
    }
    /**
     * Calculate where the input will be built for this site
     */
    calculateBatteryPos() {
        var _a;
        let originPos;
        if (this.colony.storage) {
            originPos = this.colony.storage.pos;
        }
        else if (this.colony.roomPlanner.storagePos) {
            originPos = this.colony.roomPlanner.storagePos;
        }
        else {
            return;
        }
        // Find all positions at range 2 from controller
        let inputLocations = [];
        for (const pos of this.pos.getPositionsAtRange(2)) {
            if (pos.isWalkable(true) &&
                !insideBunkerBounds(pos, this.colony) &&
                !((_a = this.colony.hatchery) === null || _a === void 0 ? void 0 : _a.batteries.some((b) => b.pos.isEqualTo(pos)))) {
                inputLocations.push(pos);
            }
        }
        // Try to find locations where there is maximal standing room
        const maxNeighbors = _.max(_.map(inputLocations, (pos) => pos.availableNeighbors(true).length));
        inputLocations = _.filter(inputLocations, (pos) => pos.availableNeighbors(true).length >= maxNeighbors);
        // Return location closest to storage by path
        const inputPos = originPos.findClosestByPath(inputLocations);
        if (inputPos) {
            return inputPos;
        }
    }
    /**
     * Build a container output at the optimal location
     */
    buildBatteryIfMissing() {
        if (!this.battery && !this.findInputConstructionSite()) {
            const buildHere = this.batteryPos;
            if (buildHere) {
                const result = buildHere.createConstructionSite(STRUCTURE_CONTAINER);
                if (result !== OK) {
                    log.warning(`${this.print}: cannot build battery at ${buildHere.print}: ${errorForCode(result)}`);
                }
            }
        }
    }
    stats() {
        // Compute downtime
        this.memory.stats.downtime =
            (this.memory.stats.downtime * (CREEP_LIFE_TIME - 1) +
                (this.battery ? +this.battery.isEmpty : 0)) /
                CREEP_LIFE_TIME;
        Stats.log(`colonies.${this.colony.name}.upgradeSite.downtime`, this.memory.stats.downtime);
    }
    run() {
        if (Game.time % 25 == 7 && this.colony.level >= 2) {
            this.buildBatteryIfMissing();
        }
    }
    drawUpgradeReport(coord) {
        let { x, y } = coord;
        let height = 1;
        if (this.controller.level !== 8) {
            height += 1;
        }
        if (this.memory.speedFactor !== undefined) {
            height += 1;
        }
        const titleCoords = Visualizer.section(`${this.colony.name} Upgrade Site (${this.controller.level})`, { x, y, roomName: this.room.name }, 9.5, height + 0.1);
        const boxX = titleCoords.x;
        y = titleCoords.y + 0.25;
        if (this.controller.level != 8) {
            Visualizer.text(`Progress`, {
                x: boxX,
                y: y,
                roomName: this.room.name,
            });
            const fmt = (num) => `${Math.floor(num / 1000)}K`;
            Visualizer.barGraph([this.controller.progress, this.controller.progressTotal], { x: boxX + 4, y: y, roomName: this.room.name }, 5, 1, fmt);
            y += 1;
        }
        if (this.memory.speedFactor !== undefined) {
            Visualizer.text(`Rate`, {
                x: boxX,
                y: y,
                roomName: this.room.name,
            });
            Visualizer.text(this.memory.speedFactor.toString(), {
                x: boxX + 4,
                y: y,
                roomName: this.room.name,
            });
            y += 1;
        }
        Visualizer.text(`Downtime`, {
            x: boxX,
            y: y,
            roomName: this.room.name,
        });
        Visualizer.barGraph(this.memory.stats.downtime, { x: boxX + 4, y: y, roomName: this.room.name }, 5);
        y += 1;
        return { x, y };
    }
    visuals(coord) {
        return this.drawUpgradeReport(coord);
    }
};
// energyPerTick: number;
UpgradeSite.settings = {
    /** Number of upgrader parts scales with energy minus this value */
    energyBuffer: 100000,
    /**
     * Scaling factor: this much excess energy adds one extra body repetition
     * TODO: scaling needs to increase with new storage/terminal system
     */
    energyPerBodyUnit: 20000,
    /** Required distance to build link */
    minLinkDistance: 10,
    /** Links request energy when less than this amount */
    linksRequestBelow: 200,
};
UpgradeSite = UpgradeSite_1 = __decorate$1([
    profile
], UpgradeSite);

/**
 * The link network controls the flow of energy through various links in a room and uses a greedy matching algorithm
 * to determine where to send energy to
 */
let LinkNetwork = class LinkNetwork {
    constructor(colony) {
        this.colony = colony;
        this.receive = [];
        this.transmit = [];
        this.settings = {
            linksTransmitAt: LINK_CAPACITY - 100,
        };
    }
    refresh() {
        this.receive = [];
        this.transmit = [];
    }
    claimLink(link) {
        if (link) {
            _.remove(this.colony.availableLinks, (l) => l.id == link.id);
        }
    }
    requestReceive(link) {
        this.receive.push(link);
    }
    requestTransmit(link) {
        this.transmit.push(link);
    }
    /**
     * Number of ticks until a dropoff link is available again to deposit energy to
     */
    getDropoffAvailability(link) {
        const dest = this.colony.commandCenter ?
            this.colony.commandCenter.pos
            : this.colony.pos;
        const usualCooldown = link.pos.getRangeTo(dest);
        if (link.energy > this.settings.linksTransmitAt) {
            // Energy will be sent next time cooldown == 0
            return link.cooldown + usualCooldown;
        }
        else {
            return link.cooldown;
        }
    }
    init() {
        // for (let link of this.colony.dropoffLinks) {
        // 	if (link.energy > this.settings.linksTrasmitAt) {
        // 		this.requestTransmit(link);
        // 	}
        // }
    }
    /**
     * Examine the link resource requests and try to efficiently (but greedily) match links that need energy in and
     * out, then send the remaining resourceOut link requests to the command center link
     */
    run() {
        // For each receiving link, greedily get energy from the closest transmitting link - at most 9 operations
        for (const receiveLink of this.receive) {
            const closestTransmitLink = receiveLink.pos.findClosestByRange(this.transmit);
            // If a send-receive match is found, transfer that first, then remove the pair from the link lists
            if (closestTransmitLink) {
                // Send min of (all the energy in sender link, amount of available space in receiver link)
                const amountToSend = _.min([
                    closestTransmitLink.energy,
                    receiveLink.energyCapacity - receiveLink.energy,
                ]);
                closestTransmitLink.transferEnergy(receiveLink, amountToSend);
                _.remove(this.transmit, (link) => link == closestTransmitLink);
                // _.remove(this.receive, link => link == receiveLink);
            }
        }
        // Now send all remaining transmit link requests to the command center
        if (this.colony.commandCenter && this.colony.commandCenter.link) {
            let free = this.colony.commandCenter.link.store.getFreeCapacity(RESOURCE_ENERGY);
            for (const transmitLink of this.transmit) {
                if (free <= 0) {
                    break;
                }
                const available = transmitLink.store.getUsedCapacity(RESOURCE_ENERGY);
                if (free >= available) {
                    transmitLink.transferEnergy(this.colony.commandCenter.link);
                    free -= available;
                }
            }
        }
    }
};
LinkNetwork = __decorate$1([
    profile
], LinkNetwork);

let Matcher = class Matcher {
    constructor(menPrefs, womenPrefs) {
        this.menPrefs = menPrefs;
        this.womenPrefs = womenPrefs;
        this.men = _.keys(menPrefs);
        this.women = _.keys(womenPrefs);
        this.menFree = _.zipObject(this.men, _.map(this.men, () => true));
        this.womenFree = _.zipObject(this.women, _.map(this.women, () => true));
        this.couples = {};
    }
    /* Return whether the woman prefer man1 over man2 */
    prefers(woman, man1, man2) {
        return (_.indexOf(this.womenPrefs[woman], man1) <
            _.indexOf(this.womenPrefs[woman], man2));
    }
    /* Engage a couple <3 */
    engage(man, woman) {
        this.menFree[man] = false;
        this.womenFree[woman] = false;
        _.remove(this.menPrefs[man], (w) => w == woman); // Remove the woman that the man proposed to
        // Don't remove from women prefs since we're matching from men side
        this.couples[man] = woman;
    }
    /* Break up a couple... </3 :'( */
    breakup(man, woman) {
        this.menFree[man] = true;
        this.womenFree[woman] = true;
        // Don't do anything to the preferences of men or women since they've already proposed
        delete this.couples[man];
    }
    /* Return the first free man who still has someone left to propose to */
    nextMan() {
        return _.find(this.men, (man) => this.menFree[man] && this.menPrefs[man].length > 0);
    }
    match() {
        const MAX_ITERATIONS = 1000;
        let count = 0;
        let man = this.nextMan();
        while (man) {
            // While there exists a free man who still has someone to propose to
            if (count > MAX_ITERATIONS) {
                console.log("Stable matching timed out!");
                return this.couples;
            }
            const woman = _.first(this.menPrefs[man]); // Get first woman on man's list
            if (this.womenFree[woman]) {
                // If woman is free, get engaged
                this.engage(man, woman);
            }
            else {
                // Else if woman prefers this man to her current, swap men
                const currentMan = _.findKey(this.couples, (w) => w == woman);
                if (this.prefers(woman, man, currentMan)) {
                    this.breakup(currentMan, woman);
                    this.engage(man, woman);
                }
                else {
                    _.remove(this.menPrefs[man], (w) => w == woman); // Record an unsuccessful proposal
                }
            }
            man = this.nextMan();
            count++;
        }
        return this.couples;
    }
};
Matcher = __decorate$1([
    profile
], Matcher);

var LogisticsNetwork_1;
const RESOURCE_ALL = "all";
const ALL_RESOURCE_TYPE_ERROR = `Improper logistics request: ${RESOURCE_ALL} can only be used for store structure, tombstone, or ruin!`;
const getDefaultLogisticsMemory = () => ({
    transporterCache: {},
});
/**
 * Logistics network: efficiently partners resource requests with transporters using a stable matching algorithm to
 * provide general-purpose resource transport. For a better explanation of how this system works, see my blog post:
 * https://bencbartlett.wordpress.com/2018/03/28/screeps-4-hauling-is-np-hard/
 */
let LogisticsNetwork = LogisticsNetwork_1 = class LogisticsNetwork {
    constructor(colony) {
        this.memory = Mem.wrap(colony.memory, "logisticsNetwork", getDefaultLogisticsMemory);
        this.requests = [];
        this.targetToRequest = {};
        this.colony = colony;
        // this.transporters = _.filter(colony.getCreepsByRole(TransporterSetup.role),
        // 							 creep => !creep.spawning &&
        // 									  creep.carryCapacity >= LogisticsNetwork.settings.carryThreshold);
        this.buffers = _.compact([colony.storage, colony.terminal]);
        this.cache = {
            nextAvailability: {},
            predictedTransporterCarry: {},
            resourceChangeRate: {},
        };
        // this.logisticPositions = {};
        // for (let room of this.colony.rooms) {
        // 	this.logisticPositions[room.name] = _.map([...room.storageUnits, ...room.links], s => s.pos);
        // }
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, "logisticsNetwork", getDefaultLogisticsMemory);
        this.requests = [];
        this.targetToRequest = {};
        this._matching = undefined;
        this.cache = {
            nextAvailability: {},
            predictedTransporterCarry: {},
            resourceChangeRate: {},
        };
    }
    get ref() {
        return `${this.colony.print}>logistics`;
    }
    debug(...args) {
        if (this.memory.debug) {
            log.alert(this.ref, ...args);
        }
    }
    static logRequest(r) {
        return `${r.id}: ${r.amount} of ${r.resourceType} (∂: ${r.dAmountdt}, prio:${r.multiplier}) at ${r.target.print}`;
    }
    // Request and provide functions ===================================================================================
    isTargetValid(target) {
        if (target.pos.availableNeighbors(true).length === 0) {
            return false;
        }
        return true;
    }
    /**
     * Request for resources to be deposited into this target
     */
    requestInput(target, opts = {}) {
        _.defaults(opts, {
            resourceType: RESOURCE_ENERGY,
            multiplier: 1,
            dAmountdt: 0,
        });
        if (target.room != this.colony.room) {
            log.warning(`${target.ref} at ${target.pos.print} is outside colony room; shouldn't request!`);
            return;
        }
        if (opts.resourceType === RESOURCE_ALL) {
            log.warning(`Logistics request error: ${RESOURCE_ALL} can only be used for output requests`);
            return;
        }
        if (!this.isTargetValid(target)) {
            log.warning(`Logistics request error: target input ${target.print} is invalid`);
            return;
        }
        if (!opts.amount) {
            opts.amount = this.getInputAmount(target, opts.resourceType);
        }
        // Register the request
        const requestID = this.requests.length;
        const req = {
            id: requestID.toString(),
            target: target,
            amount: opts.amount,
            dAmountdt: opts.dAmountdt,
            resourceType: opts.resourceType,
            multiplier: opts.multiplier,
        };
        this.debug(() => `requested to deposit ${LogisticsNetwork_1.logRequest(req)}`);
        this.requests.push(req);
        this.targetToRequest[req.target.ref] = requestID;
    }
    /**
     * Request for resources to be withdrawn from this target
     */
    requestOutput(target, opts = {}) {
        var _a;
        if (!this.isTargetValid(target)) {
            log.warning(`Logistics request error: target output ${target.print} is invalid`);
            return;
        }
        let resourceType = (_a = opts.resourceType) !== null && _a !== void 0 ? _a : RESOURCE_ALL;
        let dAmountdt = 0;
        if (isResource(target) &&
            resourceType !== RESOURCE_ALL &&
            target.resourceType !== resourceType) {
            log.warning(`Logistics request error: target output doesn't contain ${opts.resourceType}`);
            return;
        }
        else if (isResource(target) && resourceType === RESOURCE_ALL) {
            resourceType = target.resourceType;
        }
        else if (!isResource(target) && resourceType === RESOURCE_ALL) {
            // convert "all" requests to energy if that's all they have
            if (target.store.getUsedCapacity() == target.store.energy) {
                resourceType = RESOURCE_ENERGY;
            }
        }
        if (isResource(target) && opts.dAmountdt) {
            dAmountdt = Math.ceil(target.amount / 1000);
        }
        _.defaults(opts, {
            resourceType: resourceType,
            amount: this.getOutputAmount(target, resourceType),
            multiplier: 1,
            dAmountdt: dAmountdt,
        });
        opts.amount *= -1;
        opts.dAmountdt *= -1;
        // Register the request
        const requestID = this.requests.length;
        const req = {
            id: requestID.toString(),
            target: target,
            amount: opts.amount,
            dAmountdt: opts.dAmountdt,
            resourceType: opts.resourceType,
            multiplier: opts.multiplier,
        };
        this.debug(() => `requested to pickup ${LogisticsNetwork_1.logRequest(req)}`);
        this.requests.push(req);
        this.targetToRequest[req.target.ref] = requestID;
    }
    /**
     * Requests output for every mineral in a requestor object
     */
    requestOutputMinerals(target, opts = {}) {
        for (const [resourceType, amount] of target.store.contents) {
            if (resourceType == RESOURCE_ENERGY) {
                continue;
            }
            if (amount > 0) {
                opts.resourceType = resourceType;
                this.requestOutput(target, opts);
            }
        }
    }
    getInputAmount(target, resourceType) {
        if (isResource(target) || isTombstone(target) || isRuin(target)) {
            log.error(`Improper logistics request: should not request input for resource or tombstone!`);
            return 0;
        }
        return target.store.getFreeCapacity(resourceType) || 0;
    }
    getOutputAmount(target, resourceType) {
        if (resourceType === RESOURCE_ALL) {
            if (isResource(target)) {
                log.error(ALL_RESOURCE_TYPE_ERROR);
                return 0;
            }
            else {
                return target.store.getUsedCapacity() || 0;
            }
        }
        else {
            if (isResource(target)) {
                return target.amount;
            }
            else {
                return target.store.getUsedCapacity(resourceType) || 0;
            }
        }
    }
    // Transporter availability and predictive functions ===============================================================
    computeNextAvailability(transporter) {
        var _a, _b;
        if (transporter.spawning) {
            return [
                (_a = transporter.ticksUntilSpawned) !== null && _a !== void 0 ? _a : 0,
                (_b = transporter.spawnPos) !== null && _b !== void 0 ? _b : transporter.pos,
            ];
        }
        if (transporter.task) {
            let approximateDistance = transporter.task.eta;
            const targetPositions = transporter.task.targetPosManifest;
            let pos = targetPositions.shift();
            // this.debug(() => `computeNextAvailability: ${transporter.print}@${pos.print}: eta: ${approximateDistance}, pos: ${targetPositions.map(p => p.print)}`);
            // If there is a well-defined task ETA, use that as the first leg, else set dist to zero and use range
            if (approximateDistance) {
                for (const targetPos of targetPositions) {
                    // The path lengths between any two logistics targets should be well-memorized
                    approximateDistance += Math.ceil(pos.getMultiRoomRangeTo(targetPos) *
                        LogisticsNetwork_1.settings.rangeToPathHeuristic);
                    // approximateDistance += Pathing.distance(pos, targetPos);
                    pos = targetPos;
                }
            }
            else {
                // This probably shouldn't happen...
                approximateDistance = 0;
                for (const targetPos of targetPositions) {
                    approximateDistance += Math.ceil(pos.getMultiRoomRangeTo(targetPos) *
                        LogisticsNetwork_1.settings.rangeToPathHeuristic);
                    // approximateDistance += Pathing.distance(pos, targetPos);
                    pos = targetPos;
                }
            }
            return [approximateDistance, pos];
        }
        else {
            return [0, transporter.pos];
        }
    }
    /**
     * Number of ticks until the transporter is available and where it will be
     */
    nextAvailability(transporter) {
        if (!this.cache.nextAvailability[transporter.name]) {
            this.cache.nextAvailability[transporter.name] =
                this.computeNextAvailability(transporter);
        }
        return this.cache.nextAvailability[transporter.name];
    }
    static targetingTransporters(target, excludedTransporter) {
        const targetingZerg = _.map(target.targetedBy, (name) => Overmind.zerg[name]);
        const targetingTransporters = _.filter(targetingZerg, (zerg) => zerg.roleName == Roles.transport);
        if (excludedTransporter) {
            _.remove(targetingTransporters, (transporter) => transporter.name == excludedTransporter.name);
        }
        return targetingTransporters;
    }
    /**
     * Returns the predicted state of the transporter's carry after completing its current task
     */
    computePredictedTransporterCarry(transporter, nextAvailability) {
        if (transporter.task && transporter.task.target) {
            const requestID = this.targetToRequest[transporter.task.target.ref];
            if (requestID) {
                const request = this.requests[requestID];
                if (request) {
                    const carry = transporter.store;
                    const remainingCapacity = carry.getFreeCapacity();
                    const resourceAmount = -1 *
                        this.predictedRequestAmount(transporter, request, nextAvailability);
                    // ^ need to multiply amount by -1 since transporter is doing complement of what request needs
                    if (request.resourceType === RESOURCE_ALL) {
                        if (isResource(request.target)) {
                            log.error(ALL_RESOURCE_TYPE_ERROR);
                            return { energy: 0 };
                        }
                        for (const [resourceType, storeAmt] of request.target
                            .store.contents) {
                            const resourceFraction = storeAmt /
                                (request.target.store.getUsedCapacity(resourceType) || storeAmt);
                            if (carry[resourceType]) {
                                carry[resourceType] +=
                                    resourceAmount * resourceFraction;
                                carry[resourceType] = minMax(carry[resourceType], 0, remainingCapacity);
                            }
                            else {
                                carry[resourceType] = minMax(resourceAmount, 0, remainingCapacity);
                            }
                        }
                    }
                    else {
                        if (carry[request.resourceType]) {
                            carry[request.resourceType] += resourceAmount;
                            carry[request.resourceType] = minMax(carry[request.resourceType], 0, remainingCapacity);
                        }
                        else {
                            carry[request.resourceType] = minMax(resourceAmount, 0, remainingCapacity);
                        }
                    }
                    return carry;
                }
            }
        }
        return transporter.store;
    }
    /**
     * Returns the predicted state of the transporter's carry after completing its task
     */
    predictedTransporterCarry(transporter) {
        if (!this.cache.predictedTransporterCarry[transporter.name]) {
            this.cache.predictedTransporterCarry[transporter.name] =
                this.computePredictedTransporterCarry(transporter);
        }
        return this.cache.predictedTransporterCarry[transporter.name];
    }
    /**
     * Returns the effective amount that a transporter will see upon arrival, accounting for other targeting creeps
     */
    predictedRequestAmount(transporter, request, nextAvailability) {
        var _a, _b, _c;
        // Figure out when/where the transporter will be free
        let busyUntil;
        let newPos;
        if (!nextAvailability) {
            [busyUntil, newPos] = this.nextAvailability(transporter);
        }
        else {
            [busyUntil, newPos] = nextAvailability;
        }
        // let eta = busyUntil + Pathing.distance(newPos, request.target.pos);
        const eta = busyUntil +
            LogisticsNetwork_1.settings.rangeToPathHeuristic *
                newPos.getMultiRoomRangeTo(request.target.pos);
        const predictedDifference = request.dAmountdt * eta; // dAmountdt has same sign as amount
        // Account for other transporters targeting the target
        const otherTargetingTransporters = LogisticsNetwork_1.targetingTransporters(request.target, transporter);
        // let closerTargetingTransporters = _.filter(otherTargetingTransporters,
        // 										   transporter => this.nextAvailability(transporter)[0] < eta);
        let targetCapacity;
        if (isResource(request.target)) {
            targetCapacity = request.target.amount;
        }
        else if (isTombstone(request.target)) {
            targetCapacity =
                request.resourceType === RESOURCE_ALL ?
                    _.sum(request.target.store.contents)
                    : (_a = request.target.store[request.resourceType]) !== null && _a !== void 0 ? _a : 0;
        }
        else {
            targetCapacity =
                request.resourceType === RESOURCE_ALL ?
                    (_b = request.target.store.getCapacity()) !== null && _b !== void 0 ? _b : 0
                    : (_c = request.target.store.getCapacity(request.resourceType)) !== null && _c !== void 0 ? _c : 0;
        }
        const prefix = `${transporter.print} ${request.target.print}:`;
        this.debug(() => `${prefix} target capacity: ${targetCapacity}, ${otherTargetingTransporters.length} transporters also heading there`);
        if (request.amount > 0) {
            // input state, resources into target
            let predictedAmount = request.amount + predictedDifference;
            if (!isResource(request.target)) {
                predictedAmount = minMax(predictedAmount, 0, targetCapacity);
            }
            this.debug(() => `${prefix} predicted amount after drop off: ${predictedAmount}`);
            const resourceInflux = _.sum(_.map(otherTargetingTransporters, (other) => other.store[request.resourceType] || 0));
            this.debug(() => `${prefix} estimated influx: ${resourceInflux}`);
            predictedAmount = Math.max(predictedAmount - resourceInflux, 0);
            this.debug(() => `${prefix} final predicted amount after drop off: ${predictedAmount}`);
            return predictedAmount;
        }
        else {
            // output state, resources withdrawn from target
            let predictedAmount = request.amount + predictedDifference;
            if (!isResource(request.target)) {
                predictedAmount = minMax(predictedAmount, -1 * targetCapacity, 0);
            }
            this.debug(() => `${prefix} predicted amount after pickup: ${predictedAmount}`);
            const resourceOutflux = _.sum(_.map(otherTargetingTransporters, (other) => other.store.getCapacity() -
                other.store.getUsedCapacity()));
            this.debug(() => `${prefix} estimated outflux: ${resourceOutflux}`);
            predictedAmount = Math.min(predictedAmount + resourceOutflux, 0);
            this.debug(() => `${prefix} final predicted amount after pickup: ${predictedAmount}`);
            return predictedAmount;
        }
    }
    // Functions for computing resource change rate ====================================================================
    /**
     * Consider all possibilities of buffer structures to visit on the way to fulfilling the request
     */
    bufferChoices(transporter, request) {
        const [ticksUntilFree, newPos] = this.nextAvailability(transporter);
        const choices = [];
        const amount = this.predictedRequestAmount(transporter, request, [
            ticksUntilFree,
            newPos,
        ]);
        let carry;
        if (!transporter.task || transporter.task.target != request.target) {
            // If you are not targeting the requestor, use predicted carry after completing current task
            carry = this.predictedTransporterCarry(transporter);
        }
        else {
            // If you are targeting the requestor, use current carry for computations
            carry = transporter.store;
        }
        if (amount > 0) {
            // requestInput instance, needs refilling
            if (request.resourceType === RESOURCE_ALL) {
                log.warning(`Improper resourceType in bufferChoices! Type ${RESOURCE_ALL} is only allowable for outputs!`);
                return [];
            }
            // Change in resources if transporter goes straight to the input
            const dQ_direct = Math.min(amount, carry[request.resourceType] || 0);
            // let dt_direct = Pathing.distance(newPos, request.target.pos) + ticksUntilFree;
            const dt_direct = ticksUntilFree +
                newPos.getMultiRoomRangeTo(request.target.pos) *
                    LogisticsNetwork_1.settings.rangeToPathHeuristic;
            choices.push({
                dQ: dQ_direct,
                dt: dt_direct,
                targetRef: request.target.ref,
            });
            if ((carry[request.resourceType] || 0) > amount ||
                _.sum(carry) == transporter.store.getCapacity()) {
                return choices; // Return early if you already have enough resources to go direct or are already full
            }
            // Change in resources if transporter picks up resources from a buffer first
            for (const buffer of this.buffers) {
                const dQ_buffer = Math.min(amount, transporter.store.getCapacity(), buffer.store[request.resourceType] || 0);
                const dt_buffer = newPos.getMultiRoomRangeTo(buffer.pos) *
                    LogisticsNetwork_1.settings.rangeToPathHeuristic +
                    (Pathing.distance(buffer.pos, request.target.pos) ||
                        Infinity) +
                    ticksUntilFree;
                choices.push({
                    dQ: dQ_buffer,
                    dt: dt_buffer,
                    targetRef: buffer.ref,
                });
            }
        }
        else if (amount < 0) {
            // requestOutput instance, needs pickup
            // Change in resources if transporter goes straight to the output
            const remainingCarryCapacity = transporter.store.getCapacity() - _.sum(carry);
            const dQ_direct = Math.min(Math.abs(amount), remainingCarryCapacity);
            const dt_direct = newPos.getMultiRoomRangeTo(request.target.pos) *
                LogisticsNetwork_1.settings.rangeToPathHeuristic +
                ticksUntilFree;
            choices.push({
                dQ: dQ_direct,
                dt: dt_direct,
                targetRef: request.target.ref,
            });
            if (remainingCarryCapacity >= Math.abs(amount) ||
                remainingCarryCapacity == transporter.store.getCapacity()) {
                return choices; // Return early you have sufficient free space or are empty
            }
            // Change in resources if transporter drops off resources at a buffer first
            for (const buffer of this.buffers) {
                const dQ_buffer = Math.min(Math.abs(amount), transporter.store.getCapacity(), buffer.store.getFreeCapacity());
                const dt_buffer = newPos.getMultiRoomRangeTo(buffer.pos) *
                    LogisticsNetwork_1.settings.rangeToPathHeuristic +
                    (Pathing.distance(buffer.pos, request.target.pos) ||
                        Infinity) +
                    ticksUntilFree;
                choices.push({
                    dQ: dQ_buffer,
                    dt: dt_buffer,
                    targetRef: buffer.ref,
                });
            }
            // if (carry[RESOURCE_ENERGY]) {
            // 	// Only for when you're picking up more energy: check to see if you can put to available links
            // 	for (const link of this.colony.links) {
            // 		const linkDeltaResource = Math.min(Math.abs(amount), transporter.store.getCapacity(),
            // 			2 * link.energyCapacity);
            // 		const ticksUntilDropoff = Math.max(Pathing.distance(newPos, link.pos) || Infinity,
            // 										 this.colony.linkNetwork.getDropoffAvailability(link));
            // 		const linkDistance = ticksUntilDropoff +
            // 						   (Pathing.distance(link.pos, newPos) || Infinity) + ticksUntilFree;
            // 		choices.push({
            // 						 dQ: linkDeltaResource,
            // 						 dt: linkDistance,
            // 						 targetRef: link.ref
            // 					 });
            // 	}
            // }
        }
        return choices;
    }
    /**
     * Compute the best possible value of |dResource / dt|
     */
    resourceChangeRate(transporter, request) {
        if (!this.cache.resourceChangeRate[request.id]) {
            this.cache.resourceChangeRate[request.id] = {};
        }
        if (!this.cache.resourceChangeRate[request.id][transporter.name]) {
            const choices = this.bufferChoices(transporter, request);
            const dQ_dt = _.map(choices, (choice) => (request.multiplier * choice.dQ) / Math.max(choice.dt, 0.1));
            this.cache.resourceChangeRate[request.id][transporter.name] =
                _.max(dQ_dt);
        }
        return this.cache.resourceChangeRate[request.id][transporter.name];
    }
    /**
     * Generate requestor preferences in terms of transporters
     */
    requestPreferences(request, transporters) {
        // Requestors priortize transporters by change in resources per tick until pickup/delivery
        return _.sortBy(transporters, (transporter) => -1 * this.resourceChangeRate(transporter, request)); // -1 -> desc
    }
    /**
     * Generate transporter preferences in terms of store structures
     */
    transporterPreferences(transporter) {
        // Transporters prioritize requestors by change in resources per tick until pickup/delivery
        return _.sortBy(this.requests, (request) => -1 * this.resourceChangeRate(transporter, request)); // -1 -> desc
    }
    /**
     * Invalidates relevant portions of the cache once a transporter is assigned to a task
     */
    invalidateCache(transporter, request) {
        delete this.cache.nextAvailability[transporter.name];
        delete this.cache.predictedTransporterCarry[transporter.name];
        delete this.cache.resourceChangeRate[request.id][transporter.name];
    }
    /**
     * Logs the output of the stable matching result
     */
    summarizeMatching() {
        const requests = this.requests.slice();
        const transporters = _.filter(this.colony.getCreepsByRole(Roles.transport), (creep) => isCreep(creep) && !creep.spawning);
        const unmatchedTransporters = _.remove(transporters, (transporter) => !_.keys(this._matching).includes(transporter.name));
        const unmatchedRequests = _.remove(requests, (request) => !_.values(this._matching).includes(request));
        console.log(`Stable matching for ${this.colony.name} at ${Game.time}`);
        for (const transporter of transporters) {
            const transporterStr = transporter.name + " " + transporter.pos.print;
            const request = this._matching[transporter.name];
            const requestStr = request.target.print;
            console.log(`${transporterStr.padEnd(35)} : ${requestStr}`);
        }
        for (const transporter of unmatchedTransporters) {
            const transporterStr = transporter.name + " " + transporter.pos.print;
            console.log(`${transporterStr.padEnd(35)} : ${""}`);
        }
        for (const request of unmatchedRequests) {
            const requestStr = request.target.print;
            console.log(`${"".padEnd(35)} : ${requestStr}`);
        }
        console.log();
    }
    /**
     * Logs the current state of the logistics group to the console; useful for debugging
     */
    summarize() {
        // console.log(`Summary of logistics group for ${this.colony.name} at time ${Game.time}`);
        let info = [];
        for (const request of this.requests) {
            let targetType;
            if (isResource(request.target)) {
                targetType = "resource";
            }
            else if (isTombstone(request.target)) {
                targetType = "tombstone";
            }
            else if (isRuin(request.target)) {
                targetType = "ruin";
            }
            else {
                targetType = request.target.structureType;
            }
            let amount = 0;
            if (isResource(request.target)) {
                amount = request.target.amount;
            }
            else {
                if (request.resourceType === RESOURCE_ALL) {
                    if (!isResource(request.target)) {
                        amount = request.target.store.getUsedCapacity() || 0;
                    }
                    else {
                        amount = -0.001;
                    }
                }
                else {
                    if (isResource(request.target)) {
                        amount = request.target.amount;
                    }
                    else {
                        amount = request.target.store[request.resourceType];
                    }
                }
            }
            const targetingTprtrNames = _.map(LogisticsNetwork_1.targetingTransporters(request.target), (c) => c.name);
            info.push({
                target: targetType,
                type: request.resourceType,
                prio: request.multiplier,
                requested: request.amount,
                current: amount,
                "∂Current": request.dAmountdt,
                targetedBy: targetingTprtrNames,
                pos: request.target.pos.print,
            });
        }
        console.log("Requests: \n" + columnify$1(info) + "\n");
        info = [];
        for (const transporter of this.colony.overlords.logistics
            .transporters) {
            const task = transporter.task ? transporter.task.name : "none";
            const target = transporter.task ?
                transporter.task.proto._target.ref +
                    " " +
                    transporter.task.targetPos.printPlain
                : "none";
            const nextAvailability = this.nextAvailability(transporter);
            info.push({
                creep: transporter.name,
                pos: transporter.pos.printPlain,
                task: transporter.spawning ? "spawning" : task,
                target: target,
                size: transporter.store.getCapacity(),
                free: transporter.store.getFreeCapacity(),
                availability: `available in ${nextAvailability[0]} ticks at ${nextAvailability[1].print}`,
            });
        }
        console.log("Transporters: \n" + columnify$1(info) + "\n");
    }
    get matching() {
        if (!this._matching) {
            this._matching = this.stableMatching(this.colony.overlords.logistics.transporters);
        }
        return this._matching;
    }
    /**
     * Generate a stable matching of transporters to requests with Gale-Shapley algorithm
     */
    stableMatching(transporters) {
        const tPrefs = {};
        for (const transporter of transporters) {
            tPrefs[transporter.name] = _.map(this.transporterPreferences(transporter), (request) => request.id);
        }
        const rPrefs = {};
        for (const request of this.requests) {
            rPrefs[request.id] = _.map(this.requestPreferences(request, transporters), (transporter) => transporter.name);
        }
        const stableMatching = new Matcher(tPrefs, rPrefs).match();
        const requestMatch = _.mapValues(stableMatching, (reqID) => _.find(this.requests, (request) => request.id == reqID));
        return requestMatch;
    }
    bestRequestForTransporter(transporter) {
        var _a;
        const canUseFullMatching = transporter.store.getCapacity() >=
            LogisticsNetwork_1.settings.carryThreshold;
        const canAffordCPU = ((_a = Memory.stats.persistent.avgBucketDelta) !== null && _a !== void 0 ? _a : 0) >= 10;
        if (canUseFullMatching && canAffordCPU) {
            return this.colony.logisticsNetwork.matching[transporter.name];
        }
        else {
            const requests = this.transporterPreferences(transporter);
            // Just perform a single-sided greedy selection of all requests
            // WIP: this doesn't really work, as it causes each transporter to pick the same "best" request,
            // look at it and either go grab it, or park
            const bestRequestViaGreedy = _.first(requests);
            this.debug(() => `requests:\n${requests
                .map((r) => `\t- ${LogisticsNetwork_1.logRequest(r)} rate: ${this.resourceChangeRate(transporter, r)}${bestRequestViaGreedy.id === r.id ?
                " (*)"
                : ""}`)
                .join("\n")}`);
            return bestRequestViaGreedy;
        }
    }
};
LogisticsNetwork.settings = {
    flagDropAmount: 1000,
    /** findClosestByRange * this ~= findClosestByPos except in pathological cases */
    rangeToPathHeuristic: 1.1,
    /** only do stable matching on transporters at least this big (RCL4+) */
    carryThreshold: 800,
    /** ignore dropped energy below this amount */
    droppedEnergyThreshold: 200,
};
LogisticsNetwork = LogisticsNetwork_1 = __decorate$1([
    profile
], LogisticsNetwork);

var RoadLogistics_1;
const ROAD_CACHE_TIMEOUT = 25;
/**
 * RoadLogistics: groups roads in a single object for more intelligent repair requests
 */
let RoadLogistics = RoadLogistics_1 = class RoadLogistics {
    constructor(colony) {
        this.colony = colony;
        this.ref = this.colony.name + ":roadLogistics";
        this._assignedWorkers = {};
    }
    refresh() {
        this._assignedWorkers = {};
    }
    /**
     * Whether a road in the network needs repair
     */
    workerShouldRepaveRoom(worker, room) {
        // Room should be repaved if there is a road with critical HP or if energy to repave >= worker carry capacity
        const otherAssignedWorkers = _.filter(this.assignedWorkers(room), (name) => name != worker.name);
        if (otherAssignedWorkers.length <
            RoadLogistics_1.settings.allowedPaversPerRoom) {
            if (this.assignedWorkers(room).includes(worker.name)) {
                // If worker is already working in the room, have it repair until all roads are at acceptable level
                return this.repairableRoads(room).length > 0;
            }
            else {
                // If worker is not already assigned, repair if critical roads or repaving energy >= carry capacity
                return (this.criticalRoads(room).length > 0 ||
                    this.energyToRepave(room.name) >= worker.store.getCapacity());
            }
        }
        else {
            return false;
        }
    }
    /**
     * Get the room the worker should repave, if any
     */
    workerShouldRepave(worker) {
        // If the worker is already working in a room and should keep doing so, return that first
        if (worker.task && worker.task.name == repairTaskName) {
            const room = Game.rooms[worker.task.targetPos.roomName];
            if (room &&
                this.assignedWorkers(room).includes(worker.name) &&
                this.workerShouldRepaveRoom(worker, room)) {
                return room;
            }
        }
        // Otherwise scan through rooms and see if needs repaving
        for (const room of this.colony.rooms) {
            if (this.colony.isRoomActive(room.name) &&
                room.isSafe &&
                this.workerShouldRepaveRoom(worker, room)) {
                return room;
            }
        }
    }
    criticalRoads(room) {
        return $.structures(this, "criticalRoads:" + room.name, () => {
            const criticalRoads = _.filter(room.roads, (road) => road.hits <
                road.hitsMax *
                    RoadLogistics_1.settings.criticalThreshold &&
                this.colony.roomPlanner.roadShouldBeHere(road.pos));
            return _.sortBy(criticalRoads, (road) => road.pos.getMultiRoomRangeTo(this.colony.pos));
        }, ROAD_CACHE_TIMEOUT);
    }
    repairableRoads(room) {
        return $.structures(this, "repairableRoads:" + room.name, () => {
            const repairRoads = _.filter(room.roads, (road) => road.hits <
                road.hitsMax *
                    RoadLogistics_1.settings.repairThreshold &&
                this.colony.roomPlanner.roadShouldBeHere(road.pos));
            return _.sortBy(repairRoads, (road) => road.pos.getMultiRoomRangeTo(this.colony.pos));
        }, ROAD_CACHE_TIMEOUT);
    }
    unbuiltRoads(room) {
        return $.list(this, "repairableRoads:" + room.name, () => {
            const roadPositions = this.colony.roomPlanner.roadPlanner.getRoadPositions(room.name);
            const unbuiltPositions = _.filter(roadPositions, (pos) => !pos.lookForStructure(STRUCTURE_ROAD));
            return _.sortBy(unbuiltPositions, (pos) => pos.getMultiRoomRangeTo(this.colony.pos));
        }, ROAD_CACHE_TIMEOUT);
    }
    /**
     * Total amount of energy needed to repair all roads in the room and build all needed roads
     */
    energyToRepave(roomName) {
        const room = Game.rooms[roomName];
        if (room) {
            return $.number(this, "energyToRepave:" + room.name, () => {
                const repairEnergy = _.sum(this.repairableRoads(room), (road) => road.hitsMax - road.hits) / REPAIR_POWER;
                const terrain = room.getTerrain();
                const buildEnergy = _.sum(this.unbuiltRoads(room), (pos) => {
                    if (terrain.get(pos.x, pos.y) == TERRAIN_MASK_SWAMP) {
                        return (CONSTRUCTION_COST.road *
                            CONSTRUCTION_COST_ROAD_SWAMP_RATIO);
                    }
                    else if (terrain.get(pos.x, pos.y) == TERRAIN_MASK_WALL) {
                        return (CONSTRUCTION_COST.road *
                            CONSTRUCTION_COST_ROAD_WALL_RATIO);
                    }
                    else {
                        return CONSTRUCTION_COST.road;
                    }
                }) / BUILD_POWER;
                return repairEnergy + buildEnergy;
            }, ROAD_CACHE_TIMEOUT);
        }
        else {
            const cached = $.numberRecall(this, "energyToRepave:" + roomName);
            if (cached) {
                return cached;
            }
            else {
                return 0;
            }
        }
    }
    /**
     * Check that the worker is in the assignedWorker cache; avoids bugs where duplicate workers get assigned
     * on the same tick
     */
    registerWorkerAssignment(worker, room) {
        if (this._assignedWorkers[room.name]) {
            if (!this._assignedWorkers[room.name].includes(worker.name)) {
                this._assignedWorkers[room.name].push(worker.name);
            }
        }
        else {
            this._assignedWorkers[room.name] = [worker.name];
        }
    }
    assignedWorkers(room) {
        return this._assignedWorkers[room.name] || [];
    }
    init() {
        const workers = this.colony.overlords.work.workers;
        for (const worker of workers) {
            if (worker.task && worker.task.name == repairTaskName) {
                const roomName = worker.task.targetPos.roomName;
                if (!this._assignedWorkers[roomName]) {
                    this._assignedWorkers[roomName] = [];
                }
                this._assignedWorkers[roomName].push(worker.name);
            }
        }
    }
    buildPavingManifest(worker, room) {
        let energy = worker.store.energy;
        const targetRefs = {};
        const tasks = [];
        let target;
        let previousPos;
        while (true) {
            if (energy <= 0) {
                break;
            }
            if (previousPos) {
                target = _.find(this.repairableRoads(room), (road) => road.hits < road.hitsMax &&
                    !targetRefs[road.id] &&
                    road.pos.getRangeTo(previousPos) <= 1);
            }
            else {
                target = _.find(this.repairableRoads(room), (road) => road.hits < road.hitsMax && !targetRefs[road.id]);
            }
            if (target) {
                previousPos = target.pos;
                targetRefs[target.id] = true;
                energy -= (target.hitsMax - target.hits) / REPAIR_POWER;
                tasks.push(Tasks$1.repair(target));
            }
            else {
                break;
            }
        }
        return Tasks$1.chain(tasks);
    }
    run() { }
};
RoadLogistics.settings = {
    allowedPaversPerRoom: 1,
    criticalThreshold: 0.25, // When the roadnetwork forces a repair store
    repairThreshold: 0.9,
};
RoadLogistics = RoadLogistics_1 = __decorate$1([
    profile
], RoadLogistics);

/**
 * This overlord contains the default actions for any creeps which lack an overlord (for example, miners whose
 * miningSite is no longer visible, or guards with no directive)
 */
let DefaultOverlord = class DefaultOverlord extends Overlord {
    constructor(colony) {
        super(colony, "default", OverlordPriority.default);
        this.idleZerg = [];
        this.retiredZerg = [];
        this.refreshZerg = new Map();
    }
    init() {
        // Zergs are collected at end of init phase; by now anything needing to be claimed already has been
        const colonyZergs = _.map(this.colony.creeps, (creep) => Overmind.zerg[creep.name] || (isCreep(creep) && new Zerg(creep)));
        this.idleZerg = _.filter(colonyZergs, (zerg) => !zerg.overlord);
        for (const zerg of this.idleZerg) {
            this.refreshZerg.set(zerg.id, zerg);
        }
        this.retiredZerg = _.filter(colonyZergs, (zerg) => { var _a; return ((_a = zerg.task) === null || _a === void 0 ? void 0 : _a.name) === "retire"; });
        for (const zerg of this.retiredZerg) {
            this.refreshZerg.set(zerg.id, zerg);
        }
        this.debug(() => {
            const obj = {
                idle: this.idleZerg.map((z) => z.print).join(", "),
                retired: this.retiredZerg.map((z) => z.print).join(", "),
            };
            return `${this.print}: ${JSON.stringify(obj)}`;
        });
        for (const [_id, zerg] of this.refreshZerg) {
            zerg.refresh();
        }
    }
    handleIdle(_zerg) {
        // We do nothing here, this only exists so manually scheduled tasks to idle creeps get to run
    }
    handleRetired(_zerg) {
        // We do nothing here, this only exists so manually scheduled tasks to idle creeps get to run
    }
    run() {
        this.autoRun(this.idleZerg, (idleZerg) => this.handleIdle(idleZerg));
        this.autoRun(this.retiredZerg, (idleZerg) => this.handleRetired(idleZerg));
    }
};
DefaultOverlord = __decorate$1([
    profile
], DefaultOverlord);

const MAX_TRANSPORTERS = 10;
/**
 * The transport overlord handles energy transport throughout a colony
 */
let TransportOverlord = class TransportOverlord extends Overlord {
    constructor(colony, priority = OverlordPriority.ownedRoom.transport) {
        super(colony, "logistics", priority);
        this.transporters = this.zerg(Roles.transport);
    }
    get neededTransportPower() {
        return $.number(this, "_neededTransportPower", () => {
            var _a, _b, _c;
            if (!this.colony.storage &&
                !(this.colony.hatchery && this.colony.hatchery.batteries) &&
                !this.colony.upgradeSite.battery) {
                this.debug(`no transport needed`);
                return 0;
            }
            // aggregate round-trip multiplier
            let scaling = 2;
            if (this.colony.level < 3) {
                scaling = 0.6;
            }
            else if (this.colony.level < 5) {
                scaling = 0.9;
            }
            // Add contributions to transport power from hauling energy from mining sites
            let neededForMining = 0;
            for (const flagName in this.colony.miningSites) {
                const o = this.colony.miningSites[flagName].overlords.mine;
                this.debug(() => {
                    const data = {
                        suspended: o.isSuspended,
                        miners: o.miners.length,
                        container: o.container && !o.link,
                        drop: o.allowDropMining,
                    };
                    return `checking mine ${o.print}: ${JSON.stringify(data)}`;
                });
                // Only count sites that are active, have a miner present,
                // and if the colony is rebooting, has at least 1000 energy to fetch.
                // This helps in difficult "rebooting" situations and stops transporters
                // from jamming the spawn queue.
                if (o.isSuspended ||
                    o.miners.length === 0 ||
                    (this.colony.state.bootstrapping &&
                        !o.allowDropMining &&
                        ((_b = (_a = (o.container || o.link)) === null || _a === void 0 ? void 0 : _a.store.getUsedCapacity(RESOURCE_ENERGY)) !== null && _b !== void 0 ? _b : 0) > 1000)) {
                    continue;
                }
                if ((o.container && !o.link) || o.allowDropMining) {
                    neededForMining +=
                        Math.max(o.maxEnergyPerTick, o.avgEnergyPerTick) *
                            scaling *
                            o.distance;
                }
            }
            // Add transport power needed to move to upgradeSite
            let neededForUpgraders = 0;
            if (this.colony.upgradeSite.battery) {
                neededForUpgraders +=
                    UPGRADE_CONTROLLER_POWER *
                        this.colony.upgradeSite.upgradePowerNeeded *
                        scaling *
                        ((_c = Pathing.distance(this.colony.pos, this.colony.upgradeSite.battery.pos)) !== null && _c !== void 0 ? _c : 0);
            }
            let transportPower = neededForMining + neededForUpgraders;
            const { lowPowerMode, isOverfilled } = this.colony.state;
            // Severely limit the number of transporters if we're overfilled
            if (isOverfilled) {
                transportPower = 2000;
            }
            // Reduce needed transporters when colony is in low power mode
            if (lowPowerMode) {
                transportPower *= 0.5;
            }
            this.debug(`neededTransportPower: ${transportPower / CARRY_CAPACITY}, mining: ${neededForMining}, upgrading: ${neededForUpgraders}, ${JSON.stringify({ lowPowerMode, isOverfilled })}`);
            return transportPower / CARRY_CAPACITY;
        }, 5);
    }
    init() {
        const ROAD_COVERAGE_THRESHOLD = 0.75; // switch from 1:1 to 2:1 transporters above this coverage threshold
        const setup = (this.colony.roomPlanner.roadPlanner.roadCoverage <
            ROAD_COVERAGE_THRESHOLD) ?
            Setups.transporters.early
            : Setups.transporters.default;
        const transportPowerEach = setup.getBodyPotential(CARRY, this.colony);
        const neededTransportPower = this.neededTransportPower;
        let numTransporters = 0;
        if (transportPowerEach !== 0) {
            numTransporters = Math.ceil(neededTransportPower / transportPowerEach);
        }
        numTransporters = Math.min(numTransporters, MAX_TRANSPORTERS);
        this.debug(`requesting ${numTransporters} (current: ${this.transporters.length}) because of ${neededTransportPower} needed by ${transportPowerEach}`);
        if (this.transporters.length === 0) {
            this.wishlist(numTransporters, setup, {
                priority: OverlordPriority.ownedRoom.firstTransport,
            });
        }
        else if (numTransporters < this.colony.room.sources.length + 1) {
            this.wishlist(numTransporters, setup);
        }
        else {
            this.wishlist(numTransporters, setup, {
                priority: OverlordPriority.remoteRoom.transport,
            });
        }
    }
    handleTransporter(transporter, request) {
        let prefix = `${transporter.print}`;
        if (request) {
            const choices = this.colony.logisticsNetwork.bufferChoices(transporter, request);
            const bestChoice = _.last(_.sortBy(choices, (choice) => (request.multiplier * choice.dQ) /
                Math.max(choice.dt, 0.1)));
            let task = null;
            const amount = this.colony.logisticsNetwork.predictedRequestAmount(transporter, request);
            prefix = `${transporter.print}: request ${LogisticsNetwork.logRequest(request)}, predicted: ${amount}`;
            this.debug(() => `${prefix} buffer choices:\n` + columnify$1(choices));
            // Target is requesting input
            if (amount > 0) {
                if (isResource(request.target) ||
                    isTombstone(request.target) ||
                    isRuin(request.target)) {
                    log.warning(`Improper logistics request: should not request input for resource, tombstone or ruin!`);
                    return;
                }
                else if (request.resourceType === RESOURCE_ALL) {
                    log.error(`${this.print}: cannot request 'all' as input!`);
                    return;
                }
                else {
                    task = Tasks$1.transfer(request.target, request.resourceType);
                }
                if (bestChoice.targetRef != request.target.ref) {
                    // If we need to go to a buffer first to get more stuff
                    const buffer = deref(bestChoice.targetRef);
                    const withdrawAmount = Math.min(buffer.store[request.resourceType] || 0, transporter.store.getFreeCapacity(request.resourceType), amount);
                    this.debug(() => `${prefix}: going to ${buffer.print} to collect before dropping off`);
                    task = task.fork(Tasks$1.withdraw(buffer, request.resourceType, withdrawAmount));
                    if (transporter.hasMineralsInCarry &&
                        request.resourceType == RESOURCE_ENERGY) {
                        task = task.fork(Tasks$1.transferAll(buffer));
                    }
                }
            }
            else if (amount < 0) {
                // Target is requesting output
                if (isResource(request.target)) {
                    this.debug(() => `${prefix}: picking up resource`);
                    task = Tasks$1.pickup(request.target);
                }
                else if (request.resourceType === RESOURCE_ALL) {
                    if (isResource(request.target)) {
                        log.error(`${this.print} ${ALL_RESOURCE_TYPE_ERROR}`);
                        return;
                    }
                    this.debug(() => `${prefix}: withdrawing everything`);
                    task = Tasks$1.withdrawAll(request.target);
                }
                else {
                    this.debug(() => `${prefix}: withdrawing`);
                    task = Tasks$1.withdraw(request.target, request.resourceType);
                }
                if (bestChoice.targetRef != request.target.ref) {
                    // If we need to go to a buffer first to deposit stuff
                    const buffer = deref(bestChoice.targetRef);
                    this.debug(() => `${prefix}: needs a buffer first, using ${buffer.print}`);
                    task = task.fork(Tasks$1.transferAll(buffer));
                }
            }
            else {
                this.debug(() => `${prefix}: no resources expected, parking`);
                transporter.park();
            }
            // Assign the task to the transporter
            transporter.task = task;
            this.colony.logisticsNetwork.invalidateCache(transporter, request);
        }
        else {
            // If nothing to do, put everything in a store structure
            if (transporter.store.getUsedCapacity() > 0) {
                if (transporter.hasMineralsInCarry) {
                    const target = this.colony.terminal || this.colony.storage;
                    if (target) {
                        this.debug(() => `${prefix}: nothing to do, dropping off ` +
                            `everything to ${target}@${target.pos.print}`);
                        transporter.task = Tasks$1.transferAll(target);
                    }
                }
                else {
                    const dropoffPoints = _.compact([this.colony.storage, ...this.colony.links]);
                    const bestDropoffPoint = minBy(dropoffPoints, (dropoff) => {
                        const range = transporter.pos.getMultiRoomRangeTo(dropoff.pos);
                        if (dropoff instanceof StructureLink) {
                            return Math.max(range, this.colony.linkNetwork.getDropoffAvailability(dropoff));
                        }
                        else {
                            return range;
                        }
                    });
                    // const bestDropoffPoint: StructureLink | StructureStorage | undefined
                    // 	= transporter.pos.findClosestByMultiRoomRange(dropoffPoints);
                    if (bestDropoffPoint) {
                        this.debug(() => `${prefix}: nothing to do, dropping off to ` +
                            `${bestDropoffPoint}@${bestDropoffPoint.pos.print}`);
                        transporter.task = Tasks$1.transfer(bestDropoffPoint);
                    }
                }
            }
            else {
                let parkingSpot = transporter.pos;
                if (this.colony.storage) {
                    parkingSpot = this.colony.storage.pos;
                }
                else if (this.colony.roomPlanner.storagePos) {
                    parkingSpot = this.colony.roomPlanner.storagePos;
                }
                this.debug(() => `${prefix}: nothing to do and empty, parking to ${parkingSpot}`);
                transporter.park(parkingSpot);
            }
        }
    }
    retarget() {
        this.transporters.forEach((t) => (t.task = null));
        this.run();
    }
    run() {
        this.autoRun(this.transporters, (transporter) => {
            const request = this.colony.logisticsNetwork.bestRequestForTransporter(transporter);
            this.handleTransporter(transporter, request);
        }, (transporter) => transporter.avoidDanger({ timer: 5, dropEnergy: true }));
        this.stats();
    }
    stats() {
        var _a;
        const idleTransporters = this.transporters.filter((t) => !t.isIdle).length;
        const downtime = ema(idleTransporters / this.transporters.length, (_a = this.memory["d" /* TRANSPORT_MEM.DOWNTIME */]) !== null && _a !== void 0 ? _a : 0, CREEP_LIFE_TIME);
        this.memory["d" /* TRANSPORT_MEM.DOWNTIME */] = downtime;
        Stats.log(`colonies.${this.colony.name}.transportNetwork.downtime`, downtime);
    }
};
TransportOverlord = __decorate$1([
    profile
], TransportOverlord);

const DEFAULT_NUM_SCOUTS$1 = 3;
/**
 * Sends out scouts which randomly traverse rooms to uncover possible expansion locations and gather intel
 */
let RandomWalkerScoutOverlord = class RandomWalkerScoutOverlord extends Overlord {
    constructor(colony, priority = OverlordPriority.scouting.randomWalker) {
        super(colony, "scout", priority);
        this.scouts = this.zerg(Roles.scout, { notifyWhenAttacked: false });
        this.scoutMap = {};
        this.generateScoutMap();
    }
    generateScoutMap() {
        // A list of rooms to visit, keyed by creep name
        const map = {};
        // A list of scouts, keyed by starting room name
        const rooms = {};
        for (const scout of this.scouts) {
            const room = scout.room.name;
            if (rooms[scout.room.name]) {
                this.debug(`already built map for ${scout.print} in ${scout.room}`);
                // We've already generated this, skip
                rooms[scout.room.name].push(scout);
                continue;
            }
            this.debug(`rebuilding map for ${scout.print} in ${scout.room}`);
            const roomStatus = RoomIntel.getRoomStatus(room);
            const nearbyRooms = Cartographer.recursiveRoomSearch(room, 3);
            let neighboringRooms = _.flatten(_.values(nearbyRooms));
            neighboringRooms = neighboringRooms.filter((room) => RoomIntel.getRoomStatus(room).status ===
                roomStatus.status &&
                !RoomIntel.isConsideredHostile(room));
            this.debug(() => `rooms near ${room}: ${neighboringRooms}`);
            // Check all the room's exits + portals
            const exitData = RoomIntel.describeExits(scout.pos.roomName, "interOnly");
            // This is a .compact/.filter in one swoop
            const exits = _.values(exitData).reduce((s, e) => {
                if (Array.isArray(e)) {
                    for (const i of e) {
                        s.add(i);
                    }
                }
                else if (e) {
                    s.add(e);
                }
                return s;
            }, new Set());
            this.debug(() => `exits from ${room}:\ndata: ${JSON.stringify(exitData)}\nflat: ${[...exits]}`);
            // Sort by nearby exit, then by missing expansion data, then by last visible tick
            // so we prioritize going to places that need to be refreshed
            const sortedRooms = neighboringRooms.sort((a, b) => {
                if (exits.has(a) && exits.has(b)) {
                    if (RoomIntel.getExpansionData(a) ===
                        RoomIntel.getExpansionData(b)) {
                        return (RoomIntel.lastVisible(a) - RoomIntel.lastVisible(b));
                    }
                    else if (RoomIntel.getExpansionData(a) === undefined) {
                        return -1;
                    }
                    else {
                        return 1;
                    }
                }
                else if (exits.has(a)) {
                    return -1;
                }
                else {
                    return 1;
                }
            });
            this.debug(() => {
                return (`map for ${scout.name} in ${room}:\n` +
                    columnify$1(sortedRooms.map((name, idx) => {
                        return {
                            idx,
                            name,
                            exits: exits.has(name),
                            intel: (RoomIntel.getControllerInfo(name) !==
                                undefined) ?
                                "known"
                                : "unknown",
                            exp: RoomIntel.getExpansionData(name) ? "known"
                                : "unknown",
                            visible: RoomIntel.lastVisible(name),
                        };
                    })));
            });
            map[scout.name] = sortedRooms;
            rooms[scout.room.name] = [scout];
        }
        const competingRooms = Object.entries(rooms).filter(([_room, scouts]) => scouts.length > 1);
        if (competingRooms.length) {
            for (const [_room, scouts] of competingRooms) {
                // We've got a few scouts which shared a starting location, reset their list and split it out
                const roomList = map[scouts[0].name];
                scouts.forEach((s) => (map[s.name] = []));
                for (let idx = 0; idx < roomList.length; idx++) {
                    const name = scouts[idx % scouts.length].name;
                    map[name].push(roomList[idx]);
                }
                this.debug(() => `scouts ${scouts.map((s) => s.name)} were competing, split:\n${scouts.map((s) => `\t${s.name}: ${map[s.name]}\n`)}`);
            }
        }
        this.scoutMap = map;
    }
    init() {
        if (this.colony.level === 1 || this.colony.state.bootstrapping) {
            // At such low-level, or in an economic emergency, we don't really care
            // about scouts
            return;
        }
        this.wishlist(DEFAULT_NUM_SCOUTS$1, Setups.scout);
    }
    handleScout(scout) {
        // // Stomp on enemy construction sites
        // const enemyConstructionSites = scout.room.find(FIND_HOSTILE_CONSTRUCTION_SITES);
        // if (enemyConstructionSites.length > 0 && enemyConstructionSites[0].pos.isWalkable(true)) {
        // 	scout.goTo(enemyConstructionSites[0].pos);
        // 	return;
        // }
        const moveOptions = {
            pathOpts: {
                allowHostile: true,
                allowPortals: true,
            },
        };
        // Check if room might be connected to newbie/respawn zone
        // const indestructibleWalls = _.filter(scout.room.walls, wall => wall.hits == undefined);
        // if (indestructibleWalls.length > 0) { // go back to origin colony if you find a room near newbie zone
        // 	this.debug(`${scout.print} detected indestructible walls, moving somewhere else`);
        // 	log.info(`${scout.print} moving back to ${this.colony.print}`)
        // 	scout.task = Tasks.goToRoom(this.colony.room.name, { moveOptions });
        // 	return;
        // }
        if (!this.scoutMap[scout.name]) {
            this.debug(`${scout.print}: scout map outdated, regenerate`);
            this.generateScoutMap();
        }
        this.debug(`${scout.print}: available rooms: ${this.scoutMap[scout.name]}`);
        let neighboringRoom;
        while ((neighboringRoom = this.scoutMap[scout.name].shift())) {
            // Filter out any rooms we might have sent another scout to
            if (this.scouts.some((scout) => { var _a; return ((_a = scout.task) === null || _a === void 0 ? void 0 : _a.targetPos.roomName) === neighboringRoom; })) {
                continue;
            }
            this.debug(`${scout.print}: moving to ${neighboringRoom}`);
            scout.task = Tasks$1.goToRoom(neighboringRoom, { moveOptions });
            break;
        }
        // Just move back to the colony and start over
        if (!scout.task) {
            this.debug(`${scout.print}: no task, moving back to ${this.colony.print}`);
            scout.task = Tasks$1.goToRoom(this.colony.room.name, { moveOptions });
        }
    }
    run() {
        this.autoRun(this.scouts, (scout) => this.handleScout(scout));
    }
};
RandomWalkerScoutOverlord = __decorate$1([
    profile
], RandomWalkerScoutOverlord);

var DEFCON;
(function (DEFCON) {
    DEFCON[DEFCON["safe"] = 0] = "safe";
    DEFCON[DEFCON["invasionNPC"] = 1] = "invasionNPC";
    DEFCON[DEFCON["boostedInvasionNPC"] = 2] = "boostedInvasionNPC";
    DEFCON[DEFCON["playerInvasion"] = 3] = "playerInvasion";
    DEFCON[DEFCON["bigPlayerInvasion"] = 4] = "bigPlayerInvasion";
})(DEFCON || (DEFCON = {}));
function getAllColonies() {
    return _.values(Overmind.colonies);
}
function isColony(thing) {
    return thing instanceof Colony;
}
var EnergyUse;
(function (EnergyUse) {
    EnergyUse["MINED"] = "mined";
    EnergyUse["SPAWN"] = "spawn";
    EnergyUse["REPAIR"] = "repair";
    EnergyUse["UPGRADE"] = "upgrade";
    EnergyUse["FACTORY"] = "factory";
    EnergyUse["POWER_SPAWN"] = "powerspawn";
    EnergyUse["LAB"] = "lab";
})(EnergyUse || (EnergyUse = {}));
const getDefaultColonyMemory = () => ({
    defcon: {
        level: DEFCON.safe,
        tick: -Infinity,
    },
    expansionData: {
        possibleExpansions: {},
        expiration: 0,
    },
    maxLevel: 0,
    outposts: {},
    averageEnergyUse: {},
});
/**
 * Colonies are the highest-level object other than the global Overmind. A colony groups together all rooms, structures,
 * creeps, utilities, etc. which are run from a single owned room.
 */
let Colony = class Colony {
    /** The military alert state of the colony */
    get defcon() {
        return this.memory.defcon.level;
    }
    set defcon(level) {
        if (level < DEFCON.safe || level > DEFCON.bigPlayerInvasion) {
            return;
        }
        this.memory.defcon = {
            level: level,
            tick: Game.time,
        };
    }
    constructor(id, roomName, outposts) {
        // Primitive colony setup
        this.id = id;
        this.name = roomName;
        this.ref = roomName;
        this.memory = Mem.wrap(Memory.colonies, roomName, getDefaultColonyMemory);
        // Format outpost state memory
        _.forEach(outposts, (outpost) => {
            if (!this.memory.outposts[outpost]) {
                this.memory.outposts[outpost] = { active: true };
            }
        });
        _.forEach(_.keys(_.clone(this.memory.outposts)), (roomName) => {
            if (!outposts.includes(roomName)) {
                delete this.memory.outposts[roomName];
            }
        });
        // Register colony globally to allow 'W1N1' and 'w1n1' to refer to Overmind.colonies.W1N1
        // @ts-expect-error global getter for Colonies
        global[this.name] = this;
        // @ts-expect-error global getter for Colonies
        global[this.name.toLowerCase()] = this;
        // Build the colony
        this.build(roomName, outposts);
    }
    /**
     * Pretty-print the colony name in the console
     */
    get print() {
        return ('<a href="#!/room/' +
            Game.shard.name +
            "/" +
            this.room.name +
            '">[' +
            this.name +
            "]</a>");
    }
    /**
     * Pretty-print the colony colony name right-padded with spaces to fit E**S** in the console
     */
    get printAligned() {
        const msg = '<a href="#!/room/' +
            Game.shard.name +
            "/" +
            this.room.name +
            '">[' +
            this.name +
            "]</a>";
        const extraSpaces = "E12S34".length - this.room.name.length;
        return msg + " ".repeat(extraSpaces);
    }
    toString() {
        return this.print;
    }
    debug(...args) {
        if (this.memory.debug) {
            log.alert(this.print, ...args);
        }
    }
    /**
     * Builds the colony object
     */
    build(roomName, outposts) {
        // Register rooms
        this.room = Game.rooms[roomName];
        this.roomNames = [roomName].concat(outposts);
        // Register outposts
        this.outposts = _.compact(_.map(outposts, (outpost) => Game.rooms[outpost]));
        this.rooms = [this.room].concat(this.outposts);
        this.miningSites = {}; // filled in by harvest directives
        this.extractionSites = {}; // filled in by extract directives
        // this.praiseSite = undefined;
        // Register creeps
        this.creeps = Overmind.cache.creepsByColony[this.name] || [];
        this.creepsByRole = _.groupBy(this.creeps, (creep) => creep.memory.role);
        this.instantEnergyUse = {};
        // Register the rest of the colony components; the order in which these are called is important!
        this.registerRoomObjects_cached(); // Register real colony components
        this.registerOperationalState(); // Set the colony operational state
        this.registerUtilities(); // Register logistics utilities, room planners, and layout info
        this.registerHiveClusters(); // Build the hive clusters
        /* Colony.spawnMoarOverlords() gets called from Overmind.ts, along with Directive.spawnMoarOverlords() */
    }
    /**
     * Refreshes the state of the colony object
     */
    refresh() {
        this.memory = Memory.colonies[this.room.name];
        // Refresh rooms
        this.room = Game.rooms[this.room.name];
        const outpostRoomNames = _.filter(this.roomNames, (roomName) => this.room.name != roomName);
        this.outposts = _.compact(_.map(outpostRoomNames, (outpost) => Game.rooms[outpost]));
        this.rooms = [this.room].concat(this.outposts);
        // refresh creeps
        this.creeps = Overmind.cache.creepsByColony[this.name] || [];
        this.creepsByRole = _.groupBy(this.creeps, (creep) => creep.memory.role);
        this.instantEnergyUse = {};
        // Register the rest of the colony components; the order in which these are called is important!
        this.refreshRoomObjects();
        this.registerOperationalState();
        this.refreshUtilities();
        this.refreshHiveClusters();
    }
    /**
     * Registers physical game objects to the colony
     */
    registerRoomObjects() {
        // Create placeholder arrays for remaining properties to be filled in by the Overmind
        this.flags = []; // filled in by directives
        this.destinations = new Map(); // filled in by various hive clusters and directives
        // Register room objects across colony rooms
        this.controller = this.room.controller; // must be controller since colonies are based in owned rooms
        this.spawns = _.sortBy(_.filter(this.room.spawns, (spawn) => spawn.my && spawn.isActive()), (spawn) => spawn.ref);
        this.extensions = this.room.extensions;
        this.storage =
            this.room.storage && this.room.storage.isActive() ?
                this.room.storage
                : undefined;
        this.links = this.room.links;
        this.availableLinks = _.clone(this.room.links);
        this.terminal =
            this.room.terminal && this.room.terminal.isActive() ?
                this.room.terminal
                : undefined;
        this.factory =
            this.room.factory && this.room.factory.isActive() ?
                this.room.factory
                : undefined;
        this.towers = this.room.towers;
        this.labs = _.sortBy(_.filter(this.room.labs, (lab) => lab.my && lab.isActive()), (lab) => 50 * lab.pos.y + lab.pos.x); // Labs are sorted in reading order of positions
        this.powerSpawn = this.room.powerSpawn;
        this.nuker = this.room.nuker;
        this.observer = this.room.observer;
        this.pos = (this.storage ||
            this.terminal ||
            this.spawns[0] ||
            this.controller).pos;
        // Register physical objects across all rooms in the colony
        this.sources = _.sortBy(_.flatten(_.map(this.rooms, (room) => room.sources)), (source) => source.pos.getMultiRoomRangeTo(this.pos));
        this.extractors = _(this.rooms)
            .map((room) => room.extractor)
            .compact()
            .filter((extractor) => (extractor.my && extractor.room.my) ||
            Cartographer.roomType(extractor.room.name) !=
                ROOMTYPE_CONTROLLER)
            .sortBy((extractor) => extractor.pos.getMultiRoomRangeTo(this.pos))
            .value();
        this.constructionSites = _.flatten(_.map(this.rooms, (room) => room.constructionSites));
        this.tombstones = _.flatten(_.map(this.rooms, (room) => room.tombstones));
        this.drops = _.merge(_.map(this.rooms, (room) => room.drops));
        this.ruins = _.merge(_.map(this.rooms, (room) => room.ruins));
        this.repairables = _.flatten(_.map(this.rooms, (room) => room.repairables));
        this.rechargeables = _.flatten(_.map(this.rooms, (room) => room.rechargeables));
        // Register assets
        this.assets = this.computeAssets();
    }
    /**
     * Version of Colony.registerRoomObjects with additional caching functionality
     */
    registerRoomObjects_cached() {
        // Create placeholder arrays for remaining properties to be filled in by the Overmind
        this.flags = []; // filled in by directives
        this.destinations = new Map(); // filled in by various hive clusters and directives
        // Register room objects across colony rooms
        this.controller = this.room.controller; // must be controller since colonies are based in owned rooms
        this.extensions = this.room.extensions;
        this.links = this.room.links;
        this.availableLinks = _.clone(this.room.links);
        this.towers = this.room.towers;
        this.powerSpawn = this.room.powerSpawn;
        this.nuker = this.room.nuker;
        this.observer = this.room.observer;
        $.set(this, "spawns", () => _.sortBy(_.filter(this.room.spawns, (spawn) => spawn.my && spawn.isActive()), (spawn) => spawn.ref));
        $.set(this, "storage", () => this.room.storage && this.room.storage.isActive() ?
            this.room.storage
            : undefined);
        $.set(this, "terminal", () => this.room.terminal && this.room.terminal.isActive() ?
            this.room.terminal
            : undefined);
        $.set(this, "factory", () => this.room.factory && this.room.factory.isActive() ?
            this.room.factory
            : undefined);
        $.set(this, "labs", () => _.sortBy(_.filter(this.room.labs, (lab) => lab.my && lab.isActive()), (lab) => 50 * lab.pos.y + lab.pos.x));
        this.pos = (this.storage ||
            this.terminal ||
            this.spawns[0] ||
            this.controller).pos;
        // Register physical objects across all rooms in the colony
        $.set(this, "sources", () => _.sortBy(_.flatten(_.map(this.rooms, (room) => room.sources)), (source) => source.pos.getMultiRoomRangeTo(this.pos)));
        $.set(this, "extractors", () => _(this.rooms)
            .map((room) => room.extractor)
            .compact()
            .filter((e) => (e.my && e.room.my) ||
            Cartographer.roomType(e.room.name) !=
                ROOMTYPE_CONTROLLER)
            .sortBy((e) => e.pos.getMultiRoomRangeTo(this.pos))
            .value());
        $.set(this, "repairables", () => _.flatten(_.map(this.rooms, (room) => room.repairables)));
        $.set(this, "rechargeables", () => _.flatten(_.map(this.rooms, (room) => room.rechargeables)));
        $.set(this, "constructionSites", () => _.flatten(_.map(this.rooms, (room) => room.constructionSites)), 10);
        $.set(this, "tombstones", () => _.flatten(_.map(this.rooms, (room) => room.tombstones)), 5);
        this.drops = _.merge(_.map(this.rooms, (room) => room.drops));
        $.set(this, "ruins", () => _.flatten(_.map(this.rooms, (room) => room.ruins)), 5);
        // Register assets
        this.assets = this.computeAssets();
    }
    /**
     * Refresh the state of all physical game objects in the colony
     */
    refreshRoomObjects() {
        $.refresh(this, "controller", "extensions", "links", "towers", "powerSpawn", "nuker", "observer", "spawns", "storage", "terminal", "factory", "labs", "sources", "extractors", "constructionSites", "repairables", "rechargeables", "ruins");
        $.set(this, "constructionSites", () => _.flatten(_.map(this.rooms, (room) => room.constructionSites)), 10);
        $.set(this, "tombstones", () => _.flatten(_.map(this.rooms, (room) => room.tombstones)), 5);
        this.drops = _.merge(_.map(this.rooms, (room) => room.drops));
        $.set(this, "ruins", () => _.flatten(_.map(this.rooms, (room) => room.ruins)), 5);
        // Re-compute assets
        this.assets = this.computeAssets();
    }
    /**
     * Registers the operational state of the colony, computing things like colony maturity, DEFCON level, etc.
     */
    registerOperationalState() {
        this.level = this.controller.level;
        // Set DEFCON level for the colony
        let defcon = DEFCON.safe;
        const defconDecayTime = 200;
        if (this.room.dangerousHostiles.length > 0 &&
            !this.controller.safeMode) {
            const playerHostileCount = _.sum(this.room.dangerousPlayerHostiles, (hostile) => CombatIntel$1.uniqueBoosts(hostile).length > 0 ? 2 : 1);
            const hostileCount = _.sum(this.room.dangerousHostiles, (hostile) => CombatIntel$1.uniqueBoosts(hostile).length > 0 ? 2 : 1);
            if (playerHostileCount >= 3) {
                defcon = DEFCON.bigPlayerInvasion;
            }
            else if (playerHostileCount >= 1) {
                defcon = DEFCON.playerInvasion;
            }
            else if (hostileCount >= 3) {
                defcon = DEFCON.boostedInvasionNPC;
            }
            else {
                defcon = DEFCON.invasionNPC;
            }
        }
        if (defcon !== this.defcon) {
            if (defcon < this.defcon) {
                // decay defcon level over time if defcon less than memory value
                if (this.memory.defcon.tick + defconDecayTime < Game.time) {
                    log.info(`Colony ${this.print} DEFCON level lowered to ${defcon}`);
                    this.defcon = defcon;
                }
            }
            else if (defcon > this.defcon) {
                // refresh defcon time if it increases by a level
                log.alert(`Colony ${this.print} DEFCON level raised to ${defcon}!`);
                this.defcon = defcon;
            }
        }
        // Set colony state to blank - other directives can modify this
        this.state = {};
        this.state.isOverfilled =
            (this.storage || this.terminal) &&
                (!this.storage || ResourceManager.isOverCapacity(this.storage)) &&
                (!this.terminal || ResourceManager.isOverCapacity(this.terminal));
        this.state.lowPowerMode = this.state.isOverfilled && this.level === 8;
    }
    /**
     * Registers utility classes such as logistics networks
     */
    registerUtilities() {
        // Resource requests
        this.linkNetwork = new LinkNetwork(this);
        this.logisticsNetwork = new LogisticsNetwork(this);
        this.transportRequests = new TransportRequestGroup("colony");
        // Register a room planner
        this.roomPlanner = new RoomPlanner(this);
        if (this.roomPlanner.memory.bunkerData &&
            this.roomPlanner.memory.bunkerData.anchor) {
            this.layout = "bunker";
            const anchor = derefRoomPosition(this.roomPlanner.memory.bunkerData.anchor);
            // log.debug(JSON.stringify(`anchor for ${this.name}: ${anchor}`));
            const spawnPositions = _.map(bunkerLayout[8].buildings.spawn.pos, (c) => getPosFromBunkerCoord(c, this));
            // log.debug(JSON.stringify(`spawnPositions for ${this.name}: ${spawnPositions}`));
            const rightSpawnPos = maxBy(spawnPositions, (pos) => pos.x);
            const topSpawnPos = minBy(spawnPositions, (pos) => pos.y);
            const coreSpawnPos = anchor.findClosestByRange(spawnPositions);
            // log.debug(JSON.stringify(`spawnPoses: ${rightSpawnPos}, ${topSpawnPos}, ${coreSpawnPos}`));
            this.bunker = {
                anchor: anchor,
                topSpawn: topSpawnPos === null || topSpawnPos === void 0 ? void 0 : topSpawnPos.lookForStructure(STRUCTURE_SPAWN),
                coreSpawn: coreSpawnPos === null || coreSpawnPos === void 0 ? void 0 : coreSpawnPos.lookForStructure(STRUCTURE_SPAWN),
                rightSpawn: rightSpawnPos === null || rightSpawnPos === void 0 ? void 0 : rightSpawnPos.lookForStructure(STRUCTURE_SPAWN),
            };
        }
        else {
            this.layout = "twoPart";
        }
        // Register road network
        this.roadLogistics = new RoadLogistics(this);
        // // "Organism Abathur with you."
        // this.abathur = new Abathur(this);
        // Add colony to TerminalNetwork if applicable
        if (this.terminal) {
            Overmind.terminalNetwork.addColony(this);
        }
    }
    /**
     * Calls utility.refresh() for each registered utility
     */
    refreshUtilities() {
        var _a, _b, _c;
        this.linkNetwork.refresh();
        this.logisticsNetwork.refresh();
        this.transportRequests.refresh();
        this.roomPlanner.refresh();
        if (this.bunker) {
            if (this.bunker.topSpawn) {
                this.bunker.topSpawn =
                    (_a = Game.getObjectById(this.bunker.topSpawn.id)) !== null && _a !== void 0 ? _a : undefined;
            }
            if (this.bunker.coreSpawn) {
                this.bunker.coreSpawn =
                    (_b = Game.getObjectById(this.bunker.coreSpawn.id)) !== null && _b !== void 0 ? _b : undefined;
            }
            if (this.bunker.rightSpawn) {
                this.bunker.rightSpawn =
                    (_c = Game.getObjectById(this.bunker.rightSpawn.id)) !== null && _c !== void 0 ? _c : undefined;
            }
        }
        this.roadLogistics.refresh();
        // this.abathur.refresh();
    }
    /**
     * Builds hive clusters for each structural group in a colony
     */
    registerHiveClusters() {
        this.hiveClusters = [];
        // Instantiate the command center if there is storage in the room - this must be done first!
        if (this.storage) {
            this.commandCenter = new CommandCenter(this, this.storage);
        }
        // Instantiate the hatchery - the incubation directive assignes hatchery to incubator's hatchery if none exists
        if (this.spawns[0]) {
            this.hatchery = new Hatchery(this, this.spawns[0]);
        }
        // Instantiate evolution chamber once there are three labs all in range 2 of each other
        if (this.terminal &&
            _.filter(this.labs, (lab) => _.all(this.labs, (otherLab) => lab.pos.inRangeTo(otherLab, 2))).length >= 3) {
            this.evolutionChamber = new EvolutionChamber(this, this.terminal);
        }
        if (this.factory && this.terminal && this.commandCenter) {
            this.infestedFactory = new InfestedFactory(this, this.factory);
        }
        // Instantiate the upgradeSite
        this.upgradeSite = new UpgradeSite(this, this.controller);
        // Instantiate spore crawlers to wrap towers
        if (this.towers[0]) {
            this.sporeCrawler = new SporeCrawler(this, this.towers[0]);
        }
        // Reverse the hive clusters for correct order for init() and run()
        this.hiveClusters.reverse();
    }
    /**
     * Refreshes the state of each hive cluster
     */
    refreshHiveClusters() {
        for (let i = this.hiveClusters.length - 1; i >= 0; i--) {
            this.hiveClusters[i].refresh();
        }
    }
    /**
     * Returns whether a room is part of this colony and is actively being maintained
     */
    isRoomActive(roomName) {
        if (roomName == this.room.name) {
            return true;
        }
        else if (!this.roomNames.includes(roomName)) {
            return false;
        }
        else {
            return (this.memory.outposts[roomName] &&
                this.memory.outposts[roomName].active);
        }
    }
    /**
     * Deactivates an outpost and suspends operations in that room
     */
    suspendOutpost(roomName, options) {
        suspend(this.memory.outposts[roomName], options);
    }
    /**
     * Reactivates an outpost and resumes operations in that room
     */
    unsuspendOutpost(roomName) {
        unsuspend(this.memory.outposts[roomName]);
    }
    handleOutpostSuspension() {
        // Go through outposts and unsuspend then
        for (const roomName in this.memory.outposts) {
            if (expireSuspension(this.memory.outposts[roomName])) {
                log.info(`${this.print} outpost ${roomName} unsuspended`);
            }
        }
    }
    /**
     * Instantiate all overlords for the colony
     */
    spawnMoarOverlords() {
        this.overlords = {
            default: new DefaultOverlord(this),
            work: new WorkerOverlord(this),
            logistics: new TransportOverlord(this),
        };
        if (!this.observer) {
            this.overlords.scout = new RandomWalkerScoutOverlord(this);
        }
        for (const hiveCluster of this.hiveClusters) {
            hiveCluster.spawnMoarOverlords();
        }
    }
    /**
     * Get a list of creeps in the colony which have a specified role name
     */
    getCreepsByRole(roleName) {
        return this.creepsByRole[roleName] || [];
    }
    /**
     * Get a list of zerg in the colony which have a specified role name
     */
    getZergByRole(roleName) {
        return _.compact(_.map(this.getCreepsByRole(roleName), (creep) => Overmind.zerg[creep.name]));
    }
    /**
     * Check a given creep against a specific setup
     *
     * This will return true if the creep has all types of body parts the setup would create,
     * though not necessarily as many of them.
     */
    hasCompatibleBody(creep, setup) {
        let body;
        if (setup instanceof CreepSetup) {
            body = setup.generateBody(this.room.energyCapacityAvailable);
        }
        else if (setup instanceof CombatCreepSetup) {
            body = setup.create(this, true).body;
        }
        else {
            log.warning(`not sure what to do with ${setup}`);
            return false;
        }
        return body.every((part) => creep.creep.getActiveBodyparts(part) !== 0);
    }
    /**
     * Reassigns a zerg to this colony.
     *
     * This will check the to-be-reassigned zerg against the current list of
     * spawn requests, picking the first one whose body requirements match the creep.
     * With a role given, it will also ensure that it matches the spawn request.
     */
    reassign(creep, roleName) {
        var _a, _b;
        if (!(creep instanceof Zerg)) {
            log.warning(`invalid value: ${creep}`);
            return false;
        }
        for (const request of (_b = (_a = this.hatchery) === null || _a === void 0 ? void 0 : _a.spawnRequests) !== null && _b !== void 0 ? _b : []) {
            if ((request.setup.role === roleName || !roleName) &&
                this.hasCompatibleBody(creep, request.setup)) {
                log.info(`${this.print} reassigning ${creep.print} to ${request.overlord.print} as ${request.setup.role}`);
                creep.reassign(request.overlord, request.setup.role);
                return true;
            }
        }
        return false;
    }
    /**
     * Summarizes the total of all resources in colony store structures, labs, and some creeps. Will always return
     * 0 for an asset that it has none of (not undefined)
     */
    computeAssets(verbose = false) {
        // Include storage structures, lab contents, and manager carry
        const assetStructures = _.compact([
            this.storage,
            this.terminal,
            this.factory,
            ...this.labs,
        ]);
        const assetCreeps = [
            ...this.getCreepsByRole(Roles.queen),
            ...this.getCreepsByRole(Roles.manager),
        ];
        const assetStores = _.map([...assetStructures, ...assetCreeps], (thing) => thing.store);
        const allAssets = mergeSum(...assetStores, ALL_ZERO_ASSETS);
        if (verbose) {
            log.debug(`${this.room.print} assets: ` + JSON.stringify(allAssets));
        }
        return allAssets;
    }
    /**
     * Calculate the total amount of energy harvested by the colony
     */
    get energyMinedPerTick() {
        return $.number(this, "energyMinedPerTick", () => {
            return _.sum(_.map(this.miningSites, (site) => {
                const overlord = site.overlords.mine;
                return overlord.avgEnergyPerTick;
            }));
        }, 5);
    }
    /**
     * Initializes the state of the colony each tick
     */
    init() {
        var _a;
        this.handleOutpostSuspension();
        // Initialize each hive cluster
        for (const hiveCluster of this.hiveClusters) {
            if ((_a = hiveCluster.memory) === null || _a === void 0 ? void 0 : _a.debug) {
                log.debug(`${hiveCluster.print} init`);
            }
            hiveCluster.init();
        }
        this.roadLogistics.init(); // Initialize the road network
        this.linkNetwork.init(); // Initialize link network
        this.roomPlanner.init(); // Initialize the room planner
        if (Game.time % EXPANSION_EVALUATION_FREQ == 5 * this.id) {
            // Re-evaluate expansion data if needed
            ExpansionEvaluator.refreshExpansionData(this.memory.expansionData, this.room.name);
        }
    }
    /**
     * Runs the colony, performing state-changing actions each tick
     */
    run() {
        var _a;
        if (this.state.isOverfilled) {
            Overmind.overseer.notifier.alert(`Colony is overfilled!`, this.room.name, NotifierPriority.High);
        }
        // Run each hive cluster
        for (const hiveCluster of this.hiveClusters) {
            if ((_a = hiveCluster.memory) === null || _a === void 0 ? void 0 : _a.debug) {
                log.debug(`${hiveCluster.print} run`);
            }
            hiveCluster.run();
        }
        this.linkNetwork.run(); // Run the link network
        this.roadLogistics.run(); // Run the road network
        this.roomPlanner.run(); // Run the room planner
        this.stats(); // Log stats per tick
        if (this.logisticsNetwork.memory.debug) {
            this.logisticsNetwork.summarize();
            this.logisticsNetwork.summarizeMatching();
        }
    }
    markDestination(pos, order) {
        const key = `${pos.roomName}-${pos.x}-${pos.y}`;
        const dest = { pos: pos, order: order !== null && order !== void 0 ? order : 0 };
        this.destinations.set(key, dest);
    }
    trackEnergyUse(type, amount) {
        var _a;
        var _b;
        (_a = (_b = this.instantEnergyUse)[type]) !== null && _a !== void 0 ? _a : (_b[type] = 0);
        this.instantEnergyUse[type] += amount;
    }
    /**
     * Register colony-wide statistics
     */
    stats() {
        var _a, _b;
        const ENERGY_USE_EMA_WINDOW = CREEP_LIFE_TIME;
        for (const key of values(EnergyUse)) {
            this.memory.averageEnergyUse[key] = ema((_a = this.instantEnergyUse[key]) !== null && _a !== void 0 ? _a : 0, (_b = this.memory.averageEnergyUse[key]) !== null && _b !== void 0 ? _b : 0, ENERGY_USE_EMA_WINDOW);
        }
        if (!Stats.shouldLog) {
            return;
        }
        // Log energy and rcl
        Stats.log(`colonies.${this.name}.storage.energy`, this.storage ? this.storage.energy : undefined);
        Stats.log(`colonies.${this.name}.rcl.level`, this.controller.level);
        Stats.log(`colonies.${this.name}.rcl.progress`, this.controller.progress);
        Stats.log(`colonies.${this.name}.rcl.progressTotal`, this.controller.progressTotal);
        // Log average miningSite usage and uptime and estimated colony energy income
        const numSites = _.keys(this.miningSites).length;
        const avgDowntime = _.sum(this.miningSites, (site) => site.memory["d" /* HARVEST_MEM.DOWNTIME */]) / numSites;
        const avgUsage = _.sum(this.miningSites, (site) => site.memory["u" /* HARVEST_MEM.USAGE */]) /
            numSites;
        const energyInPerTick = _.sum(this.miningSites, (site) => site.overlords.mine.avgEnergyPerTick);
        Stats.log(`colonies.${this.name}.miningSites.avgDowntime`, avgDowntime);
        Stats.log(`colonies.${this.name}.miningSites.avgUsage`, avgUsage);
        Stats.log(`colonies.${this.name}.miningSites.energyInPerTick`, energyInPerTick);
        Stats.set(`colonies.${this.name}.energyUsage`, this.memory.averageEnergyUse);
        Stats.log(`colonies.${this.name}.assets`, this.assets);
        // Log defensive properties
        Stats.log(`colonies.${this.name}.defcon`, this.defcon);
        Stats.log(`colonies.${this.name}.threatLevel`, this.room.threatLevel);
        const avgBarrierHits = _.sum(this.room.barriers, (barrier) => barrier.hits) /
            this.room.barriers.length;
        Stats.log(`colonies.${this.name}.avgBarrierHits`, avgBarrierHits);
        const maxBarrierHits = WorkerOverlord.settings.barrierHits[this.level];
        Stats.log(`colonies.${this.name}.maxBarrierHits`, maxBarrierHits);
        const report = Overmind.overseer.getCreepReport(this);
        for (const [role, [current, needed]] of Object.entries(report)) {
            Stats.log(`colonies.${this.name}.creeps.${role}.current`, current);
            Stats.log(`colonies.${this.name}.creeps.${role}.needed`, needed);
        }
    }
    drawCreepReport(coord) {
        let { x, y } = coord;
        const report = Overmind.overseer.getCreepReport(this);
        const roledata = [];
        for (const role in report) {
            const [current, needed] = report[role];
            roledata.push([role, `${current}/${needed}`]);
        }
        const tablePos = new RoomPosition(x, y, this.room.name);
        y = Visualizer.infoBox(`${this.name} Creeps`, roledata, tablePos, 7);
        return { x, y };
    }
    visuals() {
        let coord = { x: 1, y: 11.5 };
        coord = this.drawCreepReport(coord);
        const overlords = [
            this.hatchery,
            this.commandCenter,
            this.evolutionChamber,
            this.upgradeSite,
        ];
        for (const hiveCluster of _.compact(overlords)) {
            coord = hiveCluster.visuals(coord);
        }
    }
};
Colony.settings = {
    remoteSourcesByLevel: {
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 9,
    },
    maxSourceDistance: 100,
};
Colony = __decorate$1([
    profile,
    assimilationLocked
], Colony);

const REBUILD_STATE_TIMEOUT = 25000;
/**
 * Put the colony's terminal in a rebuild state, which pushes resources out of a room which is undergoing reconstruction
 * while maintaining a small reserve of energy
 */
let DirectiveTerminalRebuildState = class DirectiveTerminalRebuildState extends Directive {
    constructor(flag) {
        super(flag);
        this.refresh();
    }
    refresh() {
        super.refresh();
        this.colony.state.isRebuilding = true;
    }
    spawnMoarOverlords() { }
    init() {
        if (this.colony && this.colony.terminal) {
            for (const resource of RESOURCES_ALL) {
                if (this.colony.assets[resource] > 0) {
                    if (resource == RESOURCE_ENERGY) {
                        // keep a little energy just to keep the room functioning
                        Overmind.terminalNetwork.exportResource(this.colony, resource, {
                            target: 25000,
                            tolerance: 5000,
                            surplus: 35000,
                        });
                    }
                    else {
                        Overmind.terminalNetwork.exportResource(this.colony, resource);
                    }
                }
            }
        }
        if (Game.time % 25 == 0) {
            log.alert(`${this.pos.print}: rebuild terminal state active!`);
        }
        this.alert("Rebuild terminal state active!", NotifierPriority.High);
    }
    run() {
        // Incubation directive gets removed once the colony has a command center (storage)
        if (!this.colony ||
            !this.terminal ||
            Game.time > (this.memory["T" /* MEM.TICK */] || 0) + REBUILD_STATE_TIMEOUT) {
            this.remove();
        }
    }
};
DirectiveTerminalRebuildState.directiveName = "rebuildState";
DirectiveTerminalRebuildState.color = COLOR_BROWN;
DirectiveTerminalRebuildState.secondaryColor = COLOR_YELLOW;
DirectiveTerminalRebuildState = __decorate$1([
    profile
], DirectiveTerminalRebuildState);

/**
 * Code for calculating the minCut in a room, written by Saruss,
 * adapted for Typescript and flexible room subsets by Chobobobo,
 * modified and debugged by Muon.
 */
const UNWALKABLE = -10;
const RANGE_MODIFIER = 1; // this parameter sets the scaling of weights to prefer walls closer protection bounds
const RANGE_PADDING = 3; // max range to reduce weighting; RANGE_MODIFIER * RANGE_PADDING must be < PROTECTED
const NORMAL = 0;
const PROTECTED = 10;
const CANNOT_BUILD = 20;
const EXIT = 30;
class Graph {
    constructor(totalVertices) {
        this.totalVertices = totalVertices;
        this.level = Array(totalVertices);
        // An array of edges for each vertex
        this.edges = Array(totalVertices)
            .fill(0)
            .map(() => []);
    }
    /**
     * Create a new edge in the graph as well as a corresponding reverse edge on the residual graph
     * @param from - vertex edge starts at
     * @param to - vertex edge leads to
     * @param capacity - max flow capacity for this edge
     */
    newEdge(from, to, capacity) {
        // Normal forward Edge
        this.edges[from].push({
            to,
            resEdge: this.edges[to].length,
            capacity,
            flow: 0,
        });
        // reverse Edge for Residual Graph
        this.edges[to].push({
            to: from,
            resEdge: this.edges[from].length - 1,
            capacity: 0,
            flow: 0,
        });
    }
    /**
     * Uses Breadth First Search to see if a path exists to the vertex 'to' and generate the level graph
     * @param from - vertex to start from
     * @param to - vertex to try and reach
     */
    createLevelGraph(from, to) {
        if (to >= this.totalVertices) {
            return false;
        }
        this.level.fill(-1); // reset old levels
        this.level[from] = 0;
        const q = []; // queue with s as starting point
        q.push(from);
        let u = 0;
        let edge = null;
        while (q.length) {
            u = q.shift();
            for (edge of this.edges[u]) {
                if (this.level[edge.to] < 0 && edge.flow < edge.capacity) {
                    this.level[edge.to] = this.level[u] + 1;
                    q.push(edge.to);
                }
            }
        }
        return this.level[to] >= 0; // return if theres a path, no level, no path!
    }
    /**
     * Depth First Search-like: send flow at along path from from->to recursively while increasing the level of the
     * visited vertices by one
     * @param start - the vertex to start at
     * @param end - the vertex to try and reach
     * @param targetFlow - the amount of flow to try and achieve
     * @param count - keep track of which vertices have been visited so we don't include them twice
     */
    calcFlow(start, end, targetFlow, count) {
        if (start === end) {
            // Sink reached , abort recursion
            return targetFlow;
        }
        let edge;
        let flowTillHere = 0;
        let flowToT = 0;
        while (count[start] < this.edges[start].length) {
            // Visit all edges of the vertex one after the other
            edge = this.edges[start][count[start]];
            if (this.level[edge.to] === this.level[start] + 1 &&
                edge.flow < edge.capacity) {
                // Edge leads to Vertex with a level one higher, and has flow left
                flowTillHere = Math.min(targetFlow, edge.capacity - edge.flow);
                flowToT = this.calcFlow(edge.to, end, flowTillHere, count);
                if (flowToT > 0) {
                    edge.flow += flowToT; // Add Flow to current edge
                    // subtract from reverse Edge -> Residual Graph neg. Flow to use backward direction of BFS/DFS
                    this.edges[edge.to][edge.resEdge].flow -= flowToT;
                    return flowToT;
                }
            }
            count[start]++;
        }
        return 0;
    }
    /**
     * Uses Breadth First Search to find the vertices in the minCut for the graph
     * - Must call calcMinCut first to prepare the graph
     * @param from - the vertex to start from
     */
    getMinCut(from) {
        const eInCut = [];
        this.level.fill(-1);
        this.level[from] = 1;
        const q = [];
        q.push(from);
        let u = 0;
        let edge;
        while (q.length) {
            u = q.shift();
            for (edge of this.edges[u]) {
                if (edge.flow < edge.capacity) {
                    if (this.level[edge.to] < 1) {
                        this.level[edge.to] = 1;
                        q.push(edge.to);
                    }
                }
                if (edge.flow === edge.capacity && edge.capacity > 0) {
                    // blocking edge -> could be in min cut
                    eInCut.push({ to: edge.to, unreachable: u });
                }
            }
        }
        const minCut = [];
        let cutEdge;
        for (cutEdge of eInCut) {
            if (this.level[cutEdge.to] === -1) {
                // Only edges which are blocking and lead to the sink from unreachable vertices are in the min cut
                minCut.push(cutEdge.unreachable);
            }
        }
        return minCut;
    }
    /**
     * Calculates min-cut graph using Dinic's Algorithm.
     * use getMinCut to get the actual verticies in the minCut
     * @param source - Source vertex
     * @param sink - Sink vertex
     */
    calcMinCut(source, sink) {
        if (source === sink) {
            return -1;
        }
        let ret = 0;
        let count = [];
        let flow = 0;
        while (this.createLevelGraph(source, sink)) {
            count = Array(this.totalVertices + 1).fill(0);
            do {
                flow = this.calcFlow(source, sink, Number.MAX_VALUE, count);
                if (flow > 0) {
                    ret += flow;
                }
            } while (flow);
        }
        return ret;
    }
}
/**
 * An Array with Terrain information: -1 not usable, 2 Sink (Leads to Exit)
 * @param room - the room to generate the terrain map from
 */
function get2DArray(roomName, bounds = { x1: 0, y1: 0, x2: 49, y2: 49 }) {
    const room2D = Array(50)
        .fill(NORMAL)
        .map(() => Array(50).fill(NORMAL)); // Array for room tiles
    let x;
    let y;
    const terrain = Game.map.getRoomTerrain(roomName);
    for (x = bounds.x1; x <= bounds.x2; x++) {
        for (y = bounds.y1; y <= bounds.y2; y++) {
            if (terrain.get(x, y) === TERRAIN_MASK_WALL) {
                room2D[x][y] = UNWALKABLE; // Mark unwalkable
            }
            else if (x === bounds.x1 ||
                y === bounds.y1 ||
                x === bounds.x2 ||
                y === bounds.y2) {
                room2D[x][y] = EXIT; // Mark exit tiles
            }
        }
    }
    // Marks tiles as unbuildable if they are proximate to exits
    for (y = bounds.y1 + 1; y <= bounds.y2 - 1; y++) {
        if (room2D[bounds.x1][y] === EXIT) {
            for (const dy of [-1, 0, 1]) {
                if (room2D[bounds.x1 + 1][y + dy] !== UNWALKABLE) {
                    room2D[bounds.x1 + 1][y + dy] = CANNOT_BUILD;
                }
            }
        }
        if (room2D[bounds.x2][y] === EXIT) {
            for (const dy of [-1, 0, 1]) {
                if (room2D[bounds.x2 - 1][y + dy] !== UNWALKABLE) {
                    room2D[bounds.x2 - 1][y + dy] = CANNOT_BUILD;
                }
            }
        }
    }
    for (x = bounds.x1 + 1; x <= bounds.x2 - 1; x++) {
        if (room2D[x][bounds.y1] === EXIT) {
            for (const dx of [-1, 0, 1]) {
                if (room2D[x + dx][bounds.y1 + 1] !== UNWALKABLE) {
                    room2D[x + dx][bounds.y1 + 1] = CANNOT_BUILD;
                }
            }
        }
        if (room2D[x][bounds.y2] === EXIT) {
            for (const dx of [-1, 0, 1]) {
                if (room2D[x + dx][bounds.y2 - 1] !== UNWALKABLE) {
                    room2D[x + dx][bounds.y2 - 1] = CANNOT_BUILD;
                }
            }
        }
    }
    return room2D;
}
/**
 * Function to create Source, Sink, Tiles arrays: takes a rectangle-Array as input for Tiles that are to Protect
 * @param room - the room to consider
 * @param toProtect - the coordinates to protect inside the walls
 * @param bounds - the area to consider for the minCut
 */
function createGraph(roomName, toProtect, preferCloserBarriers = true, preferCloserBarrierLimit = Infinity, // ignore the toProtect[n] for n > this value
visualize = true, bounds = { x1: 0, y1: 0, x2: 49, y2: 49 }) {
    const visual = new RoomVisual(roomName);
    const roomArray = get2DArray(roomName, bounds);
    // For all Rectangles, set edges as source (to protect area) and area as unused
    let r;
    let x;
    let y;
    for (r of toProtect) {
        if (bounds.x1 >= bounds.x2 ||
            bounds.y1 >= bounds.y2 ||
            bounds.x1 < 0 ||
            bounds.y1 < 0 ||
            bounds.x2 > 49 ||
            bounds.y2 > 49) {
            return console.log("ERROR: Invalid bounds", JSON.stringify(bounds));
        }
        else if (r.x1 >= r.x2 || r.y1 >= r.y2) {
            return console.log("ERROR: Rectangle", JSON.stringify(r), "invalid.");
        }
        else if (r.x1 < bounds.x1 ||
            r.x2 > bounds.x2 ||
            r.y1 < bounds.y1 ||
            r.y2 > bounds.y2) {
            return console.log("ERROR: Rectangle", JSON.stringify(r), "out of bounds:", JSON.stringify(bounds));
        }
        for (x = r.x1; x <= r.x2; x++) {
            for (y = r.y1; y <= r.y2; y++) {
                if (x === r.x1 || x === r.x2 || y === r.y1 || y === r.y2) {
                    if (roomArray[x][y] === NORMAL) {
                        roomArray[x][y] = PROTECTED;
                    }
                }
                else {
                    roomArray[x][y] = UNWALKABLE;
                }
            }
        }
    }
    // Preferentially weight closer tiles
    if (preferCloserBarriers) {
        for (r of _.take(toProtect, preferCloserBarrierLimit)) {
            const [xmin, xmax] = [
                Math.max(r.x1 - RANGE_PADDING, 0),
                Math.min(r.x2 + RANGE_PADDING, 49),
            ];
            const [ymin, ymax] = [
                Math.max(r.y1 - RANGE_PADDING, 0),
                Math.min(r.y2 + RANGE_PADDING, 49),
            ];
            for (x = xmin; x <= xmax; x++) {
                for (y = ymin; y <= ymax; y++) {
                    if (roomArray[x][y] >= NORMAL &&
                        roomArray[x][y] < PROTECTED) {
                        const x1range = Math.max(r.x1 - x, 0);
                        const x2range = Math.max(x - r.x2, 0);
                        const y1range = Math.max(r.y1 - y, 0);
                        const y2range = Math.max(y - r.y2, 0);
                        const rangeToBorder = Math.max(x1range, x2range, y1range, y2range);
                        const modifiedWeight = NORMAL +
                            RANGE_MODIFIER * (RANGE_PADDING - rangeToBorder);
                        roomArray[x][y] = Math.max(roomArray[x][y], modifiedWeight);
                        if (visualize) {
                            visual.text(`${roomArray[x][y]}`, x, y);
                        }
                    }
                }
            }
        }
    }
    // ********************** Visualization
    if (visualize) {
        for (x = bounds.x1; x <= bounds.x2; x++) {
            for (y = bounds.y1; y <= bounds.y2; y++) {
                if (roomArray[x][y] === UNWALKABLE) {
                    visual.circle(x, y, {
                        radius: 0.5,
                        fill: "#1b1b9f",
                        opacity: 0.3,
                    });
                }
                else if (roomArray[x][y] > UNWALKABLE &&
                    roomArray[x][y] < NORMAL) {
                    visual.circle(x, y, {
                        radius: 0.5,
                        fill: "#42cce8",
                        opacity: 0.3,
                    });
                }
                else if (roomArray[x][y] === NORMAL) {
                    visual.circle(x, y, {
                        radius: 0.5,
                        fill: "#bdb8b8",
                        opacity: 0.3,
                    });
                }
                else if (roomArray[x][y] > NORMAL &&
                    roomArray[x][y] < PROTECTED) {
                    visual.circle(x, y, {
                        radius: 0.5,
                        fill: "#9929e8",
                        opacity: 0.3,
                    });
                }
                else if (roomArray[x][y] === PROTECTED) {
                    visual.circle(x, y, {
                        radius: 0.5,
                        fill: "#e800c6",
                        opacity: 0.3,
                    });
                }
                else if (roomArray[x][y] === CANNOT_BUILD) {
                    visual.circle(x, y, {
                        radius: 0.5,
                        fill: "#e8000f",
                        opacity: 0.3,
                    });
                }
                else if (roomArray[x][y] === EXIT) {
                    visual.circle(x, y, {
                        radius: 0.5,
                        fill: "#000000",
                        opacity: 0.3,
                    });
                }
            }
        }
    }
    // initialise graph
    // possible 2*50*50 +2 (st) Vertices (Walls etc set to unused later)
    const g = new Graph(2 * 50 * 50 + 2);
    const infini = Number.MAX_VALUE;
    const surr = [
        [0, -1],
        [-1, -1],
        [-1, 0],
        [-1, 1],
        [0, 1],
        [1, 1],
        [1, 0],
        [1, -1],
    ];
    // per Tile (0 in Array) top + bot with edge of c=1 from top to bott  (use every tile once!)
    // infini edge from bot to top vertices of adjacent tiles if they not protected (array =1)
    // (no reverse edges in normal graph)
    // per prot. Tile (1 in array) Edge from source to this tile with infini cap.
    // per exit Tile (2in array) Edge to sink with infini cap.
    // source is at  pos 2*50*50, sink at 2*50*50+1 as first tile is 0,0 => pos 0
    // top vertices <-> x,y : v=y*50+x   and x= v % 50  y=v/50 (math.floor?)
    // bot vertices <-> top + 2500
    const source = 2 * 50 * 50;
    const sink = 2 * 50 * 50 + 1;
    let top = 0;
    let bot = 0;
    let dx = 0;
    let dy = 0;
    // max = 49;
    const baseCapacity = 10;
    const modifyWeight = preferCloserBarriers ? 1 : 0;
    for (x = bounds.x1 + 1; x < bounds.x2; x++) {
        for (y = bounds.y1 + 1; y < bounds.y2; y++) {
            top = y * 50 + x;
            bot = top + 2500;
            if (roomArray[x][y] >= NORMAL && roomArray[x][y] <= PROTECTED) {
                if (roomArray[x][y] >= NORMAL && roomArray[x][y] < PROTECTED) {
                    g.newEdge(top, bot, baseCapacity - modifyWeight * roomArray[x][y]); // add surplus weighting
                }
                else if (roomArray[x][y] === PROTECTED) {
                    // connect this to the source
                    g.newEdge(source, top, infini);
                    g.newEdge(top, bot, baseCapacity -
                        modifyWeight * RANGE_PADDING * RANGE_MODIFIER);
                }
                for (let i = 0; i < 8; i++) {
                    // attach adjacent edges
                    dx = x + surr[i][0];
                    dy = y + surr[i][1];
                    if ((roomArray[dx][dy] >= NORMAL &&
                        roomArray[dx][dy] < PROTECTED) ||
                        roomArray[dx][dy] === CANNOT_BUILD) {
                        g.newEdge(bot, dy * 50 + dx, infini);
                    }
                }
            }
            else if (roomArray[x][y] === CANNOT_BUILD) {
                // near Exit
                g.newEdge(top, sink, infini);
            }
        }
    } // graph finished
    return g;
}
/**
 * Main function to be called by user: calculate min cut tiles from room using rectangles as protected areas
 * @param room - the room to use
 * @param rectangles - the areas to protect, defined as rectangles
 * @param bounds - the area to be considered for the minCut
 */
function getCutTiles(roomName, toProtect, preferCloserBarriers = true, preferCloserBarrierLimit = Infinity, visualize = true, bounds = { x1: 0, y1: 0, x2: 49, y2: 49 }) {
    const graph = createGraph(roomName, toProtect, preferCloserBarriers, preferCloserBarrierLimit, visualize, bounds);
    if (!graph) {
        return [];
    }
    let x;
    let y;
    const source = 2 * 50 * 50; // Position Source / Sink in Room-Graph
    const sink = 2 * 50 * 50 + 1;
    const count = graph.calcMinCut(source, sink);
    // console.log('Number of Tiles in Cut:', count);
    const positions = [];
    if (count > 0) {
        const cutVertices = graph.getMinCut(source);
        let v;
        for (v of cutVertices) {
            // x= vertex % 50  y=v/50 (math.floor?)
            x = v % 50;
            y = Math.floor(v / 50);
            positions.push({ x, y });
        }
    }
    // Visualise Result
    if (positions.length > 0) {
        const visual = new RoomVisual(roomName);
        for (let i = positions.length - 1; i >= 0; i--) {
            visual.circle(positions[i].x, positions[i].y, {
                radius: 0.5,
                fill: "#ff7722",
                opacity: 0.9,
            });
        }
    }
    else {
        return [];
    }
    const wholeRoom = bounds.x1 === 0 &&
        bounds.y1 === 0 &&
        bounds.x2 === 49 &&
        bounds.y2 === 49;
    return wholeRoom ? positions : pruneDeadEnds(roomName, positions);
}
/**
 * Removes unnecessary tiles if they are blocking the path to a dead end
 * Useful if minCut has been run on a subset of the room
 * @param roomName - Room to work in
 * @param cutTiles - Array of tiles which are in the minCut
 */
function pruneDeadEnds(roomName, cutTiles) {
    // Get Terrain and set all cut-tiles as unwalkable
    const roomArray = get2DArray(roomName);
    let tile;
    for (tile of cutTiles) {
        roomArray[tile.x][tile.y] = UNWALKABLE;
    }
    // Floodfill from exits: save exit tiles in array and do a BFS-like search
    const unvisited = [];
    let y;
    let x;
    for (y = 0; y < 49; y++) {
        if (roomArray[0][y] === EXIT) {
            console.log("prune: toExit", 0, y);
            unvisited.push(50 * y);
        }
        if (roomArray[49][y] === EXIT) {
            console.log("prune: toExit", 49, y);
            unvisited.push(50 * y + 49);
        }
    }
    for (x = 0; x < 49; x++) {
        if (roomArray[x][0] === EXIT) {
            console.log("prune: toExit", x, 0);
            unvisited.push(x);
        }
        if (roomArray[x][49] === EXIT) {
            console.log("prune: toExit", x, 49);
            unvisited.push(2450 + x); // 50*49=2450
        }
    }
    // Iterate over all unvisited EXIT tiles and mark neigbours as EXIT tiles if walkable, add to unvisited
    const surr = [
        [0, -1],
        [-1, -1],
        [-1, 0],
        [-1, 1],
        [0, 1],
        [1, 1],
        [1, 0],
        [1, -1],
    ];
    let currPos;
    let dx;
    let dy;
    while (unvisited.length > 0) {
        currPos = unvisited.pop();
        x = currPos % 50;
        y = Math.floor(currPos / 50);
        for (let i = 0; i < 8; i++) {
            dx = x + surr[i][0];
            dy = y + surr[i][1];
            if (dx < 0 || dx > 49 || dy < 0 || dy > 49) {
                continue;
            }
            if ((roomArray[dx][dy] >= NORMAL &&
                roomArray[dx][dy] < PROTECTED) ||
                roomArray[dx][dy] === CANNOT_BUILD) {
                unvisited.push(50 * dy + dx);
                roomArray[dx][dy] = EXIT;
            }
        }
    }
    // Remove min-Cut-Tile if there is no EXIT reachable by it
    let leadsToExit;
    const validCut = [];
    for (tile of cutTiles) {
        leadsToExit = false;
        for (let j = 0; j < 8; j++) {
            dx = tile.x + surr[j][0];
            dy = tile.y + surr[j][1];
            if (roomArray[dx][dy] === EXIT) {
                leadsToExit = true;
            }
        }
        if (leadsToExit) {
            validCut.push(tile);
        }
    }
    return validCut;
}

var BarrierPlanner_1;
const getDefaultBarrierPlannerMemory = () => ({
    barrierCoordsPacked: "",
});
let BarrierPlanner = BarrierPlanner_1 = class BarrierPlanner {
    constructor(roomPlanner) {
        this.roomPlanner = roomPlanner;
        this.colony = roomPlanner.colony;
        this.memory = Mem.wrap(this.colony.memory, "barrierPlanner", getDefaultBarrierPlannerMemory);
        this.barrierPositions = [];
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, "barrierPlanner", getDefaultBarrierPlannerMemory);
        this.barrierPositions = [];
    }
    computeBunkerBarrierPositions(bunkerPos, upgradeSitePos) {
        const rectArray = [];
        const padding = BarrierPlanner_1.settings.padding;
        if (bunkerPos) {
            const { x, y } = bunkerPos;
            const r = BUNKER_RADIUS - 1;
            let [x1, y1] = [
                Math.max(x - r - padding, 0),
                Math.max(y - r - padding, 0),
            ];
            let [x2, y2] = [
                Math.min(x + r + padding, 49),
                Math.min(y + r + padding, 49),
            ];
            // Make sure you don't leave open walls
            x1 = minMax(x1, 3, 50 - 3);
            x2 = minMax(x2, 3, 50 - 3);
            y1 = minMax(y1, 3, 50 - 3);
            y2 = minMax(y2, 3, 50 - 3);
            rectArray.push({ x1: x1, y1: y1, x2: x2, y2: y2 });
        }
        // Get Min cut
        const barrierCoords = getCutTiles(this.colony.name, rectArray, false, 2, false);
        let positions = _.map(barrierCoords, (coord) => new RoomPosition(coord.x, coord.y, this.colony.name));
        positions = positions.concat(upgradeSitePos.availableNeighbors(true));
        return positions;
    }
    computeBarrierPositions(hatcheryPos, commandCenterPos, upgradeSitePos) {
        const rectArray = [];
        const padding = BarrierPlanner_1.settings.padding;
        if (hatcheryPos) {
            const { x, y } = hatcheryPos;
            const [x1, y1] = [
                Math.max(x - 5 - padding, 0),
                Math.max(y - 4 - padding, 0),
            ];
            const [x2, y2] = [
                Math.min(x + 5 + padding, 49),
                Math.min(y + 6 + padding, 49),
            ];
            rectArray.push({ x1: x1, y1: y1, x2: x2, y2: y2 });
        }
        if (commandCenterPos) {
            const { x, y } = commandCenterPos;
            const [x1, y1] = [
                Math.max(x - 3 - padding, 0),
                Math.max(y - 0 - padding, 0),
            ];
            const [x2, y2] = [
                Math.min(x + 0 + padding, 49),
                Math.min(y + 5 + padding, 49),
            ];
            rectArray.push({ x1: x1, y1: y1, x2: x2, y2: y2 });
        }
        if (upgradeSitePos) {
            const { x, y } = upgradeSitePos;
            const [x1, y1] = [Math.max(x - 1, 0), Math.max(y - 1, 0)];
            const [x2, y2] = [Math.min(x + 1, 49), Math.min(y + 1, 49)];
            rectArray.push({ x1: x1, y1: y1, x2: x2, y2: y2 });
        }
        // Get Min cut
        const barrierCoords = getCutTiles(this.colony.name, rectArray, true, 2, false);
        return _.map(barrierCoords, (coord) => new RoomPosition(coord.x, coord.y, this.colony.name));
    }
    init() { }
    /* Write everything to memory after roomPlanner is closed */
    finalize() {
        if (this.barrierPositions.length == 0) {
            if (this.roomPlanner.bunkerPos) {
                this.barrierPositions = this.computeBunkerBarrierPositions(this.roomPlanner.bunkerPos, this.colony.controller.pos);
            }
            else if (this.roomPlanner.storagePos &&
                this.roomPlanner.hatcheryPos) {
                this.barrierPositions = this.computeBarrierPositions(this.roomPlanner.hatcheryPos, this.roomPlanner.storagePos, this.colony.controller.pos);
            }
            else {
                log.error(`${this.colony.print} BARRIER PLANNER: couldn't generate barrier plan!`);
                return;
            }
        }
        this.memory.barrierCoordsPacked = packCoordList(this.barrierPositions);
    }
    /* Quick lookup for if a barrier should be in this position. Barriers returning false won't be maintained. */
    barrierShouldBeHere(pos) {
        // Once you are high level, only maintain ramparts at bunker or controller
        if (this.colony.layout == "bunker" &&
            this.colony.level >= BarrierPlanner_1.settings.bunkerizeRCL) {
            return (insideBunkerBounds(pos, this.colony) ||
                pos.getRangeTo(this.colony.controller) == 1);
        }
        // Otherwise look up from memory
        if (this._barrierLookup == undefined) {
            this._barrierLookup = _.memoize((p) => this.memory.barrierCoordsPacked.includes(packCoord(p)));
        }
        return this._barrierLookup(pos);
    }
    /* Create construction sites for any buildings that need to be built */
    buildMissingRamparts() {
        // Max buildings that can be placed each tick
        let count = RoomPlanner.settings.maxSitesPerColony -
            this.colony.constructionSites.length;
        // Build missing ramparts
        const barrierPositions = unpackCoordListAsPosList(this.memory.barrierCoordsPacked, this.colony.room.name);
        // Add critical structures to barrier lookup
        const criticalStructures = _.compact([
            ...this.colony.towers,
            ...this.colony.spawns,
            this.colony.storage,
            this.colony.terminal,
        ]);
        for (const structure of criticalStructures) {
            barrierPositions.push(structure.pos);
        }
        for (const pos of barrierPositions) {
            if (count > 0 &&
                RoomPlanner.canBuild(STRUCTURE_RAMPART, pos) &&
                this.barrierShouldBeHere(pos)) {
                const ret = pos.createConstructionSite(STRUCTURE_RAMPART);
                if (ret != OK) {
                    log.warning(`${this.colony.name}: couldn't create rampart site at ${pos.print}: ${errorForCode(ret)}`);
                }
                else {
                    count--;
                }
            }
        }
    }
    buildMissingBunkerRamparts() {
        if (!this.roomPlanner.bunkerPos) {
            return;
        }
        const bunkerCoords = getAllStructureCoordsFromLayout(bunkerLayout, this.colony.level);
        bunkerCoords.push(bunkerLayout.data.anchor); // add center bunker tile
        let bunkerPositions = _.map(bunkerCoords, (coord) => new RoomPosition(coord.x, coord.y, this.colony.name));
        bunkerPositions = translatePositions(bunkerPositions, bunkerLayout.data.anchor, this.roomPlanner.bunkerPos);
        let count = RoomPlanner.settings.maxSitesPerColony -
            this.colony.constructionSites.length;
        for (const pos of bunkerPositions) {
            if (count > 0 &&
                !pos.lookForStructure(STRUCTURE_RAMPART) &&
                pos.lookFor(LOOK_CONSTRUCTION_SITES).length == 0) {
                const ret = pos.createConstructionSite(STRUCTURE_RAMPART);
                if (ret != OK) {
                    log.warning(`${this.colony.name}: couldn't create bunker rampart at ${pos.print}. Result: ${ret}`);
                }
                else {
                    count--;
                }
            }
        }
    }
    run() {
        if (this.roomPlanner.active || this.roomPlanner.visualize) {
            if (this.roomPlanner.bunkerPos) {
                this.barrierPositions = this.computeBunkerBarrierPositions(this.roomPlanner.bunkerPos, this.colony.controller.pos);
            }
            else if (this.roomPlanner.storagePos &&
                this.roomPlanner.hatcheryPos) {
                this.barrierPositions = this.computeBarrierPositions(this.roomPlanner.hatcheryPos, this.roomPlanner.storagePos, this.colony.controller.pos);
            }
            this.visuals();
        }
        else {
            if (!this.roomPlanner.memory.relocating &&
                this.colony.level >=
                    BarrierPlanner_1.settings.buildBarriersAtRCL &&
                this.roomPlanner.shouldRecheck(2)) {
                this.buildMissingRamparts();
                if (this.colony.layout == "bunker" && this.colony.level >= 7) {
                    this.buildMissingBunkerRamparts();
                }
            }
        }
    }
    visuals() {
        for (const pos of this.barrierPositions) {
            this.colony.room.visual.structure(pos.x, pos.y, STRUCTURE_RAMPART);
        }
    }
};
BarrierPlanner.settings = {
    buildBarriersAtRCL: 3,
    padding: 3, // allow this much space between structures and barriers (if possible)
    bunkerizeRCL: 7,
};
BarrierPlanner = BarrierPlanner_1 = __decorate$1([
    profile
], BarrierPlanner);

/* eslint-disable */
var commandCenterLayout = {
    data: { anchor: { x: 25, y: 25 } },
    3: {
        name: "commandCenter",
        shard: "shard0",
        rcl: "3",
        buildings: { tower: { pos: [{ x: 24, y: 27 }] } },
    },
    4: {
        name: "commandCenter",
        shard: "shard0",
        rcl: "4",
        buildings: {
            road: {
                pos: [
                    { x: 21, y: 24 },
                    { x: 22, y: 24 },
                    { x: 23, y: 24 },
                    { x: 24, y: 24 },
                    { x: 25, y: 24 },
                    { x: 26, y: 24 },
                    { x: 21, y: 25 },
                    { x: 26, y: 25 },
                    { x: 21, y: 26 },
                    { x: 23, y: 26 },
                    { x: 24, y: 26 },
                    { x: 26, y: 26 },
                    { x: 21, y: 27 },
                    { x: 22, y: 27 },
                    { x: 25, y: 27 },
                    { x: 26, y: 27 },
                    { x: 21, y: 28 },
                    { x: 22, y: 28 },
                    { x: 25, y: 28 },
                    { x: 26, y: 28 },
                    { x: 21, y: 29 },
                    { x: 26, y: 29 },
                    { x: 21, y: 30 },
                    { x: 26, y: 30 },
                    { x: 21, y: 31 },
                    { x: 22, y: 31 },
                    { x: 23, y: 31 },
                    { x: 24, y: 31 },
                    { x: 25, y: 31 },
                    { x: 26, y: 31 },
                ],
            },
            storage: { pos: [{ x: 25, y: 25 }] },
            tower: { pos: [{ x: 24, y: 27 }] },
        },
    },
    5: {
        name: "commandCenter",
        shard: "shard0",
        rcl: "5",
        buildings: {
            road: {
                pos: [
                    { x: 21, y: 24 },
                    { x: 22, y: 24 },
                    { x: 23, y: 24 },
                    { x: 24, y: 24 },
                    { x: 25, y: 24 },
                    { x: 26, y: 24 },
                    { x: 21, y: 25 },
                    { x: 26, y: 25 },
                    { x: 21, y: 26 },
                    { x: 23, y: 26 },
                    { x: 24, y: 26 },
                    { x: 26, y: 26 },
                    { x: 21, y: 27 },
                    { x: 22, y: 27 },
                    { x: 25, y: 27 },
                    { x: 26, y: 27 },
                    { x: 21, y: 28 },
                    { x: 22, y: 28 },
                    { x: 25, y: 28 },
                    { x: 26, y: 28 },
                    { x: 21, y: 29 },
                    { x: 26, y: 29 },
                    { x: 21, y: 30 },
                    { x: 26, y: 30 },
                    { x: 21, y: 31 },
                    { x: 22, y: 31 },
                    { x: 23, y: 31 },
                    { x: 24, y: 31 },
                    { x: 25, y: 31 },
                    { x: 26, y: 31 },
                ],
            },
            link: { pos: [{ x: 24, y: 25 }] },
            storage: { pos: [{ x: 25, y: 25 }] },
            tower: { pos: [{ x: 24, y: 27 }] },
        },
    },
    6: {
        name: "commandCenter",
        shard: "shard0",
        rcl: "6",
        buildings: {
            road: {
                pos: [
                    { x: 21, y: 24 },
                    { x: 22, y: 24 },
                    { x: 23, y: 24 },
                    { x: 24, y: 24 },
                    { x: 25, y: 24 },
                    { x: 26, y: 24 },
                    { x: 21, y: 25 },
                    { x: 26, y: 25 },
                    { x: 21, y: 26 },
                    { x: 23, y: 26 },
                    { x: 24, y: 26 },
                    { x: 26, y: 26 },
                    { x: 21, y: 27 },
                    { x: 22, y: 27 },
                    { x: 25, y: 27 },
                    { x: 26, y: 27 },
                    { x: 21, y: 28 },
                    { x: 22, y: 28 },
                    { x: 25, y: 28 },
                    { x: 26, y: 28 },
                    { x: 21, y: 29 },
                    { x: 26, y: 29 },
                    { x: 21, y: 30 },
                    { x: 26, y: 30 },
                    { x: 21, y: 31 },
                    { x: 22, y: 31 },
                    { x: 23, y: 31 },
                    { x: 24, y: 31 },
                    { x: 25, y: 31 },
                    { x: 26, y: 31 },
                ],
            },
            link: { pos: [{ x: 24, y: 25 }] },
            storage: { pos: [{ x: 25, y: 25 }] },
            terminal: { pos: [{ x: 25, y: 26 }] },
            tower: { pos: [{ x: 24, y: 27 }] },
            lab: {
                pos: [
                    { x: 23, y: 28 },
                    { x: 24, y: 28 },
                    { x: 24, y: 29 },
                ],
            },
        },
    },
    7: {
        name: "commandCenter",
        shard: "shard0",
        rcl: "7",
        buildings: {
            road: {
                pos: [
                    { x: 21, y: 24 },
                    { x: 22, y: 24 },
                    { x: 23, y: 24 },
                    { x: 24, y: 24 },
                    { x: 25, y: 24 },
                    { x: 26, y: 24 },
                    { x: 21, y: 25 },
                    { x: 26, y: 25 },
                    { x: 21, y: 26 },
                    { x: 23, y: 26 },
                    { x: 24, y: 26 },
                    { x: 26, y: 26 },
                    { x: 21, y: 27 },
                    { x: 22, y: 27 },
                    { x: 25, y: 27 },
                    { x: 26, y: 27 },
                    { x: 21, y: 28 },
                    { x: 22, y: 28 },
                    { x: 25, y: 28 },
                    { x: 26, y: 28 },
                    { x: 21, y: 29 },
                    { x: 26, y: 29 },
                    { x: 21, y: 30 },
                    { x: 26, y: 30 },
                    { x: 21, y: 31 },
                    { x: 22, y: 31 },
                    { x: 23, y: 31 },
                    { x: 24, y: 31 },
                    { x: 25, y: 31 },
                    { x: 26, y: 31 },
                ],
            },
            link: { pos: [{ x: 24, y: 25 }] },
            storage: { pos: [{ x: 25, y: 25 }] },
            terminal: { pos: [{ x: 25, y: 26 }] },
            tower: {
                pos: [
                    { x: 23, y: 27 },
                    { x: 24, y: 27 },
                ],
            },
            lab: {
                pos: [
                    { x: 23, y: 28 },
                    { x: 24, y: 28 },
                    { x: 22, y: 29 },
                    { x: 23, y: 29 },
                    { x: 24, y: 29 },
                    { x: 25, y: 29 },
                ],
            },
        },
    },
    8: {
        name: "commandCenter",
        shard: "shard0",
        rcl: "8",
        buildings: {
            road: {
                pos: [
                    { x: 21, y: 24 },
                    { x: 22, y: 24 },
                    { x: 23, y: 24 },
                    { x: 24, y: 24 },
                    { x: 25, y: 24 },
                    { x: 26, y: 24 },
                    { x: 21, y: 25 },
                    { x: 26, y: 25 },
                    { x: 21, y: 26 },
                    { x: 23, y: 26 },
                    { x: 24, y: 26 },
                    { x: 26, y: 26 },
                    { x: 21, y: 27 },
                    { x: 22, y: 27 },
                    { x: 25, y: 27 },
                    { x: 26, y: 27 },
                    { x: 21, y: 28 },
                    { x: 22, y: 28 },
                    { x: 25, y: 28 },
                    { x: 26, y: 28 },
                    { x: 21, y: 29 },
                    { x: 26, y: 29 },
                    { x: 21, y: 30 },
                    { x: 26, y: 30 },
                    { x: 21, y: 31 },
                    { x: 22, y: 31 },
                    { x: 23, y: 31 },
                    { x: 24, y: 31 },
                    { x: 25, y: 31 },
                    { x: 26, y: 31 },
                ],
            },
            nuker: { pos: [{ x: 22, y: 25 }] },
            powerSpawn: { pos: [{ x: 23, y: 25 }] },
            link: { pos: [{ x: 24, y: 25 }] },
            storage: { pos: [{ x: 25, y: 25 }] },
            observer: { pos: [{ x: 22, y: 26 }] },
            terminal: { pos: [{ x: 25, y: 26 }] },
            tower: {
                pos: [
                    { x: 23, y: 27 },
                    { x: 24, y: 27 },
                ],
            },
            lab: {
                pos: [
                    { x: 23, y: 28 },
                    { x: 24, y: 28 },
                    { x: 22, y: 29 },
                    { x: 23, y: 29 },
                    { x: 24, y: 29 },
                    { x: 25, y: 29 },
                    { x: 22, y: 30 },
                    { x: 23, y: 30 },
                    { x: 24, y: 30 },
                    { x: 25, y: 30 },
                ],
            },
        },
    },
};

/* eslint-disable */
var hatcheryLayout = {
    data: { anchor: { x: 25, y: 24 } },
    1: {
        name: "hatchery",
        shard: "shard0",
        rcl: "1",
        buildings: { spawn: { pos: [{ x: 25, y: 24 }] } },
    },
    2: {
        name: "hatchery",
        shard: "shard0",
        rcl: "2",
        buildings: {
            extension: {
                pos: [
                    { x: 24, y: 23 },
                    { x: 26, y: 23 },
                    { x: 23, y: 24 },
                    { x: 27, y: 24 },
                    { x: 27, y: 26 },
                ],
            },
            spawn: { pos: [{ x: 25, y: 24 }] },
            container: { pos: [{ x: 25, y: 25 }] },
        },
    },
    3: {
        name: "hatchery",
        shard: "shard0",
        rcl: "3",
        buildings: {
            extension: {
                pos: [
                    { x: 24, y: 22 },
                    { x: 26, y: 22 },
                    { x: 24, y: 23 },
                    { x: 26, y: 23 },
                    { x: 23, y: 24 },
                    { x: 27, y: 24 },
                    { x: 23, y: 26 },
                    { x: 27, y: 26 },
                    { x: 24, y: 27 },
                    { x: 26, y: 27 },
                ],
            },
            spawn: { pos: [{ x: 25, y: 24 }] },
            container: { pos: [{ x: 25, y: 25 }] },
        },
    },
    4: {
        name: "hatchery",
        shard: "shard0",
        rcl: "4",
        buildings: {
            road: {
                pos: [
                    { x: 25, y: 25 },
                    { x: 25, y: 20 },
                    { x: 21, y: 21 },
                    { x: 24, y: 21 },
                    { x: 26, y: 21 },
                    { x: 29, y: 21 },
                    { x: 22, y: 22 },
                    { x: 25, y: 22 },
                    { x: 28, y: 22 },
                    { x: 23, y: 23 },
                    { x: 25, y: 23 },
                    { x: 27, y: 23 },
                    { x: 21, y: 24 },
                    { x: 24, y: 24 },
                    { x: 26, y: 24 },
                    { x: 29, y: 24 },
                    { x: 20, y: 25 },
                    { x: 22, y: 25 },
                    { x: 23, y: 25 },
                    { x: 27, y: 25 },
                    { x: 28, y: 25 },
                    { x: 30, y: 25 },
                    { x: 21, y: 26 },
                    { x: 24, y: 26 },
                    { x: 26, y: 26 },
                    { x: 29, y: 26 },
                    { x: 23, y: 27 },
                    { x: 25, y: 27 },
                    { x: 27, y: 27 },
                    { x: 22, y: 28 },
                    { x: 25, y: 28 },
                    { x: 28, y: 28 },
                    { x: 21, y: 29 },
                    { x: 24, y: 29 },
                    { x: 26, y: 29 },
                    { x: 29, y: 29 },
                    { x: 25, y: 30 },
                ],
            },
            extension: {
                pos: [
                    { x: 23, y: 22 },
                    { x: 24, y: 22 },
                    { x: 26, y: 22 },
                    { x: 27, y: 22 },
                    { x: 24, y: 23 },
                    { x: 26, y: 23 },
                    { x: 22, y: 24 },
                    { x: 23, y: 24 },
                    { x: 27, y: 24 },
                    { x: 28, y: 24 },
                    { x: 22, y: 26 },
                    { x: 23, y: 26 },
                    { x: 27, y: 26 },
                    { x: 28, y: 26 },
                    { x: 24, y: 27 },
                    { x: 26, y: 27 },
                    { x: 23, y: 28 },
                    { x: 24, y: 28 },
                    { x: 26, y: 28 },
                    { x: 27, y: 28 },
                ],
            },
            spawn: { pos: [{ x: 25, y: 24 }] },
            container: { pos: [{ x: 25, y: 25 }] },
        },
    },
    5: {
        name: "hatchery",
        shard: "shard0",
        rcl: "5",
        buildings: {
            road: {
                pos: [
                    { x: 25, y: 25 },
                    { x: 25, y: 20 },
                    { x: 21, y: 21 },
                    { x: 24, y: 21 },
                    { x: 26, y: 21 },
                    { x: 29, y: 21 },
                    { x: 22, y: 22 },
                    { x: 25, y: 22 },
                    { x: 28, y: 22 },
                    { x: 23, y: 23 },
                    { x: 25, y: 23 },
                    { x: 27, y: 23 },
                    { x: 21, y: 24 },
                    { x: 24, y: 24 },
                    { x: 26, y: 24 },
                    { x: 29, y: 24 },
                    { x: 20, y: 25 },
                    { x: 22, y: 25 },
                    { x: 23, y: 25 },
                    { x: 27, y: 25 },
                    { x: 28, y: 25 },
                    { x: 30, y: 25 },
                    { x: 21, y: 26 },
                    { x: 24, y: 26 },
                    { x: 26, y: 26 },
                    { x: 29, y: 26 },
                    { x: 23, y: 27 },
                    { x: 25, y: 27 },
                    { x: 27, y: 27 },
                    { x: 22, y: 28 },
                    { x: 25, y: 28 },
                    { x: 28, y: 28 },
                    { x: 21, y: 29 },
                    { x: 24, y: 29 },
                    { x: 26, y: 29 },
                    { x: 29, y: 29 },
                    { x: 25, y: 30 },
                ],
            },
            extension: {
                pos: [
                    { x: 23, y: 21 },
                    { x: 27, y: 21 },
                    { x: 23, y: 22 },
                    { x: 24, y: 22 },
                    { x: 26, y: 22 },
                    { x: 27, y: 22 },
                    { x: 21, y: 23 },
                    { x: 22, y: 23 },
                    { x: 24, y: 23 },
                    { x: 26, y: 23 },
                    { x: 28, y: 23 },
                    { x: 29, y: 23 },
                    { x: 22, y: 24 },
                    { x: 23, y: 24 },
                    { x: 27, y: 24 },
                    { x: 28, y: 24 },
                    { x: 22, y: 26 },
                    { x: 23, y: 26 },
                    { x: 27, y: 26 },
                    { x: 28, y: 26 },
                    { x: 22, y: 27 },
                    { x: 24, y: 27 },
                    { x: 26, y: 27 },
                    { x: 28, y: 27 },
                    { x: 29, y: 27 },
                    { x: 23, y: 28 },
                    { x: 24, y: 28 },
                    { x: 26, y: 28 },
                    { x: 27, y: 28 },
                    { x: 27, y: 29 },
                ],
            },
            spawn: { pos: [{ x: 25, y: 24 }] },
            container: { pos: [{ x: 25, y: 25 }] },
            tower: { pos: [{ x: 29, y: 25 }] },
            link: { pos: [{ x: 25, y: 26 }] },
        },
    },
    6: {
        name: "hatchery",
        shard: "shard0",
        rcl: "6",
        buildings: {
            road: {
                pos: [
                    { x: 25, y: 25 },
                    { x: 25, y: 20 },
                    { x: 21, y: 21 },
                    { x: 24, y: 21 },
                    { x: 26, y: 21 },
                    { x: 29, y: 21 },
                    { x: 22, y: 22 },
                    { x: 25, y: 22 },
                    { x: 28, y: 22 },
                    { x: 23, y: 23 },
                    { x: 25, y: 23 },
                    { x: 27, y: 23 },
                    { x: 21, y: 24 },
                    { x: 24, y: 24 },
                    { x: 26, y: 24 },
                    { x: 29, y: 24 },
                    { x: 20, y: 25 },
                    { x: 22, y: 25 },
                    { x: 23, y: 25 },
                    { x: 27, y: 25 },
                    { x: 28, y: 25 },
                    { x: 30, y: 25 },
                    { x: 21, y: 26 },
                    { x: 24, y: 26 },
                    { x: 26, y: 26 },
                    { x: 29, y: 26 },
                    { x: 23, y: 27 },
                    { x: 25, y: 27 },
                    { x: 27, y: 27 },
                    { x: 22, y: 28 },
                    { x: 25, y: 28 },
                    { x: 28, y: 28 },
                    { x: 21, y: 29 },
                    { x: 24, y: 29 },
                    { x: 26, y: 29 },
                    { x: 29, y: 29 },
                    { x: 25, y: 30 },
                ],
            },
            extension: {
                pos: [
                    { x: 22, y: 21 },
                    { x: 23, y: 21 },
                    { x: 27, y: 21 },
                    { x: 28, y: 21 },
                    { x: 21, y: 22 },
                    { x: 23, y: 22 },
                    { x: 24, y: 22 },
                    { x: 26, y: 22 },
                    { x: 27, y: 22 },
                    { x: 29, y: 22 },
                    { x: 21, y: 23 },
                    { x: 22, y: 23 },
                    { x: 24, y: 23 },
                    { x: 26, y: 23 },
                    { x: 28, y: 23 },
                    { x: 29, y: 23 },
                    { x: 22, y: 24 },
                    { x: 23, y: 24 },
                    { x: 27, y: 24 },
                    { x: 28, y: 24 },
                    { x: 22, y: 26 },
                    { x: 23, y: 26 },
                    { x: 27, y: 26 },
                    { x: 28, y: 26 },
                    { x: 21, y: 27 },
                    { x: 22, y: 27 },
                    { x: 24, y: 27 },
                    { x: 26, y: 27 },
                    { x: 28, y: 27 },
                    { x: 29, y: 27 },
                    { x: 21, y: 28 },
                    { x: 23, y: 28 },
                    { x: 24, y: 28 },
                    { x: 26, y: 28 },
                    { x: 27, y: 28 },
                    { x: 29, y: 28 },
                    { x: 22, y: 29 },
                    { x: 23, y: 29 },
                    { x: 27, y: 29 },
                    { x: 28, y: 29 },
                ],
            },
            spawn: { pos: [{ x: 25, y: 24 }] },
            container: { pos: [{ x: 25, y: 25 }] },
            tower: { pos: [{ x: 29, y: 25 }] },
            link: { pos: [{ x: 25, y: 26 }] },
        },
    },
    7: {
        name: "hatchery",
        shard: "shard0",
        rcl: "7",
        buildings: {
            extension: {
                pos: [
                    { x: 21, y: 20 },
                    { x: 22, y: 20 },
                    { x: 28, y: 20 },
                    { x: 29, y: 20 },
                    { x: 20, y: 21 },
                    { x: 22, y: 21 },
                    { x: 23, y: 21 },
                    { x: 27, y: 21 },
                    { x: 28, y: 21 },
                    { x: 30, y: 21 },
                    { x: 20, y: 22 },
                    { x: 21, y: 22 },
                    { x: 23, y: 22 },
                    { x: 24, y: 22 },
                    { x: 26, y: 22 },
                    { x: 27, y: 22 },
                    { x: 29, y: 22 },
                    { x: 30, y: 22 },
                    { x: 21, y: 23 },
                    { x: 22, y: 23 },
                    { x: 24, y: 23 },
                    { x: 26, y: 23 },
                    { x: 28, y: 23 },
                    { x: 29, y: 23 },
                    { x: 22, y: 24 },
                    { x: 23, y: 24 },
                    { x: 27, y: 24 },
                    { x: 28, y: 24 },
                    { x: 22, y: 26 },
                    { x: 23, y: 26 },
                    { x: 27, y: 26 },
                    { x: 28, y: 26 },
                    { x: 21, y: 27 },
                    { x: 22, y: 27 },
                    { x: 24, y: 27 },
                    { x: 26, y: 27 },
                    { x: 28, y: 27 },
                    { x: 29, y: 27 },
                    { x: 21, y: 28 },
                    { x: 23, y: 28 },
                    { x: 24, y: 28 },
                    { x: 26, y: 28 },
                    { x: 27, y: 28 },
                    { x: 29, y: 28 },
                    { x: 20, y: 29 },
                    { x: 22, y: 29 },
                    { x: 23, y: 29 },
                    { x: 27, y: 29 },
                    { x: 28, y: 29 },
                    { x: 30, y: 29 },
                ],
            },
            road: {
                pos: [
                    { x: 25, y: 25 },
                    { x: 25, y: 20 },
                    { x: 21, y: 21 },
                    { x: 24, y: 21 },
                    { x: 26, y: 21 },
                    { x: 29, y: 21 },
                    { x: 22, y: 22 },
                    { x: 25, y: 22 },
                    { x: 28, y: 22 },
                    { x: 23, y: 23 },
                    { x: 25, y: 23 },
                    { x: 27, y: 23 },
                    { x: 21, y: 24 },
                    { x: 24, y: 24 },
                    { x: 26, y: 24 },
                    { x: 29, y: 24 },
                    { x: 20, y: 25 },
                    { x: 22, y: 25 },
                    { x: 23, y: 25 },
                    { x: 27, y: 25 },
                    { x: 28, y: 25 },
                    { x: 30, y: 25 },
                    { x: 21, y: 26 },
                    { x: 24, y: 26 },
                    { x: 26, y: 26 },
                    { x: 29, y: 26 },
                    { x: 23, y: 27 },
                    { x: 25, y: 27 },
                    { x: 27, y: 27 },
                    { x: 22, y: 28 },
                    { x: 25, y: 28 },
                    { x: 28, y: 28 },
                    { x: 21, y: 29 },
                    { x: 24, y: 29 },
                    { x: 26, y: 29 },
                    { x: 29, y: 29 },
                    { x: 25, y: 30 },
                ],
            },
            spawn: {
                pos: [
                    { x: 25, y: 24 },
                    { x: 24, y: 25 },
                ],
            },
            tower: { pos: [{ x: 29, y: 25 }] },
            container: { pos: [{ x: 25, y: 25 }] },
            link: { pos: [{ x: 25, y: 26 }] },
        },
    },
    8: {
        name: "hatchery",
        shard: "shard0",
        rcl: "8",
        buildings: {
            extension: {
                pos: [
                    { x: 20, y: 20 },
                    { x: 21, y: 20 },
                    { x: 22, y: 20 },
                    { x: 28, y: 20 },
                    { x: 29, y: 20 },
                    { x: 30, y: 20 },
                    { x: 20, y: 21 },
                    { x: 22, y: 21 },
                    { x: 23, y: 21 },
                    { x: 27, y: 21 },
                    { x: 28, y: 21 },
                    { x: 30, y: 21 },
                    { x: 20, y: 22 },
                    { x: 21, y: 22 },
                    { x: 23, y: 22 },
                    { x: 24, y: 22 },
                    { x: 26, y: 22 },
                    { x: 27, y: 22 },
                    { x: 29, y: 22 },
                    { x: 30, y: 22 },
                    { x: 21, y: 23 },
                    { x: 22, y: 23 },
                    { x: 24, y: 23 },
                    { x: 26, y: 23 },
                    { x: 28, y: 23 },
                    { x: 29, y: 23 },
                    { x: 22, y: 24 },
                    { x: 23, y: 24 },
                    { x: 27, y: 24 },
                    { x: 28, y: 24 },
                    { x: 22, y: 26 },
                    { x: 23, y: 26 },
                    { x: 27, y: 26 },
                    { x: 28, y: 26 },
                    { x: 21, y: 27 },
                    { x: 22, y: 27 },
                    { x: 24, y: 27 },
                    { x: 26, y: 27 },
                    { x: 28, y: 27 },
                    { x: 29, y: 27 },
                    { x: 20, y: 28 },
                    { x: 21, y: 28 },
                    { x: 23, y: 28 },
                    { x: 24, y: 28 },
                    { x: 26, y: 28 },
                    { x: 27, y: 28 },
                    { x: 29, y: 28 },
                    { x: 30, y: 28 },
                    { x: 20, y: 29 },
                    { x: 22, y: 29 },
                    { x: 23, y: 29 },
                    { x: 27, y: 29 },
                    { x: 28, y: 29 },
                    { x: 30, y: 29 },
                    { x: 20, y: 30 },
                    { x: 21, y: 30 },
                    { x: 22, y: 30 },
                    { x: 28, y: 30 },
                    { x: 29, y: 30 },
                    { x: 30, y: 30 },
                ],
            },
            road: {
                pos: [
                    { x: 25, y: 25 },
                    { x: 25, y: 20 },
                    { x: 21, y: 21 },
                    { x: 24, y: 21 },
                    { x: 26, y: 21 },
                    { x: 29, y: 21 },
                    { x: 22, y: 22 },
                    { x: 25, y: 22 },
                    { x: 28, y: 22 },
                    { x: 23, y: 23 },
                    { x: 25, y: 23 },
                    { x: 27, y: 23 },
                    { x: 21, y: 24 },
                    { x: 24, y: 24 },
                    { x: 26, y: 24 },
                    { x: 29, y: 24 },
                    { x: 20, y: 25 },
                    { x: 22, y: 25 },
                    { x: 23, y: 25 },
                    { x: 27, y: 25 },
                    { x: 28, y: 25 },
                    { x: 30, y: 25 },
                    { x: 21, y: 26 },
                    { x: 24, y: 26 },
                    { x: 26, y: 26 },
                    { x: 29, y: 26 },
                    { x: 23, y: 27 },
                    { x: 25, y: 27 },
                    { x: 27, y: 27 },
                    { x: 22, y: 28 },
                    { x: 25, y: 28 },
                    { x: 28, y: 28 },
                    { x: 21, y: 29 },
                    { x: 24, y: 29 },
                    { x: 26, y: 29 },
                    { x: 29, y: 29 },
                    { x: 25, y: 30 },
                ],
            },
            tower: {
                pos: [
                    { x: 25, y: 21 },
                    { x: 21, y: 25 },
                    { x: 29, y: 25 },
                    { x: 25, y: 29 },
                ],
            },
            spawn: {
                pos: [
                    { x: 25, y: 24 },
                    { x: 24, y: 25 },
                    { x: 26, y: 25 },
                ],
            },
            container: { pos: [{ x: 25, y: 25 }] },
            link: { pos: [{ x: 25, y: 26 }] },
        },
    },
};

var RoadPlanner_1;
const ROAD_PLANNER_PLAIN_COST = 3;
const ROAD_PLANNER_SWAMP_COST = 4;
const ROAD_PLANNER_TUNNEL_COST = 15 * ROAD_PLANNER_PLAIN_COST;
const EXISTING_PATH_COST = ROAD_PLANNER_PLAIN_COST - 1;
const getDefaultRoadPlannerMemory = () => ({
    roadCoordsPacked: {},
    roadCoverage: 0.0,
    roadCoverages: {},
});
let RoadPlanner = RoadPlanner_1 = class RoadPlanner {
    constructor(roomPlanner) {
        this.roomPlanner = roomPlanner;
        this.colony = roomPlanner.colony;
        this.memory = Mem.wrap(this.colony.memory, "roadPlanner", getDefaultRoadPlannerMemory);
        this.costMatrices = {};
        this.roadPositions = [];
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, "roadPlanner", getDefaultRoadPlannerMemory);
        this.costMatrices = {};
        this.roadPositions = [];
    }
    get roadCoverage() {
        return this.memory.roadCoverage;
    }
    recomputeRoadCoverages(storagePos, ignoreInactiveRooms = true) {
        // Compute coverage for each path
        for (const destination of this.colony.destinations.values()) {
            const destName = destination.pos.readableName;
            if (!!this.memory.roadCoordsPacked[destination.pos.roomName]) {
                if (!this.memory.roadCoverages[destName] ||
                    Game.time > this.memory.roadCoverages[destName].exp) {
                    const roadCoverage = this.computeRoadCoverage(storagePos, destination.pos);
                    if (roadCoverage != undefined) {
                        // Set expiration to be longer if road is nearly complete
                        const expiration = (roadCoverage.roadCount / roadCoverage.length >=
                            0.75) ?
                            getCacheExpiration(RoadPlanner_1.settings
                                .recomputeCoverageInterval)
                            : getCacheExpiration(3 *
                                RoadPlanner_1.settings
                                    .recomputeCoverageInterval);
                        this.memory.roadCoverages[destName] = {
                            roadCount: roadCoverage.roadCount,
                            length: roadCoverage.length,
                            exp: expiration,
                        };
                    }
                    else {
                        if (this.memory.roadCoverages[destName]) {
                            // if you already have some data, use it for a little while
                            const waitTime = onPublicServer() ? 500 : 200;
                            this.memory.roadCoverages[destName].exp += waitTime;
                        }
                        else {
                            // otherwise put in a placeholder
                            const waitTime = onPublicServer() ? 300 : 100;
                            this.memory.roadCoverages[destName] = {
                                roadCount: 0,
                                length: 1,
                                exp: Game.time + waitTime,
                            };
                        }
                    }
                    log.debug(`Recomputing road coverage from ${storagePos.print} to ${destination.pos.print}... ` +
                        `Coverage: ${JSON.stringify(roadCoverage)}`);
                }
            }
        }
        // Store the aggregate roadCoverage score
        let totalRoadCount = 0;
        let totalPathLength = 0;
        for (const destName in this.memory.roadCoverages) {
            const destPos = posFromReadableName(destName);
            if (ignoreInactiveRooms &&
                !this.colony.isRoomActive(destPos.roomName)) {
                continue;
            }
            const { roadCount, length } = this.memory.roadCoverages[destName];
            totalRoadCount += roadCount;
            totalPathLength += length;
        }
        this.memory.roadCoverage = totalRoadCount / totalPathLength;
    }
    computeRoadCoverage(storagePos, destination) {
        const ret = Pathing.findPath(storagePos, destination, {
            terrainCosts: { plainCost: 2, swampCost: 10 },
        });
        const path = ret.path;
        const roomNames = _.unique(_.map(path, (pos) => pos.roomName));
        // If you have vision or cached vision of the room
        if (_.all(roomNames, (roomName) => Game.rooms[roomName] ||
            $.costMatrixRecall(roomName, MatrixTypes.default))) {
            let roadCount = 0;
            for (const pos of path) {
                if (Game.rooms[pos.roomName]) {
                    if (pos.lookForStructure(STRUCTURE_ROAD)) {
                        roadCount++;
                    }
                }
                else {
                    const mat = $.costMatrixRecall(pos.roomName, MatrixTypes.default);
                    if (mat) {
                        if (mat.get(pos.x, pos.y) == 1) {
                            roadCount++;
                        }
                    }
                    else {
                        // shouldn't happen
                        log.warning(`No vision or recalled cost matrix in room ${pos.roomName}! (Why?)`);
                    }
                }
            }
            return { roadCount: roadCount, length: path.length };
        }
    }
    recalculateRoadNetwork(storagePos, obstacles) {
        this.buildRoadNetwork(storagePos, obstacles);
        this.finalize();
    }
    // Connect commandCenter to hatchery, upgradeSites, and all miningSites, and place containers
    buildRoadNetwork(storagePos, obstacles) {
        this.costMatrices = {};
        this.roadPositions = [];
        const destinations = _.sortBy([...this.colony.destinations.values()], (destination) => destination.order);
        // Connect commandCenter to each destination in colony
        for (const destination of destinations) {
            this.planRoad(storagePos, destination.pos, obstacles);
        }
        this.formatRoadPositions();
    }
    // Plan a road between two locations avoiding a list of planned obstacles; pos1 should be storage for best results
    planRoad(pos1, pos2, obstacles) {
        // Find the shortest path, preferentially stepping on tiles with road routing flags on them
        const roadPath = this.generateRoadPath(pos1, pos2, obstacles);
        if (roadPath) {
            this.roadPositions = this.roadPositions.concat(roadPath);
        }
    }
    generateRoadPlanningCostMatrix(roomName, obstacles) {
        const matrix = new PathFinder.CostMatrix();
        const terrain = Game.map.getRoomTerrain(roomName);
        for (let y = 0; y < 50; ++y) {
            for (let x = 0; x < 50; ++x) {
                switch (terrain.get(x, y)) {
                    case TERRAIN_MASK_SWAMP:
                        matrix.set(x, y, ROAD_PLANNER_SWAMP_COST);
                        break;
                    case TERRAIN_MASK_WALL:
                        if (x != 0 && y != 0 && x != 49 && y != 49) {
                            // Can't tunnel through walls on edge tiles
                            matrix.set(x, y, ROAD_PLANNER_TUNNEL_COST);
                        }
                        break;
                    default: // plain
                        matrix.set(x, y, ROAD_PLANNER_PLAIN_COST);
                        break;
                }
            }
        }
        for (const pos of obstacles) {
            if (pos.roomName == roomName) {
                matrix.set(pos.x, pos.y, 0xff);
            }
        }
        const room = Game.rooms[roomName];
        if (room) {
            // Mark unpassable structures & construction sites
            for (const structure of [
                ...room.structures,
                ...room.constructionSites,
            ]) {
                if (structure.isWalkable) {
                    continue;
                }
                matrix.set(structure.pos.x, structure.pos.y, 0xff);
            }
            // If we generating a new path, ensure the current roads are reused
            if (RoadPlanner_1.settings.encourageRoadMerging) {
                const roads = room.find(FIND_STRUCTURES, {
                    filter: { structureType: STRUCTURE_ROAD },
                });
                for (const road of roads) {
                    // Only reuse roads that should already be there
                    if (matrix.get(road.pos.x, road.pos.y) === 0xff) {
                        continue;
                    }
                    matrix.set(road.pos.x, road.pos.y, EXISTING_PATH_COST);
                }
            }
        }
        return matrix;
    }
    /* Generates a road path and modifies cost matrices to encourage merging with future roads */
    generateRoadPath(origin, destination, obstacles) {
        var _a;
        const roomCallback = (roomName) => {
            if (!this.colony.roomNames.includes(roomName)) {
                // only route through colony rooms
                return false;
            }
            if (RoomIntel.isConsideredHostile(roomName) &&
                roomName != origin.roomName &&
                roomName != destination.roomName) {
                return false;
            }
            if (!this.costMatrices[roomName]) {
                this.costMatrices[roomName] =
                    this.generateRoadPlanningCostMatrix(roomName, obstacles);
            }
            return this.costMatrices[roomName];
        };
        const maxOps = 40000;
        const ret = PathFinder.search(origin, { pos: destination, range: 1 }, { roomCallback, maxOps });
        if (ret.incomplete) {
            log.warning(`Roadplanner for ${this.colony.print}: could not plan road path!`);
            log.info(`Road: ${origin.print} -> ${destination.print}, ops: ${ret.ops}/${maxOps}, length: ${ret.path.length}, end: ${(_a = ret.path[ret.path.length - 1]) === null || _a === void 0 ? void 0 : _a.print}`);
            return;
        }
        // Reduce the cost of planned paths to encourage road overlap for future pathing
        if (RoadPlanner_1.settings.encourageRoadMerging) {
            for (const i of _.range(ret.path.length)) {
                const pos = ret.path[i];
                if (i % 2 == 0 &&
                    this.costMatrices[pos.roomName] &&
                    !pos.isEdge) {
                    this.costMatrices[pos.roomName].set(pos.x, pos.y, EXISTING_PATH_COST);
                }
            }
        }
        // Return the pathfinder results
        return ret.path;
    }
    /* Ensure that the roads doesn't overlap with roads from this.map and that the positions are unique */
    formatRoadPositions() {
        // Make road position list unique
        this.roadPositions = _.unique(this.roadPositions);
        // Remove roads located on exit tiles
        _.remove(this.roadPositions, (pos) => pos.isEdge);
        // Remove any roads duplicated in this.map
        const roomPlannerRoads = this.roomPlanner.plannedStructurePositions(STRUCTURE_ROAD);
        if (roomPlannerRoads != undefined) {
            _.remove(this.roadPositions, (pos) => roomPlannerRoads.includes(pos));
        }
    }
    /* Write everything to memory after roomPlanner is closed */
    finalize() {
        // Collect all roads from this and from room planner
        let roomPlannerRoads;
        if (_.keys(this.roomPlanner.map).length > 0) {
            // use active map
            roomPlannerRoads = this.roomPlanner.map[STRUCTURE_ROAD];
        }
        else {
            // retrieve from memory
            if (this.roomPlanner.memory.bunkerData &&
                this.roomPlanner.memory.bunkerData.anchor) {
                const layout = this.roomPlanner.getStructureMapForBunkerAt(this.roomPlanner.memory.bunkerData.anchor);
                roomPlannerRoads = layout[STRUCTURE_ROAD];
            }
            else if (this.roomPlanner.memory.mapsByLevel) {
                roomPlannerRoads = _.map(this.roomPlanner.memory.mapsByLevel[8][STRUCTURE_ROAD], (protoPos) => derefRoomPosition(protoPos));
            }
            else {
                log.error(`RoadPlanner@${this.colony.room.print}: could not get road positions from room planner!`);
                roomPlannerRoads = [];
            }
        }
        const allRoadPos = _.compact(this.roadPositions.concat(roomPlannerRoads));
        const allRoadPosByRoomName = _.groupBy(allRoadPos, (pos) => pos.roomName);
        this.memory.roadCoordsPacked = {};
        for (const roomName in allRoadPosByRoomName) {
            this.memory.roadCoordsPacked[roomName] = packCoordList(allRoadPosByRoomName[roomName]);
        }
    }
    init() { }
    static shouldBuild(structureType, pos) {
        if (!pos.room) {
            return false;
        }
        const buildings = _.filter(pos.lookFor(LOOK_STRUCTURES), (s) => s && s.structureType == structureType);
        const sites = pos.lookFor(LOOK_CONSTRUCTION_SITES);
        if (!buildings || buildings.length == 0) {
            if (!sites || sites.length == 0) {
                return true;
            }
        }
        return false;
    }
    /* Create construction sites for any buildings that need to be built */
    buildMissing() {
        // Max buildings that can be placed each tick
        let count = RoomPlanner.settings.maxSitesPerColony -
            this.colony.constructionSites.length;
        // Build missing roads
        let roadPositions = [];
        for (const roomName in this.memory.roadCoordsPacked) {
            roadPositions = roadPositions.concat(unpackCoordListAsPosList(this.memory.roadCoordsPacked[roomName], roomName));
        }
        const origin = (this.colony.storage ||
            this.colony.hatchery ||
            this.colony).pos;
        roadPositions = _.sortBy(roadPositions, (pos) => pos.getMultiRoomRangeTo(origin));
        let needsRoad = false;
        const forbiddenRooms = new Set();
        for (const pos of roadPositions) {
            // Skip if we don't have visibility or we went through our quota
            if (!pos.room || forbiddenRooms.has(pos.roomName)) {
                continue;
            }
            if (count <= 0) {
                break;
            }
            const road = pos.lookForStructure(STRUCTURE_ROAD) ||
                pos
                    .lookFor(LOOK_CONSTRUCTION_SITES)
                    .some((s) => s.structureType === STRUCTURE_ROAD);
            if (!road) {
                needsRoad = true;
                const ret = pos.createConstructionSite(STRUCTURE_ROAD);
                if (ret === OK) {
                    count--;
                    continue;
                }
                log.warning(`${this.colony.print}: couldn't create road site at ${pos.print}: (${errorForCode(ret)})`);
                if (ret == ERR_NOT_OWNER) {
                    forbiddenRooms.add(pos.roomName);
                }
                else if (ret == ERR_FULL) {
                    break;
                }
            }
        }
        if (needsRoad) {
            this.roomPlanner.requestRecheck(100);
        }
    }
    /**
     * Quick lookup for if a road should be in this position. Roads returning false won't be maintained.
     */
    roadShouldBeHere(pos) {
        if (this._roadLookup == undefined) {
            this._roadLookup = _.memoize((p) => (this.memory.roadCoordsPacked[p.roomName] || "").includes(packCoord(p)));
        }
        return this._roadLookup(pos);
    }
    /**
     * Enumerate the positions in a room which should have roads on them
     */
    getRoadPositions(roomName) {
        if (this.memory.roadCoordsPacked[roomName]) {
            return unpackCoordListAsPosList(this.memory.roadCoordsPacked[roomName], roomName);
        }
        else {
            return [];
        }
    }
    /* Clean up leftover road coverage locations from remotes that aren't mined or old structures */
    cleanRoadCoverage() {
        const colonyDestinations = [...this.colony.destinations.values()].map((dest) => dest.pos.readableName);
        log.debug(`Colony ${this.colony.print} has destinations of ${JSON.stringify(colonyDestinations)}`);
        for (const roadCoverageKey of Object.keys(this.memory.roadCoverages)) {
            // console.log(`Colony ${this.colony.name} Road coverage of ${roadCoverageKey}`);
            if (colonyDestinations.includes(roadCoverageKey)) ;
            else {
                log.warning(`Colony does not have destination of ${roadCoverageKey}, deleting.`);
                delete this.memory.roadCoverages[roadCoverageKey];
            }
        }
    }
    run() {
        if (this.roomPlanner.active || this.roomPlanner.visualize) {
            if (this.roomPlanner.storagePos) {
                this.buildRoadNetwork(this.roomPlanner.storagePos, this.roomPlanner.getObstacles());
            }
            this.visuals();
        }
        else if (this.colony.defcon === DEFCON.safe) {
            // Once in a blue moon, recalculate the entire network and write to memory to keep it up to date
            if (Game.time %
                RoadPlanner_1.settings.recalculateRoadNetworkInterval ==
                this.colony.id) {
                if (this.roomPlanner.storagePos) {
                    this.cleanRoadCoverage();
                    this.recalculateRoadNetwork(this.roomPlanner.storagePos, this.roomPlanner.getObstacles());
                }
            }
            // Recompute coverage to destinations
            if (Game.time % getAllColonies().length == this.colony.id &&
                this.roomPlanner.storagePos) {
                this.recomputeRoadCoverages(this.roomPlanner.storagePos);
            }
            // Build missing roads
            if (this.colony.level >= RoadPlanner_1.settings.buildRoadsAtRCL &&
                this.roomPlanner.shouldRecheck(3)) {
                this.buildMissing();
            }
        }
    }
    visuals() {
        // Draw the map
        Visualizer.drawRoads(this.roadPositions);
    }
};
RoadPlanner.settings = {
    encourageRoadMerging: true,
    /** recalculate road networks this often */
    recalculateRoadNetworkInterval: onPublicServer() ? 1000 : 250,
    /** recompute coverage to each destination this often */
    recomputeCoverageInterval: onPublicServer() ? 1000 : 500,
    buildRoadsAtRCL: 4,
};
RoadPlanner = RoadPlanner_1 = __decorate$1([
    profile
], RoadPlanner);

var RoomPlanner_1;
const getDefaultRoomPlannerMemory = () => ({
    active: true,
    visualize: false,
    savedFlags: [],
});
function getAllStructureCoordsFromLayout(layout, rcl) {
    if (!layout[rcl]) {
        return [];
    }
    const positionsByType = layout[rcl].buildings;
    let coords = [];
    for (const structureType in positionsByType) {
        coords = coords.concat(positionsByType[structureType].pos);
    }
    return _.unique(coords, (coord) => coord.x + 50 * coord.y);
}
function translatePositions(positions, fromAnchor, toAnchor) {
    const dx = toAnchor.x - fromAnchor.x;
    const dy = toAnchor.y - fromAnchor.y;
    const newPositions = [];
    for (const pos of positions) {
        newPositions.push(new RoomPosition(pos.x + dx, pos.y + dy, pos.roomName));
    }
    return newPositions;
}
/**
 * The room planner handles structure placement within a room automatically or (in manual or semiautomatic mode) with
 * manual guidance from room planner flags.
 */
let RoomPlanner = RoomPlanner_1 = class RoomPlanner {
    constructor(colony) {
        this.colony = colony;
        this.memory = Mem.wrap(this.colony.memory, "roomPlanner", getDefaultRoomPlannerMemory);
        this.barrierPlanner = new BarrierPlanner(this);
        this.roadPlanner = new RoadPlanner(this);
        this.refresh();
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, "roomPlanner", getDefaultRoomPlannerMemory);
        this.placements = {
            hatchery: undefined,
            commandCenter: undefined,
            bunker: undefined,
        };
        this.plan = {};
        this.map = {};
        this.barrierPlanner.refresh();
        this.roadPlanner.refresh();
        if (this.active && Game.time % 25 == 0) {
            log.alert(`RoomPlanner for ${this.colony.room.print} is still active! Close to save CPU.`);
        }
    }
    get active() {
        return this.memory.active;
    }
    set active(active) {
        this.memory.active = active;
        if (active) {
            this.reactivate();
        }
    }
    get visualize() {
        return this.memory.visualize;
    }
    set visualize(state) {
        this.memory.visualize = state;
    }
    /**
     * Recall or reconstruct the appropriate map from memory
     */
    recallMap(level = this.colony.controller.level) {
        if (this.memory.bunkerData && this.memory.bunkerData.anchor) {
            this.map = this.getStructureMapForBunkerAt(this.memory.bunkerData.anchor, level);
        }
        else if (this.memory.mapsByLevel) {
            this.map = _.mapValues(this.memory.mapsByLevel[level], (posArr) => _.map(posArr, (protoPos) => derefRoomPosition(protoPos)));
        }
    }
    /**
     * Return a list of room positions for planned structure locations at RCL8 (or undefined if plan isn't made yet)
     */
    plannedStructurePositions(structureType) {
        if (this.map[structureType]) {
            return this.map[structureType];
        }
        if (this.memory.bunkerData && this.memory.bunkerData.anchor) {
            return this.getBunkerStructurePlacement(structureType, this.memory.bunkerData.anchor);
        }
        const roomMap = this.memory.mapsByLevel ? this.memory.mapsByLevel[8] : undefined;
        if (roomMap && roomMap[structureType]) {
            return _.map(roomMap[structureType], (protoPos) => derefRoomPosition(protoPos));
        }
    }
    /**
     * Return the planned location of the storage structure
     */
    get storagePos() {
        if (this.placements.commandCenter) {
            return this.placements.commandCenter;
        }
        const positions = this.plannedStructurePositions(STRUCTURE_STORAGE);
        if (positions) {
            return positions[0];
        }
    }
    /**
     * Return the planned location of the spawning structure
     */
    get hatcheryPos() {
        if (this.placements.hatchery) {
            return this.placements.hatchery;
        }
        const positions = this.plannedStructurePositions(STRUCTURE_SPAWN);
        if (positions) {
            return positions[0];
        }
    }
    get bunkerPos() {
        if (this.placements.bunker) {
            return this.placements.bunker;
        }
        if (this.memory.bunkerData && this.memory.bunkerData.anchor) {
            return new RoomPosition(this.memory.bunkerData.anchor.x, this.memory.bunkerData.anchor.y, this.colony.name);
        }
    }
    reactivate() {
        // Reinstantiate flags
        for (const protoFlag of this.memory.savedFlags) {
            const pos = derefRoomPosition(protoFlag.pos);
            const result = pos.createFlag(undefined, COLOR_WHITE, protoFlag.secondaryColor);
            if (typeof result == "string") {
                Memory.flags[result] = protoFlag.memory; // restore old memory
            }
        }
        this.memory.savedFlags = [];
        // Display the activation message
        const msg = [
            `Room planner activated for ${this.colony.name}. Reinstantiating flags from previous session on next tick.`,
            "Place colony components with room planner flags:",
            bullet + "Place bunker (recommended)  white/red",
            bullet + "Place hatchery:             white/green",
            bullet + "Place command center:       white/blue",
            // 'Set component rotation by writing an angle (0,90,180,270 or 0,1,2,3) to flag.memory.rotation.',
            "Finalize layout ",
        ];
        _.forEach(msg, (command) => console.log(command));
    }
    /**
     * Run the room planner to generate a plan and map
     */
    make(level = 8) {
        // Reset everything
        this.plan = {};
        this.map = {};
        // Generate a plan, placing components by flags
        this.plan = this.generatePlan(level);
        // Flatten it into a map
        this.map = this.mapFromPlan(this.plan);
    }
    /**
     * Adds the specified structure directly to the map. Only callable after this.map is generated.
     * Doesn't check for conflicts, so don't use freely.
     */
    placeStructure(type, pos) {
        var _a;
        var _b;
        (_a = (_b = this.map)[type]) !== null && _a !== void 0 ? _a : (_b[type] = []);
        this.map[type].push(pos);
    }
    addComponent(componentName, pos, _rotation = 0) {
        this.placements[componentName] = pos;
    }
    /**
     * Switcher that takes a component name and returns a layout
     */
    getLayout(name) {
        switch (name) {
            case "hatchery":
                return hatcheryLayout;
            case "commandCenter":
                return commandCenterLayout;
            case "bunker":
                return bunkerLayout;
        }
    }
    /**
     * Generate a plan of component placements for a given RCL
     */
    generatePlan(level = 8) {
        const plan = {};
        for (const name in this.placements) {
            const layout = this.getLayout(name);
            if (layout) {
                const anchor = layout.data.anchor;
                const pos = this.placements[name];
                if (!pos) {
                    continue;
                }
                // let rotation: number = pos!.lookFor(LOOK_FLAGS)[0]!.memory.rotation || 0;
                const componentMap = this.parseLayout(layout, level);
                this.translateComponent(componentMap, anchor, pos);
                // if (rotation != 0) this.rotateComponent(componentMap, pos!, rotation);
                plan[name] = {
                    map: componentMap,
                    pos: new RoomPosition(anchor.x, anchor.y, this.colony.name),
                    rotation: 0,
                };
            }
        }
        return plan;
    }
    /**
     * Generate a map of (structure type: RoomPositions[]) for a given layout
     */
    parseLayout(structureLayout, level = 8) {
        const map = {};
        const layout = structureLayout[level];
        if (layout) {
            for (const buildingName in layout.buildings) {
                map[buildingName] = _.map(layout.buildings[buildingName].pos, (pos) => new RoomPosition(pos.x, pos.y, this.colony.name));
            }
        }
        return map;
    }
    /**
     * Generate a flatened map from a plan
     */
    mapFromPlan(plan) {
        const map = {};
        const componentMaps = _.map(plan, (componentPlan) => componentPlan.map);
        const structureNames = _.unique(_.flatten(_.map(componentMaps, (map) => _.keys(map))));
        for (const name of structureNames) {
            map[name] = _.compact(_.flatten(_.map(componentMaps, (map) => map[name])));
        }
        return map;
    }
    /**
     * Aligns the component position to the desired position; operations done in-place
     */
    translateComponent(map, fromPos, toPos) {
        const dx = toPos.x - fromPos.x;
        const dy = toPos.y - fromPos.y;
        for (const structureType in map) {
            for (const pos of map[structureType]) {
                pos.x += dx;
                pos.y += dy;
            }
        }
    }
    // No-fixTODO: component rotation isn't currently fully supported
    /* Rotates component positions about a pivot point counterclockwise by the given angle; done in-place */
    rotateComponent(map, pivot, angle) {
        let R = ([x, y]) => [x, y];
        if (angle == 0) {
            return;
        }
        else if (angle == 90 || angle == 1) {
            R = ([x, y]) => [-y, x];
        }
        else if (angle == 180 || angle == 2) {
            R = ([x, y]) => [-x, -y];
        }
        else if (angle == 270 || angle == 3) {
            R = ([x, y]) => [y, -x];
        }
        // Apply the rotation to the map
        let offset, dx, dy;
        for (const structureType in map) {
            for (const pos of map[structureType]) {
                offset = [pos.x - pivot.x, pos.y - pivot.y];
                [dx, dy] = R(offset);
                pos.x = pivot.x + dx;
                pos.y = pivot.y + dy;
            }
        }
    }
    /**
     * Get bunker building placements as a StructureMap
     */
    getStructureMapForBunkerAt(anchor, level = 8) {
        const dx = anchor.x - bunkerLayout.data.anchor.x;
        const dy = anchor.y - bunkerLayout.data.anchor.y;
        const structureLayout = _.mapValues(bunkerLayout[level].buildings, (obj) => obj.pos);
        return _.mapValues(structureLayout, (coordArr) => _.map(coordArr, (coord) => new RoomPosition(coord.x + dx, coord.y + dy, this.colony.name)));
    }
    /**
     * Get the placement for a single type of structure for bunker layout
     */
    getBunkerStructurePlacement(structureType, anchor, level = 8) {
        const dx = anchor.x - bunkerLayout.data.anchor.x;
        const dy = anchor.y - bunkerLayout.data.anchor.y;
        return _.map(bunkerLayout[level].buildings[structureType].pos, (coord) => new RoomPosition(coord.x + dx, coord.y + dy, this.colony.name));
    }
    /**
     * Generates a list of impassible obstacles from this.map or from this.memory.map
     */
    getObstacles() {
        let obstacles = [];
        // Add sources and extractors to impassibles for tunnels
        obstacles.concat(_.map(this.colony.sources, (source) => source.pos));
        obstacles.concat(_.map(this.colony.extractors, (extr) => extr.pos));
        const passableStructureTypes = [
            STRUCTURE_ROAD,
            STRUCTURE_CONTAINER,
            STRUCTURE_RAMPART,
        ];
        if (_.keys(this.map).length > 0) {
            // if room planner has made the map, use that
            for (const structureType in this.map) {
                if (!passableStructureTypes.includes(structureType)) {
                    obstacles = obstacles.concat(this.map[structureType]);
                }
            }
        }
        else {
            // else, serialize from memory
            if (this.memory.bunkerData && this.memory.bunkerData.anchor) {
                const structureMap = this.getStructureMapForBunkerAt(this.memory.bunkerData.anchor);
                for (const structureType in structureMap) {
                    if (!passableStructureTypes.includes(structureType)) {
                        obstacles = obstacles.concat(structureMap[structureType]);
                    }
                }
            }
            else if (this.memory.mapsByLevel) {
                for (const structureType in this.memory.mapsByLevel[8]) {
                    if (!passableStructureTypes.includes(structureType)) {
                        obstacles = obstacles.concat(_.map(this.memory.mapsByLevel[8][structureType], (protoPos) => derefRoomPosition(protoPos)));
                    }
                }
            }
        }
        return _.unique(obstacles);
    }
    /**
     * Check to see if there are any structures that can't be built
     */
    findCollision(ignoreRoads = false) {
        const terrain = Game.map.getRoomTerrain(this.colony.room.name);
        for (const structureType in this.map) {
            if (ignoreRoads && structureType == STRUCTURE_ROAD) {
                continue;
            }
            for (const pos of this.map[structureType]) {
                if (terrain.get(pos.x, pos.y) == TERRAIN_MASK_WALL) {
                    return pos;
                }
            }
        }
    }
    /**
     * Write everything to memory at the end of activation. If ignoreRoads is set, it will allow collisions with
     * roads, but will continue to alert you every time it fails to build a road in the terrain pos (WIP)
     */
    finalize(ignoreRoads = false) {
        const collision = this.findCollision(ignoreRoads);
        if (collision) {
            log.warning(`Invalid layout: collision detected at ${collision.print}!`);
            return;
        }
        const layoutIsValid = (!!this.placements.commandCenter && !!this.placements.hatchery) ||
            !!this.placements.bunker;
        if (layoutIsValid) {
            // Write everything to memory
            // Generate maps for each rcl
            delete this.memory.bunkerData;
            delete this.memory.mapsByLevel;
            if (this.placements.bunker) {
                this.memory.bunkerData = {
                    anchor: this.placements.bunker,
                };
            }
            else {
                this.memory.mapsByLevel = {};
                for (let rcl = 1; rcl <= 8; rcl++) {
                    this.make(rcl);
                    this.memory.mapsByLevel[rcl] = this.map;
                }
            }
            // Finalize the barrier planner
            this.barrierPlanner.finalize();
            // Finalize the road planner
            this.roadPlanner.finalize();
            // Save flags and remove them
            const flagsToWrite = _.filter(this.colony.flags, (flag) => flag.color == COLOR_WHITE);
            for (const flag of flagsToWrite) {
                this.memory.savedFlags.push({
                    secondaryColor: flag.secondaryColor,
                    pos: flag.pos,
                    memory: flag.memory,
                });
                flag.remove();
            }
            this.memory.lastGenerated = Game.time;
            console.log("Room layout and flag positions have been saved.");
            // Destroy needed buildings
            if (this.colony.level == 1) {
                // clear out room if setting in for first time
                this.demolishMisplacedStructures(true, true);
                // Demolish all barriers that aren't yours
                for (const barrier of this.colony.room.barriers) {
                    if (barrier.structureType == STRUCTURE_WALL ||
                        !barrier.my) {
                        barrier.destroy();
                    }
                }
            }
            this.memory.recheckStructuresAt = Game.time + 3;
            this.active = false;
        }
        else {
            log.warning("Not a valid room layout! Must have both hatchery and commandCenter placements " +
                "or bunker placement.");
        }
    }
    /**
     * Whether a constructionSite should be placed at a position
     */
    static canBuild(structureType, pos) {
        if (!pos.room) {
            return false;
        }
        const structure = pos.lookForStructure(structureType);
        const constructionSite = pos.lookFor(LOOK_CONSTRUCTION_SITES)[0];
        return !structure && !constructionSite;
    }
    /**
     * Whether a structure (or constructionSite) of given type should be at location.
     */
    structureShouldBeHere(structureType, pos, level = this.colony.controller.level) {
        if (structureType == STRUCTURE_ROAD) {
            return this.roadShouldBeHere(pos);
        }
        else if (structureType == STRUCTURE_RAMPART) {
            return this.barrierPlanner.barrierShouldBeHere(pos);
        }
        else if (structureType == STRUCTURE_EXTRACTOR) {
            return pos.lookFor(LOOK_MINERALS).length > 0;
        }
        else {
            if (_.isEmpty(this.map)) {
                this.recallMap(level);
            }
            const positions = this.map[structureType];
            if (positions && _.find(positions, (p) => p.isEqualTo(pos))) {
                return true;
            }
            if (structureType == STRUCTURE_CONTAINER ||
                structureType == STRUCTURE_LINK) {
                const thingsBuildingLinksAndContainers = _.map([
                    ...this.colony.room.sources,
                    this.colony.room.mineral,
                    this.colony.controller,
                ], (thing) => thing.pos);
                const maxRange = 4;
                return (pos.findInRange(thingsBuildingLinksAndContainers, maxRange)
                    .length > 0);
            }
        }
        return false;
    }
    /**
     * Demolish all hostile structures in the room
     */
    demolishHostileStructures(destroyStorageUnits = false) {
        _.forEach(this.colony.room.walls, (wall) => wall.destroy()); // overmind never uses walls
        for (const structure of _.filter(this.colony.room.hostileStructures)) {
            if ((structure.structureType != STRUCTURE_STORAGE &&
                structure.structureType != STRUCTURE_TERMINAL) ||
                destroyStorageUnits) {
                structure.destroy();
            }
        }
    }
    /**
     * Remove all hostile constructionSites and ones which are misplaced
     */
    removeMisplacedConstructionSites() {
        for (const site of this.colony.room.find(FIND_CONSTRUCTION_SITES)) {
            if (site.owner.username != MY_USERNAME) {
                site.remove();
            }
            else if (!this.structureShouldBeHere(site.structureType, site.pos)) {
                site.remove();
            }
        }
    }
    destroyStructure(structure) {
        if (Memory.settings.roomPlanner.allowDestroy) {
            return structure.destroy();
        }
        else {
            log.warning(`${this.colony.print}: RoomPlanner would have deleted ${structure.print} but destruction is disabled in settings`);
            return OK;
        }
    }
    /**
     * Create construction sites for any buildings that need to be built
     */
    demolishMisplacedStructures(skipRamparts = true, destroyAllStructureTypes = false) {
        this.demolishHostileStructures();
        this.removeMisplacedConstructionSites();
        if (getAllColonies().length <= 1 && !this.colony.storage) {
            return; // Not safe to move structures until you have multiple colonies or a storage
        }
        // Start terminal evacuation if it needs to be moved
        if (this.colony.terminal) {
            if ((this.colony.storage &&
                !this.structureShouldBeHere(STRUCTURE_STORAGE, this.colony.storage.pos)) ||
                !this.structureShouldBeHere(STRUCTURE_TERMINAL, this.colony.terminal.pos)) {
                DirectiveTerminalRebuildState.createIfNotPresent(this.colony.terminal.pos, "pos");
            }
        }
        // Max buildings that can be placed each tick
        RoomPlanner_1.settings.maxSitesPerColony -
            this.colony.constructionSites.length;
        // Recall the appropriate map
        this.recallMap();
        if (!this.map || _.isEmpty(this.map)) {
            // in case a map hasn't been generated yet
            log.info(this.colony.name +
                " does not have a room plan yet! Unable to demolish errant structures.");
        }
        // Destroy extractor if needed
        if (this.colony.room.extractor && !this.colony.room.extractor.my) {
            this.colony.room.extractor.destroy();
        }
        // Build missing structures from room plan
        this.memory.relocating = false;
        for (const priority of DemolishStructurePriorities) {
            const structureType = priority.structureType;
            // // don't demolish bunker baby ramparts until the new ones are sufficiently big
            // if (structureType == STRUCTURE_RAMPART && this.colony.layout == 'bunker') {
            // 	let bunkerBarriers = _.filter(this.colony.room.barriers, b => insideBunkerBounds(b.pos, this.colony));
            // 	let avgBarrierHits = (_.sum(bunkerBarriers, barrier => barrier.hits) / bunkerBarriers.length) || 0;
            // 	if (avgBarrierHits < 1e+6) continue;
            // }
            const maxRemoved = priority.maxRemoved || Infinity;
            let removeCount = 0;
            let structures = _.filter(this.colony.room.find(FIND_STRUCTURES), (s) => s.structureType == structureType);
            if (structureType == STRUCTURE_WALL) {
                structures = _.filter(structures, (wall) => wall.hits != undefined); // can't destroy newbie walls
            }
            // Loop through all structures and conditionally remove ones which are misplaced
            for (const structure of structures) {
                if (!this.structureShouldBeHere(structureType, structure.pos) ||
                    (isOwnedStructure(structure) && !structure.my)) {
                    // Don't demolish your own ramparts, just let them decay
                    if (skipRamparts &&
                        !destroyAllStructureTypes &&
                        structure.structureType == STRUCTURE_RAMPART &&
                        structure.my) {
                        continue;
                    }
                    // remove misplaced structures or hostile owned structures, with exceptions below
                    if (this.colony.level < 4 &&
                        (structureType == STRUCTURE_STORAGE ||
                            structureType == STRUCTURE_TERMINAL)) {
                        break; // don't destroy terminal or storage when under RCL4 - can use energy inside
                    }
                    if (this.colony.level < 6 &&
                        structureType == STRUCTURE_TERMINAL &&
                        hasMinerals(structure.store)) {
                        break; // don't destroy terminal when under RCL6 if there are resources available.
                    }
                    // Don't destroy spawn when below RCL7
                    if (this.colony.level < 7 &&
                        structureType === STRUCTURE_SPAWN &&
                        this.colony.spawns.length <= 1) {
                        break;
                    }
                    // Don't remove the terminal until you have rebuilt storage
                    if (this.colony.level >= 6 &&
                        structureType == STRUCTURE_TERMINAL) {
                        if (!this.colony.storage) {
                            log.info(`${this.colony.name}: waiting until storage is built to remove terminal`);
                            return;
                        }
                        else if (this.colony.terminal &&
                            this.colony.terminal.store.getUsedCapacity() -
                                this.colony.terminal.energy >
                                1000) {
                            log.info(`${this.colony.name}: waiting on resources to evacuate before removing terminal`);
                            return;
                        }
                        else if (this.colony.storage &&
                            this.structureShouldBeHere(STRUCTURE_STORAGE, this.colony.storage.pos) &&
                            this.colony.storage.energy <
                                ResourceManager.settings
                                    .minimumEnergyTerminalRebuilding) {
                            log.info(`${this.colony.name}: waiting to move energy to storage before removing terminal`);
                            return;
                        }
                    }
                    // Enable relocating only after checking we can do it
                    if (structureType != STRUCTURE_WALL &&
                        structureType != STRUCTURE_RAMPART) {
                        this.memory.relocating = true;
                    }
                    // Only remove a maximum number of structures at a time
                    const amountMissing = CONTROLLER_STRUCTURES[structureType][this.colony.level] -
                        structures.length +
                        removeCount;
                    if (amountMissing < maxRemoved) {
                        if (structureType == STRUCTURE_SPAWN &&
                            this.colony.spawns.length == 1) {
                            const spawnCost = 15000;
                            if (this.colony.assets[RESOURCE_ENERGY] < spawnCost) {
                                log.warning(`${this.colony.print}: Unsafe to destroy misplaced spawn: ` +
                                    `${this.colony.assets[RESOURCE_ENERGY]}/${spawnCost} energy available`);
                                if (!destroyAllStructureTypes) {
                                    return;
                                }
                            }
                            const workTicksNeeded = 15000 / BUILD_POWER;
                            const workTicksAvailable = _.sum(this.colony.overlords.work.workers, (worker) => worker.getActiveBodyparts(WORK) *
                                (worker.ticksToLive || 0));
                            if (workTicksAvailable < workTicksNeeded) {
                                log.warning(`${this.colony.print}: Unsafe to destroy misplaced spawn: ` +
                                    `${workTicksAvailable}/${workTicksNeeded} [WORK * ticks] available`);
                                if (!destroyAllStructureTypes) {
                                    return;
                                }
                            }
                        }
                        const result = this.destroyStructure(structure);
                        if (result != OK) {
                            log.warning(`${this.colony.name}: couldn't destroy structure of type ` +
                                `"${structureType}" at ${structure.pos.print}. Result: ${result}`);
                        }
                        else {
                            log.info(`${this.colony.name}: destroyed ${structureType} at ${structure.pos.print}`);
                        }
                        removeCount++;
                        this.memory.recheckStructuresAt =
                            Game.time + RoomPlanner_1.settings.recheckAfter;
                    }
                }
            }
            if (this.memory.relocating && !destroyAllStructureTypes) {
                return;
            }
        }
    }
    /**
     * Create construction sites for any buildings that need to be built
     */
    buildMissingStructures() {
        // Max buildings that can be placed each tick
        let count = RoomPlanner_1.settings.maxSitesPerColony -
            this.colony.constructionSites.length;
        // Recall the appropriate map
        this.recallMap();
        if (!this.map || _.isEmpty(this.map)) {
            // in case a map hasn't been generated yet
            log.info(this.colony.name +
                " does not have a room plan yet! Unable to build missing structures.");
        }
        // Build missing structures from room plan
        stop: for (const structureType of BuildPriorities) {
            if (this.map[structureType]) {
                for (const pos of this.map[structureType]) {
                    if ((structureType == STRUCTURE_SPAWN || count > 0) &&
                        RoomPlanner_1.canBuild(structureType, pos)) {
                        const result = pos.createConstructionSite(structureType);
                        if (result === OK) {
                            count--;
                            this.memory.recheckStructuresAt =
                                Game.time + RoomPlanner_1.settings.recheckAfter;
                            continue;
                        }
                        log.warning(`${this.colony.name}: couldn't create construction site of type ` +
                            `"${structureType}" at ${pos.print}: ${errorForCode(result)}`);
                        if (result === ERR_FULL || result === ERR_NOT_OWNER) {
                            break stop;
                        }
                        else if (result === ERR_INVALID_TARGET) {
                            const structures = pos.lookFor(LOOK_STRUCTURES);
                            for (const structure of structures) {
                                // let thisImportance = _.findIndex(BuildPriorities, type => type == structureType);
                                // let existingImportance = _.findIndex(BuildPriorities,
                                // 									 type => type == structure.structureType);
                                const safeTypes = [
                                    STRUCTURE_STORAGE,
                                    STRUCTURE_TERMINAL,
                                    STRUCTURE_SPAWN,
                                ];
                                // Destroy the structure if it is less important and not protected
                                if (!this.structureShouldBeHere(structure.structureType, pos) &&
                                    !safeTypes.includes(structure.structureType)) {
                                    const result = this.destroyStructure(structure);
                                    if (result == OK) {
                                        log.info(`${this.colony.name}: destroyed ${structure.structureType} at ${structure.pos.print}`);
                                        this.memory.recheckStructuresAt =
                                            Game.time +
                                                RoomPlanner_1.settings.recheckAfter;
                                    }
                                    else {
                                        log.warning(`${this.colony.name}: couldn't destroy ${structure.structureType}` +
                                            ` at ${structure.pos.print}! Result: ${errorForCode(result)}`);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        // Build extractor on mineral deposit if not already present
        const mineral = this.colony.room.mineral;
        if (mineral) {
            const extractor = mineral.pos.lookForStructure(STRUCTURE_EXTRACTOR);
            if (!extractor) {
                mineral.pos.createConstructionSite(STRUCTURE_EXTRACTOR);
            }
        }
    }
    /**
     * Calculate where the link will be built
     */
    calculateLinkPos(anchor) {
        if (anchor.isEqualTo(this.colony.controller.pos)) {
            return this.calculateUpgradeSiteLinkPos();
        }
        let originPos;
        if (this.colony.storage) {
            originPos = this.colony.storage.pos;
        }
        else if (this.storagePos) {
            originPos = this.storagePos;
        }
        if (originPos) {
            const path = Pathing.findShortestPath(anchor, originPos).path;
            return _.find(path, (pos) => anchor.getRangeTo(pos) == 2);
        }
    }
    /**
     * Calculate where the link will be built for this site
     */
    calculateUpgradeSiteLinkPos() {
        let originPos;
        if (this.colony.storage) {
            originPos = this.colony.storage.pos;
        }
        else if (this.storagePos) {
            originPos = this.storagePos;
        }
        if (originPos && this.colony.upgradeSite.batteryPos) {
            // Build link at last location on path from origin to battery
            const path = Pathing.findShortestPath(this.colony.upgradeSite.batteryPos, originPos).path;
            return path[0];
        }
    }
    nextNeededLinkAnchor() {
        const linksEtAl = _.map([].concat(this.colony.links, _.filter(this.colony.constructionSites, (site) => site.structureType == STRUCTURE_LINK)), (s) => s.pos);
        // UpgradeSite goes first
        const upgradeLink = this.colony.controller.pos.findClosestByLimitedRange(linksEtAl, 3, {
            filter: (pos) => !insideBunkerBounds(pos, this.colony),
        });
        if (!upgradeLink) {
            return this.colony.controller.pos;
        }
        // MiningSites by decreasing distance
        const origin = (this.colony.storage ||
            this.colony.terminal ||
            _.first(this.colony.spawns) ||
            this.colony).pos;
        const farthestSources = _.sortBy(this.colony.room.sources, (source) => -1 * (Pathing.distance(origin, source.pos) || Infinity));
        for (const source of farthestSources) {
            const sourceLink = source.pos.findClosestByLimitedRange(linksEtAl, 2);
            if (!sourceLink) {
                return source.pos;
            }
        }
    }
    /**
     * Builds links as they become available. UpgradeSite gets link first, then miningSites by distance.
     */
    buildNeededLinks() {
        const numLinks = this.colony.links.length +
            _.filter(this.colony.constructionSites, (site) => site.structureType == STRUCTURE_LINK).length;
        const numLinksAllowed = CONTROLLER_STRUCTURES.link[this.colony.level];
        if (numLinksAllowed > numLinks &&
            (this.colony.bunker ||
                (this.colony.hatchery && this.colony.hatchery.link)) &&
            this.colony.commandCenter &&
            this.colony.commandCenter.link) {
            const anchor = this.nextNeededLinkAnchor();
            if (!anchor) {
                return;
            }
            const linkPos = this.calculateLinkPos(anchor);
            if (!linkPos) {
                log.warning(`Could not calculate link position for anchor at ${anchor.print}!`);
                return;
            }
            linkPos.createConstructionSite(STRUCTURE_LINK);
        }
    }
    /**
     * Quick lookup for if a road should be in this position. Roads returning false won't be maintained.
     */
    roadShouldBeHere(pos) {
        return this.roadPlanner.roadShouldBeHere(pos);
    }
    init() {
        if (this.active) {
            Overmind.overseer.notifier.alert(`Room planner active!`, this.colony.room.name);
        }
        if (this.active &&
            getAutonomyLevel() == Autonomy.Automatic &&
            !this.memory.bunkerData) {
            let bunkerAnchor;
            if (this.colony.spawns.length > 0) {
                // in case of very first spawn
                const lowerRightSpawn = maxBy(this.colony.spawns, (s) => 50 * s.pos.y + s.pos.x);
                const spawnPos = lowerRightSpawn.pos;
                bunkerAnchor = new RoomPosition(spawnPos.x - 4, spawnPos.y, spawnPos.roomName);
            }
            else {
                const expansionData = RoomIntel$1.getExpansionData(this.colony.room.name);
                if (expansionData) {
                    bunkerAnchor = expansionData.bunkerAnchor;
                }
                else {
                    log.error(`Cannot determine anchor! No spawns or expansionData.bunkerAnchor for ` +
                        `${this.colony.print}!`);
                    return;
                }
            }
            this.addComponent("bunker", bunkerAnchor);
        }
        this.barrierPlanner.init();
        this.roadPlanner.init();
    }
    requestRecheck(ticksFromNow = 1) {
        this.memory.recheckStructuresAt = Game.time + ticksFromNow;
    }
    shouldRecheck(offset = 0) {
        if (Game.time ==
            (this.memory.recheckStructuresAt || Infinity) + offset) {
            return true;
        }
        else {
            const checkFreq = RoomPlanner_1.settings.siteCheckFrequency * this.colony.level;
            return (Game.time % checkFreq ==
                (2 * this.colony.id + offset) % checkFreq);
        }
    }
    run() {
        if (this.memory.relocating) {
            Overmind.overseer.notifier.alert(`Colony relocating!`, this.colony.room.name, NotifierPriority.High);
        }
        if (this.active || this.visualize) {
            this.make();
            this.visuals();
        }
        else if (this.colony.defcon === DEFCON.safe) {
            // Build missing structures from the layout
            if (this.shouldRecheck()) {
                this.demolishMisplacedStructures();
            }
            else if (this.shouldRecheck(1)) {
                this.buildMissingStructures();
            }
            // Build missing links as needed
            if (Game.time % RoomPlanner_1.settings.linkCheckFrequency == 3) {
                this.buildNeededLinks();
            }
        }
        // Run the barrier planner
        this.barrierPlanner.run();
        // Run the road planner
        this.roadPlanner.run();
        if (this.active && getAutonomyLevel() == Autonomy.Automatic) {
            if (this.placements.bunker) {
                this.finalize();
            }
            else {
                log.warning(`No bunker placement!`);
            }
        }
    }
    visuals() {
        // Draw the map
        if (getAutonomyLevel() < Autonomy.Automatic) {
            const expansionData = RoomIntel$1.getExpansionData(this.colony.room.name);
            if (expansionData) {
                Visualizer.drawLayout(bunkerLayout, expansionData.bunkerAnchor, { opacity: 0.2 });
            }
        }
        Visualizer.drawStructureMap(this.map);
    }
};
RoomPlanner.settings = {
    recheckAfter: 50,
    siteCheckFrequency: onPublicServer() ? 50 : 20, // how often to recheck for structures; multiplied by RCL
    linkCheckFrequency: 100,
    maxSitesPerColony: onPublicServer() ? 10 : 25,
    maxDismantleCount: 5,
    allowDestroy: false,
};
RoomPlanner = RoomPlanner_1 = __decorate$1([
    profile
], RoomPlanner);

const BUNKER_RADIUS = 6;
const bunkerLayout = {
    data: {
        anchor: { x: 25, y: 25 },
    },
    1: {
        name: "bunkerCore",
        shard: "shard2",
        rcl: "1",
        buildings: {
            spawn: { pos: [{ x: 29, y: 25 }] },
        },
    },
    2: {
        name: "bunkerCore",
        shard: "shard2",
        rcl: "2",
        buildings: {
            extension: {
                pos: [
                    { x: 28, y: 26 },
                    { x: 28, y: 27 },
                    { x: 27, y: 27 },
                    {
                        x: 27,
                        y: 28,
                    },
                    { x: 29, y: 26 },
                ],
            },
            spawn: { pos: [{ x: 29, y: 25 }] },
            container: { pos: [{ x: 27, y: 30 }] },
        },
    },
    3: {
        name: "bunkerCore",
        shard: "shard2",
        rcl: "3",
        buildings: {
            tower: { pos: [{ x: 25, y: 26 }] },
            extension: {
                pos: [
                    { x: 28, y: 26 },
                    { x: 29, y: 27 },
                    { x: 28, y: 27 },
                    {
                        x: 27,
                        y: 27,
                    },
                    { x: 27, y: 28 },
                    { x: 28, y: 28 },
                    { x: 29, y: 28 },
                    { x: 28, y: 29 },
                    {
                        x: 27,
                        y: 29,
                    },
                    { x: 29, y: 26 },
                ],
            },
            spawn: { pos: [{ x: 29, y: 25 }] },
            container: { pos: [{ x: 27, y: 30 }] },
        },
    },
    4: {
        name: "bunkerCore",
        shard: "shard2",
        rcl: "4",
        buildings: {
            storage: { pos: [{ x: 24, y: 25 }] },
            terminal: { pos: [] },
            nuker: { pos: [] },
            tower: { pos: [{ x: 25, y: 26 }] },
            powerSpawn: { pos: [] },
            link: { pos: [] },
            road: {
                pos: [
                    { x: 24, y: 23 },
                    { x: 25, y: 22 },
                    { x: 26, y: 23 },
                    {
                        x: 27,
                        y: 24,
                    },
                    { x: 28, y: 25 },
                    { x: 27, y: 26 },
                    { x: 26, y: 27 },
                    { x: 25, y: 28 },
                    {
                        x: 24,
                        y: 27,
                    },
                    { x: 23, y: 26 },
                    { x: 22, y: 25 },
                    { x: 23, y: 24 },
                    { x: 28, y: 20 },
                    {
                        x: 30,
                        y: 22,
                    },
                    { x: 24, y: 21 },
                    { x: 30, y: 28 },
                    { x: 28, y: 30 },
                    { x: 26, y: 29 },
                    {
                        x: 20,
                        y: 22,
                    },
                    { x: 22, y: 20 },
                    { x: 20, y: 28 },
                    { x: 22, y: 30 },
                    { x: 24, y: 19 },
                    {
                        x: 26,
                        y: 19,
                    },
                    { x: 27, y: 19 },
                    { x: 31, y: 23 },
                    { x: 31, y: 24 },
                    { x: 31, y: 25 },
                    {
                        x: 31,
                        y: 26,
                    },
                    { x: 31, y: 27 },
                    { x: 27, y: 31 },
                    { x: 27, y: 31 },
                    { x: 26, y: 31 },
                    {
                        x: 24,
                        y: 31,
                    },
                    { x: 23, y: 31 },
                    { x: 19, y: 27 },
                    { x: 19, y: 26 },
                    { x: 19, y: 25 },
                    {
                        x: 19,
                        y: 24,
                    },
                    { x: 25, y: 19 },
                    { x: 19, y: 23 },
                    { x: 25, y: 31 },
                    { x: 23, y: 19 },
                    {
                        x: 29,
                        y: 21,
                    },
                    { x: 21, y: 21 },
                    { x: 21, y: 29 },
                    { x: 29, y: 29 },
                    { x: 21, y: 26 },
                    {
                        x: 29,
                        y: 24,
                    },
                    { x: 30, y: 23 },
                    { x: 20, y: 27 },
                    { x: 23, y: 25 },
                    { x: 27, y: 25 },
                    {
                        x: 23,
                        y: 20,
                    },
                    { x: 24, y: 28 },
                    { x: 23, y: 29 },
                    { x: 23, y: 30 },
                    { x: 27, y: 30 },
                ],
            },
            observer: { pos: [] },
            lab: { pos: [] },
            extension: {
                pos: [
                    { x: 30, y: 24 },
                    { x: 30, y: 25 },
                    { x: 30, y: 26 },
                    {
                        x: 28,
                        y: 26,
                    },
                    { x: 29, y: 27 },
                    { x: 28, y: 27 },
                    { x: 27, y: 27 },
                    { x: 27, y: 28 },
                    {
                        x: 28,
                        y: 28,
                    },
                    { x: 29, y: 28 },
                    { x: 28, y: 29 },
                    { x: 27, y: 29 },
                    { x: 26, y: 28 },
                    {
                        x: 24,
                        y: 30,
                    },
                    { x: 25, y: 30 },
                    { x: 26, y: 30 },
                    { x: 29, y: 26 },
                    { x: 24, y: 29 },
                    {
                        x: 30,
                        y: 27,
                    },
                    { x: 25, y: 29 },
                ],
            },
            spawn: { pos: [{ x: 29, y: 25 }] },
            container: { pos: [{ x: 27, y: 30 }] },
        },
    },
    5: {
        name: "bunkerCore",
        shard: "shard2",
        rcl: "5",
        buildings: {
            storage: { pos: [{ x: 24, y: 25 }] },
            terminal: { pos: [] },
            nuker: { pos: [] },
            tower: {
                pos: [
                    { x: 25, y: 24 },
                    { x: 25, y: 26 },
                ],
            },
            powerSpawn: { pos: [] },
            link: { pos: [{ x: 26, y: 26 }] },
            road: {
                pos: [
                    { x: 24, y: 23 },
                    { x: 25, y: 22 },
                    { x: 26, y: 23 },
                    {
                        x: 27,
                        y: 24,
                    },
                    { x: 28, y: 25 },
                    { x: 27, y: 26 },
                    { x: 26, y: 27 },
                    { x: 25, y: 28 },
                    {
                        x: 24,
                        y: 27,
                    },
                    { x: 23, y: 26 },
                    { x: 22, y: 25 },
                    { x: 23, y: 24 },
                    { x: 28, y: 20 },
                    {
                        x: 30,
                        y: 22,
                    },
                    { x: 24, y: 21 },
                    { x: 30, y: 28 },
                    { x: 28, y: 30 },
                    { x: 26, y: 29 },
                    {
                        x: 20,
                        y: 22,
                    },
                    { x: 22, y: 20 },
                    { x: 20, y: 28 },
                    { x: 22, y: 30 },
                    { x: 24, y: 19 },
                    {
                        x: 26,
                        y: 19,
                    },
                    { x: 27, y: 19 },
                    { x: 31, y: 23 },
                    { x: 31, y: 24 },
                    { x: 31, y: 25 },
                    {
                        x: 31,
                        y: 26,
                    },
                    { x: 31, y: 27 },
                    { x: 27, y: 31 },
                    { x: 27, y: 31 },
                    { x: 26, y: 31 },
                    {
                        x: 24,
                        y: 31,
                    },
                    { x: 23, y: 31 },
                    { x: 19, y: 27 },
                    { x: 19, y: 26 },
                    { x: 19, y: 25 },
                    {
                        x: 19,
                        y: 24,
                    },
                    { x: 25, y: 19 },
                    { x: 19, y: 23 },
                    { x: 25, y: 31 },
                    { x: 23, y: 19 },
                    {
                        x: 29,
                        y: 21,
                    },
                    { x: 21, y: 21 },
                    { x: 21, y: 29 },
                    { x: 29, y: 29 },
                    { x: 21, y: 26 },
                    {
                        x: 29,
                        y: 24,
                    },
                    { x: 30, y: 23 },
                    { x: 20, y: 27 },
                    { x: 23, y: 25 },
                    { x: 27, y: 25 },
                    {
                        x: 23,
                        y: 20,
                    },
                    { x: 27, y: 30 },
                ],
            },
            observer: { pos: [] },
            lab: { pos: [] },
            extension: {
                pos: [
                    { x: 30, y: 24 },
                    { x: 30, y: 25 },
                    { x: 30, y: 26 },
                    {
                        x: 28,
                        y: 26,
                    },
                    { x: 29, y: 27 },
                    { x: 28, y: 27 },
                    { x: 27, y: 27 },
                    { x: 27, y: 28 },
                    {
                        x: 28,
                        y: 28,
                    },
                    { x: 29, y: 28 },
                    { x: 28, y: 29 },
                    { x: 27, y: 29 },
                    { x: 26, y: 28 },
                    {
                        x: 23,
                        y: 27,
                    },
                    { x: 24, y: 28 },
                    { x: 23, y: 28 },
                    { x: 22, y: 27 },
                    { x: 21, y: 27 },
                    {
                        x: 22,
                        y: 28,
                    },
                    { x: 23, y: 29 },
                    { x: 21, y: 28 },
                    { x: 24, y: 30 },
                    { x: 25, y: 30 },
                    {
                        x: 26,
                        y: 30,
                    },
                    { x: 29, y: 26 },
                    { x: 24, y: 29 },
                    { x: 23, y: 30 },
                    { x: 30, y: 27 },
                    {
                        x: 25,
                        y: 29,
                    },
                    { x: 22, y: 29 },
                ],
            },
            spawn: { pos: [{ x: 29, y: 25 }] },
            container: { pos: [{ x: 27, y: 30 }] },
        },
    },
    6: {
        name: "bunkerCore",
        shard: "shard2",
        rcl: "6",
        buildings: {
            storage: { pos: [{ x: 24, y: 25 }] },
            terminal: { pos: [{ x: 26, y: 25 }] },
            nuker: { pos: [] },
            tower: {
                pos: [
                    { x: 25, y: 24 },
                    { x: 25, y: 26 },
                ],
            },
            powerSpawn: { pos: [] },
            link: { pos: [{ x: 26, y: 26 }] },
            road: {
                pos: [
                    { x: 24, y: 23 },
                    { x: 25, y: 22 },
                    { x: 26, y: 23 },
                    {
                        x: 27,
                        y: 24,
                    },
                    { x: 28, y: 25 },
                    { x: 27, y: 26 },
                    { x: 26, y: 27 },
                    { x: 25, y: 28 },
                    {
                        x: 24,
                        y: 27,
                    },
                    { x: 23, y: 26 },
                    { x: 22, y: 25 },
                    { x: 23, y: 24 },
                    { x: 28, y: 20 },
                    {
                        x: 30,
                        y: 22,
                    },
                    { x: 24, y: 21 },
                    { x: 30, y: 28 },
                    { x: 28, y: 30 },
                    { x: 26, y: 29 },
                    {
                        x: 20,
                        y: 22,
                    },
                    { x: 22, y: 20 },
                    { x: 20, y: 28 },
                    { x: 22, y: 30 },
                    { x: 24, y: 19 },
                    {
                        x: 26,
                        y: 19,
                    },
                    { x: 27, y: 19 },
                    { x: 31, y: 23 },
                    { x: 31, y: 24 },
                    { x: 31, y: 25 },
                    {
                        x: 31,
                        y: 26,
                    },
                    { x: 31, y: 27 },
                    { x: 27, y: 31 },
                    { x: 27, y: 31 },
                    { x: 26, y: 31 },
                    {
                        x: 24,
                        y: 31,
                    },
                    { x: 23, y: 31 },
                    { x: 19, y: 27 },
                    { x: 19, y: 26 },
                    { x: 19, y: 25 },
                    {
                        x: 19,
                        y: 24,
                    },
                    { x: 25, y: 19 },
                    { x: 19, y: 23 },
                    { x: 25, y: 31 },
                    { x: 23, y: 19 },
                    {
                        x: 29,
                        y: 21,
                    },
                    { x: 21, y: 21 },
                    { x: 21, y: 29 },
                    { x: 29, y: 29 },
                    { x: 21, y: 26 },
                    {
                        x: 29,
                        y: 24,
                    },
                    { x: 30, y: 23 },
                    { x: 20, y: 27 },
                    { x: 23, y: 25 },
                    { x: 27, y: 25 },
                    {
                        x: 22,
                        y: 22,
                    },
                    { x: 23, y: 23 },
                    { x: 23, y: 20 },
                    { x: 27, y: 30 },
                ],
            },
            observer: { pos: [] },
            lab: {
                pos: [
                    { x: 27, y: 23 },
                    { x: 28, y: 24 },
                    { x: 28, y: 23 },
                ],
            },
            extension: {
                pos: [
                    { x: 22, y: 24 },
                    { x: 22, y: 23 },
                    { x: 21, y: 23 },
                    {
                        x: 30,
                        y: 24,
                    },
                    { x: 30, y: 25 },
                    { x: 30, y: 26 },
                    { x: 20, y: 24 },
                    { x: 20, y: 25 },
                    {
                        x: 20,
                        y: 26,
                    },
                    { x: 21, y: 22 },
                    { x: 28, y: 26 },
                    { x: 29, y: 27 },
                    { x: 28, y: 27 },
                    {
                        x: 27,
                        y: 27,
                    },
                    { x: 27, y: 28 },
                    { x: 28, y: 28 },
                    { x: 29, y: 28 },
                    { x: 28, y: 29 },
                    {
                        x: 27,
                        y: 29,
                    },
                    { x: 26, y: 28 },
                    { x: 22, y: 26 },
                    { x: 23, y: 27 },
                    { x: 24, y: 28 },
                    {
                        x: 23,
                        y: 28,
                    },
                    { x: 22, y: 27 },
                    { x: 21, y: 27 },
                    { x: 22, y: 28 },
                    { x: 23, y: 29 },
                    {
                        x: 22,
                        y: 29,
                    },
                    { x: 21, y: 28 },
                    { x: 24, y: 30 },
                    { x: 25, y: 30 },
                    { x: 26, y: 30 },
                    {
                        x: 29,
                        y: 26,
                    },
                    { x: 21, y: 24 },
                    { x: 24, y: 29 },
                    { x: 23, y: 30 },
                    { x: 20, y: 23 },
                    {
                        x: 30,
                        y: 27,
                    },
                    { x: 25, y: 29 },
                ],
            },
            spawn: { pos: [{ x: 29, y: 25 }] },
            container: { pos: [{ x: 27, y: 30 }] },
        },
    },
    7: {
        name: "bunkerCore",
        shard: "shard2",
        rcl: "7",
        buildings: {
            storage: { pos: [{ x: 24, y: 25 }] },
            terminal: { pos: [{ x: 26, y: 25 }] },
            nuker: { pos: [] },
            tower: {
                pos: [
                    { x: 25, y: 24 },
                    { x: 25, y: 26 },
                    { x: 25, y: 23 },
                ],
            },
            factory: { pos: [{ x: 24, y: 24 }] },
            powerSpawn: { pos: [] },
            link: { pos: [{ x: 26, y: 26 }] },
            road: {
                pos: [
                    { x: 24, y: 23 },
                    { x: 25, y: 22 },
                    { x: 26, y: 23 },
                    {
                        x: 27,
                        y: 24,
                    },
                    { x: 28, y: 25 },
                    { x: 27, y: 26 },
                    { x: 26, y: 27 },
                    { x: 25, y: 28 },
                    {
                        x: 24,
                        y: 27,
                    },
                    { x: 23, y: 26 },
                    { x: 22, y: 25 },
                    { x: 23, y: 24 },
                    { x: 28, y: 20 },
                    {
                        x: 30,
                        y: 22,
                    },
                    { x: 24, y: 21 },
                    { x: 30, y: 28 },
                    { x: 28, y: 30 },
                    { x: 26, y: 29 },
                    {
                        x: 20,
                        y: 22,
                    },
                    { x: 22, y: 20 },
                    { x: 20, y: 28 },
                    { x: 22, y: 30 },
                    { x: 24, y: 19 },
                    {
                        x: 26,
                        y: 19,
                    },
                    { x: 27, y: 19 },
                    { x: 31, y: 23 },
                    { x: 31, y: 24 },
                    { x: 31, y: 25 },
                    {
                        x: 31,
                        y: 26,
                    },
                    { x: 31, y: 27 },
                    { x: 27, y: 31 },
                    { x: 27, y: 31 },
                    { x: 26, y: 31 },
                    {
                        x: 24,
                        y: 31,
                    },
                    { x: 23, y: 31 },
                    { x: 19, y: 27 },
                    { x: 19, y: 26 },
                    { x: 19, y: 25 },
                    {
                        x: 19,
                        y: 24,
                    },
                    { x: 25, y: 19 },
                    { x: 19, y: 23 },
                    { x: 25, y: 31 },
                    { x: 23, y: 19 },
                    {
                        x: 29,
                        y: 21,
                    },
                    { x: 21, y: 21 },
                    { x: 21, y: 29 },
                    { x: 29, y: 29 },
                    { x: 21, y: 26 },
                    {
                        x: 29,
                        y: 24,
                    },
                    { x: 30, y: 23 },
                    { x: 20, y: 27 },
                    { x: 27, y: 22 },
                    { x: 28, y: 21 },
                    {
                        x: 23,
                        y: 25,
                    },
                    { x: 27, y: 25 },
                    { x: 27, y: 30 },
                    { x: 23, y: 20 },
                ],
            },
            observer: { pos: [] },
            lab: {
                pos: [
                    { x: 27, y: 23 },
                    { x: 28, y: 24 },
                    { x: 28, y: 22 },
                    {
                        x: 28,
                        y: 23,
                    },
                    { x: 29, y: 23 },
                    { x: 29, y: 22 },
                ],
            },
            extension: {
                pos: [
                    { x: 24, y: 22 },
                    { x: 23, y: 23 },
                    { x: 22, y: 24 },
                    {
                        x: 22,
                        y: 23,
                    },
                    { x: 23, y: 22 },
                    { x: 23, y: 21 },
                    { x: 22, y: 22 },
                    { x: 21, y: 23 },
                    {
                        x: 25,
                        y: 20,
                    },
                    { x: 26, y: 20 },
                    { x: 30, y: 24 },
                    { x: 30, y: 25 },
                    { x: 30, y: 26 },
                    {
                        x: 20,
                        y: 24,
                    },
                    { x: 20, y: 25 },
                    { x: 20, y: 26 },
                    { x: 22, y: 21 },
                    { x: 21, y: 22 },
                    {
                        x: 28,
                        y: 26,
                    },
                    { x: 29, y: 27 },
                    { x: 28, y: 27 },
                    { x: 27, y: 27 },
                    { x: 27, y: 28 },
                    {
                        x: 28,
                        y: 28,
                    },
                    { x: 29, y: 28 },
                    { x: 28, y: 29 },
                    { x: 27, y: 29 },
                    { x: 26, y: 28 },
                    {
                        x: 22,
                        y: 26,
                    },
                    { x: 23, y: 27 },
                    { x: 24, y: 28 },
                    { x: 23, y: 28 },
                    { x: 22, y: 27 },
                    {
                        x: 21,
                        y: 27,
                    },
                    { x: 22, y: 28 },
                    { x: 23, y: 29 },
                    { x: 22, y: 29 },
                    { x: 21, y: 28 },
                    {
                        x: 24,
                        y: 30,
                    },
                    { x: 25, y: 30 },
                    { x: 26, y: 30 },
                    { x: 29, y: 26 },
                    { x: 21, y: 24 },
                    {
                        x: 26,
                        y: 21,
                    },
                    { x: 24, y: 29 },
                    { x: 23, y: 30 },
                    { x: 20, y: 23 },
                    { x: 27, y: 20 },
                    {
                        x: 30,
                        y: 27,
                    },
                    { x: 25, y: 29 },
                ],
            },
            spawn: {
                pos: [
                    { x: 29, y: 25 },
                    { x: 26, y: 24 },
                ],
            },
            container: {
                pos: [
                    { x: 27, y: 30 },
                    { x: 23, y: 20 },
                ],
            },
        },
    },
    8: {
        name: "bunkerCore",
        shard: "shard2",
        rcl: "8",
        buildings: {
            storage: { pos: [{ x: 24, y: 25 }] },
            terminal: { pos: [{ x: 26, y: 25 }] },
            factory: { pos: [{ x: 24, y: 24 }] },
            tower: {
                pos: [
                    { x: 25, y: 24 },
                    { x: 25, y: 26 },
                    { x: 25, y: 23 },
                    { x: 27, y: 25 },
                    { x: 23, y: 25 },
                    { x: 25, y: 27 },
                ],
            },
            powerSpawn: { pos: [{ x: 24, y: 26 }] },
            link: { pos: [{ x: 26, y: 26 }] },
            road: {
                pos: [
                    { x: 24, y: 23 },
                    { x: 25, y: 22 },
                    { x: 26, y: 23 },
                    {
                        x: 27,
                        y: 24,
                    },
                    { x: 28, y: 25 },
                    { x: 27, y: 26 },
                    { x: 26, y: 27 },
                    { x: 25, y: 28 },
                    {
                        x: 24,
                        y: 27,
                    },
                    { x: 23, y: 26 },
                    { x: 22, y: 25 },
                    { x: 23, y: 24 },
                    { x: 28, y: 20 },
                    {
                        x: 30,
                        y: 22,
                    },
                    { x: 24, y: 21 },
                    { x: 30, y: 28 },
                    { x: 28, y: 30 },
                    { x: 26, y: 29 },
                    {
                        x: 20,
                        y: 22,
                    },
                    { x: 22, y: 20 },
                    { x: 20, y: 28 },
                    { x: 22, y: 30 },
                    { x: 24, y: 19 },
                    {
                        x: 26,
                        y: 19,
                    },
                    { x: 27, y: 19 },
                    { x: 31, y: 23 },
                    { x: 31, y: 24 },
                    { x: 31, y: 25 },
                    {
                        x: 31,
                        y: 26,
                    },
                    { x: 31, y: 27 },
                    { x: 27, y: 31 },
                    { x: 27, y: 31 },
                    { x: 26, y: 31 },
                    {
                        x: 24,
                        y: 31,
                    },
                    { x: 23, y: 31 },
                    { x: 19, y: 27 },
                    { x: 19, y: 26 },
                    { x: 19, y: 25 },
                    {
                        x: 19,
                        y: 24,
                    },
                    { x: 25, y: 19 },
                    { x: 19, y: 23 },
                    { x: 25, y: 31 },
                    { x: 23, y: 19 },
                    {
                        x: 29,
                        y: 21,
                    },
                    { x: 21, y: 21 },
                    { x: 21, y: 29 },
                    { x: 29, y: 29 },
                    { x: 21, y: 26 },
                    {
                        x: 29,
                        y: 24,
                    },
                    { x: 30, y: 23 },
                    { x: 20, y: 27 },
                    { x: 27, y: 30 },
                    { x: 23, y: 20 },
                ],
            },
            observer: { pos: [{ x: 21, y: 25 }] },
            lab: {
                pos: [
                    { x: 26, y: 22 },
                    { x: 27, y: 23 },
                    { x: 28, y: 24 },
                    {
                        x: 27,
                        y: 22,
                    },
                    { x: 27, y: 21 },
                    { x: 28, y: 22 },
                    { x: 28, y: 23 },
                    { x: 29, y: 23 },
                    {
                        x: 28,
                        y: 21,
                    },
                    { x: 29, y: 22 },
                ],
            },
            extension: {
                pos: [
                    { x: 24, y: 22 },
                    { x: 23, y: 23 },
                    { x: 22, y: 24 },
                    {
                        x: 22,
                        y: 23,
                    },
                    { x: 23, y: 22 },
                    { x: 23, y: 21 },
                    { x: 22, y: 22 },
                    { x: 21, y: 23 },
                    {
                        x: 24,
                        y: 20,
                    },
                    { x: 25, y: 20 },
                    { x: 26, y: 20 },
                    { x: 30, y: 24 },
                    { x: 30, y: 25 },
                    {
                        x: 30,
                        y: 26,
                    },
                    { x: 20, y: 24 },
                    { x: 20, y: 25 },
                    { x: 20, y: 26 },
                    { x: 22, y: 21 },
                    {
                        x: 21,
                        y: 22,
                    },
                    { x: 28, y: 26 },
                    { x: 29, y: 27 },
                    { x: 28, y: 27 },
                    { x: 27, y: 27 },
                    {
                        x: 27,
                        y: 28,
                    },
                    { x: 28, y: 28 },
                    { x: 29, y: 28 },
                    { x: 28, y: 29 },
                    { x: 27, y: 29 },
                    {
                        x: 26,
                        y: 28,
                    },
                    { x: 22, y: 26 },
                    { x: 23, y: 27 },
                    { x: 24, y: 28 },
                    { x: 23, y: 28 },
                    {
                        x: 22,
                        y: 27,
                    },
                    { x: 21, y: 27 },
                    { x: 22, y: 28 },
                    { x: 23, y: 29 },
                    { x: 22, y: 29 },
                    {
                        x: 21,
                        y: 28,
                    },
                    { x: 24, y: 30 },
                    { x: 25, y: 30 },
                    { x: 26, y: 30 },
                    { x: 29, y: 26 },
                    {
                        x: 21,
                        y: 24,
                    },
                    { x: 26, y: 21 },
                    { x: 24, y: 29 },
                    { x: 23, y: 30 },
                    { x: 20, y: 23 },
                    {
                        x: 27,
                        y: 20,
                    },
                    { x: 30, y: 27 },
                    { x: 25, y: 29 },
                ],
            },
            spawn: {
                pos: [
                    { x: 29, y: 25 },
                    { x: 26, y: 24 },
                    { x: 25, y: 21 },
                ],
            },
            container: {
                pos: [
                    { x: 27, y: 30 },
                    { x: 23, y: 20 },
                ],
            },
        },
    },
};
const _allBunkerCoords = {};
for (const rcl of [1, 2, 3, 4, 5, 6, 7, 8]) {
    if (bunkerLayout[rcl].buildings) {
        _allBunkerCoords[rcl] = getAllStructureCoordsFromLayout(bunkerLayout, rcl);
    }
    if (rcl == 7 || rcl == 8) {
        // add center tile for advanced bunkers
        _allBunkerCoords[rcl].push(bunkerLayout.data.anchor);
    }
}
const allBunkerCoords = _allBunkerCoords;
const bunkerCoordLookup = _.mapValues(_allBunkerCoords, (coordArr) => _.zipObject(_.map(coordArr, (c) => [packCoord(c), true])));
// Fast function for checking if a position is inside the bunker
function insideBunkerBounds(pos, colony) {
    if (colony.roomPlanner.memory.bunkerData &&
        colony.roomPlanner.memory.bunkerData.anchor) {
        const dx = bunkerLayout.data.anchor.x -
            colony.roomPlanner.memory.bunkerData.anchor.x;
        const dy = bunkerLayout.data.anchor.y -
            colony.roomPlanner.memory.bunkerData.anchor.y;
        const coord = { x: pos.x + dx, y: pos.y + dy };
        return !!bunkerCoordLookup[colony.level][packCoord(coord)];
    }
    return false;
}
function getPosFromBunkerCoord(coord, colony) {
    if (colony.roomPlanner.memory.bunkerData &&
        colony.roomPlanner.memory.bunkerData.anchor) {
        const dx = colony.roomPlanner.memory.bunkerData.anchor.x -
            bunkerLayout.data.anchor.x;
        const dy = colony.roomPlanner.memory.bunkerData.anchor.y -
            bunkerLayout.data.anchor.y;
        return new RoomPosition(coord.x + dx, coord.y + dy, colony.room.name);
    }
    console.log("getPosFromBunkerCoord: shouldn't reach here! Unprotected call from non-bunker?");
    return new RoomPosition(-1, -1, "invalid");
}
// Spots where queens can sit to be renewed when idle
const bunkerChargingSpots = [
    { x: 27, y: 31 },
    { x: 23, y: 19 },
];
const reagentLabSpots = [
    { x: 27, y: 22 },
    { x: 28, y: 23 },
];
// Efficient, hard-coded order in which to refill extensions, spawns, labs, and towers
const quadrantFillOrder = {
    lowerRight: [
        { x: 30, y: 24 },
        { x: 30, y: 25 },
        { x: 29, y: 25 },
        { x: 29, y: 26 },
        { x: 28, y: 26 },
        { x: 27, y: 25 },
        { x: 28, y: 27 },
        { x: 27, y: 27 },
        { x: 27, y: 28 },
        { x: 26, y: 28 },
        { x: 27, y: 29 },
        { x: 28, y: 29 },
        { x: 28, y: 28 },
        { x: 29, y: 28 },
        { x: 29, y: 27 },
        { x: 30, y: 27 },
        { x: 30, y: 26 },
    ],
    lowerLeft: [
        { x: 22, y: 26 },
        { x: 22, y: 27 },
        { x: 23, y: 27 },
        { x: 23, y: 28 },
        { x: 24, y: 28 },
        { x: 25, y: 27 },
        { x: 24, y: 29 },
        { x: 25, y: 29 },
        { x: 25, y: 30 },
        { x: 26, y: 30 },
        { x: 24, y: 30 },
        { x: 23, y: 30 },
        { x: 23, y: 29 },
        { x: 22, y: 29 },
        { x: 22, y: 28 },
        { x: 21, y: 28 },
        { x: 21, y: 27 },
    ],
    upperLeft: [
        { x: 23, y: 21 },
        { x: 23, y: 22 },
        { x: 24, y: 22 },
        { x: 23, y: 23 },
        { x: 22, y: 23 },
        { x: 22, y: 24 },
        { x: 23, y: 25 },
        { x: 21, y: 24 },
        { x: 21, y: 25 },
        { x: 20, y: 25 },
        { x: 20, y: 26 },
        { x: 22, y: 21 },
        { x: 22, y: 22 },
        { x: 21, y: 22 },
        { x: 21, y: 23 },
        { x: 20, y: 23 },
        { x: 20, y: 24 },
    ],
    upperRight: [
        { x: 24, y: 20 },
        { x: 25, y: 20 },
        { x: 25, y: 21 },
        { x: 26, y: 21 },
        { x: 26, y: 22 },
        { x: 27, y: 22 },
        { x: 27, y: 23 },
        { x: 25, y: 23 },
        { x: 28, y: 23 },
        { x: 28, y: 24 },
        { x: 29, y: 23 },
        { x: 29, y: 22 },
        { x: 28, y: 22 },
        { x: 28, y: 21 },
        { x: 27, y: 21 },
        { x: 27, y: 20 },
        { x: 26, y: 20 },
        { x: 26, y: 24 },
    ],
};
// Used to generate energy structure ordering for spawn.spawnCreep()
const energyStructureOrder = [].concat(quadrantFillOrder.lowerRight, quadrantFillOrder.upperLeft, quadrantFillOrder.lowerLeft, quadrantFillOrder.upperRight);

const MAX_SAMPLE = 10;
const MAX_TOTAL_PATH_LENGTH = 25 * 3;
let BasePlanner = class BasePlanner {
    static getBunkerLocation(roomName, visualize = true) {
        const colony = Overmind.colonies[roomName];
        if (colony && colony.bunker && colony.bunker.anchor) {
            return colony.bunker.anchor;
        }
        let allowableLocations = this.getAllowableBunkerLocations(roomName, visualize);
        if (allowableLocations === undefined) {
            return undefined;
        }
        if (allowableLocations.length > MAX_SAMPLE) {
            allowableLocations = _.sample(allowableLocations, MAX_SAMPLE);
        }
        const info = RoomIntel.getAllRoomObjectInfo(roomName);
        const minimizePathLengthTo = _.map(_.compact([...info.sources, info.controller]), (obj) => obj.pos);
        const totalPathLength = function (anchor) {
            let totalDistance = 0;
            for (const pos of minimizePathLengthTo) {
                const ret = Pathing.findShortestPath(anchor, pos, {
                    ignoreStructures: true,
                });
                if (!ret.incomplete) {
                    totalDistance += ret.path.length;
                }
                else {
                    totalDistance += Infinity;
                }
            }
            return totalDistance;
        };
        const bestAnchor = minBy(allowableLocations, (pos) => totalPathLength(pos));
        if (bestAnchor &&
            totalPathLength(bestAnchor) <= MAX_TOTAL_PATH_LENGTH) {
            return bestAnchor;
        }
    }
    static getAllowableBunkerLocations(roomName, visualize = true) {
        const info = RoomIntel.getAllRoomObjectInfo(roomName);
        if (info === undefined) {
            return undefined;
        }
        let allowableLocations = this.getNonIntersectingBunkerLocations(roomName, visualize);
        if (allowableLocations.length > MAX_SAMPLE) {
            allowableLocations = _.sample(allowableLocations, MAX_SAMPLE);
        }
        // Filter intersection with controller
        if (info.controller === null) {
            return [];
        }
        allowableLocations = _.filter(allowableLocations, (anchor) => !this.bunkerIntersectsWith(anchor, info.controller.pos, 3));
        // Filter intersection with miningSites
        const sitesAndMineral = _.map(_.compact([...info.sources, info.mineral]), (obj) => obj.pos);
        allowableLocations = _.filter(allowableLocations, (anchor) => !_.any(sitesAndMineral, (pos) => this.bunkerIntersectsWith(anchor, pos, 1)));
        if (visualize) {
            const vis = new RoomVisual(roomName);
            for (const pos of allowableLocations) {
                vis.circle(pos.x, pos.y, { fill: "purple" });
            }
        }
        return allowableLocations;
    }
    static getNonIntersectingBunkerLocations(roomName, visualize = true) {
        const dt = distanceTransform(roomName);
        const coords = [];
        let x, y;
        for (y of _.range(BUNKER_RADIUS + 2, 50 - (BUNKER_RADIUS + 2))) {
            for (x of _.range(BUNKER_RADIUS + 2, 50 - (BUNKER_RADIUS + 2))) {
                if (dt.get(x, y) >= BUNKER_RADIUS + 1) {
                    // If it fits, I sits
                    coords.push({ x, y });
                }
                else if (dt.get(x, y) >= BUNKER_RADIUS - 1 &&
                    !this.terrainIntersectsWithBunker({ x, y }, dt)) {
                    // If it might not fits, check that it fits before I sits
                    coords.push({ x, y });
                }
            }
        }
        if (visualize) {
            const vis = new RoomVisual(roomName);
            for (const coord of coords) {
                vis.text(dt.get(coord.x, coord.y).toString(), coord.x, coord.y);
            }
        }
        return _.map(coords, (coord) => new RoomPosition(coord.x, coord.y, roomName));
    }
    static terrainIntersectsWithBunker(anchor, distanceMatrix) {
        const dx = anchor.x - bunkerLayout.data.anchor.x;
        const dy = anchor.y - bunkerLayout.data.anchor.y;
        const bunkerCoordsAtAnchor = _.map(allBunkerCoords[8], function (coord) {
            return { x: coord.x + dx, y: coord.y + dy };
        });
        return _.any(bunkerCoordsAtAnchor, (coord) => distanceMatrix.get(coord.x, coord.y) == 0);
    }
    static bunkerIntersectsWith(anchor, obstacle, padding = 1) {
        const dx = bunkerLayout.data.anchor.x - anchor.x;
        const dy = bunkerLayout.data.anchor.y - anchor.y;
        let x, y;
        for (x of _.range(obstacle.x + dx - padding, obstacle.x + dx + padding + 1)) {
            for (y of _.range(obstacle.y + dy - padding, obstacle.y + dy + padding + 1)) {
                if (bunkerCoordLookup[8][packCoord({ x, y })]) {
                    return true;
                }
            }
        }
        return false;
    }
};
BasePlanner = __decorate$1([
    profile
], BasePlanner);

/** Tick bias used to calculate if a reserver needs to be sent */
const RESERVE_BUFFER_TIME = 1000;
/**
 * Spawns reservers to reserve an outpost room
 */
let ReservingOverlord = class ReservingOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.remoteRoom.reserve) {
        super(directive, "reserve", priority);
        this.settings = {
            resetSignature: false,
        };
        // Change priority to operate per-outpost
        this.priority +=
            this.outpostIndex * OverlordPriority.remoteRoom.roomIncrement;
        this.reservers = this.zerg(Roles.claim);
        this.reserverCount = 0;
        this.refreshReservation();
    }
    get deactivationReasons() {
        return new Set([
            SuspensionReason.cpu,
            SuspensionReason.upkeep,
            SuspensionReason.harassment,
            SuspensionReason.reserved,
        ]);
    }
    get reserverCount() {
        var _a;
        return (_a = this.memory.reserverCount) !== null && _a !== void 0 ? _a : 0;
    }
    set reserverCount(c) {
        this.memory.reserverCount = Math.max(0, c);
    }
    refreshReservation() {
        var _a, _b;
        if (this.room) {
            this.reservation = {
                username: (_a = this.room.controller.reservation) === null || _a === void 0 ? void 0 : _a.username,
                ticksToEnd: (_b = this.room.controller.reservation) === null || _b === void 0 ? void 0 : _b.ticksToEnd,
            };
        }
        else {
            this.reservation = {
                username: RoomIntel$1.roomReservedBy(this.pos.roomName),
                ticksToEnd: RoomIntel$1.roomReservationRemaining(this.pos.roomName),
            };
        }
    }
    refresh() {
        super.refresh();
        this.refreshReservation();
    }
    roomReservationRemaining() {
        var _a;
        if (this.reservation.username !== MY_USERNAME) {
            return 0;
        }
        return (_a = this.reservation.ticksToEnd) !== null && _a !== void 0 ? _a : 0;
    }
    init() {
        let priority = this.priority;
        if (this.isSuspended &&
            this.colony.memory.outposts[this.pos.roomName].suspendReason ===
                SuspensionReason.reserved) {
            priority = OverlordPriority.outpostDefense.reserve;
        }
        this.wishlist(this.reserverCount, Setups.infestors.reserve, {
            priority,
        });
    }
    handleReserver(reserver) {
        if (reserver.room == this.room && !reserver.pos.isEdge) {
            // If reserver is in the room and not on exit tile
            if (!this.room.controller.signedByMe ||
                this.settings.resetSignature) {
                // Takes care of an edge case where planned newbie zone signs prevents signing until room is reserved
                if (!this.room.my && this.room.controller.signedByScreeps) {
                    reserver.task = Tasks$1.reserve(this.room.controller);
                }
                else {
                    reserver.task = Tasks$1.signController(this.room.controller);
                    this.settings.resetSignature = false;
                }
            }
            else {
                reserver.task = Tasks$1.reserve(this.room.controller);
            }
        }
        else {
            reserver.goTo(this.pos);
        }
    }
    run() {
        var _a, _b;
        const distance = this.initializer.distanceFromPOI
            .terrainWeighted;
        const waitTime = (_b = (_a = this.colony.hatchery) === null || _a === void 0 ? void 0 : _a.getWaitTimeForPriority(this.priority)) !== null && _b !== void 0 ? _b : 0;
        this.reserverCount =
            (this.roomReservationRemaining() - RESERVE_BUFFER_TIME <=
                waitTime + distance) ?
                1
                : 0;
        this.debug(`remaining ${this.roomReservationRemaining()}, distance: ${distance}, waitTime: ${waitTime}: needs ${this.reserverCount} reserver`);
        this.autoRun(this.reservers, (reserver) => this.handleReserver(reserver), (reserver) => reserver.avoidDanger());
    }
};
ReservingOverlord = __decorate$1([
    profile
], ReservingOverlord);

/**
 * Sends out a stationary scout, which travels to a waypoint and remains there indefinitely
 */
let StationaryScoutOverlord = class StationaryScoutOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.scouting.stationary) {
        super(directive, "scout", priority);
        this.scouts = this.zerg(Roles.scout, { notifyWhenAttacked: false });
    }
    init() {
        this.wishlist(1, Setups.scout);
    }
    run() {
        for (const scout of this.scouts) {
            // if (this.pos.roomName == scout.room.name) {
            // 	const enemyConstructionSites = scout.room.find(FIND_HOSTILE_CONSTRUCTION_SITES);
            // 	const squashTarget = _.first(enemyConstructionSites);
            // 	if (squashTarget) {
            // 		scout.goTo(squashTarget);
            // 		return;
            // 	}
            // }
            if (!(scout.pos.inRangeTo(this.pos, 3) && !scout.pos.isEdge)) {
                scout.goTo(this.pos, { range: 3 });
            }
        }
    }
};
StationaryScoutOverlord = __decorate$1([
    profile
], StationaryScoutOverlord);

var DirectiveOutpost_1;
/**
 * Registers an unowned mining outpost for a nearby colony
 */
let DirectiveOutpost = DirectiveOutpost_1 = class DirectiveOutpost extends Directive {
    spawnMoarOverlords() {
        if (this.colony.level >=
            DirectiveOutpost_1.settings.canSpawnReserversAtRCL &&
            Cartographer.roomType(this.pos.roomName) == ROOMTYPE_CONTROLLER) {
            this.overlords.reserve = new ReservingOverlord(this);
        }
        else {
            this.overlords.scout = new StationaryScoutOverlord(this);
        }
    }
    init() { }
    run() {
        if (RoomIntel$1.roomOwnedBy(this.pos.roomName)) {
            log.warning(`Removing ${this.print} since room is owned!`);
            this.remove();
        }
        if (Game.time % 10 == 3 &&
            this.room &&
            this.room.controller &&
            !this.pos.isEqualTo(this.room.controller.pos) &&
            !this.memory.setPos) {
            this.setPosition(this.room.controller.pos);
        }
    }
    visuals() {
        RoomIntel$1.invasionVisualsForRoom(this.pos.roomName);
    }
};
DirectiveOutpost.directiveName = "outpost";
DirectiveOutpost.color = COLOR_PURPLE;
DirectiveOutpost.secondaryColor = COLOR_PURPLE;
DirectiveOutpost.settings = {
    canSpawnReserversAtRCL: 3,
};
DirectiveOutpost = DirectiveOutpost_1 = __decorate$1([
    profile
], DirectiveOutpost);

var MiningOverlord_1;
const StandardMinerSetupCost = bodyCost(Setups.drones.miners.standard.generateBody(Infinity));
const DoubleMinerSetupCost = bodyCost(Setups.drones.miners.double.generateBody(Infinity));
const BUILD_OUTPUT_FREQUENCY$1 = 15;
const SUICIDE_CHECK_FREQUENCY = 3;
const MINER_SUICIDE_THRESHOLD = 200;
const DISMANTLE_CHECK_FREQUENCY = 1500;
const DISMANTLE_CHECK = "dc";
const ENERGY_AVERAGE_WINDOW = 50;
/**
 * Spawns miners to harvest from remote, owned, or sourcekeeper energy deposits. Standard mining actions have been
 * heavily CPU-optimized
 */
let MiningOverlord = MiningOverlord_1 = class MiningOverlord extends Overlord {
    constructor(directive, priority) {
        super(directive, "mine", priority);
        this.distance = directive.distanceFromPOI.terrainWeighted;
        this.priority +=
            this.outpostIndex * OverlordPriority.remoteRoom.roomIncrement;
        this.miners = this.zerg(Roles.drone);
        // Populate structures
        this.populateStructures();
        // Check if dismantling is needed
        if (this.memory.dismantleNeeded ||
            Game.time > (this.memory[DISMANTLE_CHECK] || 0)) {
            if (this.room) {
                const positions = this.getDismantlePositions();
                if (positions.length > 0) {
                    this.memory.dismantleNeeded = true;
                    this.dismantlePositions = positions;
                }
                else {
                    this.memory[DISMANTLE_CHECK] = getCacheExpiration(DISMANTLE_CHECK_FREQUENCY, DISMANTLE_CHECK_FREQUENCY / 5);
                }
            }
        }
        // Compute energy output
        this._energyMinedThisTick = 0;
        const roomType = Cartographer.roomType(this.pos.roomName);
        if (roomType === ROOMTYPE_SOURCEKEEPER || roomType === ROOMTYPE_CORE) {
            this._maxEnergyPerTick =
                SOURCE_ENERGY_KEEPER_CAPACITY / ENERGY_REGEN_TIME;
        }
        else if (
        // This is a colony mine, or we can spawn reservers
        this.pos.roomName === this.colony.room.name ||
            this.colony.level >=
                DirectiveOutpost.settings.canSpawnReserversAtRCL) {
            this._maxEnergyPerTick = SOURCE_ENERGY_CAPACITY / ENERGY_REGEN_TIME;
        }
        else {
            this._maxEnergyPerTick =
                SOURCE_ENERGY_NEUTRAL_CAPACITY / ENERGY_REGEN_TIME;
        }
        this.miningPowerNeeded =
            Math.ceil(this._maxEnergyPerTick / HARVEST_POWER) + 1;
        const canAffordStandardMiner = this.colony.room.energyCapacityAvailable >= StandardMinerSetupCost;
        const canAffordDoubleMiner = this.colony.room.energyCapacityAvailable >= DoubleMinerSetupCost;
        // Check if the colony is too small to support standard miners
        this.earlyMode = !canAffordStandardMiner;
        // Allow drop mining at low levels
        this.allowDropMining =
            this.colony.level < MiningOverlord_1.settings.dropMineUntilRCL;
        // Calculate optimal location for mining
        // We'll redisable below if there's a second source
        this.isDisabled = false;
        const canDoubleMine = this.canDoubleMine();
        if (!this.earlyMode && !this.allowDropMining) {
            if (canAffordDoubleMiner && canDoubleMine) {
                // Disable mining from the source with greater id
                if (this.source.id > this.secondSource.id) {
                    this.isDisabled = true;
                }
                this.harvestPos = this.getMiningPos(this.source.pos, this.secondSource.pos);
            }
            else if (this.container) {
                this.harvestPos = this.container.pos;
            }
            else if (this.link) {
                this.harvestPos = _.find(this.link.pos.availableNeighbors(true), (pos) => pos.getRangeTo(this) == 1);
            }
            else {
                this.harvestPos = this.containerPos;
            }
        }
        // In case of dual mining, we double our estimated output to cater for the other miner being disabled
        if (canDoubleMine) {
            this._maxEnergyPerTick *= this.isDisabled ? 0 : 2;
        }
        this.debug(() => {
            return (`capacity: ${this.colony.room.energyCapacityAvailable}, standard: ${canAffordStandardMiner}, double: ${canAffordDoubleMiner}, ` +
                `early mode: ${this.earlyMode}, drop mining: ${this.allowDropMining}, ` +
                (canDoubleMine ?
                    `other source is mineable from ${this.secondSource.print}, ${this.isDisabled ? "disabling" : "handling"}, `
                    : "") +
                `optimal harvest position: ${this.harvestPos ? this.harvestPos.print : undefined}`);
        });
        // Grab best miner setup
        if (Cartographer.roomType(this.pos.roomName) == ROOMTYPE_SOURCEKEEPER) {
            this.debug(`using sourceKeeper miner setup`);
            this.setup = Setups.drones.miners.sourceKeeper;
        }
        else if (this.earlyMode) {
            this.debug(`using early miner setup`);
            this.setup = Setups.drones.miners.default;
        }
        else if (this.secondSource && canAffordDoubleMiner) {
            this.debug(`using double miner setup`);
            this.setup = Setups.drones.miners.double;
        }
        else if (this.link) {
            if (this.colony.assets.energy >= 100000) {
                this.debug(`using link-optimized setup`);
                this.setup = Setups.drones.miners.linkOptimized;
            }
            else {
                this.debug(`using early miner (link?) setup`);
                this.setup = Setups.drones.miners.default;
            }
        }
        else {
            this.debug(`using standard miner setup`);
            // this.setup = Game.cpu.bucket < 9500 ? Setups.drones.miners.standardCPU : Setups.drones.miners.standard;
            this.setup = Setups.drones.miners.standard;
        }
        const miningPowerEach = this.setup.getBodyPotential(WORK, this.colony);
        this.minersNeeded = Math.min(Math.ceil(this.miningPowerNeeded / miningPowerEach), this.pos.availableNeighbors(true).length);
        this.minersNeeded = this.isDisabled ? 0 : this.minersNeeded;
    }
    get maxEnergyPerTick() {
        return this._maxEnergyPerTick;
    }
    get avgEnergyPerTick() {
        var _a;
        return (_a = this.memory.avgEnergy) !== null && _a !== void 0 ? _a : 0;
    }
    get isRegenerating() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        if (this.canDoubleMine()) {
            return (Math.min(((_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.energy) !== null && _b !== void 0 ? _b : 0) === 0 ?
                (_d = (_c = this.source) === null || _c === void 0 ? void 0 : _c.ticksToRegeneration) !== null && _d !== void 0 ? _d : 0
                : 0, ((_f = (_e = this.secondSource) === null || _e === void 0 ? void 0 : _e.energy) !== null && _f !== void 0 ? _f : 0) === 0 ?
                (_h = (_g = this.secondSource) === null || _g === void 0 ? void 0 : _g.ticksToRegeneration) !== null && _h !== void 0 ? _h : 0
                : 0) > 0);
        }
        return (((_k = (_j = this.source) === null || _j === void 0 ? void 0 : _j.energy) !== null && _k !== void 0 ? _k : 0) === 0 &&
            ((_m = (_l = this.source) === null || _l === void 0 ? void 0 : _l.ticksToRegeneration) !== null && _m !== void 0 ? _m : 0) > 0);
    }
    /**
     * Returns the best position to mine both sources
     *
     * @param first Position of the first source
     * @param second Position of the second source
     * @returns
     */
    getMiningPos(first, second) {
        // If its over 1 spot away, is there spot in between to mine?
        const myNeighbors = first.availableNeighbors(true);
        const theirNeighbors = second.availableNeighbors(true);
        return myNeighbors.find((pos) => theirNeighbors.some((oPos) => pos.x === oPos.x && pos.y === oPos.y));
    }
    /**
     * Calculates if this source has another one very nearby that should be handled by the same miner
     * @returns {boolean}
     */
    canDoubleMine() {
        if (this.secondSource) {
            return true;
        }
        const room = Game.rooms[this.pos.roomName];
        if (!room || !this.source) {
            return false;
        }
        const secondSource = _.find(this.source.pos.findInRange(FIND_SOURCES, 2), (source) => source.id != (this.source ? this.source.id : ""));
        if (!secondSource) {
            return false;
        }
        this.debug(`found other source 2 away from ${this.source.print}: ${secondSource === null || secondSource === void 0 ? void 0 : secondSource.print}`);
        const miningPos = this.getMiningPos(this.source.pos, secondSource.pos);
        if (!miningPos) {
            this.debug(`Double mining found but there is no spot between ${this.source.print} and ${secondSource.print}`);
            return false;
        }
        // Grab the second source and store it
        this.secondSource = secondSource;
        return true;
    }
    /**
     * Checks if dismantling is needed in the operating room
     */
    getDismantlePositions() {
        const dismantleStructures = [];
        if (this.room) {
            const targets = _.compact([
                this.source,
                this.secondSource,
                this.container,
                this.link,
            ]);
            for (const target of targets) {
                // Add blocking structures
                const blockingStructure = this.findBlockingStructure(target);
                if (blockingStructure) {
                    dismantleStructures.push(blockingStructure);
                }
                // Add unwalkable structures with low hits in 2 range
                for (const pos of target.pos.getPositionsInRange(2, false, false)) {
                    const unwalkableStructure = _.find(pos.lookFor(LOOK_STRUCTURES), (s) => !s.isWalkable);
                    if (unwalkableStructure &&
                        !unwalkableStructure.my) {
                        dismantleStructures.push(unwalkableStructure);
                    }
                }
            }
            this.debug(`structures to dismantle: ${dismantleStructures.map((s) => `${s.structureType} ${s.pos.print}`)}`);
        }
        else {
            log.error(`MiningOverlord.getDismantleStructures() called with no vision in room ${this.pos.roomName}!`);
        }
        return _.unique(_.map(dismantleStructures, (s) => s.pos));
    }
    /**
     * Finds the structure which is blocking access to a source or controller
     */
    findBlockingStructure(target) {
        if (!this.room) {
            return;
        }
        const pos = Pathing.findBlockingPos(this.colony.pos, target.pos, _.filter(this.room.structures, (s) => !s.isWalkable));
        if (pos) {
            const structure = _.find(pos.lookFor(LOOK_STRUCTURES), (s) => !s.isWalkable);
            return (structure ||
                log.error(`${this.print}: no structure at blocking pos ${pos.print}!`));
        }
    }
    populateStructures() {
        if (Game.rooms[this.pos.roomName]) {
            this.source = _.first(this.pos.lookFor(LOOK_SOURCES));
            this.constructionSite = _.first(_.filter(this.pos.findInRange(FIND_MY_CONSTRUCTION_SITES, 2), (site) => site.structureType == STRUCTURE_CONTAINER ||
                site.structureType == STRUCTURE_LINK));
            this.container = this.pos.findClosestByLimitedRange(Game.rooms[this.pos.roomName].containers, 1);
            this.link = this.pos.findClosestByLimitedRange(this.colony.availableLinks, 2);
        }
    }
    get deactivationReasons() {
        const reasons = super.deactivationReasons;
        reasons.add(SuspensionReason.overfilled);
        return reasons;
    }
    refresh() {
        if (!this.room && Game.rooms[this.pos.roomName]) {
            // if you just gained vision of this room
            this.populateStructures();
        }
        super.refresh();
        // Refresh your references to the objects
        $.refresh(this, "source", "secondSource", "container", "link", "constructionSite");
        // Set back to 0 so we get an accurate reading
        this._energyMinedThisTick = 0;
        if (this.colony.state.isOverfilled && !this.isSuspended) {
            log.alert(`${this.colony.print} overfilled, suspending ${this.print} for ${SUSPENSION_OVERFILL_DEFAULT_DURATION}`);
            this.suspend({
                reason: SuspensionReason.overfilled,
                duration: SUSPENSION_OVERFILL_DEFAULT_DURATION,
            });
        }
    }
    get isSuspended() {
        return super.isSuspended || this.isDisabled;
    }
    static calculateContainerPos(source, dropoffLocation, colony) {
        // log.debug(`Computing container position for mining overlord at ${source.print}...`);
        if (dropoffLocation && source.isVisible) {
            const neighbors = source.neighbors;
            // We calculate positions that would conflict with our own preferred position
            const obstacles = [];
            for (const pos of neighbors) {
                if (colony &&
                    colony.pos.roomName === pos.roomName &&
                    insideBunkerBounds(pos, colony)) {
                    continue;
                }
                const structures = pos
                    .lookFor(LOOK_STRUCTURES)
                    .filter((s) => !s.isWalkable);
                for (const struct of structures) {
                    const structNeighbors = struct.pos.availableNeighbors(true);
                    const sharedNeighbors = structNeighbors.filter((structNeighbor) => {
                        return neighbors.some((neighborPos) => neighborPos.isEqualTo(structNeighbor));
                    });
                    // Only consider the neighboring structure if it would have that one path out
                    if (sharedNeighbors.length === structNeighbors.length) {
                        obstacles.push(...sharedNeighbors);
                    }
                }
            }
            const path = Pathing.findShortestPath(source, dropoffLocation, {
                obstacles: obstacles,
            }).path;
            const pos = _.find(path, (pos) => pos.getRangeTo(source) == 1);
            if (pos) {
                return pos;
            }
        }
        log.warning(`Last resort container position calculation for ${source.print}!`);
        // A source always have at least one neighbor, force the type
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
        return _.first(source.availableNeighbors(true));
    }
    /**
     * Calculate where the container output will be built for this site
     */
    calculateContainerPos() {
        let dropoff;
        if (this.colony.storage) {
            dropoff = this.colony.storage.pos;
        }
        else if (this.colony.roomPlanner.storagePos) {
            dropoff = this.colony.roomPlanner.storagePos;
        }
        return MiningOverlord_1.calculateContainerPos(this.pos, dropoff);
    }
    get containerPos() {
        let containerPos;
        const pos = this.memory.containerPos;
        if (pos) {
            containerPos = unpackPos(pos);
        }
        else {
            containerPos = this.calculateContainerPos();
            if (this.room) {
                // Only persist to memory if we have visibility
                this.memory.containerPos = packPos(containerPos);
            }
        }
        return containerPos;
    }
    /**
     * Add or remove containers as needed to keep exactly one of container | link
     */
    addRemoveContainer() {
        if (this.allowDropMining) {
            return; // only build containers in reserved, owned, or SK rooms
        }
        // Create container if there is not already one being built and no link
        if (!this.container && !this.constructionSite && !this.link) {
            const containerPos = this.containerPos;
            if (!containerPos) {
                log.error(`${this.print}: can't build container at ${this.room}`);
                return;
            }
            const container = containerPos ?
                containerPos.lookForStructure(STRUCTURE_CONTAINER)
                : undefined;
            if (container) {
                log.warning(`${this.print}: this.container out of sync at ${containerPos.print}`);
                this.container = container;
                return;
            }
            log.info(`${this.print}: building container at ${containerPos.print}`);
            const result = containerPos.createConstructionSite(STRUCTURE_CONTAINER);
            if (result != OK) {
                log.error(`${this.print}: cannot build container at ${containerPos.print}: ${errorForCode(result)}`);
            }
            return;
        }
        // Destroy container if link is nearby
        if (this.container && this.link) {
            // safety checks
            if (this.colony.hatchery &&
                this.container.pos.getRangeTo(this.colony.hatchery) > 2 &&
                this.container.pos.getRangeTo(this.colony.upgradeSite) > 3) {
                log.info(`${this.print}: container and link present; destroying container at ${this.container.pos.print}`);
                this.container.destroy();
            }
        }
    }
    registerEnergyRequests() {
        if (this.container) {
            const transportCapacity = 200 * this.colony.level;
            const threshold = this.colony.storage ? 0.8 : 0.5;
            if (this.container.store.getUsedCapacity() >
                threshold * transportCapacity) {
                this.colony.logisticsNetwork.requestOutput(this.container, {
                    resourceType: "all",
                    dAmountdt: this.avgEnergyPerTick,
                });
            }
        }
        if (this.link) {
            // If the link will be full with next deposit from the miner
            const minerCapacity = Math.min(...this.miners.map((miner) => miner.store.getCapacity()));
            if (this.link.store.getUsedCapacity(RESOURCE_ENERGY) +
                minerCapacity >
                this.link.store.getCapacity(RESOURCE_ENERGY)) {
                this.colony.linkNetwork.requestTransmit(this.link);
            }
        }
    }
    init() {
        this.wishlist(this.minersNeeded, this.setup);
        this.registerEnergyRequests();
    }
    /**
     * Suicide outdated miners when their replacements arrive
     */
    suicideOldMiners() {
        if (this.miners.length > this.minersNeeded && this.source) {
            // if you have multiple miners and the source is visible
            const targetPos = this.harvestPos || this.source.pos;
            const minersNearSource = _.filter(this.miners, (miner) => miner.pos.getRangeTo(targetPos) <= SUICIDE_CHECK_FREQUENCY);
            if (minersNearSource.length > this.minersNeeded) {
                // if you have more miners by the source than you need
                const oldestMiner = minBy(minersNearSource, (miner) => miner.ticksToLive || 9999);
                if (oldestMiner &&
                    (oldestMiner.ticksToLive || 9999) < MINER_SUICIDE_THRESHOLD) {
                    // if the oldest miner will die sufficiently soon
                    oldestMiner.retire();
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Preliminary actions performed before going into the harvest-transfer loop
     *
     * This check for anything to dismantle, repair or build, then ensure the creep
     * is at least in the correct room to harvest.
     */
    prepareActions(miner) {
        if (this.memory.dismantleNeeded) {
            this.dismantleActions(miner);
            return true;
        }
        else if (this.container &&
            this.container.hits < this.container.hitsMax &&
            miner.store.energy >=
                Math.min(miner.store.getCapacity(), REPAIR_POWER * miner.getActiveBodyparts(WORK))) {
            // Mining container hitpoints are low
            this.debug(`${miner.print} repairing ${this.container.print}`);
            miner.repair(this.container);
            return true;
        }
        else if (this.constructionSite &&
            miner.store.energy >=
                Math.min(miner.store.getCapacity(), BUILD_POWER * miner.getActiveBodyparts(WORK))) {
            // We have a construction to complete
            this.debug(`${miner.print} building ${this.constructionSite.print}`);
            miner.build(this.constructionSite);
            return true;
        }
        else if (!this.source) {
            // We likely don't have visibilty, just move to it
            if (!miner.pos.inRangeToPos(this.pos, 1) &&
                miner.store.getFreeCapacity(RESOURCE_ENERGY) !== 0) {
                this.debug(`${miner.print} not in range, moving closer to ${this.pos}`);
                miner.goTo(this);
                return true;
            }
            log.error(`${miner.print} has no source??`);
            return true;
        }
        return false;
    }
    /**
     * Actions for handling harvesting from the source(s)
     *
     * This will cause the miner to try and harvest from its mining site's source(s),
     * potentially sending it to sleep after dropping off its last batch, or move it
     * closer if it's still too far.
     */
    miningActions(miner) {
        var _a, _b;
        if (!this.source) {
            return true;
        }
        // At this point the miner is in the room so we have vision of the source
        // Handle harvesting and moving closer if that fails
        let result = OK;
        if (this.secondSource) {
            // We're mining two sources
            if (this.source && this.source.energy > 0) {
                result = miner.harvest(this.source);
            }
            else if (this.secondSource.energy > 0) {
                result = miner.harvest(this.secondSource);
            }
        }
        else {
            result = miner.harvest(this.source);
        }
        this.debug(`${miner.print} harvesting from ${this.source.print}: ${result}`);
        // The insufficent resources takes precedence over the range check, so we have
        // to make sure we are in range before deciding what to do
        const inRange = miner.pos.inRangeTo(this.pos, 1);
        if (result === OK) {
            // All good!
            this._energyMinedThisTick += 2 * miner.bodypartCounts[WORK];
        }
        else if (result === ERR_NOT_ENOUGH_RESOURCES && inRange) {
            // Do one last transfer before going to sleep so we're empty when resuming
            const ticksToRegen = Math.min(this.source.ticksToRegeneration, (_b = (_a = this.secondSource) === null || _a === void 0 ? void 0 : _a.ticksToRegeneration) !== null && _b !== void 0 ? _b : this.source.ticksToRegeneration);
            if (ticksToRegen > (miner.ticksToLive || Infinity)) {
                miner.retire();
            }
            else {
                // Sleep until the source regenerates
                this.debug(`${miner.print} sleeping for ${ticksToRegen}`);
                miner.sleep(Game.time + ticksToRegen);
            }
            this.debug(`${miner.print} doing a last transfer before going to sleep`);
            return this.handleTransfer(miner, true);
        }
        else if (result === ERR_NOT_IN_RANGE ||
            (result === ERR_NOT_ENOUGH_RESOURCES &&
                !miner.pos.inRangeTo(this.pos, 1))) {
            this.debug(`${miner.print} not actually in range, moving closer to ${this.source.print}`);
            return this.goToMiningSite(miner);
        }
        else if (result === ERR_NOT_OWNER && Game.time % 20 == 0) {
            log.alert(`${this.print} ${miner.print} room is reserved by hostiles!`);
        }
        else if (result === ERR_NO_BODYPART) {
            this.debug(`${miner.print} is not fit for duty, retiring`);
            miner.retire();
        }
        else {
            log.error(`${miner.print}: unhandled miner.harvest() exception: ${result}`);
        }
        // We return false here so that we attempt to transfer
        return false;
    }
    /**
     * Handle post-harvest transfer actions
     *
     * This checks on the current storage of the miner (shortcircuiting if it's about to sleep
     * so it doesn't keep energy around) and transfers it over to its preferred location.
     */
    handleTransfer(miner, emptyOut) {
        var _a, _b;
        const overfilled = miner.store.energy > 0.9 * miner.store.getCapacity();
        if (!overfilled && !(emptyOut || miner.store.energy === 0)) {
            return false;
        }
        const commandCenterLink = (_b = (_a = this.colony.commandCenter) === null || _a === void 0 ? void 0 : _a.link) !== null && _b !== void 0 ? _b : undefined;
        // Check link first, then container, then drop-mining, so we favor better locations
        if (this.link && commandCenterLink) {
            this.debug(`${miner.print} overfilled, dropping into ${this.link.print}`);
            miner.goTransfer(this.link, RESOURCE_ENERGY);
            return true;
        }
        else if (this.container &&
            this.container.store.getFreeCapacity(RESOURCE_ENERGY) !== 0) {
            this.debug(`${miner.print} overfilled, dropping into ${this.container.print}`);
            miner.goTransfer(this.container);
            return true;
        }
        else if (this.allowDropMining) {
            // try to drop on top of largest drop if full, otherwise drop where we are
            const biggestDrop = maxBy(miner.pos.findInRange(miner.room.droppedEnergy, 1), (drop) => drop.amount);
            if (biggestDrop) {
                this.debug(`${miner.print} overfilled and allowed to drop-mine onto ${biggestDrop === null || biggestDrop === void 0 ? void 0 : biggestDrop.print}`);
                miner.goDrop(biggestDrop.pos, RESOURCE_ENERGY);
            }
            else {
                this.debug(`${miner.print} overfilled and allowed to drop-mine onto ${miner.pos.print}`);
                miner.drop(RESOURCE_ENERGY);
            }
            return true;
        }
        // Just drop it on the ground as a last resort
        this.debug(`${miner.print} overfilled but no drop location ready!`);
        miner.drop(RESOURCE_ENERGY);
        return true;
    }
    /**
     * Actions for handling mining at RCL high enough to spawn ideal miner body to saturate source
     */
    dismantleActions(miner) {
        // Go to the room
        if (!miner.safelyInRoom(this.pos.roomName)) {
            return miner.goToRoom(this.pos.roomName);
        }
        // We're done if there are no dismantle positions left
        if (!this.dismantlePositions || this.dismantlePositions.length == 0) {
            log.info(`Miner dismantling completed in room ${miner.room.print}`);
            delete this.memory.dismantleNeeded;
            this.memory[DISMANTLE_CHECK] = getCacheExpiration(DISMANTLE_CHECK_FREQUENCY, DISMANTLE_CHECK_FREQUENCY / 5);
            return OK;
        }
        // Find the first reachable position to dismantle stuff
        const dismantlePos = _.find(this.dismantlePositions, (pos) => Pathing.isReachable(miner.pos, pos, _.filter(miner.room.structures, (s) => !s.isWalkable)));
        if (dismantlePos) {
            // Find the first blocking structure on the target position
            const dismantleTarget = _.find(dismantlePos.lookFor(LOOK_STRUCTURES), (s) => !s.isWalkable && !s.my);
            // Dismantle it
            if (dismantleTarget) {
                if (dismantleTarget.hits > 1000 && Game.time % 10 == 0) {
                    log.alert(`${miner.print} attempting to dismantle large structure!`);
                }
                return miner.goDismantle(dismantleTarget);
            }
            else {
                // Otherwise recalculate dismantle positions and call again to get next target
                this.dismantlePositions = this.getDismantlePositions();
                return this.dismantleActions(miner);
            }
        }
        else {
            log.warning(`No reachable dismantle positions for ${miner.print}!`);
        }
        return ERR_INVALID_TARGET;
    }
    /**
     * Move onto harvesting position or near to source
     */
    goToMiningSite(miner, avoidSK = true) {
        if (this.earlyMode) {
            if (!miner.pos.inRangeToPos(this.pos, 1)) {
                // We can't use harvestPos here because miners will push
                // each other around and waste CPU
                miner.goTo(this);
                return true;
            }
            return false;
        }
        let range = 1;
        let pos = this.pos;
        if (this.harvestPos && this.harvestPos.isWalkable()) {
            range = 0;
            pos = this.harvestPos;
        }
        if (!miner.pos.inRangeToPos(pos, range)) {
            miner.goTo(pos, { range: range, pathOpts: { avoidSK: avoidSK } });
            return true;
        }
        return false;
    }
    handleMiner(miner) {
        // Mining site upgrade & repairs, or better positioning if out of room
        if (this.prepareActions(miner)) {
            return;
        }
        // Harvest and potentially sleep
        if (this.miningActions(miner)) {
            return;
        }
        // Transfer resources out to storage
        this.handleTransfer(miner);
    }
    tryRun() {
        super.tryRun();
        this.stats();
    }
    run() {
        this.autoRun(this.miners, (miner) => this.handleMiner(miner), (miner) => miner.avoidDanger({ timer: 10, dropEnergy: true }));
        if (this.room && Game.time % BUILD_OUTPUT_FREQUENCY$1 == 1) {
            this.addRemoveContainer();
        }
        if (Game.time % SUICIDE_CHECK_FREQUENCY == 0) {
            this.suicideOldMiners();
        }
    }
    stats() {
        var _a;
        if (!this.isRegenerating) {
            this.memory.avgEnergy = ema(this._energyMinedThisTick, (_a = this.memory.avgEnergy) !== null && _a !== void 0 ? _a : 0, ENERGY_AVERAGE_WINDOW);
        }
        this.colony.trackEnergyUse(EnergyUse.MINED, this._energyMinedThisTick);
    }
};
MiningOverlord.settings = {
    minLinkDistance: 10,
    dropMineUntilRCL: 3,
};
MiningOverlord = MiningOverlord_1 = __decorate$1([
    profile
], MiningOverlord);

const EXPANSION_EVALUATION_FREQ = 500;
const MIN_EXPANSION_DISTANCE = 2;
let ExpansionEvaluator = class ExpansionEvaluator {
    static refreshExpansionData(expansionData, colonyRoomName) {
        // This method is typed a little strangely to avoid some circular dependency problems
        // This only gets run once per colony
        if (_.keys(expansionData.possibleExpansions).length == 0 ||
            Game.time > expansionData.expiration) {
            // Generate a list of rooms which can possibly be settled in
            const nearbyRooms = Cartographer.recursiveRoomSearch(colonyRoomName, 5);
            let possibleExpansions = [];
            for (const depth in nearbyRooms) {
                if (parseInt(depth, 10) <= MIN_EXPANSION_DISTANCE) {
                    continue;
                }
                possibleExpansions = possibleExpansions.concat(nearbyRooms[depth]);
            }
            for (const roomName of possibleExpansions) {
                if (Cartographer.roomType(roomName) == ROOMTYPE_CONTROLLER) {
                    expansionData.possibleExpansions[roomName] = true;
                }
            }
        }
        // This gets run whenever function is called
        for (const roomName in expansionData.possibleExpansions) {
            if (expansionData.possibleExpansions[roomName] == true) {
                if (Memory.rooms[roomName]) {
                    const roomExpansionData = RoomIntel$1.getExpansionData(roomName);
                    if (roomExpansionData == false) {
                        expansionData.possibleExpansions[roomName] = false;
                    }
                    else if (roomExpansionData && roomExpansionData.score) {
                        expansionData.possibleExpansions[roomName] =
                            roomExpansionData.score;
                    }
                }
            }
        }
    }
    /**
     * Returns the net energy income per cpu spent
     * @param dropoffLocation point of origin
     * @param room
     * @param verbose
     */
    static computeTheoreticalMiningEfficiency(dropoffLocation, room) {
        const type = Cartographer.roomType(room);
        const data = {
            room: room,
            type: type,
            dropoffLocation: dropoffLocation,
            sources: 0,
            unreachableSources: 0,
            unreachableController: false,
            energyPerSource: 0,
            creepEnergyCost: 0,
            spawnTimeCost: 0,
            cpuCost: 0,
            netIncome: 0,
            avgEnergyPerCPU: 0,
        };
        const sourcePositions = RoomIntel$1.getSourceInfo(room);
        if (sourcePositions == undefined) {
            log.info(`No memory of outpost room: ${room}. Aborting score calculation!`);
            return data;
        }
        // Compute Path length
        // TODO have it track how many swamp/plain/tunnel
        const sourcePathLengths = {};
        for (const source of sourcePositions) {
            const containerPos = MiningOverlord.calculateContainerPos(source.pos, dropoffLocation);
            // TODO Need to factor in where roads would go
            const path = Pathing.findShortestPath(dropoffLocation, containerPos, {
                ignoreStructures: true,
                allowHostile: true,
                blockCreeps: false,
                avoidSK: false,
            });
            if (path.incomplete) {
                log.error(`Couldn't find path to source ${source.pos.print} for mining efficiency calc`);
                data.unreachableSources++;
                continue;
            }
            sourcePathLengths[source.pos.print] = path.path.length;
        }
        // Compute Energy Supply
        data.energyPerSource =
            type == ROOMTYPE_CONTROLLER ?
                SOURCE_ENERGY_CAPACITY
                : SOURCE_ENERGY_KEEPER_CAPACITY;
        // Compute miner upkeep
        for (const source of sourcePositions) {
            const setup = type == ROOMTYPE_CONTROLLER ?
                Setups.drones.miners.standard.generateMaxedBody()
                : Setups.drones.miners.sourceKeeper.generateMaxedBody();
            const effectiveCreepUptime = CREEP_LIFE_TIME - sourcePathLengths[source.pos.print];
            data.creepEnergyCost += bodyCost(setup) / effectiveCreepUptime;
            data.spawnTimeCost +=
                (setup.length * CREEP_SPAWN_TIME) / effectiveCreepUptime;
            // Always harvesting, sometimes replacement is moving
            data.cpuCost +=
                0.2 + 0.2 * (1 - effectiveCreepUptime / CREEP_LIFE_TIME);
        }
        // Compute reserver/skReaper upkeep
        if (type == ROOMTYPE_CONTROLLER) {
            const controller = RoomIntel$1.getControllerInfo(room);
            if (!controller) {
                log.error(`Expansion Efficiency Calc: Can't find controller for room ${room}`);
                data.unreachableController = true;
            }
            else {
                const setup = Setups.infestors.reserve.generateMaxedBody();
                const controllerPath = Pathing.findShortestPath(dropoffLocation, controller.pos, {
                    ignoreStructures: true,
                    allowHostile: true,
                });
                if (controllerPath.incomplete) {
                    log.error(`Couldn't find path to controller ${controller} for mining efficiency calc`);
                    data.unreachableController = true;
                }
                else {
                    const claimPower = _.filter(setup, (part) => part == CLAIM).length;
                    const effectiveLifetimeReservationGeneration = (CREEP_CLAIM_LIFE_TIME - controllerPath.path.length) *
                        claimPower;
                    data.creepEnergyCost +=
                        bodyCost(setup) /
                            effectiveLifetimeReservationGeneration;
                    data.spawnTimeCost +=
                        (setup.length * CREEP_SPAWN_TIME) /
                            effectiveLifetimeReservationGeneration;
                    data.cpuCost +=
                        (0.2 * CREEP_CLAIM_LIFE_TIME) /
                            effectiveLifetimeReservationGeneration;
                }
            }
        }
        else if (type == ROOMTYPE_SOURCEKEEPER) {
            // Handle SK
            const setup = CombatSetups.zerglings.sourceKeeper.generateMaxedBody();
            const skPath = Pathing.findPathToRoom(dropoffLocation, room, {
                ignoreStructures: true,
                allowHostile: true,
            });
            if (skPath.incomplete) {
                log.error(`Couldn't find path to sk room ${room} for mining efficiency calc`);
                data.unreachableController = true;
            }
            else {
                const effectiveCreepUptime = CREEP_LIFE_TIME - skPath.path.length;
                data.creepEnergyCost += bodyCost(setup) / effectiveCreepUptime;
                data.spawnTimeCost +=
                    (setup.length * CREEP_SPAWN_TIME) / effectiveCreepUptime;
                // Increased cost, always moving, frequent attack/move+heal intents,
                // and during overlap 2nd creep moving to room
                data.cpuCost +=
                    0.2 +
                        0.15 +
                        0.2 * (1 - effectiveCreepUptime / CREEP_LIFE_TIME);
                // TODO examine for accuracy Increased cost, frequent attack/move+heal intents
            }
        }
        // Compute transporter upkeep
        for (const source of sourcePositions) {
            const setup = Setups.transporters.default.generateMaxedBody();
            // Calculate amount of hauling each transporter provides in a lifetime
            const transporterCarryParts = _.filter(setup, (part) => part == CARRY).length;
            const effectiveEnergyTransportedPerTick = (transporterCarryParts * CARRY_CAPACITY) /
                (2 * sourcePathLengths[source.pos.print]); // round trip
            const transportersPerSource = data.energyPerSource /
                ENERGY_REGEN_TIME /
                effectiveEnergyTransportedPerTick;
            data.creepEnergyCost +=
                (bodyCost(setup) * transportersPerSource) / CREEP_LIFE_TIME;
            data.spawnTimeCost +=
                (setup.length * CREEP_SPAWN_TIME * transportersPerSource) /
                    CREEP_LIFE_TIME;
            data.cpuCost += 0.2 * transportersPerSource;
        }
        data.sources = sourcePositions.length;
        data.netIncome =
            (data.energyPerSource * sourcePositions.length) /
                ENERGY_REGEN_TIME -
                data.creepEnergyCost;
        data.avgEnergyPerCPU = data.netIncome / data.cpuCost || 0;
        return data;
    }
    // Compute the total score for a room
    static computeExpansionData(roomName, verbose = false) {
        if (verbose) {
            log.info(`Computing score for ${roomName}...`);
        }
        const controller = RoomIntel$1.getControllerInfo(roomName);
        if (controller === undefined) {
            if (verbose) {
                log.info(`No intel on ${roomName}, aborting score calculation!`);
            }
            return false;
        }
        if (controller === null) {
            RoomIntel$1.setExpansionData(roomName, false);
            return false;
        }
        // compute possible outposts (includes host room)
        const possibleOutpostsInRange = Cartographer.recursiveRoomSearch(roomName, 2);
        const possibleOutposts = _.flatten(_.values(possibleOutpostsInRange));
        // find source positions
        const outpostSourcePositions = {};
        for (const roomName of possibleOutposts) {
            if (Cartographer.roomType(roomName) == ROOMTYPE_ALLEY ||
                Cartographer.roomType(roomName) == ROOMTYPE_CROSSROAD) {
                continue;
            }
            const sourcePositions = RoomIntel$1.getSourceInfo(roomName);
            if (sourcePositions == undefined) {
                if (verbose) {
                    log.info(`No memory of neighbor: ${roomName}. Aborting score calculation!`);
                }
                return false;
            }
            else {
                outpostSourcePositions[roomName] = _.map(sourcePositions, (src) => src.pos);
            }
        }
        // compute a possible bunker position
        const bunkerLocation = BasePlanner.getBunkerLocation(roomName, false);
        if (!bunkerLocation) {
            RoomIntel$1.setExpansionData(roomName, false);
            log.info(`Room ${roomName} is uninhabitable because a bunker can't be built here!`);
            return false;
        }
        // evaluate energy contribution and compute outpost scores
        if (verbose) {
            log.info(`Origin: ${bunkerLocation.print}`);
        }
        const outpostScores = {};
        for (const roomName in outpostSourcePositions) {
            if (verbose) {
                log.info(`Analyzing neighbor ${roomName}`);
            }
            const sourcePositions = outpostSourcePositions[roomName];
            let valid = true;
            const roomType = Cartographer.roomType(roomName);
            let energyPerSource = SOURCE_ENERGY_CAPACITY;
            if (roomType == ROOMTYPE_SOURCEKEEPER) {
                energyPerSource = 0.6 * SOURCE_ENERGY_KEEPER_CAPACITY; // don't favor SK rooms too heavily -- more CPU
            }
            else if (roomType == ROOMTYPE_CORE) {
                energyPerSource = SOURCE_ENERGY_KEEPER_CAPACITY;
            }
            let roomScore = 0;
            for (const position of sourcePositions) {
                const msg = verbose ?
                    `Computing distance from ${bunkerLocation.print} to ${position.print}... `
                    : "";
                const ret = Pathing.findShortestPath(bunkerLocation, position, {
                    ignoreStructures: true,
                    allowHostile: true,
                });
                if (ret.incomplete ||
                    ret.path.length >
                        100 /* Colony.settings.maxSourceDistance */) {
                    if (verbose) {
                        log.info(msg + "incomplete path!");
                    }
                    valid = false;
                    break;
                }
                if (verbose) {
                    log.info(msg + ret.path.length);
                }
                const offset = 25; // prevents over-sensitivity to very close sources
                roomScore += energyPerSource / (ret.path.length + offset);
            }
            if (valid) {
                outpostScores[roomName] = Math.floor(roomScore);
            }
        }
        // Compute the total score of the room as the maximum energy score of max number of sources harvestable
        let totalScore = 0;
        let sourceCount = 0;
        const roomsByScore = _.sortBy(_.keys(outpostScores), (roomName) => -1 * outpostScores[roomName]);
        for (const scoredRoomName of roomsByScore) {
            if (sourceCount > 9 /* Colony.settings.remoteSourcesByLevel[8]*/) {
                break;
            }
            totalScore += outpostScores[scoredRoomName];
            sourceCount += outpostSourcePositions[scoredRoomName].length;
        }
        totalScore = Math.floor(totalScore);
        if (verbose) {
            log.info(`Score: ${totalScore}`);
        }
        const existingExpansionData = RoomIntel$1.getExpansionData(roomName);
        if (existingExpansionData === false) {
            log.error(`ExpansionEvaluator: shouldn't be here!`);
            return false;
        }
        if (existingExpansionData == undefined ||
            totalScore > existingExpansionData.score) {
            RoomIntel$1.setExpansionData(roomName, {
                score: totalScore,
                bunkerAnchor: bunkerLocation,
                outposts: outpostScores,
            });
        }
        return true;
    }
};
ExpansionEvaluator = __decorate$1([
    profile
], ExpansionEvaluator);

// Room intel - provides information related to room structure and occupation
var RoomIntel_1;
const RECACHE_TIME = 5000;
const OWNED_RECACHE_TIME = 1000;
const SCORE_RECALC_PROB = 0.05;
const FALSE_SCORE_RECALC_PROB = 0.01;
const ROOMINTEL_DEFAULT_VISUALS_RANGE = 5;
const defaultRoomIntelMemory = {
    portalRooms: [],
};
let RoomIntel$1 = RoomIntel_1 = class RoomIntel {
    constructor() {
        _.defaultsDeep(Memory.roomIntel, defaultRoomIntelMemory);
    }
    // Making this a static getter prevents us from having to call Overmind.roomIntel.whatever() all the time
    static get memory() {
        return Memory.roomIntel;
    }
    static cleanMemory() {
        // // Clean out memory of inactive portals // this actually gets done automatically with recordPermanentObjects
        // for (const portalRoomName in this.memory.portalRooms) {
        // 	const portals = this.memory.portalRooms[portalRoomName];
        // 	if (portals) {
        // 		for (const portal of portals) {
        // 			if (portal[MEM.EXPIRATION]) {
        // 				// TODO
        // 			}
        // 		}
        // 	}
        // }
    }
    /**
     * Mark a room as being visible this tick
     */
    static markVisible(room) {
        room.memory["T" /* MEM.TICK */] = Game.time;
    }
    /**
     * Returns the last tick at which the room was visible, or -100
     */
    static lastVisible(roomName) {
        if (Memory.rooms[roomName]) {
            return Memory.rooms[roomName]["T" /* MEM.TICK */] || -100;
        }
        else {
            return -100;
        }
    }
    /**
     * Gets expansion data from a room in readable format. Undefined means that a data is not present, while false
     * means that the room has been analyzed and determined to be unsuitable for expansion. Be sure to use === when
     * comparing to false!
     */
    static getExpansionData(roomName) {
        if (!Memory.rooms[roomName] ||
            Memory.rooms[roomName]["e" /* RMEM.EXPANSION_DATA */] === undefined) {
            return undefined;
        }
        const data = Memory.rooms[roomName]["e" /* RMEM.EXPANSION_DATA */];
        if (data === 0) {
            return false;
        }
        return {
            score: data["s" /* RMEM_EXPANSION_DATA.SCORE */],
            bunkerAnchor: unpackCoordAsPos(data["a" /* RMEM_EXPANSION_DATA.BUNKER_ANCHOR */], roomName),
            outposts: data["o" /* RMEM_EXPANSION_DATA.OUTPOSTS */],
        };
    }
    /**
     * Sets expansion data for a room. Setting the data to false marks the room as uninhabitable.
     */
    static setExpansionData(roomName, data) {
        Memory.rooms[roomName] = Memory.rooms[roomName] || {};
        if (data === false) {
            Memory.rooms[roomName]["e" /* RMEM.EXPANSION_DATA */] = 0;
        }
        else {
            Memory.rooms[roomName]["e" /* RMEM.EXPANSION_DATA */] = {
                ["s" /* RMEM_EXPANSION_DATA.SCORE */]: data.score,
                ["a" /* RMEM_EXPANSION_DATA.BUNKER_ANCHOR */]: packCoord(data.bunkerAnchor),
                ["o" /* RMEM_EXPANSION_DATA.OUTPOSTS */]: data.outposts,
            };
        }
    }
    /**
     * Returns information about known portals in a given room
     */
    static getPortalInfo(roomName) {
        var _a;
        let portalData = (_a = Memory.rooms[roomName]) === null || _a === void 0 ? void 0 : _a["pr" /* RMEM.PORTALS */];
        if (!portalData) {
            return [];
        }
        portalData = _.filter(portalData, (portal) => Game.time < portal["X" /* MEM.EXPIRATION */]);
        const portals = portalData.map((savedPortal) => {
            const pos = unpackCoordAsPos(savedPortal.c, roomName);
            let portal;
            if (typeof savedPortal.dest === "string") {
                portal = {
                    pos: pos,
                    roomDestination: unpackPos(savedPortal.dest),
                    expiration: savedPortal["X" /* MEM.EXPIRATION */],
                };
            }
            else {
                portal = {
                    pos: pos,
                    shardDestination: savedPortal.dest,
                    expiration: savedPortal["X" /* MEM.EXPIRATION */],
                };
            }
            return portal;
        });
        return portals;
    }
    /**
     * Returns information about sources in a given room
     */
    static getSourceInfo(roomName) {
        if (!Memory.rooms[roomName] || !Memory.rooms[roomName]["s" /* RMEM.SOURCES */]) {
            return;
        }
        return _.map(Memory.rooms[roomName]["s" /* RMEM.SOURCES */], (savedSource) => ({
            pos: unpackCoordAsPos(savedSource.c, roomName),
            containerPos: savedSource.cn ?
                unpackCoordAsPos(savedSource.cn, roomName)
                : undefined,
        }));
    }
    /**
     * Returns information about source keeper lairs in a given room
     */
    static getKeeperLairInfo(roomName) {
        if (!Memory.rooms[roomName] || !Memory.rooms[roomName]["k" /* RMEM.SKLAIRS */]) {
            return;
        }
        return _.map(Memory.rooms[roomName]["k" /* RMEM.SKLAIRS */], (savedLair) => ({
            pos: unpackCoordAsPos(savedLair.c, roomName),
            chillPos: savedLair.cp ?
                unpackCoordAsPos(savedLair.cp, roomName)
                : undefined,
        }));
    }
    /**
     * Unpackages saved information about a room's controller
     * @returns controller info if available, null if there's no controller, undefined otherwise
     */
    static getControllerInfo(roomName) {
        if (!Memory.rooms[roomName] ||
            Memory.rooms[roomName]["c" /* RMEM.CONTROLLER */] === undefined) {
            return;
        }
        const ctlr = Memory.rooms[roomName]["c" /* RMEM.CONTROLLER */];
        if (ctlr === null) {
            return null;
        }
        return {
            pos: unpackCoordAsPos(ctlr.c, roomName),
            level: ctlr["l" /* RMEM_CTRL.LEVEL */],
            owner: ctlr["o" /* RMEM_CTRL.OWNER */],
            reservation: ctlr["r" /* RMEM_CTRL.RESERVATION */] ?
                {
                    username: ctlr["r" /* RMEM_CTRL.RESERVATION */]["u" /* RMEM_CTRL.RES_USERNAME */],
                    ticksToEnd: ctlr["r" /* RMEM_CTRL.RESERVATION */]["t" /* RMEM_CTRL.RES_TICKSTOEND */],
                }
                : undefined,
            safemode: ctlr["s" /* RMEM_CTRL.SAFEMODE */],
            safemodeAvailable: ctlr["sa" /* RMEM_CTRL.SAFEMODE_AVAILABLE */],
            safemodeCooldown: ctlr["sc" /* RMEM_CTRL.SAFEMODE_COOLDOWN */],
            progress: ctlr["p" /* RMEM_CTRL.PROGRESS */],
            progressTotal: ctlr["pt" /* RMEM_CTRL.PROGRESS_TOTAL */],
        };
    }
    static getImportantStructureInfo(roomName) {
        if (!Memory.rooms[roomName] ||
            !Memory.rooms[roomName]["i" /* RMEM.IMPORTANT_STRUCTURES */]) {
            return;
        }
        const data = Memory.rooms[roomName]["i" /* RMEM.IMPORTANT_STRUCTURES */];
        return {
            storagePos: data["s" /* RMEM_STRUCTS.STORAGE */] ?
                unpackCoordAsPos(data["s" /* RMEM_STRUCTS.STORAGE */], roomName)
                : undefined,
            terminalPos: data["e" /* RMEM_STRUCTS.TERMINAL */] ?
                unpackCoordAsPos(data["e" /* RMEM_STRUCTS.TERMINAL */], roomName)
                : undefined,
            towerPositions: unpackCoordListAsPosList(data["t" /* RMEM_STRUCTS.TOWERS */], roomName),
            spawnPositions: unpackCoordListAsPosList(data["sp" /* RMEM_STRUCTS.SPAWNS */], roomName),
            wallPositions: unpackCoordListAsPosList(data["w" /* RMEM_STRUCTS.WALLS */], roomName),
            rampartPositions: unpackCoordListAsPosList(data["r" /* RMEM_STRUCTS.RAMPARTS */], roomName),
        };
    }
    /**
     * Retrieves all info for permanent room objects and returns it in a more readable/useful form
     */
    static getAllRoomObjectInfo(roomName) {
        const mem = Memory.rooms[roomName];
        if (mem) {
            const savedSources = mem["s" /* RMEM.SOURCES */] || [];
            const savedMineral = mem["m" /* RMEM.MINERAL */];
            let savedDeposits = mem["t" /* RMEM.DEPOSITS */] || [];
            const savedSkLairs = mem["k" /* RMEM.SKLAIRS */] || [];
            savedDeposits = savedDeposits.filter((dpst) => {
                var _a;
                const elapsed = Game.time - ((_a = dpst["i" /* RMEM_DPST.TIME */]) !== null && _a !== void 0 ? _a : 0);
                const timeToDecay = dpst["l" /* RMEM_DPST.TTL */] - elapsed;
                return timeToDecay > 0;
            });
            const returnObject = {
                controller: this.getControllerInfo(roomName),
                portals: this.getPortalInfo(roomName),
                sources: _.map(savedSources, (src) => src.cn ?
                    {
                        pos: unpackCoordAsPos(src.c, roomName),
                        containerPos: unpackCoordAsPos(src.cn, roomName),
                    }
                    : { pos: unpackCoordAsPos(src.c, roomName) }),
                mineral: savedMineral ?
                    {
                        pos: unpackCoordAsPos(savedMineral.c, roomName),
                        mineralType: savedMineral["t" /* RMEM_MNRL.MINERALTYPE */],
                        density: savedMineral["d" /* RMEM_MNRL.DENSITY */],
                    }
                    : undefined,
                deposits: savedDeposits.map((dpst) => {
                    var _a;
                    const elapsed = Game.time - ((_a = dpst["i" /* RMEM_DPST.TIME */]) !== null && _a !== void 0 ? _a : 0);
                    const timeToDecay = dpst["l" /* RMEM_DPST.TTL */] - elapsed;
                    const obj = {
                        pos: unpackCoordAsPos(dpst.c, roomName),
                        depositType: dpst["t" /* RMEM_DPST.DEPOSITTYPE */],
                        timeToDecay,
                        cooldown: dpst["d" /* RMEM_DPST.COOLDOWN */],
                    };
                    return obj;
                }),
                skLairs: _.map(savedSkLairs, (lair) => ({
                    pos: unpackCoordAsPos(lair.c, roomName),
                })),
                importantStructures: this.getImportantStructureInfo(roomName),
            };
            return returnObject;
        }
    }
    /**
     * Records all info for permanent room objects, e.g. sources, controllers, etc.
     */
    static recordPermanentObjects(room) {
        room.memory["T" /* MEM.TICK */] = Game.time;
        if (room.sources.length > 0) {
            room.memory["s" /* RMEM.SOURCES */] = _.map(room.sources, (source) => {
                const coord = packCoord(source.pos);
                const container = source.pos.findClosestByLimitedRange(room.containers, 2);
                return container ?
                    { c: coord, cn: packCoord(container.pos) }
                    : { c: coord };
            });
        }
        else {
            delete room.memory["s" /* RMEM.SOURCES */];
        }
        if (room.controller) {
            room.memory["c" /* RMEM.CONTROLLER */] = {
                c: packCoord(room.controller.pos),
                ["l" /* RMEM_CTRL.LEVEL */]: room.controller.level,
                ["o" /* RMEM_CTRL.OWNER */]: room.controller.owner ?
                    room.controller.owner.username
                    : undefined,
                ["r" /* RMEM_CTRL.RESERVATION */]: room.controller.reservation ?
                    {
                        ["u" /* RMEM_CTRL.RES_USERNAME */]: room.controller.reservation.username,
                        ["t" /* RMEM_CTRL.RES_TICKSTOEND */]: room.controller.reservation.ticksToEnd,
                    }
                    : undefined,
                ["s" /* RMEM_CTRL.SAFEMODE */]: room.controller.safeMode,
                ["sa" /* RMEM_CTRL.SAFEMODE_AVAILABLE */]: room.controller.safeModeAvailable,
                ["sc" /* RMEM_CTRL.SAFEMODE_COOLDOWN */]: room.controller.safeModeCooldown,
                ["p" /* RMEM_CTRL.PROGRESS */]: room.controller.progress,
                ["pt" /* RMEM_CTRL.PROGRESS_TOTAL */]: room.controller.progressTotal,
            };
        }
        else {
            delete room.memory["c" /* RMEM.CONTROLLER */];
        }
        if (room.mineral) {
            room.memory["m" /* RMEM.MINERAL */] = {
                c: packCoord(room.mineral.pos),
                ["d" /* RMEM_MNRL.DENSITY */]: room.mineral.density,
                ["t" /* RMEM_MNRL.MINERALTYPE */]: room.mineral.mineralType,
            };
        }
        else {
            delete room.memory["m" /* RMEM.MINERAL */];
        }
        if (room.keeperLairs.length > 0) {
            room.memory["k" /* RMEM.SKLAIRS */] = _.map(room.keeperLairs, (lair) => {
                // Keeper logic is to just move to the first _.find([...sources, mineral], range <=5); see
                // https://github.com/screeps/engine/blob/master/src/processor/intents/creeps/keepers/pretick.js
                const keeperTarget = _.find(_.compact([...room.sources, room.mineral]), (thing) => thing.pos.getRangeTo(lair.pos) <= 5);
                let chillPos;
                if (keeperTarget) {
                    // should always be true
                    chillPos =
                        lair.pos.findClosestByPath(keeperTarget.pos.neighbors) || undefined;
                }
                return chillPos ?
                    { c: packCoord(lair.pos), cp: packCoord(chillPos) }
                    : { c: packCoord(lair.pos) };
            });
        }
        else {
            delete room.memory["k" /* RMEM.SKLAIRS */];
        }
        this.recordOwnedRoomStructures(room);
        this.recordPortalInfo(room);
    }
    static recordDepositsInfo(room) {
        var _a;
        room.memory["t" /* RMEM.DEPOSITS */] = (_a = room.memory["t" /* RMEM.DEPOSITS */]) !== null && _a !== void 0 ? _a : [];
        if ((!room.memory["t" /* RMEM.DEPOSITS */].length &&
            room.deposits.length !== 0) ||
            room.memory["t" /* RMEM.DEPOSITS */].length !== room.deposits.length) {
            room.memory["t" /* RMEM.DEPOSITS */] = room.deposits.map((deposit) => {
                const dpst = {
                    c: packCoord(deposit.pos),
                    ["t" /* RMEM_DPST.DEPOSITTYPE */]: deposit.depositType,
                    ["d" /* RMEM_DPST.COOLDOWN */]: deposit.lastCooldown,
                    ["l" /* RMEM_DPST.TTL */]: deposit.ticksToDecay,
                    ["i" /* RMEM_DPST.TIME */]: Game.time,
                };
                return dpst;
            });
        }
    }
    static recordOwnedRoomStructures(room) {
        if ((room.controller && room.controller.owner) || room.invaderCore) {
            room.memory["i" /* RMEM.IMPORTANT_STRUCTURES */] = {
                ["t" /* RMEM_STRUCTS.TOWERS */]: packCoordList(_.map(room.towers, (t) => t.pos)),
                ["sp" /* RMEM_STRUCTS.SPAWNS */]: packCoordList(_.map(room.spawns, (s) => s.pos)),
                ["w" /* RMEM_STRUCTS.WALLS */]: packCoordList(_.map(room.walls, (w) => w.pos)),
                ["r" /* RMEM_STRUCTS.RAMPARTS */]: packCoordList(_.map(room.ramparts, (r) => r.pos)),
                ["s" /* RMEM_STRUCTS.STORAGE */]: room.storage ? packCoord(room.storage.pos) : undefined,
                ["e" /* RMEM_STRUCTS.TERMINAL */]: room.terminal ? packCoord(room.terminal.pos) : undefined,
            };
        }
        else {
            delete room.memory["i" /* RMEM.IMPORTANT_STRUCTURES */];
        }
    }
    static recordPortalInfo(room) {
        if (room.portals.length > 0) {
            room.memory["pr" /* RMEM.PORTALS */] = _.map(room.portals, (portal) => {
                const dest = portal.destination instanceof RoomPosition ?
                    packPos(portal.destination)
                    : portal.destination;
                const expiration = portal.ticksToDecay != undefined ?
                    Game.time + portal.ticksToDecay
                    : Game.time + 1000000;
                return {
                    c: packCoord(portal.pos),
                    dest: dest,
                    ["X" /* MEM.EXPIRATION */]: expiration,
                };
            });
            if (!this.memory.portalRooms.includes(room.name)) {
                this.memory.portalRooms.push(room.name);
            }
        }
        else {
            delete room.memory["pr" /* RMEM.PORTALS */];
            _.pull(this.memory.portalRooms, room.name);
        }
    }
    /**
     * Update time-sensitive reservation and safemode info
     */
    static recordControllerInfo(controller) {
        const savedController = controller.room.memory["c" /* RMEM.CONTROLLER */];
        if (savedController) {
            savedController["r" /* RMEM_CTRL.RESERVATION */] =
                controller.reservation ?
                    {
                        ["u" /* RMEM_CTRL.RES_USERNAME */]: controller.reservation.username,
                        ["t" /* RMEM_CTRL.RES_TICKSTOEND */]: controller.reservation.ticksToEnd,
                    }
                    : undefined;
            savedController["s" /* RMEM_CTRL.SAFEMODE */] = controller.safeMode;
            savedController["sc" /* RMEM_CTRL.SAFEMODE_COOLDOWN */] =
                controller.safeModeCooldown;
        }
    }
    static inSafeMode(roomName) {
        if (!!Memory.rooms[roomName] &&
            !!Memory.rooms[roomName]["c" /* RMEM.CONTROLLER */]) {
            const safemode = Memory.rooms[roomName]["c" /* RMEM.CONTROLLER */]["s" /* RMEM_CTRL.SAFEMODE */];
            const tick = Memory.rooms[roomName]["X" /* MEM.EXPIRATION */];
            if (safemode && tick) {
                return Game.time < tick + safemode;
            }
        }
        return false;
    }
    static safeModeCooldown(roomName) {
        if (Memory.rooms[roomName] &&
            Memory.rooms[roomName]["c" /* RMEM.CONTROLLER */] &&
            Memory.rooms[roomName]["c" /* RMEM.CONTROLLER */]["sc" /* RMEM_CTRL.SAFEMODE_COOLDOWN */]) {
            const smcooldown = Memory.rooms[roomName]["c" /* RMEM.CONTROLLER */]["sc" /* RMEM_CTRL.SAFEMODE_COOLDOWN */];
            const tick = Memory.rooms[roomName]["X" /* MEM.EXPIRATION */];
            if (smcooldown && tick) {
                return smcooldown - (Game.time - tick);
            }
        }
    }
    static recomputeScoreIfNecessary(roomName, force = false) {
        if (force) {
            return ExpansionEvaluator.computeExpansionData(roomName, true);
        }
        const memory = Memory.rooms[roomName];
        if (memory["e" /* RMEM.EXPANSION_DATA */] === 0) {
            // room is uninhabitable or owned
            if (Math.random() < FALSE_SCORE_RECALC_PROB) {
                // false scores get evaluated very occasionally
                return ExpansionEvaluator.computeExpansionData(roomName);
            }
        }
        else {
            // if the room is not uninhabitable
            if (!memory["e" /* RMEM.EXPANSION_DATA */] ||
                Math.random() < SCORE_RECALC_PROB) {
                // recompute some of the time
                return ExpansionEvaluator.computeExpansionData(roomName);
            }
        }
        return false;
    }
    static updateInvasionData(room) {
        if (!room.memory["v" /* RMEM.INVASION_DATA */]) {
            room.memory["v" /* RMEM.INVASION_DATA */] = {
                ["h" /* RMEM_INVASION.HARVESTED */]: 0,
                ["l" /* RMEM_INVASION.LAST_SEEN */]: 0,
            };
        }
        const sources = room.sources;
        const invasionData = room.memory["v" /* RMEM.INVASION_DATA */];
        for (const source of sources) {
            if (source.ticksToRegeneration == 1) {
                invasionData["h" /* RMEM_INVASION.HARVESTED */] +=
                    source.energyCapacity - source.energy;
            }
        }
        if (room.invaders.length > 0) {
            invasionData["h" /* RMEM_INVASION.HARVESTED */] = 0;
            invasionData["l" /* RMEM_INVASION.LAST_SEEN */] = Game.time;
        }
    }
    // private static updateHarvestData(room: Room): void {
    // 	if (!room.memory[RMEM.HARVEST]) {
    // 		room.memory[RMEM.HARVEST] = {
    // 			[MEM_AVGS.AMOUNT] : 0,
    // 			[MEM_AVGS.AVG10K] : _.sum(room.sources, s => s.energyCapacity / ENERGY_REGEN_TIME),
    // 			[MEM_AVGS.AVG100K]: _.sum(room.sources, s => s.energyCapacity / ENERGY_REGEN_TIME),
    // 			[MEM_AVGS.AVG1M]  : _.sum(room.sources, s => s.energyCapacity / ENERGY_REGEN_TIME),
    // 			[MEM.TICK]             : Game.time,
    // 		};
    // 	}
    // 	const harvest = room.memory[RMEM.HARVEST] as RollingStats;
    // 	for (const source of room.sources) {
    // 		if (source.ticksToRegeneration == 1) {
    // 			const dEnergy = source.energyCapacity - source.energy;
    // 			const dTime = Game.time - harvest[MEM.TICK] + 1; // +1 to avoid division by zero errors
    // 			harvest[MEM_AVGS.AMOUNT] += dEnergy;
    // 			harvest[MEM_AVGS.AVG10K] = +(irregularExponentialMovingAverage(
    // 				dEnergy / dTime, harvest[MEM_AVGS.AVG10K], dTime, 10000)).toFixed(7);
    // 			harvest[MEM_AVGS.AVG100K] = +(irregularExponentialMovingAverage(
    // 				dEnergy / dTime, harvest[MEM_AVGS.AVG100K], dTime, 100000)).toFixed(7);
    // 			harvest[MEM_AVGS.AVG1M] = +(irregularExponentialMovingAverage(
    // 				dEnergy / dTime, harvest[MEM_AVGS.AVG1M], dTime, 1000000)).toFixed(7);
    // 			harvest[MEM.TICK] = Game.time;
    // 		}
    // 	}
    // }
    // private static updateCasualtyData(room: Room): void {
    // 	if (!room.memory[RMEM.CASUALTIES]) {
    // 		room.memory[RMEM.CASUALTIES] = {
    // 			cost: {
    // 				[MEM_AVGS.AMOUNT] : 0,
    // 				[MEM_AVGS.AVG10K] : 0,
    // 				[MEM_AVGS.AVG100K]: 0,
    // 				[MEM_AVGS.AVG1M]  : 0,
    // 				[MEM.TICK]             : Game.time,
    // 			}
    // 		};
    // 	}
    // 	const casualtiesCost = room.memory[RMEM.CASUALTIES]!.cost as RollingStats;
    // 	for (const tombstone of room.tombstones) {
    // 		if (tombstone.ticksToDecay == 1) {
    // 			// record any casualties, which are my creeps which died prematurely
    // 			if ((tombstone.creep.ticksToLive || 0) > 1 && tombstone.creep.owner.username == MY_USERNAME
    // 				&& isCreep(tombstone.creep)) {
    // 				const body = _.map(tombstone.creep.body, part => part.type);
    // 				const lifetime = body.includes(CLAIM) ? CREEP_CLAIM_LIFE_TIME : CREEP_LIFE_TIME;
    // 				const dCost = bodyCost(body) * (tombstone.creep.ticksToLive || 0) / lifetime;
    // 				const dTime = Game.time - casualtiesCost[MEM.TICK] + 1;
    // 				casualtiesCost[MEM_AVGS.AMOUNT] += dCost;
    // 				casualtiesCost[MEM_AVGS.AVG10K] = +(irregularExponentialMovingAverage(
    // 					dCost / dTime, casualtiesCost[MEM_AVGS.AVG10K], dTime, 10000)).toFixed(7);
    // 				casualtiesCost[MEM_AVGS.AVG100K] = +(irregularExponentialMovingAverage(
    // 					dCost / dTime, casualtiesCost[MEM_AVGS.AVG100K], dTime, 100000)).toFixed(7);
    // 				casualtiesCost[MEM_AVGS.AVG1M] = +(irregularExponentialMovingAverage(
    // 					dCost / dTime, casualtiesCost[MEM_AVGS.AVG1M], dTime, 1000000)).toFixed(7);
    // 				casualtiesCost[MEM.TICK] = Game.time;
    // 			}
    // 		}
    // 	}
    // }
    static getExitPositions(roomName) {
        const terrain = Game.map.getRoomTerrain(roomName);
        const exitPositions = [];
        for (let x = 0; x < 50; x += 49) {
            for (let y = 0; y < 50; y++) {
                if (terrain.get(x, y) != TERRAIN_MASK_WALL) {
                    exitPositions.push(new RoomPosition(x, y, roomName));
                }
            }
        }
        for (let x = 0; x < 50; x++) {
            for (let y = 0; y < 50; y += 49) {
                if (terrain.get(x, y) != TERRAIN_MASK_WALL) {
                    exitPositions.push(new RoomPosition(x, y, roomName));
                }
            }
        }
        return exitPositions;
    }
    /**
     * Get the pos a creep was in on the previous tick, returning the same position as the creep if no data was
     * gathered on the previous tick.
     */
    static getPreviousPos(creep) {
        const prevPositions = creep.room.memory["pp" /* RMEM.PREV_POSITIONS */];
        if (prevPositions) {
            const packedId = packId(creep.id);
            if (prevPositions[packedId]) {
                return unpackCoordAsPos(prevPositions[packedId], creep.room.name);
            }
        }
        return creep.pos; // no data
    }
    static recordCreepPositions(room) {
        const positions = {};
        for (const creep of room.find(FIND_CREEPS)) {
            positions[packId(creep.id)] = packCoord(creep.pos);
        }
        room.memory["pp" /* RMEM.PREV_POSITIONS */] = {};
    }
    // private static recordCreepOccupancies(room: Room): void {
    // 	if (!room.memory[RMEM.CREEPS_IN_ROOM]) {
    // 		room.memory[RMEM.CREEPS_IN_ROOM] = {};
    // 	}
    // 	const creepsInRoom = room.memory[RMEM.CREEPS_IN_ROOM]!;
    // 	for (const tick in creepsInRoom) {
    // 		if (parseInt(tick, 10) < Game.time - ROOM_CREEP_HISTORY_TICKS) {
    // 			delete creepsInRoom[tick];
    // 		}
    // 	}
    // 	creepsInRoom[Game.time] = _.map(room.hostiles, creep => creep.name);
    // }
    /**
     * Records threat levels, visibility, consecutive safe/unsafe ticks and other data on visible or invisible rooms.
     * Must be run in RoomIntel.init(), as it populates several room properties used elsewhere // TODO: expensive
     */
    static recordSafety(roomName) {
        var _a;
        // Make sure the memory objects are there
        Memory.rooms[roomName] = Memory.rooms[roomName] || {};
        Memory.rooms[roomName]["f" /* RMEM.SAFETY */] = Memory.rooms[roomName]["f" /* RMEM.SAFETY */] || {
            ["t" /* RMEM_SAFETY.THREAT_LEVEL */]: 0,
            ["s" /* RMEM_SAFETY.SAFE_FOR */]: 0,
            ["u" /* RMEM_SAFETY.UNSAFE_FOR */]: 0,
            ["v" /* RMEM_SAFETY.INVISIBLE_FOR */]: 0,
        };
        const safetyData = Memory.rooms[roomName]["f" /* RMEM.SAFETY */];
        const room = Game.rooms[roomName];
        if (room) {
            safetyData["v" /* RMEM_SAFETY.INVISIBLE_FOR */] = 0;
            if (room.dangerousHostiles.length > 0) {
                safetyData["s" /* RMEM_SAFETY.SAFE_FOR */] = 0;
                safetyData["u" /* RMEM_SAFETY.UNSAFE_FOR */] += 1;
            }
            else {
                safetyData["s" /* RMEM_SAFETY.SAFE_FOR */] += 1;
                safetyData["u" /* RMEM_SAFETY.UNSAFE_FOR */] = 0;
            }
            if (room.my || room.isOutpost) {
                // Record combat potentials of creeps in room
                const potentials = CombatIntel$1.getCombatPotentials(room.dangerousPlayerHostiles);
                safetyData["c" /* RMEM_SAFETY.COMBAT_POTENTIALS */] = {
                    ["a" /* COMBAT_POTENTIALS.ATTACK */]: potentials.attack,
                    ["r" /* COMBAT_POTENTIALS.RANGED */]: potentials.ranged,
                    ["h" /* COMBAT_POTENTIALS.HEAL */]: potentials.heal,
                };
                if (potentials.dismantle) {
                    safetyData["c" /* RMEM_SAFETY.COMBAT_POTENTIALS */]["d" /* COMBAT_POTENTIALS.DISMANTLE */] = potentials.dismantle;
                }
                // Record hostile counts
                safetyData["nh" /* RMEM_SAFETY.NUM_HOSTILES */] = room.hostiles.length; // this records ALL hostiles!
                safetyData["nb" /* RMEM_SAFETY.NUM_BOOSTED_HOSTILES */] = _.filter(room.hostiles, (hostile) => hostile.boosts.length > 0).length;
            }
            else {
                delete safetyData["c" /* RMEM_SAFETY.COMBAT_POTENTIALS */];
                delete safetyData["nh" /* RMEM_SAFETY.NUM_HOSTILES */];
                delete safetyData["nb" /* RMEM_SAFETY.NUM_BOOSTED_HOSTILES */];
            }
        }
        else {
            safetyData["v" /* RMEM_SAFETY.INVISIBLE_FOR */] += 1;
        }
        // Instantaneous threat level for a room scales from 0 to 1, with presence from non-player hostiles capped at
        // a threat levle of 0.5.
        let instantaneousThreatLevel;
        if (!room) {
            instantaneousThreatLevel = 0.5;
        }
        else {
            if (room.controller && room.controller.safeMode) {
                instantaneousThreatLevel = 0;
            }
            else {
                if (room.dangerousPlayerHostiles.length > 0) {
                    instantaneousThreatLevel = 1;
                }
                else if (room.dangerousHostiles.length > 0) {
                    instantaneousThreatLevel = 0.5;
                }
                else {
                    instantaneousThreatLevel = 0;
                }
            }
        }
        // Average it over time, using different averaging windows depending on the scenario
        const numBoostedHostiles = safetyData["nb" /* RMEM_SAFETY.NUM_BOOSTED_HOSTILES */] || 0;
        switch (instantaneousThreatLevel) {
            case 0:
                safetyData["t" /* RMEM_SAFETY.THREAT_LEVEL */] = ema(instantaneousThreatLevel, safetyData["t" /* RMEM_SAFETY.THREAT_LEVEL */], CREEP_LIFE_TIME / 2);
                break;
            case 0.5:
                safetyData["t" /* RMEM_SAFETY.THREAT_LEVEL */] = ema(instantaneousThreatLevel, safetyData["t" /* RMEM_SAFETY.THREAT_LEVEL */], CREEP_LIFE_TIME / (1 + numBoostedHostiles));
                break;
            case 1:
                safetyData["t" /* RMEM_SAFETY.THREAT_LEVEL */] = ema(instantaneousThreatLevel, safetyData["t" /* RMEM_SAFETY.THREAT_LEVEL */], CREEP_LIFE_TIME / (4 + numBoostedHostiles));
                break;
        }
        // // Compute rolling averages
        // const dTime = Game.time - safetyData[RMEM_SAFETY.TICK];
        // safetyData[RMEM_SAFETY.SAFETY_1K] = +(irregularEma(
        // 	safety, safetyData[RMEM_SAFETY.SAFETY_1K], dTime, 1000)).toFixed(5);
        // safetyData[RMEM_SAFETY.SAFETY_10K] = +(irregularEma(
        // 	safety, safetyData[RMEM_SAFETY.SAFETY_10K], dTime, 10000)).toFixed(5);
        // Populate the per-tick properties on the room object itself
        if (room) {
            room.instantaneousThreatLevel = instantaneousThreatLevel;
            room.threatLevel = safetyData["t" /* RMEM_SAFETY.THREAT_LEVEL */];
            room.isSafe =
                room.instantaneousThreatLevel <=
                    ((_a = Memory.settings.attitude.brazenness) !== null && _a !== void 0 ? _a : 0.5) &&
                    (room.threatLevel < 0.15 ||
                        safetyData["s" /* RMEM_SAFETY.SAFE_FOR */] > 50);
        }
    }
    static getSafetyData(roomName) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const data = (((_b = (_a = Memory.rooms[roomName]) === null || _a === void 0 ? void 0 : _a["f" /* RMEM.SAFETY */]) !== null && _b !== void 0 ? _b : {}));
        return {
            threatLevel: (_c = data["t" /* RMEM_SAFETY.THREAT_LEVEL */]) !== null && _c !== void 0 ? _c : 0.5,
            safeFor: (_d = data["s" /* RMEM_SAFETY.SAFE_FOR */]) !== null && _d !== void 0 ? _d : NaN,
            unsafeFor: (_e = data["u" /* RMEM_SAFETY.UNSAFE_FOR */]) !== null && _e !== void 0 ? _e : NaN,
            invisibleFor: (_f = data["v" /* RMEM_SAFETY.INVISIBLE_FOR */]) !== null && _f !== void 0 ? _f : NaN,
            combatPotentials: (_g = data["c" /* RMEM_SAFETY.COMBAT_POTENTIALS */]) !== null && _g !== void 0 ? _g : NaN,
            numHostiles: (_h = data["nh" /* RMEM_SAFETY.NUM_HOSTILES */]) !== null && _h !== void 0 ? _h : NaN,
            numBoostedHostiles: (_j = data["nb" /* RMEM_SAFETY.NUM_BOOSTED_HOSTILES */]) !== null && _j !== void 0 ? _j : NaN,
        };
    }
    static getInvasionData(roomName) {
        const memory = Memory.rooms[roomName];
        if (!memory) {
            return undefined;
        }
        const data = memory["v" /* RMEM.INVASION_DATA */];
        if (!data) {
            return undefined;
        }
        return {
            harvested: data["h" /* RMEM_INVASION.HARVESTED */],
            lastSeen: data["l" /* RMEM_INVASION.LAST_SEEN */],
        };
    }
    static isInvasionLikely(roomName) {
        const data = this.getInvasionData(roomName);
        if (!data || data.lastSeen > 20000) {
            // maybe room is surrounded by owned/reserved rooms and invasions aren't possible
            return false;
        }
        const sources = this.getSourceInfo(roomName);
        switch (sources.length) {
            case 1:
                return data.harvested > 90000;
            case 2:
                return data.harvested > 75000;
            case 3:
                return data.harvested > 65000;
            default: // shouldn't ever get here
                return false;
        }
    }
    static invasionVisualsForRoom(roomName) {
        const invIntel = this.getInvasionData(roomName);
        if (invIntel) {
            const { harvested, lastSeen } = invIntel;
            const invasionLikely = this.isInvasionLikely(roomName);
            const invData = [];
            invData.push(["Harvested:", `${harvested}`]);
            invData.push(["Last seen:", `${Game.time - lastSeen}t ago`]);
            invData.push([
                "Invasion likely:",
                `${invasionLikely ? "yes" : "no"}`,
            ]);
            const boxY = 11;
            Visualizer.infoBox(`Invasion Data`, invData, { x: 1, y: boxY, roomName }, 9);
        }
    }
    static roomOwnedBy(roomName) {
        if (Memory.rooms[roomName] &&
            Memory.rooms[roomName]["c" /* RMEM.CONTROLLER */] &&
            Memory.rooms[roomName]["c" /* RMEM.CONTROLLER */]["o" /* RMEM_CTRL.OWNER */]) {
            if (Game.time - (Memory.rooms[roomName]["T" /* MEM.TICK */] || 0) < 25000) {
                // ownership expires after 25k ticks
                return Memory.rooms[roomName]["c" /* RMEM.CONTROLLER */]["o" /* RMEM_CTRL.OWNER */];
            }
        }
    }
    static roomReservedBy(roomName) {
        if (Memory.rooms[roomName] &&
            Memory.rooms[roomName]["c" /* RMEM.CONTROLLER */] &&
            Memory.rooms[roomName]["c" /* RMEM.CONTROLLER */]["r" /* RMEM_CTRL.RESERVATION */]) {
            if (Game.time - (Memory.rooms[roomName]["T" /* MEM.TICK */] || 0) < 10000) {
                // reservation expires after 10k ticks
                return Memory.rooms[roomName]["c" /* RMEM.CONTROLLER */]["r" /* RMEM_CTRL.RESERVATION */]["u" /* RMEM_CTRL.RES_USERNAME */];
            }
        }
    }
    static roomReservationRemaining(roomName) {
        if (Memory.rooms[roomName] &&
            Memory.rooms[roomName]["c" /* RMEM.CONTROLLER */] &&
            Memory.rooms[roomName]["c" /* RMEM.CONTROLLER */]["r" /* RMEM_CTRL.RESERVATION */]) {
            const ticksToEnd = Memory.rooms[roomName]["c" /* RMEM.CONTROLLER */]["r" /* RMEM_CTRL.RESERVATION */]["t" /* RMEM_CTRL.RES_TICKSTOEND */];
            const timeSinceLastSeen = Game.time - (Memory.rooms[roomName]["T" /* MEM.TICK */] || 0);
            return ticksToEnd - timeSinceLastSeen;
        }
        return 0;
    }
    /**
     * Get the list of all known portals.
     *
     * @param includeIntershard Whether to include intershard portals
     */
    static findAllPortals(includeIntershard = false) {
        const roomNames = [];
        for (const [name, mem] of entries(Memory.rooms)) {
            if (!mem["pr" /* RMEM.PORTALS */] || mem["pr" /* RMEM.PORTALS */].length === 0) {
                continue;
            }
            roomNames.push(name);
        }
        const portals = [];
        for (const roomName of roomNames) {
            let portalInfos = this.getPortalInfo(roomName);
            if (!includeIntershard) {
                portalInfos = portalInfos.filter((p) => p.roomDestination);
            }
            portals.push(...portalInfos);
        }
        return portals;
    }
    /**
     * Returns the portals that are within a specified range of a colony indexed by their room
     */
    static findPortalsInRange(roomName, range, includeIntershard = false) {
        var _a;
        const portals = this.findAllPortals(includeIntershard);
        const rooms = {};
        for (const portal of portals) {
            if (Game.map.getRoomLinearDistance(roomName, portal.pos.roomName) >
                range) {
                continue;
            }
            (_a = rooms[roomName]) !== null && _a !== void 0 ? _a : (rooms[roomName] = []);
            rooms[roomName].push(portal);
        }
        return rooms;
    }
    // static requestZoneData() {
    // 	const checkOnTick = 123;
    // 	if (Game.time % 1000 == checkOnTick - 2) {
    // 		Segmenter.requestForeignSegment('LeagueOfAutomatedNations', 96);
    // 	} else if (Game.time % 1000 == checkOnTick - 1) {
    // 		const loanData = Segmenter.getForeignSegment();
    // 		if (loanData) {
    // 			Memory.zoneRooms = loanData;
    // 		} else {
    // 			log.error('Empty LOAN data');
    // 		}
    // 	}
    // }
    /**
     * Cached version of Game.map.getRoomStatus() which retrieves compressed status data and converts to RoomStatus
     */
    static getRoomStatus(roomName) {
        Memory.rooms[roomName] = Memory.rooms[roomName] || {};
        // Recalculate if you haven't seen this room before or if the timestamp is expired
        if (!Memory.rooms[roomName]["rs" /* RMEM.ROOM_STATUS */] ||
            new Date().getTime() >
                new Date(Memory.rooms[roomName]["rs" /* RMEM.ROOM_STATUS */][1] * 1000).getTime()) {
            let { status, timestamp } = Game.map.getRoomStatus(roomName);
            if (timestamp == null) {
                // null timestamp means indefinite, but not really; let's recheck in a few days
                const extraMilliseconds = 3 * 24 * 60 * 60 * 1000; // check again in 3 days
                timestamp = new Date().getTime() + extraMilliseconds;
            }
            timestamp = Math.floor(timestamp / 1000); // don't need milliseconds; seconds will do
            switch (status) {
                case "normal":
                    Memory.rooms[roomName]["rs" /* RMEM.ROOM_STATUS */] = [
                        "nm" /* RMEM_ROOM_STATUS.normal */,
                        timestamp,
                    ];
                    break;
                case "closed":
                    Memory.rooms[roomName]["rs" /* RMEM.ROOM_STATUS */] = [
                        "cl" /* RMEM_ROOM_STATUS.closed */,
                        timestamp,
                    ];
                    break;
                case "novice":
                    Memory.rooms[roomName]["rs" /* RMEM.ROOM_STATUS */] = [
                        "nv" /* RMEM_ROOM_STATUS.novice */,
                        timestamp,
                    ];
                    break;
                case "respawn":
                    Memory.rooms[roomName]["rs" /* RMEM.ROOM_STATUS */] = [
                        "re" /* RMEM_ROOM_STATUS.respawn */,
                        timestamp,
                    ];
                    break;
            }
        }
        const [statusCompressed, timestampCompressed] = Memory.rooms[roomName]["rs" /* RMEM.ROOM_STATUS */];
        const timestamp = timestampCompressed * 1000;
        switch (statusCompressed) {
            case "nm" /* RMEM_ROOM_STATUS.normal */:
                return { status: "normal", timestamp: null };
            case "cl" /* RMEM_ROOM_STATUS.closed */:
                return { status: "closed", timestamp: null };
            case "nv" /* RMEM_ROOM_STATUS.novice */:
                return { status: "novice", timestamp: timestamp };
            case "re" /* RMEM_ROOM_STATUS.respawn */:
                return { status: "respawn", timestamp: timestamp };
        }
    }
    /**
     * Returns whether the room should be considered hostile
     */
    static isConsideredHostile(roomName, cutoffOrBrazen) {
        var _a, _b, _c, _d;
        const roomD = this.getAllRoomObjectInfo(roomName);
        const safety = this.getSafetyData(roomName);
        if (cutoffOrBrazen === true) {
            cutoffOrBrazen = 1.0;
        }
        else if (cutoffOrBrazen === false) {
            cutoffOrBrazen = (_a = Memory.settings.attitude.brazenness) !== null && _a !== void 0 ? _a : 0.5;
        }
        else if (typeof cutoffOrBrazen === "number") {
            cutoffOrBrazen = minMax(cutoffOrBrazen, 0, 1);
        }
        else {
            cutoffOrBrazen = (_b = Memory.settings.attitude.brazenness) !== null && _b !== void 0 ? _b : 0.5;
        }
        return (!isAlly((_d = (_c = roomD === null || roomD === void 0 ? void 0 : roomD.controller) === null || _c === void 0 ? void 0 : _c.owner) !== null && _d !== void 0 ? _d : "") &&
            safety.threatLevel > cutoffOrBrazen);
    }
    /**
     * Returns a room's available exits
     *
     * This wraps {@link Cartographer.describeExits} method and adds exit info for
     * known portals in the room.
     *
     * @param roomName The room name to check
     * @returns
     */
    static describeExits(roomName, allowPortals) {
        const exits = Cartographer.describeExits(roomName);
        if (!exits) {
            return exits;
        }
        const radius = Math.ceil(Game.map.getWorldSize() / 2) - 1;
        const coord = Cartographer.getRoomCoordinates(roomName);
        if (coord.x >= radius) {
            const xDirToMoveDir = coord.xDir === "W" ? 7 : 3;
            delete exits[xDirToMoveDir];
        }
        if (coord.y >= radius) {
            const yDirToMoveDir = coord.xDir === "N" ? 1 : 5;
            delete exits[yDirToMoveDir];
        }
        if (allowPortals) {
            let portals = this.getPortalInfo(roomName);
            if (portals) {
                if (allowPortals === "interOnly") {
                    portals = portals.filter((portal) => portal.roomDestination);
                }
                exits[FIND_EXIT_PORTAL] = portals;
            }
        }
        return exits;
    }
    /**
     * RoomIntel.init() is the very first thing that is run in the init phase of each tick. The only stuff that should
     * go in here is critical and inexpensive stuff that is necessary information for this tick.
     */
    static init() {
        for (const roomName in Game.rooms) {
            Memory.rooms[roomName] = Memory.rooms[roomName] || {};
        }
        for (const roomName in Memory.rooms) {
            const room = Game.rooms[roomName];
            this.recordSafety(roomName);
            if (room) {
                this.markVisible(room);
            }
        }
    }
    /**
     * RoomIntel.run() is the very last thing that is run in the run phase of each tick. If something times out earlier
     * in the script, then this will not be fully executed, so do not put critical stuff here.
     */
    static run() {
        let alreadyComputedScore = false;
        for (const roomName in Game.rooms) {
            // log.debug(`${roomName}: collecting intel`);
            const room = Game.rooms[roomName];
            // Track invasion data, harvesting, and casualties for all colony rooms and outposts
            if (Overmind.colonyMap[room.name]) {
                // if it is an owned or outpost room
                this.updateInvasionData(room);
                // this.updateHarvestData(room);
                // this.updateCasualtyData(room);
            }
            // Record previous creep positions (RoomIntel.run() is executed at end of each tick)
            this.recordCreepPositions(room);
            // if (room.my) {
            // 	this.recordCreepOccupancies(room);
            // }
            if (Game.time % 50 === 0 ||
                room.memory["t" /* RMEM.DEPOSITS */] === undefined) {
                this.recordDepositsInfo(room);
            }
            // Record location of permanent objects in room and recompute score as needed
            if (Game.time >= (room.memory["X" /* MEM.EXPIRATION */] || 0)) {
                this.recordPermanentObjects(room);
                if (!alreadyComputedScore) {
                    alreadyComputedScore = this.recomputeScoreIfNecessary(room.name);
                }
                // Refresh cache
                const recacheTime = room.owner ? OWNED_RECACHE_TIME : RECACHE_TIME;
                room.memory["X" /* MEM.EXPIRATION */] = getCacheExpiration(recacheTime, 250);
            }
            if (room.controller && Game.time % 5 == 0) {
                this.recordControllerInfo(room.controller);
            }
        }
        if (Game.time % 20 == 0) {
            this.cleanMemory();
        }
    }
    static drawMapVisuals(roomName) {
        const exp = RoomIntel_1.getExpansionData(roomName);
        const sec = RoomIntel_1.getSafetyData(roomName);
        const objs = RoomIntel_1.getAllRoomObjectInfo(roomName);
        const threatColor = interpolateColor("#00FF00", "#FF0000", sec.threatLevel);
        Game.map.visual.rect(new RoomPosition(2, 2, roomName), 4, 4, {
            fill: threatColor,
            stroke: "#FFFFFF",
            opacity: 1,
        });
        if (roomName in Game.rooms) {
            Game.map.visual.circle(new RoomPosition(4 + 4 + 2, 4, roomName), {
                radius: 2,
                fill: "#00CCCC",
                stroke: "#000000",
            });
        }
        const expPos = new RoomPosition(45, 5, roomName);
        const expSize = 10;
        if ((objs === null || objs === void 0 ? void 0 : objs.controller) === undefined && exp === undefined) {
            Game.map.visual.text("?", expPos, {
                fontSize: expSize,
                color: "#AAAAAA",
            });
        }
        else if (exp === undefined) {
            Game.map.visual.text("!", expPos, {
                fontSize: expSize,
                color: "#FFFF00",
            });
        }
        else if (exp === false) {
            Game.map.visual.text("X", expPos, {
                fontSize: expSize,
                color: "#FF0000",
            });
        }
        else {
            Game.map.visual.text("🏠", expPos, { fontSize: expSize });
            Game.map.visual.text(exp.score.toFixed(0), new RoomPosition(48, 14, roomName), { fontSize: 4, color: "#00FF00", align: "right" });
        }
    }
    static drawRoomVisuals(roomName) {
        const expData = [];
        const exp = RoomIntel_1.getExpansionData(roomName);
        const objs = RoomIntel_1.getAllRoomObjectInfo(roomName);
        if ((objs === null || objs === void 0 ? void 0 : objs.controller) === undefined && exp === undefined) {
            expData.push(["Incomplete"]);
        }
        else if (exp === undefined) {
            expData.push(["Incomplete"]);
        }
        else if (exp === false) {
            expData.push(["Uninhabitable"]);
        }
        else {
            expData.push(["Score", exp.score.toFixed(0)]);
            expData.push([
                "Anchor",
                `${exp.bunkerAnchor.x}, ${exp.bunkerAnchor.y}`,
            ]);
            expData.push(["Outposts:"]);
            if (_.keys(exp.outposts).length !== 0) {
                for (const outpost in exp.outposts) {
                    expData.push([outpost, exp.outposts[outpost].toString()]);
                }
            }
        }
        let boxY = 7;
        boxY = Visualizer.infoBox(`Expansion`, expData, { x: 40, y: boxY, roomName: roomName }, 6);
        const objData = [];
        // Room objects
        if (objs === null || objs === void 0 ? void 0 : objs.controller) {
            const c = objs.controller;
            if (c.owner) {
                objData.push(["Controller"]);
                objData.push([` ${c.owner}@${c.level}`]);
                if (c.level !== 8 && c.progressTotal) {
                    objData.push([
                        "Progress",
                        `${((c.progress / c.progressTotal) * 100).toFixed(1)}%`,
                    ]);
                }
            }
            if (c.reservation) {
                objData.push([
                    "Reserved",
                    `${c.reservation.username} until ${c.reservation.ticksToEnd}`,
                ]);
            }
        }
        if (objs === null || objs === void 0 ? void 0 : objs.sources.length) {
            objData.push(["Sources", `${objs.sources.length}`]);
        }
        if (objs === null || objs === void 0 ? void 0 : objs.mineral) {
            objData.push([
                "Mineral",
                `${objs.mineral.mineralType}@${objs.mineral.density}`,
            ]);
        }
        if (objs === null || objs === void 0 ? void 0 : objs.importantStructures) {
            const s = objs.importantStructures;
            objData.push(["Structures:"]);
            if (s.spawnPositions.length) {
                objData.push(["Spawns", `${s.spawnPositions.length}`]);
            }
            if (s.storagePos) {
                objData.push(["Storage", `Yes`]);
            }
            if (s.terminalPos) {
                objData.push(["Terminal", `Yes`]);
            }
            if (s.towerPositions.length) {
                objData.push(["Towers", `${s.towerPositions.length}`]);
            }
            if (s.rampartPositions.length + s.rampartPositions.length) {
                objData.push([
                    "Walls/Ramp.",
                    `${s.wallPositions.length}/${s.rampartPositions.length}`,
                ]);
            }
        }
        if (!objData.length) {
            objData.push(["Unexplored"]);
        }
        boxY = Visualizer.infoBox(`Structures`, objData, { x: 40, y: boxY, roomName: roomName }, 8);
    }
    static visuals() {
        var _a, _b, _c, _d;
        const until = Memory.settings.intelVisuals.until;
        if (!Visualizer.enabled || until === undefined || Game.time > until) {
            this.limitedRoomVisual = undefined;
            return;
        }
        if (!this.limitedRoomVisual) {
            this.limitedRoomVisual = new Set();
            const range = (_a = Memory.settings.intelVisuals.range) !== null && _a !== void 0 ? _a : ROOMINTEL_DEFAULT_VISUALS_RANGE;
            for (const colony of Object.values(Overmind.colonies)) {
                let rooms = Cartographer.findRoomsInRange(colony.room.name, range);
                const scouts = (_c = (_b = colony.overlords.scout) === null || _b === void 0 ? void 0 : _b.scouts) !== null && _c !== void 0 ? _c : [];
                rooms = rooms.concat(_.flatten(scouts.map((s) => Cartographer.findRoomsInRange(s.room.name, range))));
                for (const name of rooms) {
                    (_d = this.limitedRoomVisual) === null || _d === void 0 ? void 0 : _d.add(name);
                }
            }
        }
        for (const [name, _name] of this.limitedRoomVisual.entries()) {
            if (!Memory.rooms[name]) {
                continue;
            }
            this.drawMapVisuals(name);
            this.drawRoomVisuals(name);
        }
    }
};
RoomIntel$1 = RoomIntel_1 = __decorate$1([
    profile
], RoomIntel$1);
// For debugging purposes
global.RoomIntel = RoomIntel$1;

var Pathing_1;
const DEFAULT_MAXOPS = 20000; // default timeout for pathfinding
const DEFAULT_FLEE_RANGE = 5;
const getDefaultPathOptions = () => ({
    range: 1,
    terrainCosts: getDefaultTerrainCosts(),
    ignoreCreeps: true,
    maxOps: DEFAULT_MAXOPS,
    maxRooms: 20,
    avoidSK: true,
    allowPortals: true,
    usePortalThreshold: 10,
    portalsMustBeInRange: 6,
    ensurePath: false,
});
const pathOptionsToPathFinderOptions = (o) => {
    var _a, _b;
    return ({
        plainCost: (_a = o.terrainCosts) === null || _a === void 0 ? void 0 : _a.plainCost,
        swampCost: (_b = o.terrainCosts) === null || _b === void 0 ? void 0 : _b.swampCost,
        flee: !!o.fleeRange,
        maxOps: o.maxOps,
        maxRooms: o.maxRooms,
    });
};
/**
 * Selects the properties of PathOptions that are also on MatrixOptions.
 */
const _defaultMatrixOptionsKeys = _.keys(getDefaultMatrixOptions());
function getMatrixOptsFromPathOpts(opts) {
    const matrixOpts = _.pick(opts, _defaultMatrixOptionsKeys);
    return matrixOpts;
}
function pathOptsToMatrixAndVolatileOpts(opts) {
    const matrixOpts = getMatrixOptsFromPathOpts(opts);
    const volatileMatrixOpts = {};
    if (opts.blockCreeps) {
        volatileMatrixOpts.blockCreeps = opts.blockCreeps;
    }
    if (opts.obstacles) {
        volatileMatrixOpts.obstacles = opts.obstacles;
    }
    return [matrixOpts, volatileMatrixOpts];
}
/**
 * Module for pathing-related operations.
 */
let Pathing = Pathing_1 = class Pathing {
    // Pathfinding and room callback methods ===========================================================================
    /**
     * Find a path from origin to destination
     */
    static findPath(origin, destination, opts = {}) {
        var _a;
        _.defaultsDeep(opts, getDefaultPathOptions());
        if (opts.debug) {
            log.info(`origin: ${origin}, dest: ${destination}, opts: ${dump(opts)}`);
        }
        // check to see whether findRoute should be used
        const linearDistance = Game.map.getRoomLinearDistance(origin.roomName, destination.roomName);
        if (opts.maxRooms &&
            linearDistance > opts.maxRooms &&
            !opts.allowPortals) {
            log.warning(`Pathing from ${origin.print} to ${destination.print} exceeds max room specification ` +
                `of ${opts.maxRooms}!`);
        }
        let route = opts.route;
        if (!route &&
            (opts.useFindRoute == true ||
                (opts.useFindRoute === undefined && linearDistance >= 3))) {
            const foundRoute = this.findRoute(origin.roomName, destination.roomName, opts);
            if (foundRoute != ERR_NO_PATH) {
                route = foundRoute;
            }
        }
        const destinationGoal = {
            pos: destination,
            range: opts.range,
        };
        const callback = (roomName) => Pathing_1.roomCallback(roomName, origin, destination, route, opts);
        const pfOptions = pathOptionsToPathFinderOptions(opts);
        pfOptions.roomCallback = callback;
        let ret;
        // Did the route use portals?
        const portalExitStepIndex = _.findIndex(route || [], (step) => step.exit == FIND_EXIT_PORTAL);
        const usesPortals = portalExitStepIndex != -1; // index is -1 if not found
        let portalUsed;
        if (usesPortals) {
            // If we traversed a portal we need to call pathfinder twice and merge the two paths
            const portalEntranceStepIndex = portalExitStepIndex - 1;
            const portalEntraceRoom = portalEntranceStepIndex < 0 ?
                origin.roomName
                : route[portalExitStepIndex - 1].room;
            const portals = RoomIntel$1.getPortalInfo(portalEntraceRoom);
            const portalGoals = _.map(portals, (portal) => ({
                pos: portal.pos,
                range: 0,
            }));
            const path1ret = PathFinder.search(origin, portalGoals, pfOptions);
            // if the path is incomplete then we'll let it get handled at the end of this method
            if (!path1ret.incomplete) {
                const lastPosInPath = (_a = _.last(path1ret.path)) !== null && _a !== void 0 ? _a : origin;
                const usedPortal = _.find(portals, (portal) => portal.pos.isEqualTo(lastPosInPath));
                if (usedPortal && usedPortal.roomDestination) {
                    portalUsed = usedPortal;
                    const portalDest = usedPortal.roomDestination;
                    const path2ret = PathFinder.search(portalDest, destinationGoal, pfOptions);
                    ret = {
                        path: path1ret.path
                            .concat([usedPortal.roomDestination])
                            .concat(path2ret.path),
                        ops: path1ret.ops + path2ret.ops,
                        cost: path1ret.ops + path2ret.ops,
                        incomplete: path1ret.incomplete || path2ret.incomplete,
                    };
                }
                else {
                    log.error(`Pathing: No Portal pos in ${JSON.stringify(path1ret.path)}! (Why?)`);
                    ret = path1ret;
                }
            }
            else {
                log.error(`Pathing: Incomplete first half of pathing from ${origin.print} to nearest portal!`);
                ret = path1ret;
            }
        }
        else {
            ret = PathFinder.search(origin, destinationGoal, pfOptions);
        }
        if (ret.incomplete &&
            opts.ensurePath &&
            linearDistance <= 3 &&
            !opts.route) {
            // handle case where pathfinder failed at a short distance due to not using findRoute
            // can happen for situations where the creep would have to take an uncommonly indirect path
            // options.allowedRooms and options.routeCallback can also be used to handle this situation
            const useRoute = this.findRoute(origin.roomName, destination.roomName, opts);
            if (useRoute != ERR_NO_PATH) {
                log.warning(`Pathing: findPath from ${origin.print} to ${destination.print} failed without ` +
                    `specified route. Trying again with route: ${JSON.stringify(useRoute)}.`);
                opts.route = useRoute;
                ret = this.findPath(origin, destination, opts);
                if (ret.incomplete) {
                    log.error(`Pathing: second attempt from ${origin.print} to ${destination.print} ` +
                        `was unsuccessful!`);
                }
            }
            else {
                log.error(`Pathing: findPath from ${origin.print} to ${destination.print} failed and route could ` +
                    `not be explicitly computed!`);
            }
        }
        if (ret.incomplete) {
            const seenRooms = new Set();
            ret.path.forEach((p) => seenRooms.add(p.roomName));
            const e = new Error(`Pathing: incomplete path from ${origin.print} → ${destination.print}! ops: ${ret.ops}/${opts.maxOps}, rooms: ${seenRooms.size}/${opts.maxRooms}`);
            log.trace(e);
        }
        return {
            path: ret.path,
            incomplete: ret.incomplete,
            ops: ret.ops,
            cost: ret.cost,
            route: route,
            usesPortals: usesPortals,
            portalUsed: portalUsed,
        };
    }
    /**
     * This takes a room name and spits out the portal exit closest to the destination
     */
    static getBestPortalDestination(portalRoom, destination) {
        const portalInfo = RoomIntel$1.getPortalInfo(portalRoom);
        if (portalInfo.length == 0) {
            return;
        }
        const portals = _.unique(portalInfo
            .filter((portal) => portal.roomDestination)
            .map((portal) => portal.roomDestination.roomName));
        const bestPortalDest = minBy(portals, (portalDest) => {
            const dist = Game.map.getRoomLinearDistance(portalDest, destination);
            return dist;
        });
        return bestPortalDest;
    }
    /**
     * Find a viable sequence of rooms to narrow down Pathfinder algorithm
     */
    static findRoute(origin, destination, opts = {}) {
        _.defaultsDeep(opts, getDefaultPathOptions());
        const linearDistance = Game.map.getRoomLinearDistance(origin, destination);
        const maxRooms = opts.maxRooms || linearDistance + 10;
        if (RoomIntel$1.getRoomStatus(origin).status !=
            RoomIntel$1.getRoomStatus(destination).status) {
            return ERR_NO_PATH;
        }
        // Route finder callback for portal searching
        const callback = (roomName) => {
            const rangeToRoom = Game.map.getRoomLinearDistance(origin, roomName);
            if (rangeToRoom > maxRooms) {
                // room is too far out of the way
                return Infinity;
            }
            if (!opts.allowHostile &&
                RoomIntel$1.isConsideredHostile(roomName) &&
                roomName !== destination &&
                roomName !== origin) {
                // room is marked as "avoid" in room memory
                return Infinity;
            }
            if (RoomIntel$1.getRoomStatus(origin).status !=
                RoomIntel$1.getRoomStatus(roomName).status) {
                return Infinity; // can't path outside of your local newbie/respawn zone
            }
            return 1;
            // TODO: include better pathing heuristics here such as average terrain value or avg pathing btw 2 points
        };
        let route = Game.map.findRoute(origin, destination, { routeCallback: callback });
        if (opts.allowPortals &&
            (route == ERR_NO_PATH ||
                route.length >= (opts.usePortalThreshold || 1))) {
            // Narrow down a list of portal rooms that could possibly lead to the destination
            const validPortalRooms = _.filter(RoomIntel$1.memory.portalRooms, (roomName) => {
                // Is the first leg of the trip too far?
                const originToPortal = Game.map.getRoomLinearDistance(origin, roomName);
                if (originToPortal > opts.maxRooms) {
                    return false;
                }
                if (opts.portalsMustBeInRange &&
                    originToPortal > opts.portalsMustBeInRange) {
                    return false;
                }
                // Are there intra-shard portals here?
                const bestPortalDestination = this.getBestPortalDestination(roomName, destination);
                if (opts.debug) {
                    log.info(`getBestPortalDestination: o: ${origin}, d: ${destination}, r: ${roomName} => ${bestPortalDestination}`);
                }
                if (!bestPortalDestination) {
                    return false;
                }
                // Is the first + second leg of the trip too far?
                const portalToDestination = Game.map.getRoomLinearDistance(destination, bestPortalDestination);
                return (originToPortal + portalToDestination <= opts.maxRooms);
            });
            // Figure out which portal room is the best one to use
            const portalCallback = (roomName) => {
                if (!opts.allowHostile &&
                    RoomIntel$1.isConsideredHostile(roomName) &&
                    roomName !== destination &&
                    roomName !== origin) {
                    // room is marked as "avoid" in room memory
                    return Infinity;
                }
                if (RoomIntel$1.getRoomStatus(origin).status !=
                    RoomIntel$1.getRoomStatus(roomName).status) {
                    return Infinity; // can't path outside of your local newbie/respawn zone
                }
                return 1;
            };
            const bestPortalRoom = minBy(validPortalRooms, (portalRoom) => {
                const bestPortalDestination = this.getBestPortalDestination(portalRoom, destination);
                const originToPortalRoute = Game.map.findRoute(origin, portalRoom, { routeCallback: portalCallback });
                const portalToDestinationRoute = Game.map.findRoute(bestPortalDestination, destination, {
                    routeCallback: portalCallback,
                });
                if (originToPortalRoute != ERR_NO_PATH &&
                    portalToDestinationRoute != ERR_NO_PATH) {
                    const portalRouteLength = originToPortalRoute.length +
                        portalToDestinationRoute.length;
                    const directRouteLength = route != ERR_NO_PATH ? route.length : Infinity;
                    if (portalRouteLength < directRouteLength) {
                        return portalRouteLength;
                    }
                    else {
                        return false; // no sense using portals if it make the route even longer
                    }
                }
                else {
                    return false;
                }
            });
            if (bestPortalRoom) {
                const portalDest = this.getBestPortalDestination(bestPortalRoom, destination);
                const originToPortalRoute = Game.map.findRoute(origin, bestPortalRoom, {
                    routeCallback: portalCallback,
                });
                const portalToDestinationRoute = Game.map.findRoute(portalDest, destination, {
                    routeCallback: portalCallback,
                });
                // This will always be true but gotta check so TS doesn't complain...
                if (originToPortalRoute != ERR_NO_PATH &&
                    portalToDestinationRoute != ERR_NO_PATH) {
                    route = [
                        ...originToPortalRoute,
                        { exit: FIND_EXIT_PORTAL, room: portalDest },
                        ...portalToDestinationRoute,
                    ];
                }
            }
        }
        if (route == ERR_NO_PATH) {
            log.trace(new Error(`Pathing: couldn't findRoute from ${origin} to ${destination} ` +
                `with opts ${JSON.stringify(opts)}!`));
            return ERR_NO_PATH;
        }
        else {
            return route;
        }
    }
    /**
     * Find a path from origin to destination
     */
    static findSwarmPath(origin, destination, width, height, options = {}) {
        _.defaultsDeep(options, {
            blockCreeps: false,
            maxOps: 2 * DEFAULT_MAXOPS,
            range: 1,
        });
        // Make copies of the destination offset for where anchor could be
        const destinations = this.getPosWindow(destination, -width, -height);
        const callback = (roomName) => this.swarmRoomCallback(roomName, width, height, options);
        const pfOptions = pathOptionsToPathFinderOptions(options);
        pfOptions.roomCallback = callback;
        return PathFinder.search(origin, _.map(destinations, (pos) => ({ pos: pos, range: options.range })), pfOptions);
    }
    /**
     * Get a window of offset RoomPositions from an anchor position and a window width and height
     */
    static getPosWindow(anchor, width, height) {
        const positions = [];
        for (const dx of _.range(0, width, width < 0 ? -1 : 1)) {
            for (const dy of _.range(0, height, height < 0 ? -1 : 1)) {
                positions.push(anchor.getOffsetPos(dx, dy));
            }
        }
        return positions;
    }
    /**
     * Returns the shortest path from start to end position, regardless of (passable) terrain
     */
    static findShortestPath(startPos, endPos, opts = {}) {
        const optDefaults = {
            blockCreeps: false,
            range: 1,
            terrainCosts: { plainCost: 1, swampCost: 1, roadCost: 1 },
        };
        _.defaultsDeep(opts, optDefaults);
        const ret = this.findPath(startPos, endPos, opts);
        if (ret.incomplete) {
            log.alert(`Pathing: incomplete path from ${startPos.print} to ${endPos.print}!`);
        }
        return ret;
    }
    /**
     * Returns the shortest path from start to end position, regardless of (passable) terrain
     */
    static findPathToRoom(startPos, roomName, options = {}) {
        options.range = 23;
        const ret = this.findPath(startPos, new RoomPosition(25, 25, roomName), options);
        if (ret.incomplete) {
            log.alert(`Pathing: incomplete path from ${startPos.print} to ${roomName}!`);
        }
        return ret;
    }
    /**
     * Default room callback, which automatically determines the most appropriate callback method to use
     */
    static roomCallback(roomName, origin, destination, route, opts) {
        if (roomName != origin.roomName && roomName != destination.roomName) {
            if (route &&
                !_.any(route, (routePart) => routePart.room == roomName)) {
                return false; // only allowed to visit these rooms if route is specified
            }
            if (!opts.allowHostile && RoomIntel$1.isConsideredHostile(roomName)) {
                return false; // don't go through hostile rooms
            }
            // Skip blocked rooms entirely
            if (Overmind.overseer.roomIsBlocked(roomName)) {
                return false;
            }
        }
        const [matrixOpts, volatileMatrixOpts] = pathOptsToMatrixAndVolatileOpts(opts);
        const matrix = MatrixLib.getMatrix(roomName, matrixOpts, volatileMatrixOpts);
        if (opts.modifyRoomCallback) {
            // Return a modified copy the matrix
            return opts.modifyRoomCallback(roomName, matrix.clone());
        }
        else {
            // No modifications necessary; return the matrix
            return matrix;
        }
    }
    static swarmRoomCallback(roomName, width, height, opts) {
        var _a;
        const [mOpts, vOpts] = pathOptsToMatrixAndVolatileOpts(opts);
        const matrixOpts = _.defaultsDeep({
            explicitTerrainCosts: true,
            swarmWidth: width,
            swarmHeight: height,
        }, mOpts);
        const volatileMatrixOpts = _.defaultsDeep({}, vOpts);
        const matrix = MatrixLib.getMatrix(roomName, matrixOpts, volatileMatrixOpts);
        if ((_a = opts.pathOpts) === null || _a === void 0 ? void 0 : _a.modifyRoomCallback) {
            // Return a modified copy the matrix
            const modMatrix = opts.pathOpts.modifyRoomCallback(roomName, matrix.clone());
            if (modMatrix === false) {
                return false;
            }
        }
        if (opts.displayCostMatrix) {
            Visualizer.displayCostMatrix(matrix, roomName);
        }
        return matrix;
    }
    static kitingRoomCallback(roomName) {
        const room = Game.rooms[roomName];
        if (room) {
            return Pathing_1.getKitingMatrix(room);
        }
        else {
            // have no vision
            return true;
        }
    }
    /**
     * Get a kiting path within a room
     */
    static findKitingPath(creepPos, fleeFrom, opts = {}) {
        _.defaultsDeep(opts, {
            fleeRange: DEFAULT_FLEE_RANGE,
        });
        const fleeFromPos = _.map(fleeFrom, (flee) => normalizePos(flee));
        const avoidGoals = _.map(fleeFromPos, (pos) => {
            return { pos: pos, range: opts.fleeRange };
        });
        const pfOptions = pathOptionsToPathFinderOptions(opts);
        pfOptions.roomCallback = (room) => Pathing_1.kitingRoomCallback(room);
        pfOptions.maxRooms = 1;
        return PathFinder.search(creepPos, avoidGoals, pfOptions);
    }
    /**
     * Get a flee path possibly leaving the room; generally called further in advance of kitingPath
     */
    static findFleePath(creepPos, fleeFrom, opts = {}) {
        _.defaultsDeep(opts, {
            terrainCosts: getDefaultTerrainCosts(),
        });
        if (opts.fleeRange == undefined) {
            opts.fleeRange = opts.terrainCosts.plainCost > 1 ? 20 : 10;
        }
        const fleeFromPos = _.map(fleeFrom, (flee) => normalizePos(flee));
        const avoidGoals = _.map(fleeFromPos, (pos) => {
            return { pos: pos, range: opts.fleeRange };
        });
        const callback = (roomName) => {
            if (!opts.allowHostile &&
                RoomIntel$1.isConsideredHostile(roomName) &&
                roomName != creepPos.roomName) {
                return false;
            }
            const [matrixOpts, volatileMatrixOpts] = pathOptsToMatrixAndVolatileOpts(opts);
            const matrix = MatrixLib.getMatrix(roomName, matrixOpts, volatileMatrixOpts);
            // Modify cost matrix if needed
            if (opts.modifyRoomCallback) {
                return opts.modifyRoomCallback(roomName, matrix.clone());
            }
            else {
                return matrix;
            }
        };
        const pfOptions = pathOptionsToPathFinderOptions(opts);
        pfOptions.roomCallback = callback;
        return PathFinder.search(creepPos, avoidGoals, pfOptions);
    }
    // Cost matrix retrieval functions =================================================================================
    // /**
    //  * Get a cloned copy of the cost matrix for a room with specified options
    //  */
    // static getCostMatrix(room: Room, options: PathOptions, clone = true): CostMatrix {
    // 	let matrix: CostMatrix;
    // 	if (options.avoidSK) {
    // 		matrix = this.getSkMatrix(room);
    // 	} else if (options.ignoreStructures) {
    // 		matrix = new PathFinder.CostMatrix();
    // 	} else {
    // 		matrix = this.getDefaultMatrix(room);
    // 	}
    // 	if (options.ignoreCreeps == false) {
    // 		matrix = this.getCreepMatrix(room, matrix);
    // 	}
    // 	// Register other obstacles
    // 	if (options.obstacles && options.obstacles.length > 0) {
    // 		matrix = matrix.clone();
    // 		for (const obstacle of options.obstacles) {
    // 			if (obstacle && obstacle.roomName == room.name) {
    // 				matrix.set(obstacle.x, obstacle.y, 0xff);
    // 			}
    // 		}
    // 	}
    // 	if (clone) {
    // 		matrix = matrix.clone();
    // 	}
    // 	return matrix;
    // }
    // static getSwarmDefaultMatrix(room: Room, width: number, height: number,
    // 							 options: SwarmMoveOptions = {}, clone = true): CostMatrix {
    // 	let matrix = $.costMatrix(room.name, `swarm${width}x${height}`, () => {
    // 		const mat = this.getTerrainMatrix(room.name).clone();
    // 		this.blockImpassibleStructures(mat, room);
    // 		this.setExitCosts(mat, room.name, options.exitCost || 10);
    // 		this.applyMovingMaximum(mat, width, height);
    // 		return mat;
    // 	}, 25);
    // 	if (options.ignoreCreeps == false) {
    // 		matrix = matrix.clone();
    // 		this.blockHostileCreeps(matrix, room); // todo: need to smear again?
    // 	}
    // 	if (clone) {
    // 		matrix = matrix.clone();
    // 	}
    // 	return matrix;
    // }
    // private static getCostMatrixForInvisibleRoom(roomName: string, options: PathOptions,
    // 											 clone = true): CostMatrix {
    // 	let matrix: CostMatrix | undefined;
    // 	if (options.avoidSK) {
    // 		matrix = $.costMatrixRecall(roomName, MatrixTypes.sk);
    // 	} else {
    // 		matrix = $.costMatrixRecall(roomName, MatrixTypes.default);
    // 	}
    // 	// Hm, we haven't found any previously cached matrices; let's see if we can get stuff from room intel
    // 	if (!matrix) {
    // 		const roomInfo = RoomIntel.getAllRoomObjectInfo(roomName);
    // 		if (roomInfo) {
    // 			// Cool let's set walkability based on what we remember
    // 			matrix = new PathFinder.CostMatrix();
    // 			const structureData = roomInfo.importantStructures;
    // 			if (structureData) {
    // 				const structures = _.compact([structureData.storagePos,
    // 											  structureData.terminalPos,
    // 											  ...structureData.towerPositions,
    // 											  ...structureData.spawnPositions,
    // 											  ...structureData.wallPositions,
    // 											  ...structureData.rampartPositions]) as RoomPosition[];
    // 				_.forEach(structures, pos => matrix!.set(pos.x, pos.y, 0xff));
    // 			}
    // 			const portals = roomInfo.portals;
    // 			_.forEach(portals, portal => matrix!.set(portal.pos.x, portal.pos.y, PORTAL_COST));
    // 			const skLairs = roomInfo.skLairs;
    //
    // 			if (skLairs.length > 0) {
    // 				// The source keepers usually hang out by the closest mineral or source but sometimes on lair
    // 				const avoidRange = 5;
    // 				const terrain = Game.map.getRoomTerrain(roomName);
    // 				const blockThese = _.compact([...roomInfo.sources,
    // 											  roomInfo.mineral,
    // 											  ...roomInfo.skLairs]) as HasPos[];
    // 				_.forEach(blockThese, thing => {
    // 					let x, y: number;
    // 					for (let dx = -avoidRange; dx <= avoidRange; dx++) {
    // 						for (let dy = -avoidRange; dy <= avoidRange; dy++) {
    // 							x = thing.pos.x + dx;
    // 							y = thing.pos.y + dy;
    // 							if (terrain.get(x, y) != TERRAIN_MASK_WALL) {
    // 								const cost = SK_COST * (avoidRange + 1 - Math.max(Math.abs(dx), Math.abs(dy)));
    // 								matrix!.set(thing.pos.x + dx, thing.pos.y + dy, cost);
    // 							}
    // 						}
    // 					}
    // 				});
    // 			}
    // 		}
    // 	}
    // 	// Register other obstacles
    // 	if (matrix && options.obstacles && options.obstacles.length > 0) {
    // 		matrix = matrix.clone();
    // 		for (const obstacle of options.obstacles) {
    // 			if (obstacle && obstacle.roomName == roomName) {
    // 				matrix.set(obstacle.x, obstacle.y, 0xff);
    // 			}
    // 		}
    // 	}
    // 	if (matrix && clone) {
    // 		matrix = matrix.clone();
    // 	}
    // 	return matrix!;
    // }
    // Cost matrix generation functions ================================================================================
    // /**
    //  * Get a matrix of explicit terrain values for a room
    //  */
    // static getTerrainMatrix(roomName: string, costs: TerrainCosts = {plainCost: 1, swampCost: 5}): CostMatrix {
    // 	return $.costMatrix(roomName, `terrain:${costs.plainCost}:${costs.swampCost}`, () => {
    // 		const matrix = new PathFinder.CostMatrix();
    // 		const terrain = Game.map.getRoomTerrain(roomName);
    // 		for (let y = 0; y < 50; ++y) {
    // 			for (let x = 0; x < 50; ++x) {
    // 				switch (terrain.get(x, y)) {
    // 					case TERRAIN_MASK_SWAMP:
    // 						matrix.set(x, y, costs.swampCost);
    // 						break;
    // 					case TERRAIN_MASK_WALL:
    // 						matrix.set(x, y, 0xff);
    // 						break;
    // 					default: // plain
    // 						matrix.set(x, y, costs.plainCost);
    // 						break;
    // 				}
    // 			}
    // 		}
    // 		return matrix;
    // 	}, 10000);
    // }
    // /**
    //  * Default matrix for a room, setting impassable structures and constructionSites to impassible
    //  */
    // static getDefaultMatrix(room: Room): CostMatrix {
    // 	return $.costMatrix(room.name, MatrixTypes.default, () => {
    // 		const matrix = new PathFinder.CostMatrix();
    // 		// Set passability of structure positions
    // 		const impassibleStructures: Structure[] = [];
    // 		_.forEach(room.find(FIND_STRUCTURES), (s: Structure) => {
    // 			if (s.structureType == STRUCTURE_ROAD) {
    // 				matrix.set(s.pos.x, s.pos.y, 1);
    // 			} else if (!s.isWalkable) {
    // 				impassibleStructures.push(s);
    // 			}
    // 		});
    // 		_.forEach(impassibleStructures, s => matrix.set(s.pos.x, s.pos.y, 0xff));
    // 		const portals = _.filter(impassibleStructures, s => s.structureType == STRUCTURE_PORTAL);
    // 		_.forEach(portals, p => matrix.set(p.pos.x, p.pos.y, PORTAL_COST));
    // 		// Set passability of construction sites
    // 		_.forEach(room.find(FIND_CONSTRUCTION_SITES), (site: ConstructionSite) => {
    // 			if (site.my && !site.isWalkable) {
    // 				matrix.set(site.pos.x, site.pos.y, 0xff);
    // 			}
    // 		});
    // 		return matrix;
    // 	});
    // }
    //
    //
    // /**
    //  * Default matrix for a room, setting impassable structures and constructionSites to impassible, ignoring roads
    //  */
    // static getDirectMatrix(room: Room): CostMatrix { // TODO: deprecated
    // 	return $.costMatrix(room.name, MatrixTypes.direct, () => {
    // 		const matrix = new PathFinder.CostMatrix();
    // 		// Set passability of structure positions
    // 		const impassibleStructures: Structure[] = [];
    // 		_.forEach(room.find(FIND_STRUCTURES), (s: Structure) => {
    // 			if (!s.isWalkable) {
    // 				impassibleStructures.push(s);
    // 			}
    // 		});
    // 		_.forEach(impassibleStructures, s => matrix.set(s.pos.x, s.pos.y, 0xff));
    // 		const portals = _.filter(impassibleStructures, s => s.structureType == STRUCTURE_PORTAL);
    // 		_.forEach(portals, p => matrix.set(p.pos.x, p.pos.y, 0xfe));
    // 		// Set passability of construction sites
    // 		_.forEach(room.find(FIND_MY_CONSTRUCTION_SITES), (site: ConstructionSite) => {
    // 			if (!site.isWalkable) {
    // 				matrix.set(site.pos.x, site.pos.y, 0xff);
    // 			}
    // 		});
    // 		return matrix;
    // 	});
    // }
    //
    // /**
    //  * Avoids creeps in a room
    //  */
    // static getCreepMatrix(room: Room, fromMatrix?: CostMatrix): CostMatrix {
    // 	if (room._creepMatrix) {
    // 		return room._creepMatrix;
    // 	}
    // 	let matrix: CostMatrix;
    // 	if (fromMatrix) {
    // 		matrix = fromMatrix.clone();
    // 		_.forEach(room.find(FIND_CREEPS), c => matrix.set(c.pos.x, c.pos.y, CREEP_COST));
    // 		return matrix;
    // 	}
    // 	matrix = this.getDefaultMatrix(room).clone();
    // 	_.forEach(room.find(FIND_CREEPS), c => matrix.set(c.pos.x, c.pos.y, CREEP_COST)); // don't block off entirely
    // 	room._creepMatrix = matrix;
    // 	return room._creepMatrix;
    // }
    /**
     * Kites around hostile creeps in a room
     */
    static getKitingMatrix(room) {
        if (room._kitingMatrix) {
            return room._kitingMatrix;
        }
        const matrix = MatrixLib.getMatrix(room.name, {}).clone();
        const avoidCreeps = room.dangerousHostiles;
        _.forEach(avoidCreeps, (avoidCreep) => MatrixLib.addSquarePotential(matrix, avoidCreep.pos, 3, 30));
        // // || c.getActiveBodyparts(HEAL) > 0);
        // const terrain = Game.map.getRoomTerrain(room.name);
        // _.forEach(avoidCreeps, avoidCreep => {
        // 	let cost: number;
        // 	for (let dx = -3; dx <= 3; dx++) {
        // 		for (let dy = -3; dy <= 3; dy++) {
        // 			const x = avoidCreep.pos.x + dx;
        // 			const y = avoidCreep.pos.y + dy;
        // 			if (terrain.get(x, y) != TERRAIN_MASK_WALL && matrix.get(x, y) != 1) { // if wall and no tunnel
        // 				cost = matrix.get(x, y);
        // 				cost += 40 - (10 * Math.max(Math.abs(dx), Math.abs(dy)));
        // 				matrix.set(avoidCreep.pos.x + dx, avoidCreep.pos.y + dy, cost);
        // 			}
        // 		}
        // 	}
        // });
        room._kitingMatrix = matrix;
        return room._kitingMatrix;
    }
    // /**
    //  * Avoids source keepers in a room
    //  */
    // private static getSkMatrix(room: Room): CostMatrix {
    // 	if (Cartographer.roomType(room.name) != ROOMTYPE_SOURCEKEEPER) {
    // 		return this.getDefaultMatrix(room);
    // 	}
    // 	return $.costMatrix(room.name, MatrixTypes.sk, () => {
    // 		const matrix = this.getDefaultMatrix(room).clone();
    // 		if (room.sourceKeepers.length > 0) {
    // 			// const blockThese = _.compact([...room.sources, room.mineral, ...room.keeperLairs]) as HasPos[];
    // 			// _.forEach(blockThese, thing => {
    // 			// 	for (let dx = -avoidRange; dx <= avoidRange; dx++) {
    // 			// 		for (let dy = -avoidRange; dy <= avoidRange; dy++) {
    // 			// 			const cost = SK_COST / 5 * (avoidRange + 1 - Math.max(Math.abs(dx), Math.abs(dy)));
    // 			// 			matrix!.set(thing.pos.x + dx, thing.pos.y + dy, cost);
    // 			// 		}
    // 			// 	}
    // 			// });
    // 			const terrain = Game.map.getRoomTerrain(room.name);
    // 			const avoidRange = 5;
    // 			_.forEach(room.sourceKeepers, sourceKeeper => {
    // 				let x, y: number;
    // 				for (let dx = -avoidRange; dx <= avoidRange; dx++) {
    // 					for (let dy = -avoidRange; dy <= avoidRange; dy++) {
    // 						x = sourceKeeper.pos.x + dx;
    // 						y = sourceKeeper.pos.y + dy;
    // 						if (terrain.get(x, y) != TERRAIN_MASK_WALL) {
    // 							const cost = SK_COST * 2 * (avoidRange + 1 - Math.max(Math.abs(dx), Math.abs(dy)));
    // 							matrix.set(x, y, cost);
    // 						}
    // 					}
    // 				}
    // 			});
    // 		}
    // 		return matrix;
    // 	});
    // }
    // /**
    //  * Avoid locations in melee range of ramparts
    //  * @param room
    //  */
    // private static getNearRampartsMatrix(room: Room): CostMatrix {
    // 	return $.costMatrix(room.name, MatrixTypes.nearRampart, () => {
    // 		const matrix = this.getDefaultMatrix(room).clone();
    // 		const avoidRange = 1;
    // 		_.forEach(room.ramparts, rampart => {
    // 			for (let dx = -avoidRange; dx <= avoidRange; dx++) {
    // 				for (let dy = -avoidRange; dy <= avoidRange; dy++) {
    // 					matrix.set(rampart.pos.x + dx, rampart.pos.y + dy, 0xfe);
    // 				}
    // 			}
    // 		});
    // 		return matrix;
    // 	});
    // }
    // /* Avoids source keepers in a room */
    // private static getInvisibleSkMatrix(roomName: string): CostMatrix {
    // 	let matrix = new PathFinder.CostMatrix();
    // 	if (Cartographer.roomType(roomName) == ROOMTYPE_SOURCEKEEPER) {
    // 		if (Memory.rooms[roomName] && Memory.rooms[roomName].SKlairs != undefined) {
    //
    // 			const avoidRange = 5;
    // 			const lairs: RoomPosition[] = _.map(Memory.rooms[roomName].SKlairs!,
    // 												saved => derefCoords(saved.c, roomName));
    // 			_.forEach(lairs, lair => {
    // 				for (let dx = -avoidRange; dx <= avoidRange; dx++) {
    // 					for (let dy = -avoidRange; dy <= avoidRange; dy++) {
    // 						matrix.set(lair.x + dx, lair.y + dy, 0xff);
    // 					}
    // 				}
    // 			});
    // 		}
    // 	}
    // 	return matrix;
    // }
    // In-place CostMatrix manipulation routines =======================================================================
    /**
     * Sets impassible structure positions to 0xff
     */
    static blockImpassibleStructures(matrix, room) {
        _.forEach(room.find(FIND_STRUCTURES), (s) => {
            if (!s.isWalkable) {
                if (s.structureType == STRUCTURE_PORTAL) {
                    matrix.set(s.pos.x, s.pos.y, 0xfe);
                }
                else {
                    matrix.set(s.pos.x, s.pos.y, 0xff);
                }
            }
        });
    }
    // /**
    //  * Explicitly blocks off walls for a room
    //  */
    // static blockImpassibleTerrain(matrix: CostMatrix, roomName: string) {
    // 	const terrain = Game.map.getRoomTerrain(roomName);
    // 	for (let y = 0; y < 50; ++y) {
    // 		for (let x = 0; x < 50; ++x) {
    // 			if (terrain.get(x, y) === TERRAIN_MASK_WALL) {
    // 				matrix.set(x, y, 0xff);
    // 			}
    // 		}
    // 	}
    // }
    // /**
    //  * Transform a CostMatrix such that the cost at each point is transformed to the max of costs in a width x height
    //  * window (indexed from upper left corner). This requires that terrain be explicitly specified in the matrix!
    //  */
    // static applyMovingMaxPool(matrix: CostMatrix, width: number, height: number) {
    // 	// Since we're moving in increasing order of x, y, we don't need to clone the matrix
    // 	let x, y, dx, dy: number;
    // 	let maxCost, cost: number;
    // 	for (x = 0; x <= 50 - width; x++) {
    // 		for (y = 0; y <= 50 - height; y++) {
    // 			maxCost = matrix.get(x, y);
    // 			for (dx = 0; dx <= width - 1; dx++) {
    // 				for (dy = 0; dy <= height - 1; dy++) {
    // 					cost = matrix.get(x + dx, y + dy);
    // 					if (cost > maxCost) {
    // 						maxCost = cost;
    // 					}
    // 				}
    // 			}
    // 			matrix.set(x, y, maxCost);
    // 		}
    // 	}
    // }
    // static setCostsInRange(matrix: CostMatrix, pos: RoomPosition | HasPos, range: number, cost = 30, add = false) {
    // 	pos = normalizePos(pos);
    // 	const terrain = Game.map.getRoomTerrain(pos.roomName);
    //
    // 	for (let dx = -range; dx <= range; dx++) {
    // 		const x = pos.x + dx;
    // 		if (x < 0 || x > 49) continue;
    // 		for (let dy = -range; dy <= range; dy++) {
    // 			const y = pos.y + dy;
    // 			if (y < 0 || y > 49) continue;
    // 			const posTerrain = terrain.get(x, y);
    // 			if (posTerrain === TERRAIN_MASK_WALL) {
    // 				continue;
    // 			}
    // 			let currentCost = matrix.get(x, y);
    // 			if (currentCost === 0) {
    // 				if (posTerrain === TERRAIN_MASK_SWAMP) {
    // 					currentCost += 10;
    // 				} else {
    // 					currentCost += 2;
    // 				}
    // 			}
    // 			if (currentCost >= 0xff || currentCost > cost) continue;
    // 			matrix.set(x, y, add ? Math.min(cost + currentCost, 200) : cost);
    // 		}
    // 	}
    // }
    // static blockExits(matrix: CostMatrix, rangeToEdge = 0) {
    // 	for (let x = rangeToEdge; x < 50 - rangeToEdge; x += 49 - rangeToEdge * 2) {
    // 		for (let y = rangeToEdge; y < 50 - rangeToEdge; y++) {
    // 			matrix.set(x, y, 0xff);
    // 		}
    // 	}
    // 	for (let x = rangeToEdge; x < 50 - rangeToEdge; x++) {
    // 		for (let y = rangeToEdge; y < 50 - rangeToEdge; y += 49 - rangeToEdge * 2) {
    // 			matrix.set(x, y, 0xff);
    // 		}
    // 	}
    // }
    //
    // static setExitCosts(matrix: CostMatrix, roomName: string, cost: number, rangeToEdge = 0) {
    // 	const terrain = Game.map.getRoomTerrain(roomName);
    //
    // 	for (let x = rangeToEdge; x < 50 - rangeToEdge; x += 49 - rangeToEdge * 2) {
    // 		for (let y = rangeToEdge; y < 50 - rangeToEdge; y++) {
    // 			if (terrain.get(x, y) != TERRAIN_MASK_WALL) {
    // 				matrix.set(x, y, cost);
    // 			}
    // 		}
    // 	}
    // 	for (let x = rangeToEdge; x < 50 - rangeToEdge; x++) {
    // 		for (let y = rangeToEdge; y < 50 - rangeToEdge; y += 49 - rangeToEdge * 2) {
    // 			if (terrain.get(x, y) != TERRAIN_MASK_WALL) {
    // 				matrix.set(x, y, cost);
    // 			}
    // 		}
    // 	}
    // }
    /**
     * Serialize a path as a string of move directions
     */
    static serializePath(startPos, path, color = "orange") {
        let serializedPath = "";
        let lastPosition = startPos;
        for (const position of path) {
            if (position.roomName == lastPosition.roomName) {
                new RoomVisual(position.roomName).line(position, lastPosition, {
                    color: color,
                    lineStyle: "dashed",
                });
                serializedPath += lastPosition.getDirectionTo(position);
            }
            lastPosition = position;
        }
        return serializedPath;
    }
    static deserializePath(startPos, path) {
        if (typeof path !== "string") {
            return [];
        }
        const positions = [];
        let lastPosition = startPos;
        const pathDirs = path.split("");
        let dirStr;
        while ((dirStr = pathDirs.shift())) {
            const dir = parseInt(dirStr, 10);
            const pos = this.positionAtDirection(lastPosition, dir);
            if (!pos) {
                log.warning(`path cutoff?`);
                break;
            }
            if (pos.roomName !== lastPosition.roomName) {
                lastPosition = pos;
                continue;
            }
            positions.push(pos);
            lastPosition = pos;
        }
        return positions;
    }
    static nextDirectionInPath(creep) {
        const moveData = creep.memory._go;
        if (!moveData || !moveData.path || moveData.path.length == 0) {
            return;
        }
        return Number.parseInt(moveData.path[0], 10);
    }
    static nextPositionInPath(creep) {
        const nextDir = this.nextDirectionInPath(creep);
        if (!nextDir) {
            return;
        }
        return this.positionAtDirection(creep.pos, nextDir);
    }
    static oppositeDirection(direction) {
        switch (direction) {
            case TOP:
                return BOTTOM;
            case TOP_LEFT:
                return BOTTOM_RIGHT;
            case LEFT:
                return RIGHT;
            case BOTTOM_LEFT:
                return TOP_RIGHT;
            case BOTTOM:
                return TOP;
            case BOTTOM_RIGHT:
                return TOP_LEFT;
            case RIGHT:
                return LEFT;
            case TOP_RIGHT:
                return BOTTOM_LEFT;
        }
    }
    /**
     * Returns a position at a direction from origin
     */
    static positionAtDirection(origin, direction) {
        const offsetX = [0, 0, 1, 1, 1, 0, -1, -1, -1];
        const offsetY = [0, -1, -1, 0, 1, 1, 1, 0, -1];
        return origin.getOffsetPos(offsetX[direction], offsetY[direction]);
    }
    // static savePath(path: RoomPosition[]): void {
    // 	const savedPath: CachedPath = {
    // 		path  : path,
    // 		length: path.length,
    // 		tick  : Game.time
    // 	};
    // 	const originName = _.first(path).name;
    // 	const destinationName = _.last(path).name;
    // 	if (!Memory.pathing.paths[originName]) {
    // 		Memory.pathing.paths[originName] = {};
    // 	}
    // 	Memory.pathing.paths[originName][destinationName] = savedPath;
    // }
    // Distance and path weight calculations ===========================================================================
    /**
     * Calculate and/or cache the length of the shortest path between two points.
     * Cache is probabilistically cleared in Mem
     */
    static distance(pos1, pos2) {
        const [name1, name2] = [packPos(pos1), packPos(pos2)].sort(); // path length is the same in either direction
        if (!Memory.pathing.distances[name1]) {
            Memory.pathing.distances[name1] = {};
        }
        if (!Memory.pathing.distances[name1][name2]) {
            const ret = this.findPath(pos1, pos2, {
                avoidSK: false,
                allowHostile: true,
                ignoreStructures: true,
            });
            if (!ret.incomplete) {
                Memory.pathing.distances[name1][name2] = ret.path.length;
            }
            else {
                const e = new Error(`PATHING: could not compute distance from ${pos1.print} to ${pos2.print}!`);
                log.trace(e);
            }
        }
        return Memory.pathing.distances[name1][name2];
    }
    // static calculatePathWeight(startPos: RoomPosition, endPos: RoomPosition, options: MoveOptions = {}): number {
    // 	_.defaults(options, {
    // 		range: 1,
    // 	});
    // 	const ret = this.findPath(startPos, endPos, options);
    // 	let weight = 0;
    // 	for (const pos of ret.path) {
    // 		if (!pos.room) { // If you don't have vision, assume there are roads
    // 			weight += 1;
    // 		} else {
    // 			if (pos.lookForStructure(STRUCTURE_ROAD)) {
    // 				weight += 1;
    // 			} else {
    // 				const terrain = pos.lookFor(LOOK_TERRAIN)[0];
    // 				if (terrain == 'plain') {
    // 					weight += 2;
    // 				} else if (terrain == 'swamp') {
    // 					weight += 10;
    // 				}
    // 			}
    // 		}
    // 	}
    // 	return weight;
    // }
    // /**
    //  * Calculates and/or caches the weighted distance for the most efficient path. Weight is sum of tile weights:
    //  * Road = 1, Plain = 2, Swamp = 10. Cached weights are cleared in Mem occasionally.
    //  */
    // static weightedDistance(arg1: RoomPosition, arg2: RoomPosition): number {
    // 	const [pos1, pos2] = _.sortBy([arg1, arg2], pos => packPos(pos)); // alphabetize since path lengths are the same
    // 	if (!Memory.pathing.weightedDistances[pos1.name]) {
    // 		Memory.pathing.weightedDistances[pos1.name] = {};
    // 	}
    // 	if (!Memory.pathing.weightedDistances[pos1.name][pos2.name]) {
    // 		Memory.pathing.weightedDistances[pos1.name][pos2.name] = this.calculatePathWeight(pos1, pos2);
    // 	}
    // 	return Memory.pathing.weightedDistances[pos1.name][pos2.name];
    // }
    /**
     * Whether another object in the same room can be reached from the current position.
     * This method is very expensive and kind of stupid, so use it sparingly!
     */
    static isReachable(startPos, endPos, obstacles, options = {}) {
        _.defaultsDeep(options, {
            blockCreeps: false,
            range: 1,
            maxOps: 2000,
            ensurePath: false,
        });
        if (startPos.roomName != endPos.roomName) {
            log.error(`isReachable() should only be used within a single room!`);
            return false;
        }
        const matrix = new PathFinder.CostMatrix();
        _.forEach(obstacles, (obstacle) => {
            if (hasPos(obstacle)) {
                matrix.set(obstacle.pos.x, obstacle.pos.y, 0xfe);
            }
            else {
                matrix.set(obstacle.x, obstacle.y, 0xfe);
            }
        });
        const callback = (roomName) => roomName == endPos.roomName ? matrix : false;
        const pfOptions = pathOptionsToPathFinderOptions(options);
        pfOptions.maxRooms = 1;
        pfOptions.roomCallback = callback;
        const ret = PathFinder.search(startPos, { pos: endPos, range: options.range }, pfOptions);
        if (ret.incomplete) {
            return false;
        }
        else {
            for (const pos of ret.path) {
                if (matrix.get(pos.x, pos.y) > 100) {
                    return false;
                }
            }
        }
        return true;
    }
    /**
     * Like isReachable(), but returns the first position which should be cleared to find a path to destination
     */
    static findBlockingPos(startPos, endPos, obstacles, options = {}) {
        _.defaultsDeep(options, {
            blockCreeps: false,
            range: 1,
            maxOps: 2000,
            ensurePath: false,
        });
        if (startPos.roomName !== endPos.roomName) {
            // Start and end aren't in the same room.
            const pathToEnd = this.findPath(startPos, endPos, options);
            const newStartPos = pathToEnd.path.find((step) => step.roomName === endPos.roomName);
            if (!newStartPos) {
                return undefined;
            }
            startPos = newStartPos;
        }
        const matrix = new PathFinder.CostMatrix();
        _.forEach(obstacles, (obstacle) => {
            if (hasPos(obstacle)) {
                matrix.set(obstacle.pos.x, obstacle.pos.y, 0xfe);
            }
            else {
                matrix.set(obstacle.x, obstacle.y, 0xfe);
            }
        });
        const callback = (roomName) => roomName == endPos.roomName ? matrix : false;
        const pfOpts = pathOptionsToPathFinderOptions(options);
        pfOpts.roomCallback = callback;
        const ret = PathFinder.search(startPos, { pos: endPos, range: options.range }, pfOpts);
        for (const pos of ret.path) {
            if (matrix.get(pos.x, pos.y) > 100) {
                return pos;
            }
        }
        return undefined;
    }
    /**
     * Find the first walkable position in the room, spiraling outward from the center
     */
    static findPathablePosition(roomName, clearance = { width: 1, height: 1 }) {
        const terrain = Game.map.getRoomTerrain(roomName);
        let x, y;
        let allClear;
        for (let radius = 0; radius < 23; radius++) {
            for (let dx = -radius; dx <= radius; dx++) {
                for (let dy = -radius; dy <= radius; dy++) {
                    if (Math.abs(dy) !== radius && Math.abs(dx) !== radius) {
                        continue;
                    }
                    x = 25 + dx;
                    y = 25 + dy;
                    allClear = true;
                    for (let w = 0; w < clearance.width; w++) {
                        for (let h = 0; h < clearance.height; h++) {
                            if (terrain.get(x + w, y + h) === TERRAIN_MASK_WALL) {
                                allClear = false;
                            }
                        }
                    }
                    if (allClear) {
                        return new RoomPosition(x, y, roomName);
                    }
                }
            }
        }
        // Should never reach here!
        return new RoomPosition(-10, -10, "cannotFindPathablePosition");
    }
};
Pathing = Pathing_1 = __decorate$1([
    profile
], Pathing);
// Register global instance
global.Pathing = Pathing;

// Combat Intel - provides information related to making combat-related decisions
var CombatIntel_1;
const getDefaultCombatIntelMemory = () => ({
    cache: {
        tick: Game.time,
    },
});
let CombatIntel$1 = CombatIntel_1 = class CombatIntel {
    constructor(directive) {
        this.directive = directive;
    }
    get memory() {
        return Mem.wrap(this.directive.memory, "combatIntel", getDefaultCombatIntelMemory);
    }
    get room() {
        return this.directive.room;
    }
    get colony() {
        return this.directive.colony;
    }
    // Tower damage ====================================================================================================
    /**
     * Get the tower damage at a given range
     */
    static singleTowerDamage(range) {
        if (range <= TOWER_OPTIMAL_RANGE) {
            return TOWER_POWER_ATTACK;
        }
        range = Math.min(range, TOWER_FALLOFF_RANGE);
        const falloff = (range - TOWER_OPTIMAL_RANGE) /
            (TOWER_FALLOFF_RANGE - TOWER_OPTIMAL_RANGE);
        return TOWER_POWER_ATTACK * (1 - TOWER_FALLOFF * falloff);
    }
    /**
     * Total tower damage from all towers in room at a given position
     */
    static towerDamageAtPos(pos, ignoreEnergy = false) {
        if (pos.room) {
            let expectedDamage = 0;
            for (const tower of pos.room.towers) {
                if (tower.store[RESOURCE_ENERGY] > 0 || ignoreEnergy) {
                    expectedDamage += this.singleTowerDamage(pos.getRangeTo(tower));
                }
            }
            return expectedDamage;
        }
        const structs = RoomIntel$1.getImportantStructureInfo(pos.roomName);
        if (!structs) {
            log.warning(`CombatIntel.towerDamageAtPos: room visibility at ${pos.print}!`);
            return 0;
        }
        let expectedDamage = 0;
        for (const tower of structs.towerPositions) {
            expectedDamage += this.singleTowerDamage(pos.getRangeTo(tower));
        }
        return expectedDamage;
    }
    // Cost matrix calculations
    computeCostMatrix() {
        if (this.room) {
            const matrix = new PathFinder.CostMatrix();
            const barriers = this.room.barriers;
            if (barriers.length > 0) {
                const highestHits = _.last(_.sortBy(barriers, (barrier) => barrier.hits)).hits;
                for (const barrier of barriers) {
                    matrix.set(barrier.pos.x, barrier.pos.y, Math.ceil((barrier.hits * 10) / highestHits) * 10);
                }
            }
            return matrix;
        }
    }
    /**
     * Calculates the total potential damage per tile in a region
     */
    static computeCreepDamagePotentialMatrix(room, creeps, startingMatrix) {
        if (room) {
            const cpuUsed = Game.cpu.getUsed();
            const matrix = startingMatrix || new PathFinder.CostMatrix();
            // const otherMatrix = new Array(50);
            // otherMatrix.forEach((loc, index) => otherMatrix[index] = new Array(50));
            creeps.forEach((creep) => {
                const meleeAttack = CombatIntel_1.getAttackPotential(creep);
                const rangedAttack = CombatIntel_1.getRangedAttackPotential(creep);
                // const heal = CombatIntel.getHealPotential(creep);
                if (meleeAttack > 0) {
                    creep.pos.neighbors.forEach((pos) => matrix.set(pos.x, pos.y, matrix.get(pos.x, pos.y) +
                        (meleeAttack * ATTACK_POWER) / 100));
                }
                if (rangedAttack > 0) {
                    creep.pos
                        .getPositionsInRange(3)
                        .forEach((pos) => matrix.set(pos.x, pos.y, matrix.get(pos.x, pos.y) +
                        (rangedAttack * RANGED_ATTACK_POWER) / 100));
                }
            });
            Visualizer.displayCostMatrix(matrix, room.name);
            console.log(`Cost matrix cpu used in ${room.print} = ${Game.cpu.getUsed() - cpuUsed}`);
            return matrix;
        }
    }
    /**
     * Calculates potential damage and heal per location in a region
     */
    static computeTotalCreepPotentialMatrix(room, creeps, startingMatrix) {
        if (room) {
            const cpuUsed = Game.cpu.getUsed();
            const matrix = startingMatrix || new PathFinder.CostMatrix();
            // const otherMatrix = new Array(50);
            // otherMatrix.forEach((loc, index) => otherMatrix[index] = new Array(50));
            creeps.forEach((creep) => {
                const meleeAttack = CombatIntel_1.getAttackPotential(creep);
                const rangedAttack = CombatIntel_1.getRangedAttackPotential(creep);
                // const heal = CombatIntel.getHealPotential(creep);
                if (meleeAttack > 0) {
                    creep.pos.neighbors.forEach((pos) => matrix.set(pos.x, pos.y, matrix.get(pos.x, pos.y) +
                        (meleeAttack * ATTACK_POWER) / 100));
                }
                if (rangedAttack > 0) {
                    creep.pos
                        .getPositionsInRange(3)
                        .forEach((pos) => matrix.set(pos.x, pos.y, matrix.get(pos.x, pos.y) +
                        (rangedAttack * RANGED_ATTACK_POWER) / 100));
                }
            });
            Visualizer.displayCostMatrix(matrix, room.name);
            console.log(`Cost matrix cpu used in ${room.print} = ${Game.cpu.getUsed() - cpuUsed}`);
            return matrix;
        }
    }
    // Fallback and exit calculations ==================================================================================
    findBestExit(matrix, towers, _spawns) {
        if (!this.room) {
            return;
        }
        let bestExit;
        const destination = this.room.spawns[0] || this.room.storage; // enemy structure you are trying to get to
        if (!destination) {
            return;
        }
        const ret = Pathing.findPath(this.colony.pos, destination.pos, {
            range: 1,
        });
        if (!ret.incomplete) {
            bestExit = _.find(ret.path, (p) => p.roomName == this.room.name);
        }
        // Figure out possible exits to go from enemy room back to colony in a reasonable amount of time
        const maxRoomDistance = 8;
        const allowedExits = {};
        if (!bestExit) {
            const exitData = Cartographer.describeExits(this.room.name);
            for (const direction in exitData) {
                const roomName = exitData[direction];
                const allowedRooms = Pathing.findRoute(this.colony.name, roomName);
                if (allowedRooms &&
                    Object.keys(allowedRooms).length <= maxRoomDistance) {
                    allowedExits[direction] = true;
                }
            }
            if (_.keys(allowedExits).length == 0) {
                return;
            }
        }
        const exitPositions = [];
        const terrain = Game.map.getRoomTerrain(this.room.name);
        for (let x = 0; x < 50; x += 49) {
            for (let y = 0; y < 50; y++) {
                if (x !== 0 && y !== 0 && x !== 49 && y !== 49) {
                    continue;
                }
                if (terrain.get(x, y) === TERRAIN_MASK_WALL) {
                    continue;
                }
                matrix.set(x, y, 0xff);
                if (bestExit) {
                    continue;
                }
                if (allowedExits["1"] && y === 0) {
                    exitPositions.push(new RoomPosition(x, y, this.room.name));
                }
                else if (allowedExits["3"] && x === 49) {
                    exitPositions.push(new RoomPosition(x, y, this.room.name));
                }
                else if (allowedExits["5"] && y === 49) {
                    exitPositions.push(new RoomPosition(x, y, this.room.name));
                }
                else if (allowedExits["7"] && x === 0) {
                    exitPositions.push(new RoomPosition(x, y, this.room.name));
                }
            }
        }
        if (!bestExit) {
            bestExit = _(exitPositions)
                .sortBy((p) => -_.sum(towers, (t) => p.getRangeTo(t)))
                .head();
        }
        matrix.set(bestExit.x, bestExit.y, 1);
        return bestExit;
    }
    // static findBestSiegeExit(roomName: string, matrix?: CostMatrix): RoomPosition | undefined  {
    // 	let edgeCoords: [number, number][] = [];
    // 	for (let x = 0; x < 50; x += 49) {
    // 		for (let y = 0; y < 50; y++) {
    // 			edgeCoords.push([x,y])
    // 		}
    // 	}
    // 	for (let x = 0; x < 50; x++) {
    // 		for (let y = 0; y < 50; y += 49) {
    // 			edgeCoords.push([x,y])
    // 		}
    // 	}
    //
    // 	const room = Game.rooms[roomName];
    // 	let siegeTarget = CombatTargeting.findBestStructureTarget()
    // }
    /**
     * Simple routine to find an assembly point outside of the target room
     */
    findSimpleSiegeFallback() {
        const ret = Pathing.findPath(this.colony.pos, this.directive.pos, {
            range: 23,
        });
        if (ret.incomplete) {
            log.warning(`Incomplete path while finding fallback! Destination: ${this.directive.pos.print}`);
        }
        const firstPosInRoom = _.find(ret.path, (pos) => pos.roomName == this.directive.pos.roomName);
        if (firstPosInRoom) {
            return CombatIntel_1.getFallbackFrom(firstPosInRoom);
        }
        else {
            return CombatIntel_1.getFallbackFrom(this.directive.pos);
        }
    }
    /**
     * Finds a location for a swarm to assemble outside of the target room
     */
    findSwarmAssemblyPoint(clearance, swarmIndex = 0) {
        const simpleFallback = this.findSimpleSiegeFallback();
        const startPos = Pathing.findPathablePosition(simpleFallback.roomName, clearance);
        let ret = Pathing.findSwarmPath(startPos, this.directive.pos, clearance.width, clearance.height);
        if (ret.incomplete) {
            log.debug(`Incomplete swarm path to find assembly point. Retrying with startpos = fallback.`);
            ret = Pathing.findSwarmPath(simpleFallback, this.directive.pos, clearance.width, clearance.height);
            if (ret.incomplete) {
                log.warning(`No pathable assembly point!`);
            }
        }
        const path = ret.path.reverse();
        const acceptablePositions = _.filter(path, (pos) => pos.roomName == simpleFallback.roomName && pos.rangeToEdge > 1);
        const swarmSize = Math.max(clearance.width, clearance.height);
        const posIndex = (swarmSize + 1) * swarmIndex;
        return (acceptablePositions[posIndex] ||
            acceptablePositions[0] ||
            simpleFallback);
    }
    /**
     * Finds a location for a swarm to assemble within an owned room
     */
    findSwarmAssemblyPointInColony(clearance, swarmIndex = 0) {
        // let ret = Pathing.findSwarmPath(this.colony.pos, this.directive.pos, clearance.width, clearance.height,
        // 								{ignoreCreeps: true});
        const ret = Pathing.findPath(this.colony.pos, this.directive.pos);
        const path = ret.path.reverse();
        const acceptablePositions = _.filter(path, (pos) => pos.roomName == this.colony.name && pos.rangeToEdge > 1);
        const swarmSize = Math.max(clearance.width, clearance.height);
        const posIndex = (swarmSize + 1) * swarmIndex;
        return acceptablePositions[posIndex] || acceptablePositions[0];
    }
    /**
     * Fallback is a location on the other side of the nearest exit the directive is placed at
     */
    static getFallbackFrom(pos, fallbackDistance = 2) {
        let { x, y, roomName } = pos;
        const rangesToExit = [
            [x, "left"],
            [49 - x, "right"],
            [y, "top"],
            [49 - y, "bottom"],
        ];
        const [_range, direction] = _.first(_.sortBy(rangesToExit, (pair) => pair[0]));
        switch (direction) {
            case "left":
                x = 49 - fallbackDistance;
                roomName = Cartographer.findRelativeRoomName(roomName, -1, 0);
                break;
            case "right":
                x = fallbackDistance;
                roomName = Cartographer.findRelativeRoomName(roomName, 1, 0);
                break;
            case "top":
                y = 49 - fallbackDistance;
                roomName = Cartographer.findRelativeRoomName(roomName, 0, -1);
                break;
            case "bottom":
                y = fallbackDistance;
                roomName = Cartographer.findRelativeRoomName(roomName, 0, 1);
                break;
            default:
                log.error("Error getting fallback position!");
                break;
        }
        return new RoomPosition(x, y, roomName);
    }
    // Creep potentials ================================================================================================
    /**
     * Cache the result of a computation for a tick
     */
    static cache(creep, key, callback) {
        var _a, _b;
        var _c;
        (_a = creep.intel) !== null && _a !== void 0 ? _a : (creep.intel = {});
        (_b = (_c = creep.intel)[key]) !== null && _b !== void 0 ? _b : (_c[key] = callback());
        return creep.intel[key];
    }
    static uniqueBoosts(creep) {
        return _.compact(_.unique(_.map(creep.body, (bodyPart) => bodyPart.boost)));
    }
    /**
     * Calculate the potential power of a specific type from a body definition,
     * taking into account boosts (from the definition or that would be applied)
     *
     * @param body - The creep's body definition
     * @param type - The potential type to check
     * @param intendedBoosts - An optional list of boosts to take into account
     * @returns The estimated power for that type
     */
    static getBodyPotential(body, type, intendedBoosts = []) {
        const bodyPart = BoostTypeBodyparts[type];
        return _.sum(body, function (part) {
            var _a, _b, _c;
            if (part.hits == 0) {
                return 0;
            }
            if (part.type === bodyPart) {
                let boost = part.boost;
                if (!boost && intendedBoosts) {
                    boost = _.find(intendedBoosts, (boost) => boost == BOOST_TIERS[type].T1 ||
                        boost == BOOST_TIERS[type].T2 ||
                        boost == BOOST_TIERS[type].T3);
                }
                const boosts = BOOSTS;
                if (!boost) {
                    return 1;
                }
                const key = BoostTypeToBoostArray[type];
                return (_c = (_b = (_a = boosts[bodyPart]) === null || _a === void 0 ? void 0 : _a[boost]) === null || _b === void 0 ? void 0 : _b[key]) !== null && _c !== void 0 ? _c : 0;
            }
            return 0;
        });
    }
    /**
     * Estimate the power of a given part type from body parts and potential boosts
     *
     * This will build a compatible definition from the body parts, given no damage.
     *
     * Prefer using one of the {@link getAttackPotential} & friends methods if you
     * have an actual creep to cache the results, or {@link getBodyPotential}. This
     * one is merely useful to do estimations before the creep exists.
     */
    static getBodyPartPotential(body, type, intendedBoosts = []) {
        const bodyDef = body.map((part) => ({
            type: part,
            hits: 50,
        }));
        return this.getBodyPotential(bodyDef, type, intendedBoosts);
    }
    /**
     * Heal potential of a single creep in units of effective number of parts
     */
    static getHealPotential(creep, countIntendedBoosts = false) {
        const intendedBoosts = countIntendedBoosts && creep.my && creep.memory.needBoosts ?
            creep.memory.needBoosts
            : [];
        return this.cache(creep, "healPotential", () => this.getBodyPotential(creep.body, HEAL, intendedBoosts));
    }
    static getHealAmount(creep) {
        return HEAL_POWER * this.getHealPotential(toCreep(creep));
    }
    static getRangedHealAmount(creep) {
        return RANGED_HEAL_POWER * this.getHealPotential(toCreep(creep));
    }
    /**
     * If a creep appears to primarily be a healer
     */
    static isHealer(zerg) {
        const healParts = _.filter(zerg.body, (part) => part.type == HEAL).length;
        const attackParts = _.filter(zerg.body, (part) => part.type == ATTACK).length;
        const rangedAttackParts = _.filter(zerg.body, (part) => part.type == RANGED_ATTACK).length;
        return healParts > attackParts + rangedAttackParts;
    }
    /**
     * Attack potential of a single creep in units of effective number of parts
     */
    static getAttackPotential(creep, countIntendedBoosts = false) {
        const intendedBoosts = countIntendedBoosts && creep.my && creep.memory.needBoosts ?
            creep.memory.needBoosts
            : [];
        return this.cache(creep, "attackPotential", () => this.getBodyPotential(creep.body, ATTACK, intendedBoosts));
    }
    static getAttackDamage(creep) {
        return ATTACK_POWER * this.getAttackPotential(toCreep(creep));
    }
    /**
     * Ranged attack potential of a single creep in units of effective number of parts
     */
    static getRangedAttackPotential(creep, countIntendedBoosts = false) {
        const intendedBoosts = countIntendedBoosts && creep.my && creep.memory.needBoosts ?
            creep.memory.needBoosts
            : [];
        return this.cache(creep, "rangedAttackPotential", () => this.getBodyPotential(creep.body, RANGED_ATTACK, intendedBoosts));
    }
    static getRangedAttackDamage(creep) {
        return (RANGED_ATTACK_POWER * this.getRangedAttackPotential(toCreep(creep)));
    }
    /**
     * Attack potential of a single creep in units of effective number of parts
     */
    static getDismantlePotential(creep, countIntendedBoosts = false) {
        const intendedBoosts = countIntendedBoosts && creep.my && creep.memory.needBoosts ?
            creep.memory.needBoosts
            : [];
        return this.cache(creep, "dismantlePotential", () => this.getBodyPotential(creep.body, DISMANTLE, intendedBoosts));
    }
    static getDismantleDamage(creep) {
        return DISMANTLE_POWER * this.getDismantlePotential(toCreep(creep));
    }
    static getRepairPotential(creep, countIntendedBoosts = false) {
        const intendedBoosts = countIntendedBoosts && creep.my && creep.memory.needBoosts ?
            creep.memory.needBoosts
            : [];
        return this.cache(creep, "repairPotential", () => this.getBodyPotential(creep.body, CONSTRUCT, intendedBoosts));
    }
    static getRepairPower(creep) {
        return REPAIR_POWER * this.getRepairPotential(toCreep(creep));
    }
    /**
     * Attack potential of a single creep in units of effective number of parts
     */
    static getCarryPotential(creep, countIntendedBoosts = false) {
        const intendedBoosts = countIntendedBoosts && creep.my && creep.memory.needBoosts ?
            creep.memory.needBoosts
            : [];
        return this.cache(creep, "carryPotential", () => this.getBodyPotential(creep.body, CARRY, intendedBoosts));
    }
    /**
     * Minimum damage multiplier a creep has
     */
    static minimumDamageTakenMultiplier(creep) {
        return this.cache(creep, "minDamageMultiplier", () => _.min(_.map(creep.body, function (part) {
            if (part.type == TOUGH && part.hits > 0) {
                if (part.boost == BOOST_TIERS.tough.T1) {
                    return BOOSTS.tough.GO.damage;
                }
                else if (part.boost == BOOST_TIERS.tough.T2) {
                    return BOOSTS.tough.GHO2.damage;
                }
                else if (part.boost == BOOST_TIERS.tough.T3) {
                    return BOOSTS.tough.XGHO2.damage;
                }
            }
            return 1;
        })));
    }
    static minimumDamageMultiplierForGroup(creeps) {
        return _.min(_.map(creeps, (creep) => this.minimumDamageTakenMultiplier(creep)));
    }
    static getMassAttackDamageTo(attacker, target) {
        if (isStructure(target) && (!isOwnedStructure(target) || target.my)) {
            return 0;
        }
        const range = attacker.pos.getRangeTo(target.pos);
        let rangedMassAttackPower = 0;
        if (range <= 1) {
            rangedMassAttackPower = 10;
        }
        else if (range == 2) {
            rangedMassAttackPower = 4;
        }
        else if (range == 3) {
            rangedMassAttackPower = 1;
        }
        return (rangedMassAttackPower *
            this.getRangedAttackPotential(isStandardZerg(attacker) ? attacker.creep : attacker));
    }
    /**
     * Total damage to enemy creeps done by attacker.rangedMassAttack()
     */
    static getMassAttackDamage(attacker, targets = attacker.room.hostiles, checkRampart = true) {
        const hostiles = attacker.pos.findInRange(targets, RANGES.RANGED_ATTACK);
        return _.sum(hostiles, function (hostile) {
            if (checkRampart &&
                hostile.pos.lookForStructure(STRUCTURE_RAMPART)) {
                return 0; // Creep inside rampart
            }
            else {
                return CombatIntel_1.getMassAttackDamageTo(attacker, hostile);
            }
        });
    }
    /**
     * A heuristic for scoring the effectiveness of creeps
     */
    static rating(creep) {
        const c = toCreep(creep);
        return this.cache(c, "rating", () => {
            let rating = this.getRangedAttackPotential(c) +
                this.getAttackPotential(c) / 2;
            const healMultiplier = 1 / this.minimumDamageTakenMultiplier(c);
            rating += healMultiplier * this.getHealPotential(c);
            return rating;
        });
    }
    // Group creep calculations ========================================================================================
    /**
     * Maximum damage that a group of creeps can dish out (doesn't count for simultaneity restrictions)
     */
    static maxDamageByCreeps(creeps) {
        return _.sum(creeps, (creep) => ATTACK_POWER * this.getAttackPotential(creep) +
            RANGED_ATTACK_POWER * this.getRangedAttackPotential(creep));
    }
    /**
     * Maximum healing that a group of creeps can provide (doesn't count for simultaneity restrictions)
     */
    static maxHealingByCreeps(creeps) {
        return _.sum(creeps, (creep) => this.getHealAmount(creep));
    }
    /**
     * Total attack/rangedAttack/heal potentials for a group of creeps
     */
    static getCombatPotentials(creeps, countIntendedBoosts = true) {
        const attack = _.sum(creeps, (unit) => isAnyZerg(unit) || isCreep(unit) ?
            this.getAttackPotential(toCreep(unit), countIntendedBoosts)
            : this.getBodyPartPotential(unit.body, ATTACK, unit.boosts));
        const ranged = _.sum(creeps, (unit) => isAnyZerg(unit) || isCreep(unit) ?
            this.getRangedAttackPotential(toCreep(unit), countIntendedBoosts)
            : this.getBodyPartPotential(unit.body, RANGED_ATTACK, unit.boosts));
        const heal = _.sum(creeps, (unit) => isAnyZerg(unit) || isCreep(unit) ?
            this.getHealPotential(toCreep(unit), countIntendedBoosts)
            : this.getBodyPartPotential(unit.body, HEAL, unit.boosts));
        const dismantle = _.sum(creeps, (unit) => isAnyZerg(unit) || isCreep(unit) ?
            this.getDismantlePotential(toCreep(unit), countIntendedBoosts)
            : this.getBodyPartPotential(unit.body, DISMANTLE, unit.boosts));
        return { attack, ranged, heal, dismantle };
    }
    /**
     * Maximum damage that is dealable at a given position by enemy forces
     */
    static maxDamageAtPos(pos) {
        if (!pos.room) {
            return 0;
        }
        const hostilesInMeleeRange = _.filter(pos.room.dangerousHostiles, (creep) => pos.getRangeTo(creep) <= 1);
        const meleeDamage = _.sum(hostilesInMeleeRange, (hostile) => this.getAttackDamage(hostile));
        const hostilesInRange = _.filter(pos.room.dangerousHostiles, (creep) => pos.getRangeTo(creep) <= 3);
        const rangedDamage = _.sum(hostilesInRange, (hostile) => this.getRangedAttackDamage(hostile));
        let totalDamage = meleeDamage + rangedDamage;
        if (!pos.room.my) {
            totalDamage += this.towerDamageAtPos(pos) || 0;
        }
        return totalDamage;
    }
    /**
     * Heal potential of self and possible healer neighbors
     */
    static maxHostileHealingTo(creep) {
        return this.cache(creep, "maxHostileHealing", () => {
            const selfHealing = this.getHealAmount(creep);
            const neighbors = _.filter(creep.room.hostiles, (hostile) => hostile.pos.isNearTo(creep));
            const neighborHealing = _.sum(neighbors, (neighbor) => this.getHealAmount(neighbor));
            const rangedHealers = _.filter(creep.room.hostiles, (hostile) => hostile.pos.getRangeTo(creep) <= 3 &&
                !neighbors.includes(hostile));
            const rangedHealing = _.sum(rangedHealers, (healer) => this.getRangedHealAmount(healer));
            return selfHealing + neighborHealing + rangedHealing;
        });
    }
    /**
     * Heal potential of self and possible healer neighbors
     */
    static avgHostileHealingTo(creeps) {
        return (_.max(_.map(creeps, (creep) => CombatIntel_1.maxHostileHealingTo(creep))) / creeps.length);
    }
    /**
     * Heal potential of self and possible healer neighbors
     */
    static maxFriendlyHealingTo(friendly) {
        const creep = toCreep(friendly);
        return this.cache(creep, "maxFriendlyHealing", () => {
            const selfHealing = this.getHealAmount(creep);
            const neighbors = _.filter(creep.room.creeps, (hostile) => hostile.pos.isNearTo(creep));
            const neighborHealing = _.sum(neighbors, (neighbor) => this.getHealAmount(neighbor));
            const rangedHealers = _.filter(creep.room.creeps, (hostile) => hostile.pos.getRangeTo(creep) <= 3 &&
                !neighbors.includes(hostile));
            const rangedHealing = _.sum(rangedHealers, (healer) => this.getHealAmount(healer));
            return selfHealing + neighborHealing + rangedHealing;
        });
    }
    /**
     * Determine the predicted damage amount of a certain type of attack. Can specify if you should use predicted or
     * current hits amount and whether to include predicted healing. Does not update predicted hits.
     */
    static predictedDamageAmount(attacker, target, attackType, useHitsPredicted = true) {
        var _a;
        // Compute initial (gross) damage amount
        let grossDamage;
        if (attackType == "attack") {
            grossDamage = this.getAttackDamage(attacker);
        }
        else if (attackType == "rangedAttack") {
            grossDamage = this.getRangedAttackDamage(attacker);
        }
        else {
            // rangedMassAttack; not currently used
            grossDamage = this.getMassAttackDamageTo(attacker, target);
        }
        // Adjust for remaining tough parts
        let toughHits;
        let damageMultiplier;
        if (isCreep(target)) {
            if (useHitsPredicted) {
                (_a = target.hitsPredicted) !== null && _a !== void 0 ? _a : (target.hitsPredicted = target.hits);
                const nonToughHits = _.sum(target.body, (part) => part.type == TOUGH ? 0 : part.hits);
                toughHits = Math.min(target.hitsPredicted - nonToughHits, 0); // predicted amount of TOUGH
            }
            else {
                toughHits = 100 * target.getActiveBodyparts(TOUGH);
            }
            damageMultiplier = this.minimumDamageTakenMultiplier(target); // assumes only 1 tier of boosts
        }
        else {
            toughHits = 0;
            damageMultiplier = 1;
        }
        if (grossDamage * damageMultiplier < toughHits) {
            // if you can't eat through armor
            return grossDamage * damageMultiplier;
        }
        else {
            // if you break tough shield
            grossDamage -= toughHits / damageMultiplier;
            return toughHits + grossDamage;
        }
    }
    // Creep position calculations =====================================================================================
    // // Distance from a given creep to the nearest rampart or wall; Infinity if no barriers in room
    // static distanceToBarrier(creep: Creep): number {
    //
    // }
    static isApproaching(approacher, toPos) {
        const previousPos = RoomIntel$1.getPreviousPos(approacher);
        const previousRange = toPos.getRangeTo(previousPos);
        const currentRange = toPos.getRangeTo(approacher.pos);
        return currentRange < previousRange;
    }
    static isRetreating(retreater, fromPos) {
        const previousPos = RoomIntel$1.getPreviousPos(retreater);
        const previousRange = fromPos.getRangeTo(previousPos);
        const currentRange = fromPos.getRangeTo(retreater.pos);
        return currentRange > previousRange;
    }
    /**
     * This method is probably expensive; use sparingly
     */
    static isEdgeDancing(creep, _reentryThreshold = 3) {
        return false;
        // TODO: rewrite this
        // if (!creep.room.my) {
        // 	log.warning(`isEdgeDancing should only be called in owned rooms!`);
        // }
        // const creepOccupancies = creep.room.memory[RMEM.CREEPS_IN_ROOM];
        // if (creepOccupancies) {
        // 	// Look to see if the creep has exited and re-entered the room a given number of times
        // 	const creepInRoomTicks = [];
        // 	for (const tick in creepOccupancies) {
        // 		if (creepOccupancies[tick].includes(creep.name)) {
        // 			creepInRoomTicks.push(parseInt(tick, 10));
        // 		}
        // 	}
        // 	let reentries = 1;
        // 	if (creepInRoomTicks.length > 0) {
        // 		for (const i of _.range(creepInRoomTicks.length - 1)) {
        // 			if (creepInRoomTicks[i + 1] != creepInRoomTicks[i] + 1) {
        // 				// There was a gap between the creep's presence in the room so it must have reentered
        // 				reentries++;
        // 			}
        // 		}
        // 	}
        // 	return reentries >= reentryThreshold;
        // } else {
        // 	return false;
        // }
    }
    static getPositionsNearEnemies(hostiles, range = 0) {
        return _.unique(_.flatten(_.map(hostiles, (hostile) => hostile.pos.getPositionsInRange(range, false, true))));
    }
};
CombatIntel$1 = CombatIntel_1 = __decorate$1([
    profile
], CombatIntel$1);
// For debugging
global.CombatIntel = CombatIntel$1;

const getDefaultSwarmMemory = () => ({
    creeps: [],
    orientation: TOP,
    numRetreats: 0,
});
const DEBUG = true;
/**
 * Swarms represent a coordinated group of creeps moving as a single unit and use special-purpose pathing and movement
 * functions to ensure they don't get separated
 */
let Swarm = class Swarm {
    constructor(overlord, ref, creeps, width = 2, height = 2) {
        this.overlord = overlord;
        this.ref = ref;
        this.memory = Mem.wrap(overlord.memory, `swarm:${ref}`, getDefaultSwarmMemory);
        // Build the static formation by putting attackers at the front and healers at the rear
        const paddedCreeps = _.clone(creeps);
        for (let i = paddedCreeps.length; i < width * height; i++) {
            paddedCreeps.push(undefined); // fill in remaining positions with undefined
        }
        const creepScores = this.getCreepScores(paddedCreeps);
        const sortedCreeps = _.sortBy(paddedCreeps, (creep) => creepScores[creep != undefined ? creep.name : "undefined"]);
        this.uniformCreepType =
            _.unique(_.filter(_.values(creepScores), (score) => score != 0))
                .length <= 1;
        this.staticFormation = _.chunk(sortedCreeps, width);
        this.width = width;
        this.height = height;
        const firstCreepIndex = _.findIndex(sortedCreeps);
        let leadPos; // upper left corner of formation when in TOP orientation
        if (firstCreepIndex != -1) {
            const firstCreepPos = sortedCreeps[firstCreepIndex].pos;
            const dx = firstCreepIndex % width;
            const dy = Math.floor(firstCreepIndex / width);
            leadPos = firstCreepPos.getOffsetPos(-dx, -dy);
        }
        else {
            leadPos = this.overlord.pos;
        }
        switch (this.orientation) {
            case TOP:
                this.anchor = leadPos;
                break;
            case RIGHT:
                this.anchor = leadPos.getOffsetPos(-1 * (height - 1), 0);
                break;
            case BOTTOM:
                this.anchor = leadPos.getOffsetPos(-1 * (width - 1), -1 * (height - 1));
                break;
            case LEFT:
                this.anchor = leadPos.getOffsetPos(0, -1 * (width - 1));
                break;
        }
        this.formation = rotatedMatrix(this.staticFormation, this.rotationsFromOrientation(this.orientation));
        this.creeps = creeps;
        this.rooms = _.unique(_.map(this.creeps, (creep) => creep.room), (room) => room.name);
        this.roomsByName = _.zipObject(_.map(this.rooms, (room) => [room.name, room]));
        this.fatigue = _.max(_.map(this.creeps, (creep) => creep.fatigue));
        this.debug(`\n${this.print} tick ${Game.time} ========================================`);
        // this.debug(`Orientation: ${this.orientation}, anchor: ${this.anchor.print}, leadPos: ${leadPos.print}`);
        // this.debug(`Formation: ${this.printFormation(this.formation)}`);
        // this.debug(`StaticFormation: ${this.printFormation(this.staticFormation)}`);
    }
    getCreepScores(creeps) {
        const keys = _.map(creeps, (c) => c != undefined ? c.name : "undefined");
        const values = _.map(creeps, (z) => {
            if (z == undefined) {
                return 0;
            }
            else {
                const score = CombatIntel$1.getAttackPotential(z.creep) +
                    CombatIntel$1.getRangedAttackPotential(z.creep) +
                    CombatIntel$1.getDismantlePotential(z.creep) -
                    CombatIntel$1.getHealPotential(z.creep);
                return -1 * score || 1;
            }
        });
        return _.zipObject(keys, values);
    }
    printFormation(formation) {
        const names = _.map(formation, (creeps) => _.map(creeps, (creep) => (creep ? creep.name : "NONE")));
        const SPACE = "    ";
        let msg = "";
        for (const row of names) {
            msg += "\n" + SPACE;
            for (const name of row) {
                if (name != "NONE") {
                    const role = name.split("_")[0];
                    const num = name.split("_")[1];
                    const shortName = role.slice(0, 4 - num.length) + num;
                    msg += shortName;
                }
                else {
                    msg += name;
                }
                msg += " ";
            }
        }
        return msg;
    }
    get print() {
        return ('<a href="#!/room/' +
            Game.shard.name +
            "/" +
            (this.anchor || this.rooms[0]).roomName +
            '">[' +
            `Swarm ` +
            this.ref +
            "]</a>");
    }
    debug(...args) {
        {
            console.log(args);
        }
    }
    // This should occasionally be executed at run() phase
    static cleanMemory(overlord) {
        for (const _ref in overlord.swarms) {
            // TODO
        }
    }
    get target() {
        if (this.memory.target && this.memory.target.exp > Game.time) {
            const target = Game.getObjectById(this.memory.target.id);
            if (target) {
                return target;
            }
        }
        // If nothing found
        delete this.memory.target;
    }
    set target(targ) {
        if (targ) {
            this.memory.target = { id: targ.id, exp: getCacheExpiration(100) };
        }
        else {
            delete this.memory.target;
        }
    }
    get orientation() {
        return this.memory.orientation;
    }
    set orientation(direction) {
        this.memory.orientation = direction;
        this.formation = rotatedMatrix(this.staticFormation, this.rotationsFromOrientation(direction));
    }
    /**
     * Pivots the swarm formation clockwise or counterclockwise
     */
    pivot(direction) {
        if (this.fatigue > 0) {
            return ERR_TIRED;
        }
        this.debug(`Rotating ${direction}`);
        const [[c1, c2], [c3, c4]] = this.formation;
        this.debug(`c1...c4: ${this.printFormation([
            [c1, c2],
            [c3, c4],
        ])}`);
        let r1, r2, r3, r4 = OK;
        if (direction == "clockwise") {
            if (c1) {
                r1 = c1.move(RIGHT);
            }
            if (c2) {
                r2 = c2.move(BOTTOM);
            }
            if (c3) {
                r3 = c3.move(TOP);
            }
            if (c4) {
                r4 = c4.move(LEFT);
            }
        }
        else {
            if (c1) {
                r1 = c1.move(BOTTOM);
            }
            if (c2) {
                r2 = c2.move(LEFT);
            }
            if (c3) {
                r3 = c3.move(RIGHT);
            }
            if (c4) {
                r4 = c4.move(TOP);
            }
        }
        const allMoved = _.all([r1, r2, r3, r4], (r) => r == OK);
        if (allMoved) {
            return OK;
        }
        else {
            for (const creep of this.creeps) {
                creep.cancelOrder("move");
            }
            return (-1 * _.findIndex([r1, r2, r3, r4], (r) => r != OK) +
                ERR_SWARM_ROTATE_FAILED_1);
        }
    }
    /**
     * Reverses the orientation of the swarm formation in an X pattern to preserve the reflective parity of the
     * original formation
     */
    swap(direction) {
        if (this.fatigue > 0) {
            return ERR_TIRED;
        }
        this.debug(`Swapping ${direction}ly`);
        const [[c1, c2], [c3, c4]] = this.formation;
        this.debug(`c1...c4: ${this.printFormation([
            [c1, c2],
            [c3, c4],
        ])}`);
        let r1, r2, r3, r4 = OK;
        // This operation is actually the same for both horizontal and vertical swaps
        if (c1) {
            r1 = c1.move(BOTTOM_RIGHT);
        }
        if (c2) {
            r2 = c2.move(BOTTOM_LEFT);
        }
        if (c3) {
            r3 = c3.move(TOP_RIGHT);
        }
        if (c4) {
            r4 = c4.move(TOP_LEFT);
        }
        const allMoved = _.all([r1, r2, r3, r4], (r) => r == OK);
        if (allMoved) {
            return OK;
        }
        else {
            for (const creep of this.creeps) {
                creep.cancelOrder("move");
            }
            return (-1 * _.findIndex([r1, r2, r3, r4], (r) => r != OK) +
                ERR_SWARM_ROTATE_FAILED_1);
        }
    }
    rotate(direction) {
        if (direction == this.orientation) {
            // do nothing
            return NO_ACTION;
        }
        if (!(this.width == 2 && this.height == 2)) {
            console.log("NOT IMPLEMENTED FOR LARGER SWARMS YET");
            return ERR_NOT_IMPLEMENTED;
        }
        let ret = OK;
        if (this.fatigue > 0) {
            ret = ERR_TIRED;
        }
        else {
            const prevDirection = this.orientation;
            this.formation;
            const prevAngle = this.rotationsFromOrientation(prevDirection);
            const newAngle = this.rotationsFromOrientation(direction);
            const rotateAngle = newAngle - prevAngle;
            if (rotateAngle == 3 || rotateAngle == -1) {
                ret = this.pivot("counterclockwise");
            }
            else if (rotateAngle == 1 || rotateAngle == -3) {
                ret = this.pivot("clockwise");
            }
            else if (rotateAngle == 2 || rotateAngle == -2) {
                if (newAngle % 2 == 0) {
                    ret = this.swap("vertical");
                }
                else {
                    ret = this.swap("horizontal");
                }
            }
            if (ret == OK) {
                this.orientation = direction;
            }
        }
        this.debug(`Rotating to ${direction}, result: ${errorForCode(ret)}`);
        return ret;
    }
    /**
     * Number of clockwise 90 degree turns corresponding to an orientation
     */
    rotationsFromOrientation(direction) {
        switch (direction) {
            case TOP:
                return 0;
            case RIGHT:
                return 1;
            case BOTTOM:
                return 2;
            case LEFT:
                return 3;
        }
    }
    // Swarm assignment ================================================================================================
    // Range finding methods ===========================================================================================
    minRangeTo(obj) {
        if (hasPos(obj)) {
            return _.min(_.map(this.creeps, (creep) => creep.pos.roomName === obj.pos.roomName ?
                creep.pos.getRangeToXY(obj.pos.x, obj.pos.y)
                : Infinity));
        }
        else {
            return _.min(_.map(this.creeps, (creep) => creep.pos.roomName === obj.roomName ?
                creep.pos.getRangeToXY(obj.x, obj.y)
                : Infinity));
        }
    }
    maxRangeTo(obj) {
        if (hasPos(obj)) {
            return _.max(_.map(this.creeps, (creep) => creep.pos.roomName === obj.pos.roomName ?
                creep.pos.getRangeToXY(obj.pos.x, obj.pos.y)
                : Infinity));
        }
        else {
            return _.max(_.map(this.creeps, (creep) => creep.pos.roomName === obj.roomName ?
                creep.pos.getRangeToXY(obj.x, obj.y)
                : Infinity));
        }
    }
    findInMinRange(targets, range) {
        const initialRange = range + Math.max(this.width, this.height) - 1;
        const targetsInRange = _.filter(targets, (t) => this.anchor.inRangeToXY(t.pos.x, t.pos.y, initialRange));
        return _.filter(targetsInRange, (t) => this.minRangeTo(t) <= range);
    }
    /**
     * Compute the "average" direction to a target
     */
    getDirectionTo(obj) {
        normalizePos(obj);
        _.map(this.creeps, (creep) => creep.pos.getDirectionTo(obj));
        // TODO
        log.warning(`NOT IMPLEMENTED`);
        return TOP;
    }
    // Formation methods ===============================================================================================
    /**
     * Generates a table of formation positions for each creep
     */
    getFormationPositionsFromAnchor(anchor) {
        const formationPositions = {};
        for (let dy = 0; dy < this.formation.length; dy++) {
            for (let dx = 0; dx < this.formation[dy].length; dx++) {
                if (this.formation[dy][dx]) {
                    formationPositions[this.formation[dy][dx].name] =
                        anchor.getOffsetPos(dx, dy);
                }
            }
        }
        // this.debug(`Formation positions: `, JSON.stringify(formationPositions));
        return formationPositions;
    }
    /**
     * Returtn whether every creep in the swarm is in the position dictated by formation
     */
    isInFormation(anchor = this.anchor) {
        const formationPositions = this.getFormationPositionsFromAnchor(anchor);
        return _.all(this.creeps, (creep) => creep.pos.isEqualTo(formationPositions[creep.name]));
    }
    get hasMaxCreeps() {
        return this.creeps.length == this.width * this.height;
    }
    /**
     * Returns true if the swarm has lost a creep and the oldest living creep is too old to partner with a new one
     */
    get isExpired() {
        if (!this.hasMaxCreeps) {
            const minTicksToLive = _.min(_.map(this.creeps, (creep) => creep.ticksToLive || 9999)) || 0;
            const spawnBuffer = 150 + 25;
            const newCreepTicksToLive = CREEP_LIFE_TIME + spawnBuffer; // TTL of a creep spawned right now
            return (newCreepTicksToLive - minTicksToLive >=
                DEFAULT_SWARM_TICK_DIFFERENCE);
        }
        else {
            return false;
        }
    }
    get inMultipleRooms() {
        return _.keys(this.roomsByName).length > 1;
    }
    /**
     * Assemble the swarm at the target location
     */
    assemble(assemblyPoint, allowIdleCombat = true) {
        if (this.isInFormation(assemblyPoint) && this.hasMaxCreeps) {
            this.memory.initialAssembly = true;
            return true;
        }
        else {
            // Creeps travel to their relative formation positions
            const formationPositions = this.getFormationPositionsFromAnchor(assemblyPoint);
            console.log(`assemble: ${JSON.stringify(formationPositions)}`);
            for (const creep of this.creeps) {
                if (creep.hasValidTask || creep.spawning) {
                    // Ignore creeps which have tasks (usually getting boosted)
                    continue;
                }
                if (allowIdleCombat &&
                    creep.room.dangerousPlayerHostiles.length > 0 &&
                    !this.hasMaxCreeps) {
                    creep.autoSkirmish(creep.room.name);
                }
                else {
                    const destination = formationPositions[creep.name];
                    const ret = creep.goTo(destination, {
                        noPush: creep.pos.inRangeToPos(destination, 5),
                        ignoreCreepsOnDestination: true,
                    });
                    console.log(`${creep.print} moves to ${destination.print}, response: ${errorForCode(ret)}`);
                }
            }
            return false;
        }
    }
    findRegroupPosition() {
        let x, y;
        const MAX_RADIUS = 10;
        for (let radius = 0; radius < MAX_RADIUS; radius++) {
            for (let dx = -radius; dx <= radius; dx++) {
                for (let dy = -radius; dy <= radius; dy++) {
                    if (Math.abs(dy) !== radius && Math.abs(dx) !== radius) {
                        continue;
                    }
                    x = this.anchor.x + dx;
                    y = this.anchor.y + dy;
                    if (x < 0 || x > 49 || y < 0 || y > 49) {
                        continue;
                    }
                    let allPathable = true;
                    const pos = new RoomPosition(x, y, this.anchor.roomName);
                    for (let i = 0; i < this.formation.length; i++) {
                        for (let j = 0; j < this.formation[i].length; j++) {
                            if (!pos.getOffsetPos(i, j).isWalkable(true)) {
                                allPathable = false;
                            }
                        }
                    }
                    if (allPathable) {
                        return pos;
                    }
                }
            }
        }
        // Should never reach here!
        return new RoomPosition(-10, -10, "cannotFindLocationPosition");
    }
    /**
     * Try to re-assemble the swarm at the nearest possible location in case it broke formation
     */
    regroup() {
        if (this.isInFormation(this.anchor)) {
            return true;
        }
        else {
            const regroupPosition = this.findRegroupPosition();
            this.debug(`Reassembling at ${regroupPosition.print}`);
            return this.assemble(regroupPosition, false);
        }
    }
    // Movement methods ================================================================================================
    move(direction) {
        let allMoved = true;
        for (const creep of this.creeps) {
            const result = creep.move(direction);
            this.debug(`${creep.print} move ${direction}, result: ${result}`);
            if (result != OK) {
                allMoved = false;
            }
        }
        if (!allMoved) {
            for (const creep of this.creeps) {
                creep.cancelOrder("move");
            }
        }
        return allMoved ? OK : ERR_SWARM_BUSY;
    }
    goTo(destination, options = {}) {
        _.defaultsDeep(options, {
            pathOpts: { allowHostile: true },
        });
        return Movement.swarmMove(this, destination, options);
    }
    goToRoom(roomName, options = {}) {
        _.defaultsDeep(options, {
            pathOpts: { allowHostile: true },
        });
        return Movement.goToRoom_swarm(this, roomName, options);
    }
    combatMove(approach, avoid, options = {}) {
        // if (DEBUG) {
        // 	options.displayAvoid = true;
        // }
        const ret = Movement.swarmCombatMove(this, approach, avoid, options);
        this.debug(`Moving... Result: ${ret}`);
        return ret;
    }
    safelyInRoom(roomName) {
        return _.all(this.creeps, (creep) => creep.safelyInRoom(roomName));
    }
    // private getBestSiegeOrientation(room: Room): TOP | RIGHT | BOTTOM | LEFT {
    // 	let targets: HasPos[] = [];
    // 	let structureTargets = this.findInMinRange(room.hostileStructures, 1);
    // 	for (let structure of structureTargets) {
    // 		targets.push(structure);
    // 	}
    // 	this.debug(`Targets: `, _.map(targets, t => t.pos.print));
    // 	if (targets.length == 0) {
    // 		return this.orientation;
    // 	}
    // 	let dxList = _.flatten(_.map(this.creeps,
    // 								 creep => _.map(targets,
    // 												target => target.pos.x - creep.pos.x))) as number[];
    // 	let dyList = _.flatten(_.map(this.creeps,
    // 								 creep => _.map(targets,
    // 												target => target.pos.y - creep.pos.y))) as number[];
    // 	let dx = _.sum(dxList) / dxList.length || 0;
    // 	let dy = _.sum(dyList) / dyList.length || 0;
    // 	this.debug(`dx: ${dx}, dy: ${dy}`);
    // 	if (Math.abs(dx) > Math.abs(dy)) {
    // 		return dx > 0 ? RIGHT : LEFT;
    // 	} else {
    // 		return dy > 0 ? BOTTOM : TOP;
    // 	}
    // }
    reorient(includeStructures = true, includeCreeps = false) {
        if (this.uniformCreepType) {
            return NO_ACTION;
        }
        const targetRoom = _.find(this.rooms, (room) => room.owner && !room.my);
        if (targetRoom) {
            const orientation = this.getBestOrientation(targetRoom, includeStructures, includeCreeps);
            if (orientation != this.orientation && this.fatigue == 0) {
                this.debug(`Reorienting to ${orientation}!`);
                return this.rotate(orientation);
            }
        }
        return NO_ACTION;
    }
    getBestOrientation(room, includeStructures = true, includeCreeps = false) {
        const targets = [];
        if (includeStructures) {
            const structureTargets = this.findInMinRange(room.hostileStructures, 1);
            for (const structure of structureTargets) {
                targets.push(structure);
            }
        }
        if (includeCreeps) {
            const creepTargets = this.findInMinRange(room.dangerousHostiles, 2);
            for (const creep of creepTargets) {
                targets.push(creep);
            }
        }
        this.debug(`Targets: `, _.map(targets, (t) => t.pos.print));
        if (targets.length == 0) {
            return this.orientation;
        }
        const dxList = _.flatten(_.map(this.creeps, (creep) => _.map(targets, (target) => target.pos.x - creep.pos.x)));
        const dyList = _.flatten(_.map(this.creeps, (creep) => _.map(targets, (target) => target.pos.y - creep.pos.y)));
        const dx = _.sum(dxList) / dxList.length || 0;
        const dy = _.sum(dyList) / dyList.length || 0;
        this.debug(`dx: ${dx}, dy: ${dy}`);
        if (Math.abs(dx) > Math.abs(dy)) {
            return dx > 0 ? RIGHT : LEFT;
        }
        else {
            return dy > 0 ? BOTTOM : TOP;
        }
    }
    // Auto-combat methods =============================================================================================
    /**
     * Automatically melee-attack the best creep in range
     */
    autoMelee() {
        for (const creep of this.creeps) {
            if (creep.getActiveBodyparts(ATTACK) > 0) {
                creep.autoMelee();
            }
        }
    }
    /**
     * Automatically ranged-attack the best creep in range
     */
    autoRanged() {
        for (const creep of this.creeps) {
            if (creep.getActiveBodyparts(RANGED_ATTACK) > 0) {
                creep.autoRanged();
            }
        }
    }
    /**
     * Automatically heal the best creep in range
     */
    autoHeal(allowRangedHeal = true) {
        for (const creep of this.creeps) {
            if (creep.getActiveBodyparts(HEAL) > 0) {
                creep.autoHeal(allowRangedHeal);
            }
        }
    }
    /**
     * Standard sequence of actions for sieging a room. Assumes the swarm has already initially assembled.
     */
    autoSiege(roomName, waypoint) {
        this.autoMelee();
        this.autoRanged();
        this.autoHeal();
        if (!this.isInFormation()) {
            this.debug(`Regrouping!`);
            if (!_.any(this.creeps, (creep) => creep.pos.isEdge)) {
                return this.regroup() ? OK : ERR_BUSY;
            }
        }
        // Handle recovery if low on HP
        if (this.needsToRecover()) {
            this.debug(`Recovering!`);
            this.target = undefined; // invalidate target
            return this.recover();
        }
        // Travel to the target room
        if (!this.safelyInRoom(roomName)) {
            if (waypoint) {
                return this.goTo(waypoint);
            }
            else {
                return this.goToRoom(roomName);
            }
        }
        // Find a target if needed
        if (!this.target) {
            const displayCostMatrix = DEBUG;
            this.target = CombatTargeting.findBestSwarmStructureTarget(this, roomName, 10 * this.memory.numRetreats, displayCostMatrix);
            this.debug(this.target);
        }
        // Approach the siege target
        if (this.target) {
            // let approach = _.map(Pathing.getPosWindow(this.target.pos, -this.width, -this.height),
            // 					 pos => ({pos: pos, range: 1}));
            const result = this.combatMove([{ pos: this.target.pos, range: 1 }], []);
            if (result != NO_ACTION) {
                this.debug(`Moving to target ${this.target}: ${errorForCode(result)}`);
                return result;
            }
        }
        else {
            log.warning(`No target for swarm ${this.ref}!`);
        }
        // Orient yourself to face structure targets
        return this.reorient(true, false);
    }
    /**
     * Standard sequence of actions for fighting within a room. Assumes the swarm has already initially assembled.
     */
    autoCombat(roomName, waypoint) {
        this.debug(`Running autocombat!`);
        this.autoMelee();
        this.autoRanged();
        this.autoHeal();
        if (!this.isInFormation()) {
            this.debug(`Regrouping!`);
            if (!_.any(this.creeps, (creep) => creep.pos.isEdge)) {
                return this.regroup() ? OK : ERR_BUSY;
            }
        }
        // Handle recovery if low on HP
        if (this.needsToRecover()) {
            this.debug(`Recovering!`);
            this.target = undefined; // invalidate target
            return this.recover();
        }
        // Travel to the target room
        if (!this.safelyInRoom(roomName)) {
            this.debug(`Going to room!`);
            // if (this.rooms[0].dangerousHostiles.length > 0) {
            //
            // } else {
            //
            // }
            if (waypoint) {
                return this.goTo(waypoint);
            }
            else {
                return this.goToRoom(roomName);
            }
        }
        // Maneuver around the room
        const goals = GoalFinder.swarmCombatGoals(this, true);
        this.debug(`Goals: ${JSON.stringify(goals)}`);
        if (_.any(goals.avoid, (goal) => this.minRangeTo(goal) <= goal.range)) {
            // If creeps nearby, try to flee first, then reorient
            let result = this.combatMove(goals.approach, goals.avoid);
            if (result != OK) {
                result = this.reorient(true, true);
            }
            return result;
        }
        else {
            // Otherwise try to reorient first then move
            let result = this.reorient(true, true);
            if (result != OK) {
                result = this.combatMove(goals.approach, goals.avoid);
            }
            return result;
        }
    }
    needsToRecover(recoverThreshold = 0.75, reengageThreshold = 1.0) {
        let recovering;
        if (this.memory.recovering) {
            recovering = _.any(this.creeps, (creep) => creep.hits < creep.hitsMax * reengageThreshold);
        }
        else {
            recovering = _.any(this.creeps, (creep) => creep.hits < creep.hitsMax * recoverThreshold);
        }
        if (recovering && recovering != this.memory.recovering) {
            this.memory.numRetreats++;
        }
        this.memory.recovering = recovering;
        return recovering;
    }
    recover() {
        const allHostiles = _.flatten(_.map(this.rooms, (room) => room.hostiles));
        const allTowers = _.flatten(_.map(this.rooms, (room) => room.owner && !room.my ? room.towers : []));
        if (_.filter(allHostiles, (h) => this.minRangeTo(h)).length > 0 ||
            allTowers.length > 0) {
            this.memory.lastInDanger = Game.time;
        }
        const allAvoidGoals = _.flatten(_.map(this.rooms, (room) => GoalFinder.retreatGoalsForRoom(room).avoid));
        const result = Movement.swarmCombatMove(this, [], allAvoidGoals);
        if (result == NO_ACTION) {
            const safeRoom = _.first(_.filter(this.rooms, (room) => !room.owner || room.my));
            if (safeRoom && !this.safelyInRoom(safeRoom.name)) {
                if (Game.time < (this.memory.lastInDanger || 0) + 3) {
                    return this.goToRoom(safeRoom.name);
                }
            }
        }
        return result;
    }
    // Simulated swarms ================================================================================================
    /**
     * Groups enemies into proto-swarms based on proximity to each other
     */
    static findEnemySwarms(room, anchor, maxClumpSize = 3) {
        const enemySwarms = [];
        const origin = anchor ||
            _.first(room.spawns) ||
            room.controller || { pos: new RoomPosition(25, 25, room.name) };
        let attackers = _.sortBy(room.dangerousHostiles, (creep) => origin.pos.getRangeTo(creep));
        while (attackers.length > 0) {
            const clump = _.first(attackers).pos.findInRange(attackers, maxClumpSize);
            attackers = _.difference(attackers, clump);
            enemySwarms.push({ creeps: clump });
        }
        return enemySwarms;
    }
};
Swarm = __decorate$1([
    profile
], Swarm);

let GoalFinder = class GoalFinder {
    // Standard set of goals for fighting small groups of hostiles (not optimal for larger fights)
    static skirmishGoals(zerg) {
        const approach = [];
        const avoid = [];
        const room = zerg.room;
        const analysis = {};
        const myAttack = CombatIntel$1.getAttackDamage(zerg);
        const myRangedAttack = CombatIntel$1.getRangedAttackDamage(zerg);
        const myHealing = CombatIntel$1.getHealAmount(zerg);
        // If you're purely a healer, ignore combat goals
        if (myHealing > 0 && myAttack == 0 && myRangedAttack == 0) {
            return this.healingGoals(zerg);
        }
        const preferCloseCombat = myAttack > 0;
        const myRating = CombatIntel$1.rating(zerg);
        const nearbyRating = _.sum(zerg.pos.findInRange(room.creeps, 6), (c) => CombatIntel$1.rating(c));
        const braveMode = zerg.hits * (nearbyRating / myRating) * 0.5 > zerg.hitsMax;
        const hostileHealers = [];
        // Analyze capabilities of hostile creeps in the room
        for (const hostile of room.hostiles) {
            if (hostile.owner.username == "Source Keeper") {
                continue;
            }
            const attack = CombatIntel$1.getAttackDamage(hostile);
            const rangedAttack = CombatIntel$1.getRangedAttackDamage(hostile);
            const healing = CombatIntel$1.getHealAmount(hostile);
            if (healing > 0 && attack == 0 && rangedAttack == 0) {
                hostileHealers.push(hostile);
            }
            analysis[hostile.id] = {
                attack: attack,
                rangedAttack: rangedAttack,
                heal: healing,
                advantage: healing == 0 ||
                    attack + rangedAttack == 0 ||
                    myAttack +
                        myRangedAttack +
                        myHealing /
                            CombatIntel$1.minimumDamageTakenMultiplier(zerg.creep) >
                        attack +
                            rangedAttack +
                            healing /
                                CombatIntel$1.minimumDamageTakenMultiplier(hostile),
                isRetreating: CombatIntel$1.isRetreating(hostile, RoomIntel$1.getPreviousPos(zerg.creep)),
                isApproaching: CombatIntel$1.isApproaching(hostile, RoomIntel$1.getPreviousPos(zerg.creep)),
            };
        }
        // Generate list of targets to approach and respective ranges to keep them at
        const approachTargets = hostileHealers.length > 0 ? hostileHealers : room.hostiles;
        for (const target of approachTargets) {
            const data = analysis[target.id];
            if (data && (data.advantage || braveMode)) {
                let range = 1;
                if (!preferCloseCombat &&
                    (data.attack > 0 || data.rangedAttack > myRangedAttack)) {
                    range =
                        zerg.pos.getRangeTo(target) == 3 && data.isRetreating ?
                            2
                            : 3;
                    avoid.push({ pos: target.pos, range: range });
                }
                approach.push({ pos: target.pos, range: range });
            }
        }
        // If there's nothing left to approach, group up with other creeps
        if (approach.length == 0) {
            for (const friendly of room.creeps) {
                approach.push({ pos: friendly.pos, range: 0 });
            }
        }
        // Avoid hostiles that are significantly better than you
        for (const target of room.hostiles) {
            const data = analysis[target.id];
            if (data && !data.advantage && !braveMode) {
                let range = data.isApproaching ? 3 : 2;
                if (data.rangedAttack > 0) {
                    range = 8;
                }
                avoid.push({ pos: target.pos, range: range });
            }
        }
        log.debugCreep(zerg, () => {
            const debugAnalysis = entries(analysis).map(([t, a]) => Object.assign({ target: t }, a));
            return `Skirmish goals:\n${columnify$1(debugAnalysis)}\nApproach:\n${columnify$1(approach)}\nAvoid:\n${columnify$1(avoid)}`;
        });
        return { approach, avoid };
    }
    static swarmCombatGoals(swarm, includeStructures = true) {
        const approach = [];
        const avoid = [];
        if (swarm.rooms.length > 1) {
            log.warning(`Swarm in more than 1 room!`);
        }
        // If in more than 1 room, pick the room with more hostile stuff in it
        const room = maxBy(swarm.rooms, (room) => room.hostiles.length + room.hostileStructures.length);
        const myAttack = _.sum(swarm.creeps, (creep) => CombatIntel$1.getAttackDamage(creep));
        const myRangedAttack = _.sum(swarm.creeps, (creep) => CombatIntel$1.getRangedAttackDamage(creep));
        const myHealing = _.sum(swarm.creeps, (creep) => CombatIntel$1.getHealAmount(creep));
        const myDamageMultiplier = CombatIntel$1.minimumDamageMultiplierForGroup(_.map(swarm.creeps, (c) => c.creep));
        const preferCloseCombat = myAttack > myRangedAttack;
        _.sum(swarm.creeps, (creep) => CombatIntel$1.rating(creep));
        const hostileSwarms = Swarm.findEnemySwarms(room, {
            pos: swarm.anchor,
        });
        // Analyze capabilities of hostile creeps in the room
        for (const swarms of hostileSwarms) {
            const hostiles = swarms.creeps;
            const attack = _.sum(hostiles, (creep) => CombatIntel$1.getAttackDamage(creep));
            const rangedAttack = _.sum(hostiles, (creep) => CombatIntel$1.getRangedAttackDamage(creep));
            const healing = _.sum(hostiles, (creep) => CombatIntel$1.getHealAmount(creep));
            const damageMultiplier = CombatIntel$1.minimumDamageMultiplierForGroup(hostiles);
            const canPopShield = (attack +
                rangedAttack +
                CombatIntel$1.towerDamageAtPos(swarm.anchor)) *
                myDamageMultiplier >
                _.min(_.map(swarm.creeps, (creep) => 100 * creep.getActiveBodyparts(TOUGH)));
            const isRetreating = _.sum(hostiles, (creep) => +CombatIntel$1.isRetreating(creep, swarm.anchor)) /
                hostiles.length >=
                0.5;
            const isApproaching = _.sum(hostiles, (creep) => +CombatIntel$1.isApproaching(creep, swarm.anchor)) /
                hostiles.length >=
                0.5;
            const advantage = healing == 0 ||
                attack + rangedAttack == 0 ||
                myAttack + myRangedAttack + myHealing / myDamageMultiplier >
                    attack + rangedAttack + healing / damageMultiplier;
            for (const hostile of hostiles) {
                if (canPopShield &&
                    hostile.pos.lookForStructure(STRUCTURE_RAMPART)) {
                    let range = (rangedAttack > attack || !preferCloseCombat ? 3 : 1) +
                        1;
                    if (CombatIntel$1.isApproaching(hostile, swarm.anchor)) {
                        range += 1;
                    }
                    avoid.push({ pos: hostile.pos, range: range });
                }
                else {
                    if (advantage) {
                        let range = preferCloseCombat ? 3 : 1;
                        if (!preferCloseCombat &&
                            (attack > 0 || rangedAttack > myAttack)) {
                            range =
                                swarm.minRangeTo(hostile) == 3 && isRetreating ?
                                    2
                                    : 3;
                            avoid.push({ pos: hostile.pos, range: range });
                        }
                        approach.push({ pos: hostile.pos, range: range });
                    }
                    else {
                        let range = isApproaching ? 3 : 2;
                        if (rangedAttack > attack) {
                            range = 5;
                        }
                        avoid.push({ pos: hostile.pos, range: range });
                    }
                }
            }
        }
        if (includeStructures) {
            const approachStructures = [];
            for (const structure of room.hostileStructures) {
                approachStructures.push(structure);
            }
            for (const wall of room.walls) {
                approachStructures.push(wall);
            }
            for (const approachStructure of approachStructures) {
                approach.push({ pos: approachStructure.pos, range: 1 });
            }
        }
        log.debugCreep(swarm.creeps[0], () => {
            return `Swarm combat goals:\nApproach:\n${columnify$1(approach)}\nAvoid:\n${columnify$1(avoid)}`;
        });
        return { approach, avoid };
    }
    static retreatGoals(creep) {
        const approach = [];
        const avoid = [];
        const isHealer = CombatIntel$1.isHealer(creep);
        for (const friendly of creep.room.creeps) {
            if (CombatIntel$1.getHealPotential(friendly) > 0 ||
                (isHealer && isCombatZerg(creep))) {
                approach.push({ pos: friendly.pos, range: 1 });
            }
        }
        for (const hostile of creep.room.hostiles) {
            if (CombatIntel$1.getAttackPotential(hostile) > 0 ||
                CombatIntel$1.getRangedAttackPotential(hostile) > 0) {
                avoid.push({ pos: hostile.pos, range: 8 });
            }
        }
        if (creep.room.owner && !creep.room.my) {
            for (const tower of creep.room.towers) {
                avoid.push({ pos: tower.pos, range: 50 });
            }
        }
        return { approach, avoid };
    }
    static retreatGoalsForRoom(room) {
        const avoid = [];
        for (const hostile of room.hostiles) {
            if (CombatIntel$1.getAttackPotential(hostile) > 0 ||
                CombatIntel$1.getRangedAttackPotential(hostile) > 0) {
                avoid.push({ pos: hostile.pos, range: 8 });
            }
        }
        if (room.owner && !room.my) {
            for (const tower of room.towers) {
                avoid.push({ pos: tower.pos, range: 50 });
            }
        }
        return { approach: [], avoid: avoid };
    }
    static healingGoals(healer) {
        const approach = [];
        const avoid = [];
        const healAmount = CombatIntel$1.getHealAmount(healer);
        let target = minBy(_.filter(healer.room.creeps, (c) => c.hits < c.hitsMax), (c) => c.hits + healer.pos.getRangeTo(c));
        if (!target) {
            target = minBy(healer.room.creeps, (creep) => {
                const range = healer.pos.getRangeTo(creep);
                return range > 0 ?
                    CombatIntel$1.maxFriendlyHealingTo(creep) / healAmount +
                        range
                    : false;
            });
        }
        if (target) {
            approach.push({ pos: target.pos, range: 0 });
        }
        for (const hostile of healer.room.hostiles) {
            const meleeDamage = CombatIntel$1.getAttackDamage(hostile);
            const rangedDamage = CombatIntel$1.getRangedAttackDamage(hostile);
            if (meleeDamage + rangedDamage > 0) {
                const range = rangedDamage > healAmount ? 4 : 3;
                avoid.push({ pos: hostile.pos, range: range });
            }
        }
        return { approach, avoid };
    }
    static structureGoals(_creep) {
        const approach = [];
        // // TODO: finish this
        // let range = CombatIntel.getAttackDamage(creep) > 0 || CombatIntel.getDismantleDamage(creep) > 0 ? 1 : 3;
        // let structureTarget = CombatTargeting.findBestStructureTarget(creep);
        // if (structureTarget) {
        // 	approach.push({pos: structureTarget.pos, range: range});
        // }
        log.error(`NOT IMPLEMENTED`);
        return { approach: approach, avoid: [] };
    }
};
GoalFinder = __decorate$1([
    profile
], GoalFinder);
global.GoalFinder = GoalFinder;

const DEFAULT_PARTNER_TICK_DIFFERENCE = 650;
const DEFAULT_SWARM_TICK_DIFFERENCE = 500;
/**
 * CombatZerg is an extension of the Zerg class which contains additional combat-related methods
 */
let CombatZerg = class CombatZerg extends Zerg {
    constructor(creep, notifyWhenAttacked = true) {
        super(creep, notifyWhenAttacked);
        this.isCombatZerg = true;
        _.defaults(this.memory, {
            recovering: false,
            lastInDanger: 0,
            targets: {},
        });
    }
    findPartner(partners, tickDifference = DEFAULT_PARTNER_TICK_DIFFERENCE) {
        if (this.memory.partner) {
            const partner = _.find(partners, (partner) => partner.name == this.memory.partner);
            if (partner) {
                return partner;
            }
            else {
                delete this.memory.partner;
                this.findPartner(partners, tickDifference);
            }
        }
        else {
            let partner = _.find(partners, (partner) => partner.memory.partner == this.name);
            if (!partner) {
                partner = _(partners)
                    .filter((partner) => !partner.memory.partner &&
                    Math.abs((this.ticksToLive || CREEP_LIFE_TIME) -
                        (partner.ticksToLive || CREEP_LIFE_TIME)) <= tickDifference)
                    .min((partner) => Math.abs((this.ticksToLive || CREEP_LIFE_TIME) -
                    (partner.ticksToLive || CREEP_LIFE_TIME)));
            }
            if (_.isObject(partner)) {
                this.memory.partner = partner.name;
                partner.memory.partner = this.name;
                return partner;
            }
        }
    }
    findSwarm(partners, maxByRole, tickDifference = DEFAULT_SWARM_TICK_DIFFERENCE) {
        if (this.memory.swarm) {
            return this.memory.swarm;
        }
        else {
            // Find a swarm that isn't too old and that has space for the creep's role
            const partnersBySwarm = _.groupBy(partners, (partner) => partner.memory.swarm);
            for (const swarmRef in partnersBySwarm) {
                if (swarmRef == undefined || swarmRef == "undefined") {
                    continue;
                }
                if (_.all(partnersBySwarm[swarmRef], (c) => Math.abs((this.ticksToLive || CREEP_LIFE_TIME) -
                    (c.ticksToLive || CREEP_LIFE_TIME)) <= tickDifference)) {
                    const swarmCreepsByRole = _.groupBy(partnersBySwarm[swarmRef], (c) => c.memory.role);
                    if ((swarmCreepsByRole[this.memory.role] || []).length +
                        1 <=
                        maxByRole[this.memory.role]) {
                        this.memory.swarm = swarmRef;
                        return swarmRef;
                    }
                }
            }
            // Otherwise just make a new swarm ref
            const newSwarmRef = randomHex(6);
            this.memory.swarm = newSwarmRef;
            return newSwarmRef;
        }
    }
    /**
     * Returns true if there is a target for medic actions, otherwise false
     */
    doMedicActions(roomName) {
        // Travel to the target room
        if (!this.safelyInRoom(roomName)) {
            this.goToRoom(roomName, { pathOpts: { ensurePath: true } });
            return true; // en route
        }
        // Heal friendlies
        const target = CombatTargeting.findClosestHurtFriendly(this);
        if (target) {
            // Approach the target
            const range = this.pos.getRangeTo(target);
            if (range > 1) {
                this.goTo(target, { movingTarget: true });
            }
            // Heal or ranged-heal the target
            if (range <= 1) {
                this.heal(target);
            }
            else if (range <= 3) {
                this.rangedHeal(target);
            }
        }
        else {
            this.park();
        }
        return !!target;
    }
    healSelfIfPossible() {
        // Heal yourself if it won't interfere with attacking
        if (this.canExecute("heal") &&
            (this.hits < this.hitsMax ||
                this.pos.findInRange(this.room.hostiles, 3).length > 0)) {
            return this.heal(this);
        }
    }
    /**
     * Attack and chase the specified target
     */
    attackAndChase(target) {
        let ret;
        // Attack the target if you can, else move to get in range
        if (this.pos.isNearTo(target)) {
            ret = this.attack(target);
            // Move in the direction of the creep to prevent it from running away
            this.move(this.pos.getDirectionTo(target));
            return ret;
        }
        else {
            if (this.pos.getRangeTo(target.pos) > 10 &&
                target instanceof Creep) {
                this.goTo(target, { movingTarget: true });
            }
            else {
                this.goTo(target);
            }
            return ERR_NOT_IN_RANGE;
        }
    }
    // Standard action sequences for engaging small numbers of enemies in a neutral room ===============================
    /**
     * Automatically melee-attack the best creep in range
     */
    autoMelee(possibleTargets = this.room.hostiles) {
        const target = CombatTargeting.findBestCreepTargetInRange(this, 1, possibleTargets) || CombatTargeting.findBestStructureTargetInRange(this, 1);
        if (!target) {
            return NO_ACTION;
        }
        this.debug(`Melee-ing target: ${target}`);
        return this.attack(target);
    }
    /**
     * Automatically ranged-attack the best creep in range
     */
    autoRanged(possibleTargets = this.room.hostiles, allowMassAttack = true) {
        const target = CombatTargeting.findBestCreepTargetInRange(this, 3, possibleTargets) || CombatTargeting.findBestStructureTargetInRange(this, 3, false);
        // disabled allowUnowned structure attack in order not to desrtory poison walls
        if (!target) {
            return NO_ACTION;
        }
        if (allowMassAttack &&
            CombatIntel$1.getMassAttackDamage(this, possibleTargets) >
                CombatIntel$1.getRangedAttackDamage(this)) {
            this.debug(`Ranged mass attack on target: ${target}`);
            return this.rangedMassAttack();
        }
        this.debug(`Ranged attack on target: ${target}`);
        return this.rangedAttack(target);
    }
    kiteIfNecessary() {
        // Should filter by melee at some point
        const nearbyHostiles = _.filter(this.room.dangerousHostiles, (c) => this.pos.inRangeToXY(c.pos.x, c.pos.y, 2));
        if (nearbyHostiles.length && !this.inRampart) {
            // this.rangedMassAttack();
            this.debug(`Kiting nearby targets: ${nearbyHostiles.map((h) => h.print)}`);
            return this.kite(nearbyHostiles);
        }
        return NO_ACTION;
    }
    /**
     * Automatically heal the best creep in range
     */
    autoHeal(allowRangedHeal = true, friendlies) {
        const target = CombatTargeting.findBestHealingTargetInRange(this, allowRangedHeal ? RANGES.HEAL : RANGES.RANGED_HEAL, friendlies);
        if (!target) {
            return NO_ACTION;
        }
        this.debug(`Heal target: ${target}`);
        if (this.pos.getRangeTo(target) <= RANGES.HEAL) {
            return this.heal(target);
        }
        else if (allowRangedHeal &&
            this.pos.getRangeTo(target) <= RANGES.RANGED_HEAL) {
            return this.rangedHeal(target);
        }
    }
    /**
     * Navigate to a room, then engage hostile creeps there, perform medic actions, etc.
     */
    autoSkirmish(roomName, _verbose = false) {
        // Do standard melee, ranged, and heal actions
        if (this.getActiveBodyparts(ATTACK) > 0) {
            this.autoMelee(); // Melee should be performed first
        }
        if (this.getActiveBodyparts(RANGED_ATTACK) > 0) {
            this.autoRanged();
        }
        if (this.canExecute("heal")) {
            this.autoHeal(this.canExecute("rangedHeal"));
        }
        // Handle recovery if low on HP
        if (this.needsToRecover()) {
            this.debug(`Recovering!`);
            return this.recover();
        }
        // Travel to the target room
        if (!this.safelyInRoom(roomName)) {
            this.debug(`Going to room!`);
            return this.goToRoom(roomName, { pathOpts: { ensurePath: true } });
        }
        // Skirmish within the room
        const goals = GoalFinder.skirmishGoals(this);
        this.debug(`goals: ${JSON.stringify(goals)}`);
        return Movement.combatMove(this, goals.approach, goals.avoid);
    }
    /**
     * Navigate to a room, then engage hostile creeps there, perform medic actions, etc.
     */
    autoCombat(roomName, options) {
        var _a;
        // Do standard melee, ranged, and heal actions
        if (this.getActiveBodyparts(ATTACK) > 0) {
            this.autoMelee(); // Melee should be performed first
        }
        if (this.getActiveBodyparts(RANGED_ATTACK) > 0) {
            this.autoRanged();
        }
        if (this.canExecute("heal")) {
            this.autoHeal(this.canExecute("rangedHeal"));
        }
        // Handle recovery if low on HP
        if (this.needsToRecover()) {
            this.debug(`Recovering!`);
            return this.recover();
        }
        // Travel to the target room
        if (!this.safelyInRoom(roomName)) {
            this.debug(`Going to room!`);
            return this.goToRoom(roomName, { pathOpts: { ensurePath: true } });
        }
        // Fight within the room
        const target = CombatTargeting.findTarget(this, options === null || options === void 0 ? void 0 : options.targets);
        const preferRanged = this.getActiveBodyparts(RANGED_ATTACK) >
            this.getActiveBodyparts(ATTACK);
        const targetRange = (_a = options === null || options === void 0 ? void 0 : options.preferredRange) !== null && _a !== void 0 ? _a : (preferRanged ? RANGES.RANGED_ATTACK : RANGES.ATTACK);
        this.debug(`fighting: ${target}, ${targetRange}`);
        if (target) {
            const avoid = [];
            // Avoid melee hostiles if you are a ranged creep
            if (preferRanged) {
                const meleeHostiles = _.filter(this.room.hostiles, (h) => CombatIntel$1.getAttackDamage(h) > 0);
                for (const hostile of meleeHostiles) {
                    this.debug(`adding melee hostile ${hostile.print}`);
                    avoid.push({ pos: hostile.pos, range: targetRange - 1 });
                }
                if (this.kiteIfNecessary() !== NO_ACTION) {
                    this.debug(`kited`);
                    return;
                }
            }
            this.debug(`moving closer to ${target} at range ${targetRange}`);
            return Movement.combatMove(this, [{ pos: target.pos, range: targetRange }], avoid, options === null || options === void 0 ? void 0 : options.moveOptions);
        }
    }
    autoBunkerCombat(roomName) {
        const targets = this.colony ?
            this.room.playerHostiles.filter((creep) => creep.pos.getRangeTo(this.colony.pos) <= 9)
            : this.room.dangerousHostiles;
        const opts = {
            targets: targets,
            preferredRange: 1,
            moveOptions: {
                preferRamparts: true,
                requireRamparts: true,
            },
        };
        return this.autoCombat(roomName, opts);
    }
    needsToRecover(recoverThreshold = (CombatIntel$1.minimumDamageTakenMultiplier(this.creep) < 1) ?
        0.85
        : 0.75, reengageThreshold = 1.0) {
        let recovering;
        if (this.memory.recovering) {
            recovering = this.hits < this.hitsMax * reengageThreshold;
        }
        else {
            recovering = this.hits < this.hitsMax * recoverThreshold;
        }
        this.memory.recovering = recovering;
        return recovering;
    }
    /**
     * Retreat and get healed
     */
    recover() {
        if (this.pos.findInRange(this.room.hostiles, 5).length > 0 ||
            this.room.towers.length > 0) {
            this.memory.lastInDanger = Game.time;
        }
        const goals = GoalFinder.retreatGoals(this);
        const result = Movement.combatMove(this, goals.approach, goals.avoid, {
            allowExit: true,
        });
        if (result == NO_ACTION && this.pos.isEdge) {
            if (Game.time < this.memory.lastInDanger + 3) {
                return this.moveOffExit();
            }
        }
        return result;
    }
};
CombatZerg = __decorate$1([
    profile
], CombatZerg);

const getDefaultSpawnGroupMemory = () => ({
    colonies: [],
    distances: {},
    // routes    : {},
    // paths    : {},
    expiration: 0,
});
const MAX_LINEAR_DISTANCE = 10; // maximum linear distance to search for ANY spawn group
const DEFAULT_RECACHE_TIME = onPublicServer() ? 2000 : 1000;
const defaultSettings = {
    maxPathDistance: DEFAULT_MAX_PATH_LENGTH, // override default path distance
    requiredRCL: 7,
    maxLevelDifference: 8,
    // flexibleEnergy    : true,
};
/**
 * SpawnGroup provides a decentralized method of spawning creeps from multiple nearby colonies. Use cases include
 * incubation, spawning large combat groups, etc.
 */
let SpawnGroup = class SpawnGroup {
    constructor(initializer, settings = {}) {
        this.roomName = initializer.pos.roomName;
        // this.room = initializer.room;
        if (!Memory.rooms[this.roomName]) {
            Memory.rooms[this.roomName] = {};
        }
        this.memory = Mem.wrap(Memory.rooms[this.roomName], "spawnGroup", getDefaultSpawnGroupMemory);
        this.ref = initializer.ref + ":SG";
        this.stats = {
            avgDistance: _.sum(this.memory.distances) /
                _.keys(this.memory.distances).length || 100,
        };
        this.requests = [];
        this.settings = _.defaults(settings, defaultSettings);
        if (Game.time >= this.memory.expiration) {
            this.recalculateColonies();
        }
        this.energyCapacityAvailable = _.max(_.map(this.memory.colonies, (roomName) => Game.rooms[roomName].energyCapacityAvailable));
        this._colonies = undefined;
        Overmind.spawnGroups[this.ref] = this;
    }
    get print() {
        return ('<a href="#!/room/' +
            Game.shard.name +
            "/" +
            this.roomName +
            '">[' +
            this.ref +
            "]</a>");
    }
    debug(...args) {
        if (this.memory.debug) {
            log.alert(this.print, ...args);
        }
    }
    get colonyNames() {
        return this.memory.colonies;
    }
    get colonies() {
        if (!this._colonies) {
            this._colonies = _.compact(_.map(this.memory.colonies, (roomName) => Overmind.colonies[roomName]));
        }
        return this._colonies;
    }
    /**
     * Refresh the state of the spawnGroup; called by the Overmind object.
     */
    refresh() {
        this.memory = Mem.wrap(Memory.rooms[this.roomName], "spawnGroup", getDefaultSpawnGroupMemory);
        this.requests = [];
        this._colonies = undefined;
    }
    recalculateColonies() {
        var _a, _b;
        // Get all colonies in range that are of required level, then filter out ones that are too far from best
        let coloniesInRange = _.filter(getAllColonies(), (colony) => Game.map.getRoomLinearDistance(colony.room.name, this.roomName) <= MAX_LINEAR_DISTANCE &&
            colony.spawns.length > 0 &&
            colony.level >= this.settings.requiredRCL);
        if (this.settings.maxLevelDifference !== 8) {
            const maxColonyLevel = (_b = (_a = maxBy(coloniesInRange, (colony) => colony.level)) === null || _a === void 0 ? void 0 : _a.level) !== null && _b !== void 0 ? _b : 8;
            coloniesInRange = _.filter(coloniesInRange, (colony) => maxColonyLevel - colony.level <=
                this.settings.maxLevelDifference);
        }
        this.debug(`recalculateColonies: initial set: ${coloniesInRange.map((c) => c.print)}`);
        const colonyNames = [];
        // const routes = {} as { [colonyName: string]: { [roomName: string]: boolean } };
        // let paths = {} as { [colonyName: string]: { startPos: RoomPosition, path: string[] } };
        const distances = {};
        for (const colony of coloniesInRange) {
            const spawn = colony.room.spawns[0];
            const path = Pathing.findPathToRoom(spawn.pos, this.roomName, {
                useFindRoute: true,
            });
            if (!path.incomplete &&
                path.path.length <= this.settings.maxPathDistance) {
                colonyNames.push(colony.room.name);
                // routes[colony.room.name] = route;
                // paths[room.name] = path.path;
                distances[colony.room.name] = path.path.length;
            }
        }
        if (colonyNames.length == 0) {
            log.warning(`No colonies meet the requirements for SpawnGroup: ${this.ref}`);
            return;
        }
        this.debug(`recalculateColonies: valid colonies: ${colonyNames}`);
        this.memory.colonies = colonyNames;
        // this.memory.routes = routes;
        // this.memory.paths = TODO
        this.memory.distances = distances;
        this.memory.expiration = getCacheExpiration(DEFAULT_RECACHE_TIME, 25);
    }
    enqueue(request) {
        const threshold = this.settings.spawnPriorityThreshold;
        if (threshold !== undefined && request.priority > threshold) {
            return;
        }
        const boost = this.settings.spawnPriorityBoost;
        if (boost !== undefined) {
            request.priority += boost;
        }
        this.requests.push(request);
    }
    init() { }
    run() {
        // This needs to happen in run, after colonies & hatcheries are initialized, and
        // getWaitTimeForPriority can construct boosted creeps
        const colonies = _.compact(_.map(this.memory.colonies, (name) => Overmind.colonies[name]));
        const hatcheries = _.compact(_.map(colonies, (colony) => colony.hatchery));
        const distanceTo = (hatchery) => this.memory.distances[hatchery.pos.roomName] + 25;
        const smallestColony = minBy(colonies, (c) => c.room.energyCapacityAvailable);
        this.debug(`enqueuing ${this.requests.length} requests to hatcheries: ${hatcheries.map((h) => h.print)}`);
        // Enqueue each requests to the hatchery with least expected wait time, which is updated after each enqueue
        for (const request of this.requests) {
            const minCost = bodyCost(request.setup.create(smallestColony, true).body);
            const okHatcheries = _.filter(hatcheries, (hatchery) => hatchery.room.energyCapacityAvailable >= minCost);
            const bestHatchery = minBy(okHatcheries, (hatchery) => hatchery.getWaitTimeForPriority(request.priority) +
                distanceTo(hatchery));
            this.debug(`enqueuing request: ${request.setup.role}@${request.priority} to ${bestHatchery === null || bestHatchery === void 0 ? void 0 : bestHatchery.print}`);
            if (bestHatchery) {
                bestHatchery.enqueue(request);
            }
            else {
                log.error(`Could not enqueue creep with role ${request.setup.role} in ${this.roomName} ` +
                    `for Overlord ${request.overlord.print}, cost: ${minCost}!`);
            }
        }
    }
};
SpawnGroup = __decorate$1([
    profile
], SpawnGroup);

const getDefaultCombatOverlordMemory = () => ({
    active: true,
    ["T" /* MEM.TICK */]: Game.time,
});
/**
 * CombatOverlords extend the base Overlord class to provide additional combat-specific behavior
 */
let CombatOverlord = class CombatOverlord extends Overlord {
    constructor(directive, name, priority, options, getDefaultMemory = getDefaultCombatOverlordMemory) {
        super(directive, name, priority, getDefaultMemory);
        this.directive = directive;
        this.requiredRCL = options.requiredRCL;
        this.spawnGroup = new SpawnGroup(this, {
            requiredRCL: this.requiredRCL,
            maxPathDistance: options.maxSpawnDistance,
        });
    }
    get age() {
        return Game.time - this.memory["T" /* MEM.TICK */];
    }
    /**
     * A list of suspension reasons that will cause the overlord to deactivate itself.
     *
     * Subclasses should override this.
     */
    get deactivationReasons() {
        return new Set([SuspensionReason.cpu, SuspensionReason.upkeep]);
    }
    // Standard sequence of actions for running combat creeps
    autoRun(roleCreeps, creepHandler) {
        for (const creep of roleCreeps) {
            if (creep.spawning) {
                continue;
            }
            if (creep.hasValidTask) {
                creep.run();
            }
            else {
                if (creep.needsBoosts) {
                    this.handleBoosting(creep);
                }
                else {
                    creepHandler(creep);
                }
            }
        }
    }
    /**
     * Contains logic for shutting down the overlord
     */
    finish(_successful) {
        for (const zerg of this.getAllZerg()) {
            zerg.reassign(this.colony.overlords.default);
        }
        // TODO: CombatOverlord
    }
};
CombatOverlord = __decorate$1([
    profile
], CombatOverlord);

var SourceReaperOverlord_1;
/**
 * SourceReaperOverlord -- spawns offensive creeps to allow source keeper mining
 */
let SourceReaperOverlord = SourceReaperOverlord_1 = class SourceReaperOverlord extends CombatOverlord {
    constructor(directive, priority = OverlordPriority.remoteSKRoom.sourceReaper) {
        super(directive, "sourceReaper", priority, {
            requiredRCL: SourceReaperOverlord_1.requiredRCL,
        });
        this.priority +=
            this.outpostIndex * OverlordPriority.remoteSKRoom.roomIncrement;
        this.reapers = this.combatZerg(Roles.melee);
        this.defenders = this.combatZerg(Roles.ranged);
        this.computeTargetLair();
    }
    computeTargetLair() {
        this.targetLair =
            this.memory.targetLairID ?
                deref(this.memory.targetLairID)
                : undefined;
        if (!this.targetLair ||
            (this.targetLair.ticksToSpawn || Infinity) >= 299) {
            if (this.room) {
                // If any lairs have an active keeper, target that
                const activeLair = _.find(this.room.keeperLairs, (lair) => lair.pos.findInRange(lair.room.sourceKeepers, 5)
                    .length > 0);
                if (activeLair) {
                    this.targetLair = activeLair;
                }
                else {
                    // Otherwise target whatever is closest to spawning
                    this.targetLair = minBy(this.room.keeperLairs, (lair) => lair.ticksToSpawn || Infinity);
                }
            }
        }
    }
    refresh() {
        super.refresh();
        this.computeTargetLair();
    }
    init() {
        let defenderAmount = 0;
        if (this.room &&
            (this.room.invaders.length > 0 ||
                RoomIntel$1.isInvasionLikely(this.room.name))) {
            // Spawn as many defenders as there are invaders, which might be a bit wasteful
            defenderAmount = this.room.invaders.length;
        }
        const priority = OverlordPriority.priorityOwnedRoom.prioritySKReaper;
        this.wishlist(1, CombatSetups.zerglings.sourceKeeper, { priority });
        this.wishlist(defenderAmount, CombatSetups.hydralisks.sourceKeeper, {
            priority,
        });
    }
    handleReaper(reaper) {
        const moveOpts = { pathOpts: { avoidSK: false } };
        // Go to keeper room
        if (!this.targetLair ||
            !this.room ||
            reaper.room != this.room ||
            reaper.pos.isEdge) {
            log.debugCreep(reaper, `Going to room ${this.pos.print}!`);
            reaper.healSelfIfPossible();
            reaper.goTo(this.pos, moveOpts);
            return;
        }
        // Once you're safely in the room, block off the exits
        moveOpts.pathOpts.blockExits = true;
        const nonStrongholdInvaders = this.room.invaders.filter((creep) => !creep.inRampart);
        if (nonStrongholdInvaders.length > 0) {
            // Handle invader actions
            if (reaper.hits >= reaper.hitsMax * 0.5) {
                const result = reaper.autoMelee(this.room.invaders);
                if (result === NO_ACTION) {
                    // didn't attack
                    reaper.autoHeal();
                }
            }
            else {
                reaper.healSelfIfPossible();
            }
            // Kite around ranged invaders until a defender arrives
            if (this.room.invaders.length > 2 &&
                _.filter(this.defenders, (def) => def.room == this.room)
                    .length == 0) {
                reaper.kite(_.filter(this.room.hostiles, (h) => h.getActiveBodyparts(RANGED_ATTACK) > 0), moveOpts);
                reaper.healSelfIfPossible();
            }
            else {
                // If defender is already here or a small invasion
                const target = CombatTargeting.findTarget(reaper, this.room.invaders);
                if (target) {
                    Movement.invasionMove(reaper, target);
                }
                else {
                    log.warning(`KeeperReaper@${reaper.pos.print}: no invader target!`);
                }
            }
        }
        else {
            // Standard keeperReaper actions
            const nearestHostile = reaper.pos.findClosestByRange(this.room.hostiles);
            if (nearestHostile && reaper.pos.isNearTo(nearestHostile)) {
                log.debugCreep(reaper, `Attacking nearest hostile: ${nearestHostile.print}!`);
                reaper.attack(nearestHostile);
                reaper.move(reaper.pos.getDirectionTo(nearestHostile));
            }
            else {
                const keeper = this.targetLair.pos.findClosestByLimitedRange(this.room.sourceKeepers, 7);
                if (keeper) {
                    // attack the source keeper
                    log.debugCreep(reaper, `Attacking source keeper: ${nearestHostile.print}!`);
                    // stop and heal at range 4 if needed
                    const approachRange = (reaper.hits == reaper.hitsMax ||
                        reaper.pos.getRangeTo(keeper) <= 3) ?
                        1
                        : 4;
                    reaper.goTo(keeper, {
                        range: approachRange,
                        pathOpts: moveOpts.pathOpts,
                    });
                }
                else {
                    // travel to next lair
                    reaper.goTo(this.targetLair, {
                        range: 1,
                        pathOpts: moveOpts.pathOpts,
                    });
                }
            }
            reaper.healSelfIfPossible();
        }
    }
    handleDefender(defender) {
        // Go to keeper room
        if (!this.targetLair ||
            !this.room ||
            defender.room != this.room ||
            defender.pos.isEdge) {
            log.debugCreep(defender, `Going to room ${this.pos.roomName}!`);
            defender.healSelfIfPossible();
            defender.goToRoom(this.pos.roomName, {
                pathOpts: { avoidSK: false },
            });
            return;
        }
        if (this.room.invaders.length > 0) {
            // Handle invader actions
            log.debugCreep(defender, `AutoCombat`);
            defender.autoSkirmish(this.room.name);
        }
        else {
            log.debugCreep(defender, `Standard duty`);
            const minKeepersToHelp = this.reapers.length == 0 ? 1 : 2;
            if (this.room.sourceKeepers.length >= minKeepersToHelp) {
                // Help out with keeper reaping
                defender.autoRanged();
                defender.autoHeal(false);
                const reaper = defender.pos.findClosestByRange(this.reapers);
                if (reaper) {
                    defender.goTo(reaper, {
                        movingTarget: defender.pos.getRangeTo(reaper) > 8,
                        repathChance: 0.1,
                        pathOpts: {
                            maxRooms: 1,
                            avoidSK: false,
                            blockExits: true,
                        },
                    });
                }
                else {
                    const keeper = this.targetLair.pos.findClosestByLimitedRange(this.room.sourceKeepers, 7);
                    if (keeper) {
                        // attack the source keeper
                        const range = defender.pos.getRangeTo(keeper);
                        const keepAtRange = defender.hits < defender.hitsMax * 0.9 ? 4 : 3;
                        if (range < keepAtRange) {
                            defender.kite(this.room.hostiles, {
                                range: keepAtRange,
                                pathOpts: {
                                    avoidSK: false,
                                    blockExits: true,
                                },
                            });
                        }
                        else if (range > keepAtRange) {
                            defender.goTo(keeper, {
                                range: keepAtRange,
                                pathOpts: {
                                    avoidSK: false,
                                    blockExits: true,
                                },
                            });
                        }
                    }
                    else {
                        // travel to next lair
                        defender.goTo(this.targetLair, {
                            range: 5,
                            pathOpts: {
                                avoidSK: false,
                                blockExits: true,
                            },
                        });
                    }
                }
            }
            else {
                // Do medic actions
                log.debugCreep(defender, `Medic actions`);
                defender.doMedicActions(this.room.name);
            }
        }
    }
    run() {
        this.autoRun(this.reapers, (reaper) => this.handleReaper(reaper));
        this.autoRun(this.defenders, (defender) => this.handleDefender(defender));
    }
    visuals() {
        if (this.room && this.targetLair) {
            Visualizer.marker(this.targetLair.pos);
        }
    }
};
SourceReaperOverlord.requiredRCL = 7;
SourceReaperOverlord = SourceReaperOverlord_1 = __decorate$1([
    profile
], SourceReaperOverlord);

/**
 * Remote mining directive for source keeper rooms
 */
let DirectiveSKOutpost = class DirectiveSKOutpost extends Directive {
    constructor(flag) {
        super(flag, (colony) => colony.level >= SourceReaperOverlord.requiredRCL);
        this.refresh();
    }
    refresh() {
        super.refresh();
    }
    spawnMoarOverlords() {
        this.overlords.sourceReaper = new SourceReaperOverlord(this);
    }
    init() { }
    run() { }
    visuals() {
        RoomIntel.invasionVisualsForRoom(this.pos.roomName);
    }
};
DirectiveSKOutpost.directiveName = "outpostSK";
DirectiveSKOutpost.color = COLOR_PURPLE;
DirectiveSKOutpost.secondaryColor = COLOR_YELLOW;
DirectiveSKOutpost = __decorate$1([
    profile
], DirectiveSKOutpost);

/**
 * Empire: Utilities on analyzing the overall empire
 */
let EmpireAnalysis = class EmpireAnalysis {
    static empireMineralDistribution() {
        const colonies = getAllColonies();
        const minedSKRooms = DirectiveSKOutpost.find(Object.values(Game.flags));
        const mineralDistribution = {};
        for (const colony of colonies) {
            const mineral = colony.room.find(FIND_MINERALS)[0];
            if (!mineralDistribution[mineral.mineralType]) {
                mineralDistribution[mineral.mineralType] = 0;
            }
            mineralDistribution[mineral.mineralType] += 1;
        }
        for (const skRoomFlag of minedSKRooms) {
            if (!skRoomFlag.room) {
                continue;
            }
            const mineral = skRoomFlag.room.find(FIND_MINERALS)[0];
            if (!mineralDistribution[mineral.mineralType]) {
                mineralDistribution[mineral.mineralType] = 0;
            }
            mineralDistribution[mineral.mineralType] += 1;
        }
        return mineralDistribution;
    }
};
EmpireAnalysis = __decorate$1([
    profile
], EmpireAnalysis);

/**
 * OvermindConsole registers a number of global methods for direct use in the Screeps console
 */
class OvermindConsole {
    static init() {
        for (const cmd of this.commands) {
            const para = cmd.name.indexOf("(");
            const funcName = para !== -1 ? cmd.name.substring(0, para) : cmd.name;
            // @ts-expect-error define commands on the global object
            global[funcName] = cmd.command;
        }
        this.generateHelp();
        // @ts-expect-error set this one directly so that the parsing happens once
        global.help = this.helpMsg;
    }
    static help() {
        if (!this.helpMsg) {
            this.generateHelp();
        }
        console.log(this.helpMsg);
    }
    static generateHelp() {
        let msg = '\n<font color="#ff00ff">';
        for (const line of asciiLogoSmall) {
            msg += line + "\n";
        }
        msg += "</font>";
        // Console list
        const descr = {};
        for (const cmd of this.commands) {
            if (!cmd.description) {
                continue;
            }
            descr[cmd.name] = cmd.description;
        }
        const descrMsg = toColumns(descr, { justify: true, padChar: "." });
        const maxLineLength = _.max(_.map(descrMsg, (line) => line.length)) + 2;
        msg +=
            "Console Commands: ".padEnd(maxLineLength, "=") +
                "\n" +
                descrMsg.join("\n");
        msg += "\n\nRefer to the repository for more information\n";
        this.helpMsg = msg;
    }
    static printUpdateMessage(aligned = false) {
        const joinChar = aligned ? alignedNewline : "\n";
        const msg = `Codebase updated or global reset. Type "help" for a list of console commands.` +
            joinChar +
            color(asciiLogoSmall.join(joinChar), "#ff00ff") +
            joinChar +
            OvermindConsole.info(aligned);
        log.alert(msg);
    }
    static printTrainingMessage() {
        console.log("\n" + asciiLogoRL.join("\n") + "\n");
    }
    static info(aligned = false) {
        const b = bullet;
        const checksum = Assimilator.generateChecksum();
        const clearanceCode = Assimilator.getClearanceCode(MY_USERNAME);
        const baseInfo = [
            `${b}Version:        Overmind v${__VERSION__}`,
            `${b}Checksum:       ${checksum}`,
            `${b}Assimilated:    ${clearanceCode ? "Yes" : "No"} (clearance code: ${clearanceCode}) [WIP]`,
            `${b}Operating mode: ${Memory.settings.operationMode}`,
        ];
        const joinChar = aligned ? alignedNewline : "\n";
        return baseInfo.join(joinChar);
    }
    static notifications() {
        const notifications = Overmind.overseer.notifier.generateNotificationsList(true);
        return _.map(notifications, (msg) => bullet + msg).join("\n");
    }
    static setMode(mode) {
        if ("manual".startsWith(mode)) {
            Memory.settings.operationMode = "manual";
            console.log(`Operational mode set to manual. Only defensive directives will be placed automatically; ` +
                `remove harvesting, claiming, room planning, and raiding must be done manually.`);
        }
        else if ("semiautomatic".startsWith(mode)) {
            Memory.settings.operationMode = "semiautomatic";
            console.log(`Operational mode set to semiautomatic. Claiming, room planning, and raiding must be done ` +
                `manually; everything else is automatic.`);
        }
        else if ("automatic".startsWith(mode)) {
            Memory.settings.operationMode = "automatic";
            console.log(`Operational mode set to automatic. All actions are done automatically, but manually placed ` +
                `directives will still be responded to.`);
        }
        else {
            console.log(`Invalid mode: please specify 'manual', 'semiautomatic', or 'automatic'.`);
        }
    }
    static setSignature(signature) {
        const sig = signature ? signature : DEFAULT_OVERMIND_SIGNATURE$1;
        if (sig.length > 100) {
            throw new Error(`Invalid signature: ${signature}; length is over 100 chars.`);
        }
        else if (!sig.toLowerCase().includes("overmind") &&
            !sig.includes(__DEFAULT_OVERMIND_SIGNATURE__)) {
            throw new Error(`Invalid signature: ${signature}; must contain the string "Overmind" or ` +
                `${__DEFAULT_OVERMIND_SIGNATURE__} (accessible on global with __DEFAULT_OVERMIND_SIGNATURE__)`);
        }
        Memory.settings.signature = sig;
        _.each(Overmind.colonies, (colony) => {
            const signer = _.sample(colony.getZergByRole("worker"));
            if (!signer) {
                log.warning(`${colony.print}: unable to find a random worker to re-sign the controller`);
                return;
            }
            signer.task = new TaskSignController(colony.controller);
        });
        _.filter(Overmind.directives, (directive) => directive instanceof DirectiveOutpost).forEach((directive) => {
            const overlord = directive.overlords.reserve;
            overlord.settings.resetSignature = true;
            if (overlord.reservers[0]) {
                overlord.reservers[0].task = null;
            }
        });
        console.log(`Controller signature set to ${sig}`);
    }
    // Debugging methods ===============================================================================================
    static debug(...things) {
        let mode;
        const debugged = [];
        for (const thing of things) {
            const name = `${thing.print || thing.ref || thing.name || "(no name or ref)"}`;
            if ((thing.memory && thing.memory.debug && mode === undefined) ||
                mode === false) {
                mode = false;
                delete thing.memory.debug;
                debugged.push(name);
            }
            else if ((thing.memory && mode === undefined) || mode === true) {
                mode = true;
                thing.memory.debug = true;
                debugged.push(name);
            }
            else {
                log.info(`don't know what to do with ${thing}`);
                return;
            }
        }
        console.log(`${mode ? "Enabled" : "Disabled"} debugging for ${debugged.join(", ")}`);
    }
    static startRemoteDebugSession() {
        global.remoteDebugger.enable();
        console.log(`Started remote debug session.`);
    }
    static endRemoteDebugSession() {
        global.remoteDebugger.disable();
        console.log(`Ended remote debug session.`);
    }
    static print(...args) {
        console.log(dump(args));
    }
    static timeit(callback, repeat = 1) {
        const start = Game.cpu.getUsed();
        let i;
        for (i = 0; i < repeat; i++) {
            callback();
        }
        const used = Game.cpu.getUsed() - start;
        console.log(`CPU used: ${used}. Repetitions: ${repeat} (${used / repeat} each).`);
    }
    // Overlord profiling ==============================================================================================
    static profileOverlord(overlord, ticks) {
        const overlordInstance = typeof overlord == "string" ?
            Overmind.overlords[overlord]
            : overlord;
        if (!overlordInstance) {
            console.log(`No overlord found for ${overlord}!`);
        }
        else {
            overlordInstance.startProfiling(ticks);
            console.log(`Profiling ${overlordInstance.print} for ${ticks || "indefinite"} ticks.`);
        }
    }
    static finishProfilingOverlord(overlord) {
        const overlordInstance = typeof overlord == "string" ?
            Overmind.overlords[overlord]
            : overlord;
        if (!overlordInstance) {
            console.log(`No overlord found for ${overlord}!`);
        }
        else {
            overlordInstance.finishProfiling();
            console.log(`Profiling ${overlordInstance.print} stopped.`);
        }
    }
    // Colony suspension ===============================================================================================
    static suspendColony(roomName) {
        if (!Memory.colonies[roomName]) {
            console.log(`Colony ${roomName} is not a valid colony!`);
            return;
        }
        const colonyMemory = Memory.colonies[roomName];
        if (!colonyMemory) {
            console.log(`No colony memory for ${roomName}!`);
            return;
        }
        colonyMemory.suspend = true;
        Overmind.shouldBuild = true;
        console.log(`Colony ${roomName} suspended.`);
    }
    static unsuspendColony(roomName) {
        if (!Memory.colonies[roomName]) {
            console.log(`Colony ${roomName} is not a valid colony!`);
            return;
        }
        const colonyMemory = Memory.colonies[roomName];
        if (!colonyMemory) {
            console.log(`No colony memory for ${roomName}!`);
            return;
        }
        delete colonyMemory.suspend;
        Overmind.shouldBuild = true;
        console.log(`Colony ${roomName} unsuspended.`);
    }
    static listSuspendedColonies() {
        const suspended = _.filter(Object.entries(Memory.colonies), ([_name, mem]) => mem.suspend);
        let msg = "Colonies currently suspended: \n";
        for (const [name, _mem] of suspended) {
            msg += `Colony ${name}\n`;
        }
        console.log(msg);
        return suspended.map(([name, _mem]) => Overmind.colonies[name]);
    }
    // Room planner control ============================================================================================
    static openRoomPlanner(roomName) {
        if (!Overmind.colonies[roomName]) {
            console.log(`Error: ${roomName} is not a valid colony!`);
            return;
        }
        if (Overmind.colonies[roomName].roomPlanner.active) {
            console.log(`RoomPlanner for ${roomName} is already active!`);
            return;
        }
        console.log(`Enabled RoomPlanner for ${Overmind.colonies[roomName].print}`);
        Overmind.colonies[roomName].roomPlanner.active = true;
    }
    static closeRoomPlanner(roomName) {
        if (!Overmind.colonies[roomName]) {
            console.log(`Error: ${roomName} is not a valid colony!`);
            return;
        }
        if (!Overmind.colonies[roomName].roomPlanner.active) {
            console.log(`RoomPlanner for ${roomName} is not active!`);
            return;
        }
        console.log(`Closed RoomPlanner for ${Overmind.colonies[roomName].print}`);
        Overmind.colonies[roomName].roomPlanner.finalize();
    }
    static cancelRoomPlanner(roomName) {
        if (!Overmind.colonies[roomName]) {
            console.log(`Error: ${roomName} is not a valid colony!`);
            return;
        }
        if (!Overmind.colonies[roomName].roomPlanner.active) {
            console.log(`RoomPlanner for ${roomName} is not active!`);
            return;
        }
        Overmind.colonies[roomName].roomPlanner.active = false;
        console.log(`RoomPlanner for ${Overmind.colonies[roomName].print} has been deactivated without saving changes`);
    }
    static listActiveRoomPlanners() {
        const coloniesWithActiveRoomPlanners = _.filter(_.map(_.keys(Overmind.colonies), (colonyName) => Overmind.colonies[colonyName]), (colony) => colony.roomPlanner.active);
        const names = _.map(coloniesWithActiveRoomPlanners, (colony) => colony.room.print);
        if (names.length > 0) {
            console.log("Colonies with active room planners: " + names.toString());
            return coloniesWithActiveRoomPlanners;
        }
        else {
            console.log(`No colonies with active room planners`);
            return [];
        }
    }
    static listConstructionSites(filter) {
        if (!filter) {
            filter = () => true;
        }
        const sites = _.filter(Game.constructionSites, filter);
        let msg = `${_.keys(Game.constructionSites).length} construction sites currently present: \n`;
        for (const site of sites) {
            msg +=
                `${bullet}Type: ${site.structureType}`.padEnd(20) +
                    `Pos: ${site.pos.print}`.padEnd(65) +
                    `Progress: ${site.progress} / ${site.progressTotal} \n`;
        }
        console.log(msg);
        return sites;
    }
    // Directive management ============================================================================================
    static listDirectives(filter) {
        if (typeof filter === "string") {
            const match = filter;
            filter = (dir) => dir.name.startsWith(match);
        }
        else if (!filter) {
            filter = () => true;
        }
        const matches = _.filter(Overmind.directives, filter);
        let msg = "";
        for (const dir of matches) {
            msg +=
                `${bullet}Name: ${dir.print}`.padEnd(70) +
                    `Colony: ${dir.colony.print}`.padEnd(55) +
                    `Pos: ${dir.pos.print}\n`;
        }
        console.log(msg);
        return matches;
    }
    static removeAllLogisticsDirectives() {
        const logisticsFlags = _.filter(Game.flags, (flag) => flag.color == COLOR_YELLOW &&
            flag.secondaryColor == COLOR_YELLOW);
        for (const dir of logisticsFlags) {
            dir.remove();
        }
        console.log(`Removed ${logisticsFlags.length} logistics directives.`);
    }
    static listPersistentDirectives() {
        const directives = _.filter(Overmind.directives, (dir) => dir.memory.persistent);
        let msg = "";
        for (const dir of directives) {
            msg +=
                `Type: ${dir.directiveName}`.padEnd(20) +
                    `Name: ${dir.name}`.padEnd(15) +
                    `Pos: ${dir.pos.print}\n`;
        }
        console.log(msg);
        return directives;
    }
    static removeFlagsByColor(color, secondaryColor) {
        const removeFlags = _.filter(Game.flags, (flag) => flag.color == color && flag.secondaryColor == secondaryColor);
        for (const flag of removeFlags) {
            flag.remove();
        }
        console.log(`Removed ${removeFlags.length} flags.`);
    }
    static removeErrantFlags() {
        let count = 0;
        for (const name in Game.flags) {
            if (!Overmind.directives[name]) {
                Game.flags[name].remove();
                count += 1;
            }
        }
        console.log(`Removed ${count} flags.`);
    }
    // Structure management ============================================================================================
    static destroyErrantStructures(roomName) {
        const colony = Overmind.colonies[roomName];
        if (!colony) {
            console.log(`${roomName} is not a valid colony!`);
            return;
        }
        const room = colony.room;
        const allStructures = room.find(FIND_STRUCTURES);
        let i = 0;
        for (const s of allStructures) {
            if (s.structureType == STRUCTURE_CONTROLLER) {
                continue;
            }
            if (!colony.roomPlanner.structureShouldBeHere(s.structureType, s.pos)) {
                const result = s.destroy();
                if (result == OK) {
                    i++;
                }
            }
        }
        console.log(`Destroyed ${i} misplaced structures in ${roomName}.`);
    }
    static destroyAllHostileStructures(roomName) {
        const room = Game.rooms[roomName];
        if (!room) {
            console.log(`${roomName} is undefined! (No vision?)`);
            return;
        }
        if (!room.my) {
            console.log(`${roomName} is not owned by you!`);
            return;
        }
        const hostileStructures = room.find(FIND_HOSTILE_STRUCTURES);
        for (const structure of hostileStructures) {
            structure.destroy();
        }
        console.log(`Destroyed ${hostileStructures.length} hostile structures.`);
    }
    static destroyAllBarriers(roomName) {
        const room = Game.rooms[roomName];
        if (!room) {
            console.log(`${roomName} is undefined! (No vision?)`);
            return;
        }
        if (!room.my) {
            console.log(`${roomName} is not owned by you!`);
            return;
        }
        for (const barrier of room.barriers) {
            barrier.destroy();
        }
        console.log(`Destroyed ${room.barriers.length} barriers.`);
    }
    static removeUnbuiltConstructionSites() {
        let msg = "";
        for (const id in Game.constructionSites) {
            const csite = Game.constructionSites[id];
            if (csite.progress == 0) {
                const ret = csite.remove();
                msg +=
                    `Removing construction site for ${csite.structureType} with 0% progress at ` +
                        `${csite.pos.print}; response: ${ret}\n`;
            }
        }
        console.log(msg);
    }
    // Colony Management ===============================================================================================
    static setRoomUpgradeRate(colonySpec, rate) {
        const colony = this.resolveSingleColonySpec(colonySpec);
        const oldRate = colony.upgradeSite.memory.speedFactor;
        if (typeof rate === "number") {
            rate = Math.max(0, rate);
            colony.upgradeSite.memory.speedFactor = rate;
            console.log(`Colony ${colony.name} is now upgrading at a rate of ${rate} (previously ${oldRate}).`);
        }
        else if (rate === null) {
            delete colony.upgradeSite.memory.speedFactor;
        }
        else {
            const rate = colony.upgradeSite.memory.speedFactor;
            console.log(`Colony ${colony.name} currently upgrading at a rate of ${rate}.`);
        }
    }
    static getEmpireMineralDistribution() {
        const minerals = EmpireAnalysis.empireMineralDistribution();
        let msg = "Empire Mineral Distribution \n";
        for (const mineral in minerals) {
            msg += `${mineral}: ${minerals[mineral]} \n`;
        }
        console.log(msg);
    }
    static listPortals(rangeFromColonies = 5, includeIntershard = false) {
        const colonies = getAllColonies();
        const portalsByColony = colonies.map((colony) => [
            colony.name,
            RoomIntel$1.findPortalsInRange(colony.name, rangeFromColonies, includeIntershard),
        ]);
        const allPortals = new Set();
        let msg = `Empire Portal Census\n`;
        const table = [];
        for (const [colonyName, portals] of portalsByColony) {
            for (const portalRoomName of _.keys(portals)) {
                for (const portal of portals[portalRoomName]) {
                    let dest;
                    if (portal.roomDestination) {
                        dest = portal.roomDestination.print;
                    }
                    else {
                        const { shard, room } = portal.shardDestination;
                        dest = `<a href="#!/room/${shard}/${room}">[${room}@${shard}]</a>`;
                    }
                    const data = {
                        colony: colonyName,
                        expiration: portal.expiration ?
                            portal.expiration - Game.time
                            : "stable",
                        portal: portal.pos.print,
                        destination: dest,
                    };
                    table.push(data);
                    allPortals.add(portal);
                }
            }
        }
        msg += columnify$1(table);
        console.log(msg);
        return [...allPortals];
    }
    static evaluateOutpostEfficiencies() {
        const outpostsPerColony = getAllColonies()
            .filter((c) => c.bunker)
            .map((c) => [c, c.outposts.map((r) => r.name)]);
        console.log(OvermindConsole.reportOutpostEfficiency(outpostsPerColony, (avg, colonyAvg) => avg < colonyAvg * 0.75));
    }
    static evaluatePotentialOutpostEfficiencies() {
        const outpostsPerColony = getAllColonies()
            .filter((c) => c.bunker)
            .map((c) => {
            const outpostNames = c.outposts.map((room) => room.name);
            return [
                c,
                Cartographer.findRoomsInRange(c.name, 2).filter((r) => !outpostNames.includes(r)),
            ];
        });
        console.log(OvermindConsole.reportOutpostEfficiency(outpostsPerColony, (avg, colonyAvg) => avg > colonyAvg * 1.25 || avg > 20));
    }
    static reportOutpostEfficiency(outpostsPerColony, selectionCallback) {
        let msg = `Estimated outpost efficiency:\n`;
        for (const [colony, outposts] of outpostsPerColony) {
            let avgEnergyPerCPU = 0;
            const outpostAvgEnergyPerCPU = [];
            msg += ` • Colony at ${colony.room.name}:\n`;
            for (const outpost of outposts) {
                const d = ExpansionEvaluator.computeTheoreticalMiningEfficiency(colony.bunker.anchor, outpost);
                msg += `\t - ${d.room} ${`(${d.type})`.padStart(6)}: `;
                msg += `${((d.energyPerSource * d.sources) /
                    ENERGY_REGEN_TIME).toFixed(2)} energy/source, `;
                msg += `Net income: ${d.netIncome.toFixed(2)}, `;
                msg += `Net energy/CPU: ${(d.netIncome / d.cpuCost).toFixed(2)}\n`;
                msg += `\t   Creep costs: ${d.creepEnergyCost.toFixed(2)} energy/tick, `;
                msg += `spawn time: ${d.spawnTimeCost.toFixed(2)}, CPU: ${d.cpuCost.toFixed(2)} cycles/tick\n`;
                if (d.unreachableSources || d.unreachableController) {
                    const { unreachableSources: s, unreachableController: c } = d;
                    msg += `\t   ${color("Unreachable:", "yellow")} `;
                    if (s) {
                        msg += `sources: ${s}`;
                    }
                    if (s && c) {
                        msg += ", ";
                    }
                    if (c) {
                        msg += `controller: ${c}`;
                    }
                    msg += `\n`;
                }
                outpostAvgEnergyPerCPU.push(d.avgEnergyPerCPU);
                avgEnergyPerCPU += d.avgEnergyPerCPU;
            }
            const bestOutposts = outpostAvgEnergyPerCPU
                .map((avg, idx) => {
                // 20E/cpu is a good guideline for an efficient room
                if (selectionCallback(avg, avgEnergyPerCPU)) {
                    return idx + 1;
                }
                return undefined;
            })
                .filter((avg) => avg);
            msg += `\n   Outposts with above average efficiency of ${avgEnergyPerCPU.toFixed(2)}: `;
            msg += `${bestOutposts.join(", ")}\n`;
        }
        return msg;
    }
    // Memory management ===============================================================================================
    static deepCleanMemory() {
        // Clean colony memory
        const protectedColonyKeys = [
            "defcon",
            "roomPlanner",
            "roadPlanner",
            "barrierPlanner",
        ];
        for (const colName in Memory.colonies) {
            for (const key in Memory.colonies[colName]) {
                if (!protectedColonyKeys.includes(key)) {
                    // @ts-expect-error direct property access
                    delete Memory.colonies[colName][key];
                }
            }
        }
        // Suicide any creeps which have no memory
        for (const i in Game.creeps) {
            if (_.isEmpty(Game.creeps[i].memory)) {
                Game.creeps[i].suicide();
            }
        }
        // Remove profiler memory
        delete Memory.screepsProfiler;
        // Remove overlords memory from flags
        for (const i in Memory.flags) {
            if (Memory.flags[i].overlords) {
                delete Memory.flags[i].overlords;
            }
        }
        // Clean creep memory
        for (const i in Memory.creeps) {
            // Remove all creep tasks to fix memory leak in 0.3.1
            if (Memory.creeps[i].task) {
                Memory.creeps[i].task = null;
            }
        }
        console.log(`Memory has been cleaned.`);
    }
    static recursiveMemoryProfile(prefix, memoryObject, sizes, currentDepth) {
        let total = 0;
        for (const key in memoryObject) {
            const fullKey = `${prefix}.${key}`;
            if (currentDepth == 0 ||
                !_.keys(memoryObject[key]) ||
                _.keys(memoryObject[key]).length == 0) {
                let len = NaN;
                try {
                    len = JSON.stringify(memoryObject[key]).length; // 2 for the brackets
                }
                catch (e) {
                    if (memoryObject[key] !== undefined) {
                        console.log(`failed to get JSON for ${fullKey}: ${memoryObject[key]}`);
                    }
                }
                sizes[fullKey] = len;
                if (!isNaN(len)) {
                    total += len;
                }
            }
            else {
                total += OvermindConsole.recursiveMemoryProfile(fullKey, memoryObject[key], sizes, currentDepth - 1);
                sizes[`${prefix}.TOTAL`] = total;
            }
        }
        return total;
    }
    static profileMemory(root = Memory, depth = 1) {
        var _a, _b;
        const sizes = {};
        console.log(`Profiling memory...`);
        const start = Game.cpu.getUsed();
        OvermindConsole.recursiveMemoryProfile("ROOT", root, sizes, depth);
        const sortedSizes = _.sortBy(Object.entries(sizes), (val) => -val[1]);
        console.log(`Time elapsed: ${Game.cpu.getUsed() - start}`);
        const maxKeyLen = (_b = (_a = maxBy(sortedSizes, ([k, _v]) => k.length)) === null || _a === void 0 ? void 0 : _a[0].length) !== null && _b !== void 0 ? _b : 0;
        console.log(sortedSizes
            .map(([k, v]) => `${k}:${"".padStart(maxKeyLen - k.length)}${v}`)
            .join("\n"));
        return sizes;
    }
    static cancelMarketOrders(filter) {
        const ordersToCancel = !!filter ?
            _.filter(Game.market.orders, (order) => filter(order))
            : Game.market.orders;
        _.forEach(_.values(ordersToCancel), (order) => Game.market.cancelOrder(order.id));
        console.log(`Canceled ${_.values(ordersToCancel).length} orders.`);
    }
    static showRoomSafety(roomName) {
        const names = roomName ? [roomName] : Object.keys(Memory.rooms);
        let msg = `Room Intelligence data for ${roomName ? `room ${roomName}` : "all rooms"}:\n`;
        const roomData = _.sortBy(names.map((n) => {
            var _a, _b, _c;
            const { threatLevel, safeFor, unsafeFor, invisibleFor, combatPotentials, numHostiles, numBoostedHostiles, } = RoomIntel$1.getSafetyData(n);
            function fmtThreat(lvl) {
                let suffix = "";
                if (lvl < 0.1) {
                    suffix = "---";
                }
                else if (lvl < 0.2) {
                    suffix = " --";
                }
                else if (lvl < 0.4) {
                    suffix = "  -";
                }
                else if (lvl < 0.6) {
                    suffix = "   ";
                }
                else if (lvl < 0.8) {
                    suffix = "  +";
                }
                else if (lvl < 0.9) {
                    suffix = " ++";
                }
                else {
                    suffix = "+++";
                }
                return lvl.toFixed(4) + " " + suffix;
            }
            const obj = {
                room: n,
                threatlevel: fmtThreat(threatLevel),
                safeFor: safeFor !== null && safeFor !== void 0 ? safeFor : 0,
                unsafeFor: unsafeFor !== null && unsafeFor !== void 0 ? unsafeFor : 0,
                invisibleFor: invisibleFor !== null && invisibleFor !== void 0 ? invisibleFor : 0,
                hostiles: numHostiles !== null && numHostiles !== void 0 ? numHostiles : 0,
                boostedHostiles: numBoostedHostiles !== null && numBoostedHostiles !== void 0 ? numBoostedHostiles : 0,
                ranged: (_a = combatPotentials === null || combatPotentials === void 0 ? void 0 : combatPotentials.r) !== null && _a !== void 0 ? _a : 0,
                heal: (_b = combatPotentials === null || combatPotentials === void 0 ? void 0 : combatPotentials.h) !== null && _b !== void 0 ? _b : 0,
                dismantle: (_c = combatPotentials === null || combatPotentials === void 0 ? void 0 : combatPotentials.d) !== null && _c !== void 0 ? _c : 0,
            };
            return obj;
        }), (data) => data.room);
        msg += columnify$1(roomData);
        console.log(msg);
    }
    static resolveColonySpec(colonySpec) {
        let colonies;
        if (typeof colonySpec === "string") {
            if (!Overmind.colonies[colonySpec]) {
                throw new Error(`Unknown colony ${colonySpec}`);
            }
            colonies = [Overmind.colonies[colonySpec]];
        }
        else if (colonySpec instanceof Colony) {
            colonies = [colonySpec];
        }
        else if (typeof colonySpec === "undefined") {
            colonies = Object.values(Overmind.colonies);
        }
        else {
            throw new Error(`Don't know what to do with ${colonySpec}`);
        }
        return colonies;
    }
    static resolveSingleColonySpec(colonySpec) {
        const colonies = this.resolveColonySpec(colonySpec);
        if (colonies.length > 1) {
            throw new Error(`more than one colony matched ${colonySpec}`);
        }
        return colonies[0];
    }
    static spawnSummary(colonySpec) {
        var _a, _b;
        const colonies = this.resolveColonySpec(colonySpec);
        let msg = `Ongoing creep requests:\n`;
        for (const colony of colonies) {
            if (!colony.hatchery) {
                msg += `\n${bullet} ${colony.name} has no hatchery\n`;
                continue;
            }
            if (((_a = colony.hatchery) === null || _a === void 0 ? void 0 : _a.spawnRequests.length) === 0) {
                msg += `\n${bullet} ${colony.name} is idle\n`;
                continue;
            }
            msg += `\n${bullet} ${colony.name} has the following requests:\n`;
            const requestsByRole = _.groupBy((_b = colony.hatchery) === null || _b === void 0 ? void 0 : _b.spawnRequests, (req) => req.setup.role);
            for (const [role, requests] of Object.entries(requestsByRole)) {
                if (requests.length === 1) {
                    const req = requests[0];
                    msg += `\t\t- "${role}": ${req.overlord.print} at priority ${req.priority}\n`;
                }
                else {
                    msg += `\t\t- "${role}":\n`;
                    for (const req of requests) {
                        msg += `\t\t\t${req.overlord.print} at priority ${req.priority}\n`;
                    }
                }
            }
            msg += `\n`;
        }
        console.log(msg);
    }
    static idleCreeps(colonySpec) {
        const colonies = this.resolveColonySpec(colonySpec);
        let idleCreeps = [];
        let msg = "The following creeps are idle:\n";
        for (const colony of colonies) {
            const idle = colony.overlords.default.idleZerg;
            if (idle.length === 0) {
                continue;
            }
            msg += `\t${bullet} ${colony.name}: ${idle.map((z) => z.print)}\n`;
            idleCreeps = idleCreeps.concat(...idle);
        }
        if (idleCreeps.length === 0) {
            msg = "No idle creeps";
        }
        console.log(msg);
        return idleCreeps;
    }
    static visuals() {
        Memory.settings.enableVisuals = !Memory.settings.enableVisuals;
        console.log(`Visuals ${Memory.settings.enableVisuals ? "enabled" : "disabled"}.`);
    }
    static showIntelVisuals(ticks = 100, range) {
        Memory.settings.intelVisuals.until = Game.time + ticks;
        Memory.settings.intelVisuals.range =
            range && range > 0 ? range : ROOMINTEL_DEFAULT_VISUALS_RANGE;
        RoomIntel$1.limitedRoomVisual = undefined;
        console.log(`Intel visuals enabled in range ${Memory.settings.intelVisuals.range} for the next ${ticks} ticks (until ${Memory.settings.intelVisuals.until}).`);
    }
    static showAssets(...args) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        var _j, _k;
        const colonyFilter = new Set();
        const resourceFilter = new Set();
        for (const arg of args) {
            if (typeof arg === "string" && RESOURCES_ALL.includes(arg)) {
                resourceFilter.add(arg);
            }
            else if (typeof arg === "string" && Overmind.colonies[arg]) {
                colonyFilter.add(arg);
            }
            else if (isColony(arg)) {
                colonyFilter.add(arg.name);
            }
        }
        let data = [];
        const columnifyOpts = {
            config: { resource: { align: "right" }, total: { align: "right" } },
            headingTransform(header) {
                if (header.startsWith("S-")) {
                    return "";
                }
                else if (header.startsWith("T-")) {
                    return header.substring(2);
                }
                else {
                    return header.toUpperCase();
                }
            },
        };
        for (const resourceType of RESOURCES_ALL) {
            if (resourceFilter.size > 0 && !resourceFilter.has(resourceType)) {
                continue;
            }
            let total = 0;
            const resourceTally = {
                resource: resourceType,
                total: 0,
            };
            for (const colony of Object.values(Overmind.colonies)) {
                let count = 0;
                count += (_b = (_a = colony.storage) === null || _a === void 0 ? void 0 : _a.store[resourceType]) !== null && _b !== void 0 ? _b : 0;
                count += (_d = (_c = colony.terminal) === null || _c === void 0 ? void 0 : _c.store[resourceType]) !== null && _d !== void 0 ? _d : 0;
                count += (_f = (_e = colony.factory) === null || _e === void 0 ? void 0 : _e.store[resourceType]) !== null && _f !== void 0 ? _f : 0;
                total += count;
                const threshold = TerminalNetwork.thresholds(colony, resourceType);
                const min = threshold.target - threshold.tolerance;
                const max = threshold.target + threshold.tolerance;
                let status = "~";
                if (count > 0 && count >= ((_g = threshold.surplus) !== null && _g !== void 0 ? _g : Infinity)) {
                    status = "!";
                }
                else if (count < min) {
                    status = "-";
                }
                else if (count > max) {
                    status = "+";
                }
                (_h = (_j = columnifyOpts.config)[_k = `T-${colony.name}`]) !== null && _h !== void 0 ? _h : (_j[_k] = {});
                columnifyOpts.config[`T-${colony.name}`].align = "right";
                resourceTally[`S-${colony.name}`] = status;
                resourceTally[`T-${colony.name}`] = count;
            }
            resourceTally.total = total;
            // We only display the row if there's any stored amount, unless we're filtering
            if (total > 0 ||
                resourceFilter.has(resourceType) ||
                colonyFilter.size) {
                data.push(resourceTally);
            }
        }
        data = data.sort((a, b) => {
            const a_prio = RESOURCE_IMPORTANCE.indexOf(a.resource);
            const b_prio = RESOURCE_IMPORTANCE.indexOf(b.resource);
            if (a_prio === b_prio) {
                return b.total - a.total;
            }
            if (a_prio === -1) {
                return 1;
            }
            if (b_prio === -1) {
                return -1;
            }
            return a_prio - b_prio;
        });
        if (colonyFilter.size > 0) {
            data = data.map((tally) => {
                const filteredTally = {
                    resource: tally.resource,
                    total: tally.total,
                };
                colonyFilter.forEach((name) => {
                    filteredTally[`S-${name}`] = tally[`S-${name}`];
                    filteredTally[`T-${name}`] = tally[`T-${name}`];
                });
                return filteredTally;
            });
        }
        let type = "all";
        if (colonyFilter.size || resourceFilter.size) {
            const filters = [
                ...colonyFilter.values(),
                ...resourceFilter.values(),
            ];
            type = `filtered on ${filters.join(", ")}`;
        }
        const msg = `Reporting ${type} assets:\n` +
            `\tThresholds markers: <b>!</b> - surplus, <b>+</b> - above, <b>~</b> - between, <b>-</b> - under\n` +
            columnify$1(data, columnifyOpts);
        console.log(msg);
        return data;
    }
    static toggleRoomActive(roomName, state) {
        const colonyName = Overmind.colonyMap[roomName];
        if (!colonyName) {
            log.error(`${roomName} is not a known outpost`);
            return;
        }
        const colony = Overmind.colonies[colonyName];
        if (state === undefined) {
            state = !colony.memory.outposts[roomName].active;
        }
        colony.memory.outposts[roomName].active = state;
        console.log(`Toggled room ${roomName} of colony ${colony.name} ${state ? "online" : "offline"}`);
    }
    static listFactories() {
        const status = getAllColonies()
            .filter((c) => c.infestedFactory)
            .map((c) => {
            var _a, _b;
            return Object.assign({ colony: c.name }, (_a = c.infestedFactory) === null || _a === void 0 ? void 0 : _a.memory.activeProduction, { produced: (_b = c.infestedFactory) === null || _b === void 0 ? void 0 : _b.memory.produced });
        });
        log.info(`Factory status:\n${columnify$1(status)}`);
    }
    static resetFactories() {
        _.each(_.filter(Overmind.colonies, (c) => c.infestedFactory), (c) => (c.infestedFactory.memory.suspendProductionUntil = Game.time));
    }
}
OvermindConsole.commands = [
    {
        name: "help",
        description: "show this message",
        command: () => OvermindConsole.help(),
    },
    {
        name: "info()",
        description: "display version and operation information",
        command: () => OvermindConsole.info(),
    },
    {
        name: "notifications()",
        description: "print a list of notifications with hyperlinks to the console",
        command: () => OvermindConsole.notifications(),
    },
    {
        name: "setMode(mode)",
        description: 'set the operational mode to "manual", "semiautomatic", or "automatic"',
        command: OvermindConsole.setMode.bind(OvermindConsole),
    },
    {
        name: "setSignature(newSignature)",
        description: "set your controller signature; no argument sets to default",
        command: OvermindConsole.setSignature.bind(OvermindConsole),
    },
    {
        name: "print(...args[])",
        description: "log stringified objects to the console",
        command: OvermindConsole.print.bind(OvermindConsole),
    },
    {
        name: "debug(thing | ...things)",
        description: "enable debug logging for a game object or process",
        command: OvermindConsole.debug.bind(OvermindConsole),
    },
    {
        name: "stopDebug(thing | ...things)",
        description: "disable debug logging for a game object or process",
        command: OvermindConsole.debug.bind(OvermindConsole),
    },
    {
        name: "timeit(function, repeat=1)",
        description: "time the execution of a snippet of code",
        command: OvermindConsole.timeit.bind(OvermindConsole),
    },
    {
        name: "profileOverlord(overlord, ticks?)",
        description: "start profiling on an overlord instance or name",
        command: OvermindConsole.profileOverlord.bind(OvermindConsole),
    },
    {
        name: "finishProfilingOverlord(overlord)",
        description: "stop profiling on an overlord",
        command: OvermindConsole.finishProfilingOverlord.bind(OvermindConsole),
    },
    {
        name: "setLogLevel(int)",
        description: "set the logging level from 0 - 4",
        command: log.setLogLevel.bind(OvermindConsole),
    },
    {
        name: "suspendColony(roomName)",
        description: "suspend operations within a colony",
        command: OvermindConsole.suspendColony.bind(OvermindConsole),
    },
    {
        name: "unsuspendColony(roomName)",
        description: "resume operations within a suspended colony",
        command: OvermindConsole.unsuspendColony.bind(OvermindConsole),
    },
    {
        name: "listSuspendedColonies()",
        description: "Prints all suspended colonies",
        command: OvermindConsole.listSuspendedColonies.bind(OvermindConsole),
    },
    {
        name: "openRoomPlanner(roomName)",
        description: "open the room planner for a room",
        command: OvermindConsole.openRoomPlanner.bind(OvermindConsole),
    },
    {
        name: "closeRoomPlanner(roomName)",
        description: "close the room planner and save changes",
        command: OvermindConsole.closeRoomPlanner.bind(OvermindConsole),
    },
    {
        name: "cancelRoomPlanner(roomName)",
        description: "close the room planner and discard changes",
        command: OvermindConsole.cancelRoomPlanner.bind(OvermindConsole),
    },
    {
        name: "listActiveRoomPlanners()",
        description: "display a list of colonies with open room planners",
        command: OvermindConsole.listActiveRoomPlanners.bind(OvermindConsole),
    },
    {
        name: "destroyErrantStructures(roomName)",
        description: "destroys all misplaced structures within an owned room",
        command: OvermindConsole.destroyErrantStructures.bind(OvermindConsole),
    },
    {
        name: "destroyAllHostileStructures(roomName)",
        description: "destroys all hostile structures in an owned room",
        command: OvermindConsole.destroyAllHostileStructures.bind(OvermindConsole),
    },
    {
        name: "destroyAllBarriers(roomName)",
        description: "destroys all ramparts and barriers in a room",
        command: OvermindConsole.destroyAllBarriers.bind(OvermindConsole),
    },
    {
        name: "listConstructionSites(filter?)",
        description: "list all construction sites matching an optional filter",
        command: OvermindConsole.listConstructionSites.bind(OvermindConsole),
    },
    {
        name: "removeUnbuiltConstructionSites()",
        description: "removes all construction sites with 0 progress",
        command: OvermindConsole.removeUnbuiltConstructionSites.bind(OvermindConsole),
    },
    {
        name: "listDirectives(filter?)",
        description: "list directives, matching a filter if specified",
        command: OvermindConsole.listDirectives.bind(OvermindConsole),
    },
    {
        name: "listPersistentDirectives()",
        description: "print type, name, pos of every persistent directive",
        command: OvermindConsole.listPersistentDirectives.bind(OvermindConsole),
    },
    {
        name: "removeFlagsByColor(color, secondaryColor)",
        description: "remove flags that match the specified colors",
        command: OvermindConsole.removeFlagsByColor.bind(OvermindConsole),
    },
    {
        name: "removeErrantFlags()",
        description: "remove all flags which don't match a directive",
        command: OvermindConsole.removeErrantFlags.bind(OvermindConsole),
    },
    {
        name: "deepCleanMemory()",
        description: "deletes all non-critical portions of memory (be careful!)",
        command: OvermindConsole.deepCleanMemory.bind(OvermindConsole),
    },
    {
        name: "profileMemory(root=Memory, depth=1)",
        description: "scan through memory to get the size of various objects",
        command: OvermindConsole.profileMemory.bind(OvermindConsole),
    },
    {
        name: "startRemoteDebugSession()",
        description: "enables the remote debugger so Muon can debug your code",
        command: OvermindConsole.startRemoteDebugSession.bind(OvermindConsole),
    },
    {
        name: "cancelMarketOrders(filter?)",
        description: "cancels all market orders matching filter (if provided)",
        command: OvermindConsole.cancelMarketOrders.bind(OvermindConsole),
    },
    {
        name: "setRoomUpgradeRate(Colony|string, upgradeRate?)",
        description: "changes the rate which a room upgrades at, default is 1. Pass no rate to get the current value",
        command: OvermindConsole.setRoomUpgradeRate.bind(OvermindConsole),
    },
    {
        name: "getEmpireMineralDistribution()",
        description: "returns current census of colonies and mined sk room minerals",
        command: OvermindConsole.getEmpireMineralDistribution.bind(OvermindConsole),
    },
    {
        name: "listPortals(rangeFromColonies)",
        description: "returns active portals within colony range",
        command: OvermindConsole.listPortals.bind(OvermindConsole),
    },
    {
        name: "evaluateOutpostEfficiencies()",
        description: "prints all colony outposts efficiency",
        command: OvermindConsole.evaluateOutpostEfficiencies.bind(OvermindConsole),
    },
    {
        name: "evaluatePotentialOutpostEfficiencies()",
        description: "prints all nearby unmined outposts",
        command: OvermindConsole.evaluatePotentialOutpostEfficiencies.bind(OvermindConsole),
    },
    {
        name: "showRoomSafety(roomName?)",
        description: "show gathered safety data about rooms",
        command: OvermindConsole.showRoomSafety.bind(OvermindConsole),
    },
    {
        name: "spawnSummary(Colony | string)",
        description: "show all ongoing spawn requests",
        command: OvermindConsole.spawnSummary.bind(OvermindConsole),
    },
    {
        name: "idleCreeps(Colony | string)",
        description: "show all idle creeps",
        command: OvermindConsole.idleCreeps.bind(OvermindConsole),
    },
    {
        name: "visuals()",
        description: "enable/disable showing visuals",
        command: OvermindConsole.visuals.bind(OvermindConsole),
    },
    {
        name: "showIntelVisuals(ticks?, range?)",
        description: "show intel in range using visuals (ticks defaults to 100)",
        command: OvermindConsole.showIntelVisuals.bind(OvermindConsole),
    },
    {
        name: "showAssets()",
        description: "show all available resources across colonies",
        command: OvermindConsole.showAssets.bind(OvermindConsole),
    },
    {
        name: "toggleRoomActive(roomName, state?)",
        description: "activate or deactivate a given room",
        command: OvermindConsole.toggleRoomActive.bind(OvermindConsole),
    },
    {
        name: "listFactories()",
        description: "list all factories and their status",
        command: OvermindConsole.listFactories.bind(OvermindConsole),
    },
    {
        name: "resetFactories()",
        description: "reset all factories production queues",
        command: OvermindConsole.resetFactories.bind(OvermindConsole),
    },
];

/**
 * GameCache does initial low-level preprocessing before each tick is run
 */
let GameCache = class GameCache {
    constructor() {
        this.outpostFlags = _.filter(Game.flags, (flag) => DirectiveOutpost.filter(flag) || DirectiveSKOutpost.filter(flag));
    }
    cacheCreepByColony(creep) {
        const colony = creep.memory["C" /* MEM.COLONY */];
        if (colony) {
            if (!this.creepsByColony[colony]) {
                this.creepsByColony[colony] = [];
            }
            this.creepsByColony[colony].push(creep);
        }
    }
    cacheOverlord(creep) {
        const overlordRef = creep.memory["O" /* MEM.OVERLORD */];
        const role = creep.memory.role;
        if (overlordRef && role) {
            if (!this.overlords[overlordRef]) {
                this.overlords[overlordRef] = {};
            }
            if (!this.overlords[overlordRef][role]) {
                this.overlords[overlordRef][role] = [];
            }
            this.overlords[overlordRef][role].push(creep.name);
        }
    }
    cacheTaskTargets(creep) {
        var _a;
        var _b, _c;
        let task = creep.memory.task;
        while (task) {
            (_a = (_b = this.targets)[_c = task._target.ref]) !== null && _a !== void 0 ? _a : (_b[_c] = []);
            this.targets[task._target.ref].push(creep.name);
            task = task._parent;
        }
    }
    rebuildCache() {
        this.overlords = {};
        this.creepsByColony = {};
        this.targets = {};
        for (const name of Object.keys(Game.creeps)) {
            const creep = Game.creeps[name];
            this.cacheCreepByColony(creep);
            this.cacheOverlord(creep);
            this.cacheTaskTargets(creep);
        }
        for (const name of Object.keys(Game.powerCreeps)) {
            const creep = Game.powerCreeps[name];
            this.cacheOverlord(creep);
            this.cacheTaskTargets(creep);
        }
    }
    build() {
        this.rebuildCache();
    }
    refresh() {
        this.rebuildCache();
    }
};
GameCache = __decorate$1([
    profile
], GameCache);

/**
 * Claim an unowned room
 */
let ClaimingOverlord = class ClaimingOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.colonization.claim) {
        super(directive, "claim", priority);
        this.directive = directive;
        this.claimers = this.zerg(Roles.claim);
    }
    init() {
        const amount = $.number(this, "claimerAmount", () => {
            if (this.room) {
                // if you have vision
                if (this.room.my) {
                    // already claimed
                    return 0;
                }
                else {
                    // don't ask for claimers if you can't reach controller
                    const pathablePos = this.room.creeps[0] ?
                        this.room.creeps[0].pos
                        : Pathing.findPathablePosition(this.room.name);
                    if (!Pathing.isReachable(pathablePos, this.room.controller.pos, _.filter(this.room.structures, (s) => !s.isWalkable))) {
                        return 0;
                    }
                }
            }
            return 1; // otherwise ask for 1 claimer
        });
        const setup = this.colony.level > 4 ?
            Setups.infestors.fastClaim
            : Setups.infestors.claim;
        this.wishlist(amount, setup);
    }
    handleClaimer(claimer) {
        if (claimer.room == this.room && !claimer.pos.isEdge) {
            if (!this.room.controller.signedByMe) {
                // Takes care of an edge case where planned newbie zone signs prevents signing until room is reserved
                if (!this.room.my && this.room.controller.signedByScreeps) {
                    claimer.task = Tasks$1.claim(this.room.controller);
                }
                else {
                    claimer.task = Tasks$1.signController(this.room.controller);
                }
            }
            else {
                claimer.task = Tasks$1.claim(this.room.controller);
            }
        }
        else {
            claimer.goTo(this.pos, {
                pathOpts: { ensurePath: true, avoidSK: true },
            });
        }
    }
    run() {
        this.autoRun(this.claimers, (claimer) => this.handleClaimer(claimer));
        if (this.room &&
            this.room.controller &&
            this.room.controller.my &&
            this.room.controller.signedByMe) {
            for (const claimer of this.claimers) {
                claimer.retire();
            }
        }
    }
};
ClaimingOverlord = __decorate$1([
    profile
], ClaimingOverlord);

/**
 * Spawns special-purpose haulers for transporting resources to/from a specified target
 */
let HaulingOverlord = class HaulingOverlord extends Overlord {
    constructor(directive, priority = directive.hasDrops ?
        OverlordPriority.collectionUrgent.haul
        : OverlordPriority.tasks.haul) {
        super(directive, "haul", priority);
        this.directive = directive;
        this.haulers = this.zerg(Roles.transport);
    }
    init() {
        if (!this.colony.storage ||
            ResourceManager.isOverCapacity(this.colony.storage)) {
            return;
        }
        // Spawn a number of haulers sufficient to move all resources within a lifetime, up to a max
        const MAX_HAULERS = 5;
        // Calculate total needed amount of hauling power as (resource amount * trip distance)
        const tripDistance = 2 *
            (Pathing.distance((this.colony.storage || this.colony).pos, this.directive.pos) || 0);
        const haulingPowerNeeded = Math.min(this.directive.totalResources, this.colony.storage.store.getCapacity() -
            this.colony.storage.store.getUsedCapacity()) * tripDistance;
        // Calculate amount of hauling each hauler provides in a lifetime
        const haulerCarryParts = Setups.transporters.early.getBodyPotential(CARRY, this.colony);
        const haulingPowerPerLifetime = CREEP_LIFE_TIME * haulerCarryParts * CARRY_CAPACITY;
        // Calculate number of haulers
        const numHaulers = Math.min(Math.ceil(haulingPowerNeeded / haulingPowerPerLifetime), MAX_HAULERS);
        // Request the haulers
        if (this.haulers.length === 0) {
            this.wishlist(numHaulers, Setups.transporters.early, {
                priority: OverlordPriority.collectionUrgent.haul,
            });
        }
        else {
            this.wishlist(numHaulers, Setups.transporters.early);
        }
    }
    handleHauler(hauler) {
        if (hauler.store.getUsedCapacity() == 0) {
            // Travel to directive and collect resources
            if (hauler.inSameRoomAs(this.directive)) {
                // Pick up drops first
                if (this.directive.hasDrops) {
                    const allDrops = _.flatten(_.values(this.directive.drops));
                    const drop = _.find(allDrops, (drop) => drop.resourceType != "energy") || allDrops[0];
                    if (drop) {
                        hauler.task = Tasks$1.pickup(drop);
                        return;
                    }
                }
                // Withdraw from store structure
                if (this.directive.storeStructure) {
                    const store = this.directive.store;
                    let totalDrawn = 0; // Fill to full
                    for (const resourceType of (Object.keys(store))) {
                        if (store[resourceType] > 0) {
                            if (hauler.task) {
                                hauler.task = Tasks$1.withdraw(this.directive.storeStructure, resourceType).fork(hauler.task);
                            }
                            else {
                                hauler.task = Tasks$1.withdraw(this.directive.storeStructure, resourceType);
                            }
                            totalDrawn += store[resourceType];
                            if (totalDrawn >= hauler.store.getCapacity()) {
                                return;
                            }
                        }
                    }
                    if (hauler.task) {
                        // If can't fill up, just go ahead and go home
                        // log.notify(`Can't finish filling up ${totalDrawn} ${JSON.stringify(hauler.task)} ${this.room}`);
                        return;
                    }
                }
                // Shouldn't reach here
                log.warning(`${hauler.name} in ${hauler.room.print}: nothing to collect!`);
            }
            else {
                // hauler.task = Tasks.goTo(this.directive);
                hauler.goTo(this.directive, { pathOpts: { avoidSK: true } });
            }
        }
        else {
            // Travel to colony room and deposit resources
            if (hauler.inSameRoomAs(this.colony)) {
                // Put energy in storage and minerals in terminal if there is one
                for (const [resourceType, amount] of hauler.store.contents) {
                    if (amount == 0) {
                        continue;
                    }
                    if (resourceType == RESOURCE_ENERGY) {
                        // prefer to put energy in storage
                        if (this.colony.storage &&
                            this.colony.storage.store.getUsedCapacity() <
                                STORAGE_CAPACITY) {
                            hauler.task = Tasks$1.transfer(this.colony.storage, resourceType);
                            return;
                        }
                        else if (this.colony.terminal &&
                            this.colony.terminal.store.getUsedCapacity() <
                                TERMINAL_CAPACITY) {
                            hauler.task = Tasks$1.transfer(this.colony.terminal, resourceType);
                            return;
                        }
                    }
                    else {
                        // prefer to put minerals in terminal
                        if (this.colony.terminal &&
                            this.colony.terminal.my &&
                            this.colony.terminal.store.getUsedCapacity() <
                                TERMINAL_CAPACITY) {
                            hauler.task = Tasks$1.transfer(this.colony.terminal, resourceType);
                            return;
                        }
                        else if (this.colony.storage &&
                            this.colony.storage.store.getUsedCapacity() <
                                STORAGE_CAPACITY) {
                            hauler.task = Tasks$1.transfer(this.colony.storage, resourceType);
                            return;
                        }
                    }
                }
                // Shouldn't reach here
                log.warning(`${hauler.name} in ${hauler.room.print}: nowhere to put resources!`);
            }
            else {
                hauler.task = Tasks$1.goToRoom(this.colony.room.name);
            }
        }
    }
    run() {
        this.autoRun(this.haulers, (hauler) => this.handleHauler(hauler));
        // TODO: fix the way this is done
        if (this.directive.memory.totalResources == 0 &&
            this.haulers.filter((hauler) => hauler.store.getUsedCapacity() > 0)
                .length == 0) {
            this.directive.remove();
        }
    }
};
HaulingOverlord = __decorate$1([
    profile
], HaulingOverlord);

var DirectiveHaul_1;
/**
 * Hauling directive: spawns hauler creeps to move large amounts of resources from a location (e.g. draining a storage)
 */
let DirectiveHaul = DirectiveHaul_1 = class DirectiveHaul extends Directive {
    constructor(flag) {
        super(flag, (colony) => colony.level >= DirectiveHaul_1.requiredRCL);
    }
    spawnMoarOverlords() {
        this.overlords.haul = new HaulingOverlord(this);
    }
    get targetedBy() {
        return Overmind.cache.targets[this.ref];
    }
    get drops() {
        if (!this.pos.isVisible) {
            return {};
        }
        if (!this._drops) {
            const drops = this.pos.lookFor(LOOK_RESOURCES);
            this._drops = (_.groupBy(drops, (drop) => drop.resourceType));
        }
        return this._drops;
    }
    get hasDrops() {
        return _.keys(this.drops).length > 0;
    }
    get storeStructure() {
        if (this.pos.isVisible) {
            return (this.pos.lookForStructure(STRUCTURE_STORAGE) ||
                this.pos.lookForStructure(STRUCTURE_TERMINAL) ||
                this.pos.lookForStructure(STRUCTURE_NUKER) ||
                this.pos.lookForStructure(STRUCTURE_CONTAINER) ||
                this.pos
                    .lookFor(LOOK_RUINS)
                    .filter((ruin) => ruin.store.getUsedCapacity() > 0)[0] ||
                this.pos
                    .lookFor(LOOK_TOMBSTONES)
                    .filter((tombstone) => tombstone.store.getUsedCapacity() > 0)[0]);
        }
        return undefined;
    }
    get store() {
        if (!this._store) {
            // Merge the "storage" of drops with the store of structure
            let store = {};
            if (this.storeStructure) {
                store = this.storeStructure.store;
            }
            else {
                store = { energy: 0 };
            }
            // Merge with drops
            for (const resourceType of _.keys(this.drops)) {
                const totalResourceAmount = _.sum(this.drops[resourceType], (drop) => drop.amount);
                if (store[resourceType]) {
                    store[resourceType] += totalResourceAmount;
                }
                else {
                    store[resourceType] = totalResourceAmount;
                }
            }
            this._store = store;
        }
        // log.alert(`Haul directive ${this.print} has store of ${JSON.stringify(this._store)}`);
        return this._store;
    }
    /**
     * Total amount of resources remaining to be transported; cached into memory in case room loses visibility
     */
    get totalResources() {
        if (this.pos.isVisible && this.store) {
            this.memory.totalResources = _.sum(this.store); // update total amount remaining
        }
        else {
            if (this.memory.totalResources == undefined) {
                return 1000; // pick some non-zero number so that haulers will spawn
            }
        }
        return this.memory.totalResources;
    }
    init() {
        this.alert(`Haul directive active - ${this.totalResources}`);
    }
    run() {
        if (this.pos.isVisible && _.sum(this.store) == 0) {
            // If everything is picked up, crudely give enough time to bring it back
            this._finishAtTime = this._finishAtTime || Game.time + 300;
        }
        if (Game.time >= this._finishAtTime ||
            (this.totalResources == 0 &&
                this.overlords.haul.haulers.length == 0)) ;
    }
};
DirectiveHaul.directiveName = "haul";
DirectiveHaul.color = COLOR_YELLOW;
DirectiveHaul.secondaryColor = COLOR_BLUE;
DirectiveHaul = DirectiveHaul_1 = __decorate$1([
    profile
], DirectiveHaul);

/**
 * Register a target to be dismantled by workers. This is not a siege directive, and clearing rooms should
 * be done with the DirectiveRoomClear
 */
let DirectiveDismantle = class DirectiveDismantle extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() { }
    getTarget() {
        if (!this.pos.isVisible) {
            return;
        }
        const targetedStructures = this.pos.lookFor(LOOK_STRUCTURES);
        for (const structure of targetedStructures) {
            for (const structureType of AttackStructurePriorities) {
                if (structure.structureType == structureType) {
                    return structure;
                }
            }
        }
    }
    init() {
        // Add this structure to worker overlord's dismantle list
        const target = this.getTarget();
        if (target &&
            !this.colony.overlords.work.dismantleStructures.includes(target)) {
            this.colony.overlords.work.dismantleStructures.push(target);
        }
    }
    run() {
        // Remove the directive once structures have been destroyed
        if (this.pos.isVisible && !this.getTarget()) {
            this.remove();
        }
    }
    visuals() {
        Visualizer.marker(this.pos, { color: "yellow" });
    }
};
DirectiveDismantle.directiveName = "dismantle";
DirectiveDismantle.color = COLOR_GREY;
DirectiveDismantle.secondaryColor = COLOR_YELLOW;
DirectiveDismantle = __decorate$1([
    profile
], DirectiveDismantle);

/**
 * Claims a new room, destroys all structures in the room, then unclaims it
 */
let DirectiveClearRoom = class DirectiveClearRoom extends Directive {
    constructor(flag) {
        super(flag, (colony) => colony.level >= 3);
        // Remove if misplaced
        if (Cartographer.roomType(this.pos.roomName) != ROOMTYPE_CONTROLLER) {
            log.warning(`${this.print}: ${printRoomName(this.pos.roomName)} is not a controller room; ` + `removing directive!`);
            this.remove(true);
        }
        if (Memory.settings.resourceCollectionMode &&
            Memory.settings.resourceCollectionMode >= 1) {
            this.memory.keepStorageStructures = true;
        }
        this.memory.preexistingFlags = _.filter(Game.flags, (testingflag) => testingflag.pos.roomName == flag.pos.roomName &&
            testingflag.name != flag.name).map((testingFlag) => testingFlag.name);
        console.log("Existing flags in clear room are " +
            JSON.stringify(this.memory.preexistingFlags));
    }
    spawnMoarOverlords() {
        this.overlords.claim = new ClaimingOverlord(this);
    }
    init() {
        this.alert(`Clearing out room`);
    }
    removeAllStructures() {
        const keepStorageStructures = this.memory.keepStorageStructures !== undefined ?
            this.memory.keepStorageStructures
            : true;
        const keepRoads = this.memory.keepRoads !== undefined ? this.memory.keepRoads : true;
        const keepContainers = this.memory.keepContainers !== undefined ?
            this.memory.keepContainers
            : true;
        if (this.room) {
            const allStructures = this.room.find(FIND_STRUCTURES);
            let i = 0;
            for (const s of allStructures) {
                if (s.structureType == STRUCTURE_CONTROLLER) {
                    continue;
                }
                if (keepStorageStructures &&
                    (s.structureType == STRUCTURE_STORAGE ||
                        s.structureType == STRUCTURE_TERMINAL) &&
                    !s.isEmpty) {
                    // Create a collection flag
                    DirectiveHaul.createIfNotPresent(s.pos, "pos");
                    continue;
                }
                if (s.structureType == STRUCTURE_NUKER && s.energy > 50000) {
                    DirectiveHaul.createIfNotPresent(s.pos, "pos");
                }
                if (keepRoads && s.structureType == STRUCTURE_ROAD) {
                    continue;
                }
                if (keepContainers && s.structureType == STRUCTURE_CONTAINER) {
                    continue;
                }
                const result = s.destroy();
                if (result == OK) {
                    i++;
                }
            }
            log.alert(`Destroyed ${i} structures in ${this.room.print}.`);
            this.memory.completedTime = Game.time;
            return true;
        }
        else {
            return false;
        }
    }
    findStructureBlockingController(pioneer) {
        const blockingPos = Pathing.findBlockingPos(pioneer.pos, pioneer.room.controller.pos, _.filter(pioneer.room.structures, (s) => !s.isWalkable));
        if (blockingPos) {
            const structure = blockingPos.lookFor(LOOK_STRUCTURES)[0];
            if (structure) {
                return structure;
            }
            else {
                log.error(`${this.print}: no structure at blocking pos ${blockingPos.print}! (Why?)`);
            }
        }
    }
    cleanupFlags() {
        if (!this.room) {
            return false;
        }
        for (const flag of this.room.flags) {
            if (!_.contains(this.memory.preexistingFlags, flag.name) &&
                flag.name != this.flag.name &&
                !DirectiveHaul.filter(flag)) {
                flag.remove();
            }
        }
    }
    run() {
        // Remove if structures are done
        if (this.room && this.room.my) {
            const done = this.removeAllStructures();
            if (done) {
                const result = this.room.controller.unclaim();
                // Clear up flags that weren't there before and aren't haul
                this.cleanupFlags();
                log.notify(`Removing clearRoom directive in ${this.pos.roomName}: operation completed.`);
                if (result == OK) {
                    this.remove();
                    Overmind.shouldBuild = true; // rebuild to account for difference in rooms
                }
            }
            // Clear path if controller is not reachable
        }
        else if (this.room && this.room.creeps.length > 1) {
            const currentlyDismantlingLocations = DirectiveDismantle.find(this.room.flags);
            if (currentlyDismantlingLocations.length == 0) {
                const pathablePos = this.room.creeps[0] ?
                    this.room.creeps[0].pos
                    : Pathing.findPathablePosition(this.room.name);
                const blockingLocation = Pathing.findBlockingPos(pathablePos, this.room.controller.pos, _.filter(this.room.structures, (s) => !s.isWalkable));
                if (blockingLocation &&
                    !Directive.isPresent(blockingLocation)) {
                    log.notify(`Adding dismantle directive for ${this.pos.roomName} to reach controller.`);
                    DirectiveDismantle.create(blockingLocation);
                }
            }
        }
        // Remove if owned by other player
        if (Game.time % 10 == 2 &&
            this.room &&
            !!this.room.owner &&
            !this.room.my) {
            log.notify(`Removing clearRoom directive in ${this.pos.roomName}: room already owned by another player.`);
            this.remove();
        }
    }
};
DirectiveClearRoom.directiveName = "clearRoom";
DirectiveClearRoom.color = COLOR_PURPLE;
DirectiveClearRoom.secondaryColor = COLOR_ORANGE;
DirectiveClearRoom = __decorate$1([
    profile
], DirectiveClearRoom);

var RoomPoisonerOverlord_1;
/**
 * Spawn roomPoisoner - upgrqde controller to lvl2, wall in controller then sources.
 */
let RoomPoisonerOverlord = RoomPoisonerOverlord_1 = class RoomPoisonerOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.outpostOffense.roomPoisoner) {
        super(directive, "PoisonRoom", priority);
        this.roomPoisoners = this.zerg(Roles.roomPoisoner);
    }
    init() {
        // Re-compute the list of positions to block
        if (this.room) {
            const thingsToBlock = _.compact([
                this.room.controller,
                ...this.room.sources,
            ]);
            const neighborTiles = _.unique(_.flatten(_.map(thingsToBlock, (obj) => obj.pos.neighbors)), (pos) => packPos(pos));
            this.blockPositions = _.filter(neighborTiles, (pos) => pos.isWalkable(true));
        }
        else {
            this.blockPositions = [];
        }
        if (this.room && this.room.dangerousPlayerHostiles.length == 0) {
            this.wishlist(1, Setups.roomPoisoner);
        }
    }
    handleRoomPoisoner(posioner) {
        // Recharge if needed
        if (posioner.store.energy < BUILD_POWER) {
            posioner.task = Tasks$1.recharge();
            return;
        }
        // Go to Target Room
        if (!posioner.inSameRoomAs(this)) {
            posioner.goTo(this.pos, {
                pathOpts: { ensurePath: true, avoidSK: true },
            });
            return;
        }
        // If you're in the room
        if (this.room && this.room.controller && this.room.controller.my) {
            // Upgrade controller to level 2
            if (this.room.controller.level < 2) {
                posioner.task = Tasks$1.upgrade(this.room.controller);
                return;
            }
            // Fortify any walls below threshold (can't used cached room.walls here)
            const wallsUncached = this.room.find(FIND_STRUCTURES, {
                filter: { structureType: STRUCTURE_WALL },
            });
            const fortifyTarget = _.find(wallsUncached, (wall) => wall.hits < RoomPoisonerOverlord_1.settings.wallHits);
            if (fortifyTarget) {
                posioner.task = Tasks$1.fortify(fortifyTarget, RoomPoisonerOverlord_1.settings.wallHits);
                return;
            }
            // Construct walls
            const wallConstructionSite = _.first(this.room.constructionSites);
            if (wallConstructionSite) {
                posioner.task = Tasks$1.build(wallConstructionSite);
                return;
            }
            // If nothing to do, then move away from possible construction site locations
            posioner.flee(this.blockPositions, {}, { fleeRange: 4 });
        }
    }
    run() {
        this.autoRun(this.roomPoisoners, (roomPoisoner) => this.handleRoomPoisoner(roomPoisoner));
    }
};
RoomPoisonerOverlord = RoomPoisonerOverlord_1 = __decorate$1([
    profile
], RoomPoisonerOverlord);

/**
 * General purpose skirmishing overlord for dealing with player combat in an outpost
 */
let OutpostDefenseOverlord = class OutpostDefenseOverlord extends CombatOverlord {
    constructor(directive, priority = OverlordPriority.outpostDefense.outpostDefense) {
        super(directive, "outpostDefense", priority, { requiredRCL: 1 });
        // this.spawnGroup.settings.flexibleEnergy = true;
        this.zerglings = this.combatZerg(Roles.melee);
        this.hydralisks = this.combatZerg(Roles.ranged);
        this.healers = this.combatZerg(Roles.healer);
    }
    handleCombat(zerg) {
        if (this.room && this.room.hostiles.length == 0) {
            zerg.doMedicActions(this.room.name);
        }
        else {
            zerg.autoSkirmish(this.pos.roomName);
        }
    }
    handleHealer(healer) {
        if (CombatIntel$1.isHealer(healer) &&
            healer.getActiveBodyparts(HEAL) == 0) {
            if (this.colony.towers.length > 0) {
                return healer.goToRoom(this.colony.room.name); // go get healed
            }
            else {
                return healer.retire(); // you're useless at this point // TODO: this isn't smart
            }
        }
        else {
            if (this.room &&
                _.any([...this.zerglings, ...this.hydralisks], (creep) => creep.room == this.room)) {
                this.handleCombat(healer); // go to room if there are any fighters in there
            }
            else {
                healer.autoSkirmish(healer.room.name);
            }
        }
    }
    // private computeNeededHydraliskAmount(setup: CombatCreepSetup, enemyRangedPotential: number): number {
    // 	const hydraliskPotential = setup.getBodyPotential(RANGED_ATTACK, this.colony);
    // 	// TODO: body potential from spawnGroup energy?
    // 	// let worstDamageMultiplier = CombatIntel.minimumDamageMultiplierForGroup(this.room.hostiles);
    // 	// TODO this was reduced from 1.5 due to draining, but should be re-evaluated when we have infra in place to track
    // 	// If a directive is being too costly
    // 	return Math.ceil(1.1 * enemyRangedPotential / hydraliskPotential);
    // }
    //
    // // TODO: division by 0 error!
    // private computeNeededBroodlingAmount(setup: CombatCreepSetup, enemyAttackPotential: number): number {
    // 	const broodlingPotential = setup.getBodyPotential(ATTACK, this.colony);
    // 	// let worstDamageMultiplier = CombatIntel.minimumDamageMultiplierForGroup(this.room.hostiles);
    // 	return Math.ceil(1.1 * enemyAttackPotential / broodlingPotential);
    // }
    //
    // private computeNeededHealerAmount(setup: CombatCreepSetup, enemyHealPotential: number): number {
    // 	const healerPotential = setup.getBodyPotential(HEAL, this.colony);
    // 	return Math.ceil(1.1 * enemyHealPotential / healerPotential);
    // }
    getEnemyPotentials() {
        if (this.room) {
            return CombatIntel$1.getCombatPotentials(this.room.hostiles);
        }
        else {
            return { attack: 0, ranged: 1, heal: 0 };
        }
    }
    init() {
        const enemyPotentials = this.getEnemyPotentials();
        const needAttack = enemyPotentials.attack * 1.1;
        const needRanged = enemyPotentials.ranged * 1.3;
        const needHeal = enemyPotentials.heal * 1.2;
        if (needAttack > 100 || needRanged > 100 || needHeal > 100) {
            log.warning(`${this.print}: too much firepower needed to fight: ${JSON.stringify(enemyPotentials)}`);
            return; // fuck it let's not fight this
        }
        // Only try to obtain one additional creep at a time
        if (this.reassignIdleCreeps(Roles.melee, 1)) {
            return;
        }
        if (this.reassignIdleCreeps(Roles.ranged, 1)) {
            return;
        }
        if (this.reassignIdleCreeps(Roles.healer, 1)) {
            return;
        }
        const noBigColoniesNearby = _.all(this.spawnGroup.colonies, (col) => col.room.energyCapacityAvailable < 800);
        const myPotentials = CombatIntel$1.getCombatPotentials([
            ...this.zerglings,
            ...this.hydralisks,
            ...this.healers,
        ]);
        // if (attack > 30 || rangedAttack > 30) {
        // 	// Handle boost worthy attackers
        // 	this.wishlist(1, CombatSetups.hydralisks.boosted_T3);
        // }
        const hydraliskSetup = noBigColoniesNearby ?
            CombatSetups.hydralisks.noHeal
            : CombatSetups.hydralisks.default;
        const zerglingSetup = noBigColoniesNearby ?
            CombatSetups.zerglings.default
            : CombatSetups.zerglings.healing;
        const healerSetup = CombatSetups.transfusers.default;
        if (myPotentials.ranged < needRanged) {
            this.requestCreep(hydraliskSetup);
        }
        else if (myPotentials.heal < needHeal) {
            this.requestCreep(healerSetup);
        }
        else if (myPotentials.attack < needAttack) {
            this.requestCreep(zerglingSetup);
        }
    }
    run() {
        this.autoRun(this.zerglings, (zergling) => this.handleCombat(zergling));
        this.autoRun(this.hydralisks, (hydralisk) => this.handleCombat(hydralisk));
        this.autoRun(this.healers, (healer) => this.handleHealer(healer));
    }
};
OutpostDefenseOverlord = __decorate$1([
    profile
], OutpostDefenseOverlord);

/**
 * Defend an outpost against an incoming player invasion
 */
let DirectiveOutpostDefense = class DirectiveOutpostDefense extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
        this.overlords.outpostDefense = new OutpostDefenseOverlord(this);
    }
    init() {
        const numHostiles = this.room ? this.room.hostiles.length.toString() : "???";
        this.alert(`Outpost defense (hostiles: ${numHostiles})`, NotifierPriority.High);
    }
    run() {
        if (!this.room || this.room.hostiles.length > 0) {
            this.memory.safeSince = Game.time;
        }
        // If there are no hostiles left in the room and everyone's healed, then remove the flag
        if (this.room &&
            this.room.hostiles.length == 0 &&
            Game.time - this.memory.safeSince > 100) {
            if (_.filter(this.room.creeps, (creep) => creep.hits < creep.hitsMax).length == 0) {
                this.remove();
            }
        }
    }
};
DirectiveOutpostDefense.directiveName = "outpostDefense";
DirectiveOutpostDefense.color = COLOR_BLUE;
DirectiveOutpostDefense.secondaryColor = COLOR_RED;
DirectiveOutpostDefense = __decorate$1([
    profile
], DirectiveOutpostDefense);

var ControllerAttackerOverlord_1;
/**
 * Controller attacker overlord.  Spawn CLAIM creeps to mass up on a controller and attack all at once
 * This module was contributed by @sarrick and has since been modified
 */
let ControllerAttackerOverlord = ControllerAttackerOverlord_1 = class ControllerAttackerOverlord extends CombatOverlord {
    constructor(directive, priority = OverlordPriority.offense.controllerAttack) {
        super(directive, "controllerAttack", priority, {
            requiredRCL: ControllerAttackerOverlord_1.requiredRCL,
        });
        this.controllerAttackers = this.zerg(Roles.claim);
        this.refresh();
    }
    refresh() {
        super.refresh();
        if (this.room && this.room.controller) {
            this.attackPositions =
                this.room.controller.pos.availableNeighbors(true);
            this.readyTick =
                Game.time + (this.room.controller.upgradeBlocked || 0);
        }
        else {
            this.attackPositions = [];
            this.readyTick = Game.time;
        }
        this.assignments = this.getPositionAssignments();
    }
    getPositionAssignments() {
        const assignments = {};
        const maxLoops = Math.min(this.attackPositions.length, this.controllerAttackers.length);
        const controllerAttackers = _.sortBy(this.controllerAttackers, (zerg) => zerg.name);
        for (let i = 0; i < maxLoops; i++) {
            assignments[controllerAttackers[i].name] = this.attackPositions[i];
        }
        return assignments;
    }
    init() {
        // TODO: Prespawn attackers to arrive as cooldown disappears
        if (this.attackPositions.length > 0 && Game.time >= this.readyTick) {
            this.wishlist(this.attackPositions.length, Setups.infestors.controllerAttacker, { noLifetimeFilter: true });
        }
    }
    run() {
        for (const controllerAttacker of this.controllerAttackers) {
            const attackPos = this.assignments[controllerAttacker.name];
            if (attackPos) {
                controllerAttacker.goTo(attackPos);
            }
            else {
                log.debug(`No attack position for ${controllerAttacker.print}!`);
            }
        }
        if (this.room &&
            this.room.controller &&
            this.room.controller.reservation &&
            !this.room.controller.reservedByMe) {
            this.launchAttack();
        }
        else if (this.room &&
            this.room.controller &&
            !this.room.controller.upgradeBlocked) {
            if (_.all(this.controllerAttackers, (creep) => creep.pos.isEqualTo(this.assignments[creep.name])) ||
                _.any(this.controllerAttackers, (creep) => creep.pos.isNearTo(this.room.controller) &&
                    (creep.ticksToLive || 10) <= 2)) {
                this.launchAttack();
            }
        }
    }
    launchAttack() {
        let signed = false;
        if (this.room && this.room.controller) {
            for (const infestor of this.controllerAttackers) {
                infestor.attackController(this.room.controller);
                if (!signed) {
                    signed =
                        infestor.signController(this.room.controller, "For the swarm") == OK;
                }
            }
        }
    }
};
ControllerAttackerOverlord.requiredRCL = 4;
ControllerAttackerOverlord = ControllerAttackerOverlord_1 = __decorate$1([
    profile
], ControllerAttackerOverlord);

/**
 * Attack a controller, downgrading it to level 0
 */
let DirectiveControllerAttack = class DirectiveControllerAttack extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
        this.overlords.scout = new StationaryScoutOverlord(this); // TODO: Not have a scout at all times
        this.overlords.controllerAttack = new ControllerAttackerOverlord(this);
    }
    init() {
        const level = this.room && this.room.controller ?
            this.room.controller.level.toString()
            : "???";
        this.alert(`Downgrading controller (RCL${level})`);
    }
    run() {
        if (this.room &&
            this.room.controller &&
            this.room.controller.level == 0 &&
            (!this.room.controller.reservation ||
                this.room.controller.reservation.ticksToEnd < 5)) {
            log.notify(`Removing ${this.name} since controller has reached level 0.`);
            this.remove();
        }
    }
};
DirectiveControllerAttack.directiveName = "controllerAttack";
DirectiveControllerAttack.color = COLOR_RED;
DirectiveControllerAttack.secondaryColor = COLOR_PURPLE;
DirectiveControllerAttack = __decorate$1([
    profile
], DirectiveControllerAttack);

var DirectivePoisonRoom_1;
/**
 * Poison sources in remote rooms by claiming controller, walling in its sources and controller then unclaiming it.
 */
let DirectivePoisonRoom = DirectivePoisonRoom_1 = class DirectivePoisonRoom extends Directive {
    constructor(flag) {
        super(flag, (colony) => colony.level >= DirectivePoisonRoom_1.requiredRCL);
        // Remove if misplaced
        let remove = false;
        if (Cartographer.roomType(this.pos.roomName) != ROOMTYPE_CONTROLLER) {
            log.error(`${this.print}: not placed is not a controller room; removing directive!`);
            remove = true;
        }
        // failsafe - if already owned and controller level > 2, remove flag
        if (this.room &&
            this.room.controller &&
            this.room.controller.my &&
            this.room.controller.level > 2) {
            log.error(`Removing ${this.print}: room owned by self and above RCL 2!`);
            remove = true;
        }
        // Remove if owned by other player
        if (this.room && this.room.owner && !this.room.my) {
            log.error(`Removing poisonRoom directive in ${this.pos.roomName}: room already owned by another player.`);
            remove = true;
        }
        if (remove) {
            this.remove(true);
        }
    }
    spawnMoarOverlords() {
        this.overlords.claim = new ClaimingOverlord(this);
        this.overlords.roomPoisoner = new RoomPoisonerOverlord(this);
    }
    /**
     * Returns whether the room has already been poisoned
     */
    static roomAlreadyPoisoned(room) {
        const thingsToBlock = _.compact([
            room.controller,
            ...room.sources,
        ]);
        const neighborTiles = _.unique(_.flatten(_.map(thingsToBlock, (obj) => obj.pos.neighbors)), (pos) => packPos(pos));
        const blockPositions = _.filter(neighborTiles, (pos) => pos.isWalkable(true));
        return blockPositions.length == 0;
    }
    /**
     * Returns whether you can poison a specific room; assumes that poisoning is enabled and that you can claim another
     * room and can poison another room (these checks should be done once on Overseer)
     */
    static canAutoPoison(room, allowReserved = false) {
        if (room.isColony || room.isOutpost) {
            return false;
        }
        if (!room.controller) {
            return false;
        }
        if (allowReserved && room.controller.reservation) {
            return false;
        }
        if (room.dangerousHostiles.length > 0) {
            return false;
        }
        if (_.filter(room.controller.pos.neighbors, (pos) => pos.isWalkable(true)).length == 0) {
            return false;
        }
        return true;
    }
    init() {
        this.alert(`Poisoning room`);
        // Re-compute the list of positions to block
        if (this.room) {
            const thingsToBlock = _.compact([
                this.room.controller,
                ...this.room.sources,
            ]);
            const neighborTiles = _.unique(_.flatten(_.map(thingsToBlock, (obj) => obj.pos.neighbors)), (pos) => packPos(pos));
            this.blockPositions = _.filter(neighborTiles, (pos) => pos.isWalkable(true));
        }
        else {
            this.blockPositions = [];
        }
    }
    prePoisonActions() {
        if (this.room &&
            this.room.controller &&
            this.room.controller.level != 1) {
            return; // failsafe to prevent you from accidentally killing your own room
        }
        if (this.room) {
            const removeStructures = this.room.find(FIND_STRUCTURES, {
                filter: (s) => s.structureType != STRUCTURE_CONTROLLER &&
                    s.structureType != STRUCTURE_STORAGE &&
                    s.structureType != STRUCTURE_TERMINAL &&
                    s.structureType != STRUCTURE_FACTORY &&
                    s.structureType != STRUCTURE_LAB &&
                    s.structureType != STRUCTURE_NUKER,
            });
            _.forEach(removeStructures, (s) => s.destroy());
            _.forEach(this.room.find(FIND_HOSTILE_CONSTRUCTION_SITES), (csite) => csite.remove());
        }
    }
    poisonActions() {
        if (!(this.room &&
            this.room.controller &&
            this.room.controller.level == 2)) {
            return;
        }
        const positionToBlock = _.first(this.blockPositions);
        if (!positionToBlock) {
            return; // all blocked off
        }
        // Don't lock off the last position unless there's a creep with energy to build the site
        const enoughEnergyToBuildFinalWall = _.any(this.overlords.roomPoisoner.roomPoisoners, (creep) => creep.store.energy >= BUILD_POWER);
        if (this.blockPositions.length == 1 && !enoughEnergyToBuildFinalWall) {
            return;
        }
        // Otherwise build one site at a time
        positionToBlock.createConstructionSite(STRUCTURE_WALL);
    }
    clearRoom() {
        if (this.room) {
            const allStructures = this.room.find(FIND_STRUCTURES, {
                filter: (s) => s.structureType != STRUCTURE_CONTROLLER &&
                    s.structureType != STRUCTURE_STORAGE &&
                    s.structureType != STRUCTURE_TERMINAL &&
                    s.structureType != STRUCTURE_FACTORY &&
                    s.structureType != STRUCTURE_LAB &&
                    s.structureType != STRUCTURE_NUKER,
            });
            _.forEach(allStructures, (s) => s.destroy());
        }
    }
    run() {
        if (this.room &&
            this.room.controller &&
            Game.time % DirectivePoisonRoom_1.settings.runFrequency == 0) {
            // Remove hostile reservation if needed
            if (this.room.controller.reservation &&
                this.room.controller.reservation.ticksToEnd > 500) {
                DirectiveControllerAttack.createIfNotPresent(this.room.controller.pos, "room");
            }
            // Send fighters if needed
            if (this.room.playerHostiles.length > 0) {
                DirectiveOutpostDefense.createIfNotPresent(this.room.controller.pos, "room");
            }
        }
        if (this.room && this.room.controller && this.room.controller.my) {
            if (Game.time % DirectivePoisonRoom_1.settings.runFrequency == 0 ||
                this.room.constructionSites.length == 0) {
                // At RCL 1, prepare room by removing structures and hostile construction sites
                if (this.room.controller.level == 1) {
                    this.prePoisonActions();
                    return;
                }
                // At RCL 2, build walls to make the room useless
                if (this.room.controller.level == 2) {
                    if (this.blockPositions.length > 0) {
                        this.poisonActions();
                    }
                    else {
                        this.room.controller.unclaim();
                        log.notify(`Removing poisonRoom directive in ${this.pos.roomName}: operation completed.`);
                        this.remove();
                    }
                }
            }
        }
    }
};
DirectivePoisonRoom.directiveName = "poisonRoom";
DirectivePoisonRoom.color = COLOR_PURPLE;
DirectivePoisonRoom.secondaryColor = COLOR_RED;
DirectivePoisonRoom.requiredRCL = 5;
DirectivePoisonRoom.settings = {
    runFrequency: 12,
};
DirectivePoisonRoom = DirectivePoisonRoom_1 = __decorate$1([
    profile
], DirectivePoisonRoom);

/**
 * Claims a new room and builds a spawn but does not incubate. Removes when spawn is constructed.
 */
let DirectivePrioritize = class DirectivePrioritize extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() { }
    init() { }
    run() {
        if (this.room &&
            this.flag.pos.lookFor(LOOK_CONSTRUCTION_SITES).length === 0) {
            log.alert(`Cannot find construction site to prioritize at ${this.flag.pos.print}`);
            this.remove(true);
            return;
        }
        this.alert(`Prioritizing workers at ${this.flag.pos.printPlain}`);
        this.colony.overlords.work.prioritizeTask(this.flag);
    }
};
DirectivePrioritize.directiveName = "prioritize";
DirectivePrioritize.color = COLOR_PURPLE;
DirectivePrioritize.secondaryColor = COLOR_CYAN;
DirectivePrioritize = __decorate$1([
    profile
], DirectivePrioritize);

/**
 * Spawn pioneers - early workers which help to build a spawn in a new colony, then get converted to workers or drones
 */
let PioneerOverlord = class PioneerOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.colonization.pioneer) {
        super(directive, "pioneer", priority);
        this.directive = directive;
        this.pioneers = this.zerg(Roles.pioneer);
        this.spawnSite =
            this.room ?
                _.filter(this.room.constructionSites, (s) => s.structureType == STRUCTURE_SPAWN)[0]
                : undefined;
    }
    refresh() {
        super.refresh();
        this.spawnSite =
            this.room ?
                _.filter(this.room.constructionSites, (s) => s.structureType == STRUCTURE_SPAWN)[0]
                : undefined;
    }
    init() {
        var _a, _b;
        let pioneersNeeded = 4;
        if (((_b = (_a = this.colony.hatchery) === null || _a === void 0 ? void 0 : _a.spawns.length) !== null && _b !== void 0 ? _b : 0) < 2) {
            pioneersNeeded = 2;
        }
        this.wishlist(pioneersNeeded, Setups.pioneer);
    }
    findStructureBlockingController(pioneer) {
        const blockingPos = Pathing.findBlockingPos(pioneer.pos, pioneer.room.controller.pos, _.filter(pioneer.room.structures, (s) => !s.isWalkable));
        if (blockingPos) {
            const structure = blockingPos.lookFor(LOOK_STRUCTURES)[0];
            return (structure ||
                log.error(`${this.print}: no structure at blocking pos ${blockingPos.print}!`));
        }
    }
    handlePioneer(pioneer) {
        var _a, _b;
        // Ensure you are in the assigned room
        if (pioneer.room == this.room && !pioneer.pos.isEdge) {
            // Remove any blocking structures preventing claimer from reaching controller
            if (!this.room.my && this.room.structures.length > 0) {
                const dismantleTarget = this.findStructureBlockingController(pioneer);
                if (dismantleTarget) {
                    pioneer.task = Tasks$1.dismantle(dismantleTarget);
                    return;
                }
            }
            // Build and recharge
            if (pioneer.store.energy == 0) {
                const task = Tasks$1.recharge();
                if ((_a = this.directive.toColonize) === null || _a === void 0 ? void 0 : _a.sources.length) {
                    task.data.sourcesIDs =
                        (_b = this.directive.toColonize) === null || _b === void 0 ? void 0 : _b.sources.map((s) => s.id);
                }
                pioneer.task = task;
            }
            else if (this.room &&
                this.room.controller &&
                (this.room.controller.ticksToDowngrade <
                    0.1 * CONTROLLER_DOWNGRADE[this.room.controller.level] ||
                    !this.spawnSite) &&
                !(this.room.controller.upgradeBlocked > 0)) {
                // Save controller if it's about to downgrade or if you have nothing else to do
                pioneer.task = Tasks$1.upgrade(this.room.controller);
            }
            else if (this.spawnSite) {
                pioneer.task = Tasks$1.build(this.spawnSite);
            }
        }
        else {
            // pioneer.task = Tasks.goTo(this.pos);
            pioneer.goTo(this.pos, {
                pathOpts: { ensurePath: true, avoidSK: true },
            });
        }
    }
    run() {
        this.autoRun(this.pioneers, (pioneer) => this.handlePioneer(pioneer));
    }
};
PioneerOverlord = __decorate$1([
    profile
], PioneerOverlord);

var DirectiveIncubate_1;
const MAX_INCUBATION_LINEAR_DISTANCE = 10;
/**
 * Claims a new room and incubates it from the nearest (or specified) colony
 */
let DirectiveIncubate = DirectiveIncubate_1 = class DirectiveIncubate extends Directive {
    constructor(flag) {
        super(flag, (colony) => colony.level >= DirectiveIncubate_1.requiredRCL &&
            flag.pos.roomName !== colony.room.name &&
            _.filter(colony.flags, (flag) => DirectiveIncubate_1.filter(flag))
                .length == 0 &&
            Game.map.getRoomLinearDistance(flag.pos.roomName, colony.room.name) <= MAX_INCUBATION_LINEAR_DISTANCE);
        // Register incubation status
        this.incubatee =
            this.room ?
                Overmind.colonies[Overmind.colonyMap[this.room.name]]
                : undefined;
        this.refresh();
    }
    refresh() {
        if (this.incubatee) {
            const group = new SpawnGroup(this.flag, {
                requiredRCL: DirectiveIncubate_1.requiredRCL,
                maxPathDistance: 400,
                spawnPriorityThreshold: OverlordPriority.incubationThreshold,
                spawnPriorityBoost: 200,
            });
            if (group.colonyNames.length === 0) {
                log.warning(`${this.print}: unable to find any nearby colony to be the incubator, removing directive`);
                this.remove();
                return;
            }
            // Manually add the incubated room to the spawn group's colonies
            // as soon as it gets its spawn up, since its level is below the
            // directive's minimum RCL
            if (this.incubatee.spawns.length > 0 &&
                !group.memory.colonies.includes(this.pos.roomName)) {
                group.memory.colonies.push(this.pos.roomName);
            }
            this.incubatee.spawnGroup = group;
            this.incubatee.state.isIncubating = true;
        }
    }
    spawnMoarOverlords() {
        // Only claim if there's no colony yet and we're not also colonizing
        if (!this.incubatee &&
            !DirectiveColonize.findInRoom(this.flag.pos.roomName)) {
            this.overlords.claim = new ClaimingOverlord(this);
        }
    }
    init() {
        if (!DirectiveColonize.isPresent(this.flag.pos.roomName)) {
            this.alert(`Incubating from ${this.colony.name}`);
        }
    }
    remove(force) {
        const res = super.remove(force);
        if (this.incubatee) {
            this.incubatee.state.isIncubating = false;
        }
        return res;
    }
    run() {
        if (this.incubatee) {
            if (this.incubatee.level >= DirectiveIncubate_1.requiredRCL &&
                this.incubatee.storage &&
                this.incubatee.terminal) {
                this.remove();
            }
        }
    }
};
DirectiveIncubate.directiveName = "incubate";
DirectiveIncubate.color = COLOR_PURPLE;
DirectiveIncubate.secondaryColor = COLOR_WHITE;
DirectiveIncubate.requiredRCL = 4;
DirectiveIncubate = DirectiveIncubate_1 = __decorate$1([
    profile
], DirectiveIncubate);

var DirectiveColonize_1;
/**
 * Claims a new room and builds a spawn but does not incubate. Removes when spawn is constructed.
 */
let DirectiveColonize = DirectiveColonize_1 = class DirectiveColonize extends Directive {
    constructor(flag) {
        flag.memory.allowPortals = true;
        super(flag, (colony) => colony.level >= DirectiveColonize_1.requiredRCL &&
            colony.name != Directive.getPos(flag).roomName &&
            colony.spawns.length > 0);
        // Register incubation status
        this.toColonize =
            this.room ?
                Overmind.colonies[Overmind.colonyMap[this.room.name]]
                : undefined;
        // Remove if misplaced
        if (Cartographer.roomType(this.pos.roomName) != ROOMTYPE_CONTROLLER) {
            log.warning(`${this.print}: ${printRoomName(this.pos.roomName)} is not a controller room; ` + `removing directive!`);
            this.remove(true);
            return;
        }
    }
    spawnMoarOverlords() {
        this.overlords.claim = new ClaimingOverlord(this);
        this.overlords.pioneer = new PioneerOverlord(this);
    }
    init() {
        const incubator = DirectiveIncubate.findInRoom(this.flag.pos.roomName).shift();
        if (incubator && incubator.colony.spawnGroup) {
            this.alert(`Colonization in progress, incubating from ${incubator.colony.spawnGroup.colonyNames}`);
        }
        else {
            this.alert(`Colonization in progress`);
        }
    }
    run(verbose = false) {
        // TODO bug where can't claim a reservation room -> this.flag.pos.roomName == this.toColonize.name
        if (this.toColonize && this.toColonize.spawns.length > 0) {
            // Reassign all pioneers to be miners and workers
            const miningOverlords = _.map(this.toColonize.miningSites, (site) => site.overlords.mine);
            for (const pioneer of this.overlords.pioneer.pioneers) {
                const miningOverlord = miningOverlords.shift();
                if (miningOverlord) {
                    if (verbose) {
                        log.debug(`Reassigning: ${pioneer.print} to mine: ${miningOverlord.print}`);
                    }
                    pioneer.reassign(miningOverlord, Roles.drone);
                }
                else {
                    if (verbose) {
                        log.debug(`Reassigning: ${pioneer.print} to work: ${this.toColonize.overlords.work.print}`);
                    }
                    pioneer.reassign(this.toColonize.overlords.work, Roles.worker);
                }
            }
            // Remove the directive
            this.remove();
        }
        if (Game.time % 10 == 2 &&
            this.room &&
            this.room.owner &&
            !this.room.my) {
            log.notify(`Removing Colonize directive in ${this.pos.roomName}: room already owned by another player.`);
            this.remove();
        }
    }
};
DirectiveColonize.directiveName = "colonize";
DirectiveColonize.color = COLOR_PURPLE;
DirectiveColonize.secondaryColor = COLOR_GREY;
DirectiveColonize.requiredRCL = 3;
DirectiveColonize = DirectiveColonize_1 = __decorate$1([
    profile
], DirectiveColonize);

/**
 * Guard swarm overlord: spawns lots of smaller guards to deal with swarm-like attacks or harassments
 */
let GuardSwarmOverlord = class GuardSwarmOverlord extends CombatOverlord {
    constructor(directive, priority = OverlordPriority.outpostDefense.guard) {
        super(directive, "swarmGuard", priority, { requiredRCL: 0 });
        this.guards = this.combatZerg(Roles.guardMelee);
    }
    init() {
        if (this.directive.memory.amount) {
            this.wishlist(this.directive.memory.amount, CombatSetups.broodlings.early);
        }
        else {
            if (this.room) {
                const smallHostiles = _.filter(this.room.dangerousHostiles, (creep) => creep.body.length < 10);
                if (smallHostiles.length > 2) {
                    this.wishlist(Math.round(smallHostiles.length), CombatSetups.broodlings.early);
                }
            }
            else {
                this.wishlist(2, CombatSetups.broodlings.early);
            }
        }
    }
    findAttackTarget(guard) {
        if (guard.room.hostiles.length > 0) {
            const targets = _.filter(guard.room.hostiles, (hostile) => hostile.pos.rangeToEdge > 0);
            return guard.pos.findClosestByRange(targets);
        }
        if (guard.room.hostileStructures.length > 0) {
            return guard.pos.findClosestByRange(guard.room.hostileStructures);
        }
    }
    handleGuard(guard) {
        if (guard.pos.roomName != this.pos.roomName) {
            // Move into the assigned room if there is a guard flag present
            guard.goToRoom(this.pos.roomName);
        }
        else if (guard.pos.isEdge) {
            guard.moveOffExit();
        }
        else {
            // If you're in the assigned room or if there is no assignment, try to attack or heal
            const attackTarget = this.findAttackTarget(guard);
            if (attackTarget) {
                guard.attackAndChase(attackTarget);
            }
            else {
                guard.park(this.pos); // Move off-road
            }
        }
    }
    run() {
        this.autoRun(this.guards, (guard) => this.handleGuard(guard));
    }
};
GuardSwarmOverlord = __decorate$1([
    profile
], GuardSwarmOverlord);

var DefenseNPCOverlord_1;
/**
 * NPC defense overlord: spawns specially-optimized guards as needed to deal with standard NPC invasions
 */
let DefenseNPCOverlord = DefenseNPCOverlord_1 = class DefenseNPCOverlord extends CombatOverlord {
    constructor(directive, priority = OverlordPriority.outpostDefense.guard) {
        super(directive, "guard", priority, {
            requiredRCL: DefenseNPCOverlord_1.requiredRCL,
        });
        this.guards = this.combatZerg(Roles.guardMelee);
    }
    init() {
        const amount = (this.room &&
            (this.room.invaders.length > 0 ||
                this.room.invaderCore ||
                RoomIntel$1.isInvasionLikely(this.room.name))) ?
            1
            : 0;
        let setup = CombatSetups.broodlings.default;
        if (CombatSetups.broodlings.default.generateBody(this.colony.room.energyCapacityAvailable).length === 0) {
            setup = CombatSetups.broodlings.early;
        }
        this.wishlist(amount, setup, { reassignIdle: true });
    }
    handleGuard(guard) {
        guard.autoCombat(this.pos.roomName);
    }
    run() {
        this.autoRun(this.guards, (guard) => this.handleGuard(guard));
    }
};
DefenseNPCOverlord.requiredRCL = 3;
DefenseNPCOverlord = DefenseNPCOverlord_1 = __decorate$1([
    profile
], DefenseNPCOverlord);

/**
 * NPC defense directive for outpost rooms with invaders
 */
let DirectiveGuard = class DirectiveGuard extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
        if (this.colony.level >= DefenseNPCOverlord.requiredRCL) {
            // if (this.memory.enhanced || this.name.includes('enhanced')) {
            // 	this.overlords.guardPair = new GuardPairOverlord(this);
            // } else {
            this.overlords.guard = new DefenseNPCOverlord(this);
            // }
        }
        else {
            this.overlords.swarmGuard = new GuardSwarmOverlord(this);
        }
    }
    init() {
        if (this.room && this.room.invaderCore) {
            this.memory.invaderCore = true;
        }
        if (this.memory.invaderCore) {
            this.alert(`Attacking invader core`, NotifierPriority.Low);
        }
    }
    run() {
        // If there are no hostiles or hostiles structures left in the room, possibly remove
        if (this.room &&
            this.room.hostiles.length == 0 &&
            this.room.hostileStructures.length == 0) {
            // If everyone's healed up and the room is safe, remove
            const creepsNeedingHealing = _.filter(this.room.creeps, (creep) => creep.hits < creep.hitsMax);
            if (creepsNeedingHealing.length == 0 && this.room.isSafe) {
                this.remove();
            }
        }
    }
};
DirectiveGuard.directiveName = "guard";
DirectiveGuard.color = COLOR_BLUE;
DirectiveGuard.secondaryColor = COLOR_BLUE;
DirectiveGuard = __decorate$1([
    profile
], DirectiveGuard);

/**
 * Spawns bunker-only defenders to defend against incoming sieges // TODO: needs some revision
 */
let BunkerDefenseOverlord = class BunkerDefenseOverlord extends CombatOverlord {
    constructor(directive, priority = OverlordPriority.defense.meleeDefense) {
        // Only spawn inside room
        super(directive, "bunkerDefense", priority, {
            requiredRCL: 1,
            maxSpawnDistance: 30,
        });
        this.defenders = this.combatZerg(Roles.bunkerDefender);
    }
    handleDefender(lurker) {
        if (!lurker.inRampart) {
            const nearbyRampart = _.find(lurker.room.walkableRamparts, (rampart) => rampart.pos.getRangeTo(lurker) < 5);
            if (nearbyRampart) {
                lurker.goTo(nearbyRampart);
            }
        }
        if (lurker.room.hostiles.length > 0) {
            lurker.autoBunkerCombat(lurker.room.name);
        }
    }
    init() {
        this.reassignIdleCreeps(Roles.bunkerDefender);
        this.wishlist(1, CombatSetups.bunkerDefender.boosted);
    }
    run() {
        this.autoRun(this.defenders, (defender) => this.handleDefender(defender));
    }
};
BunkerDefenseOverlord.settings = {
    retreatHitsPercent: 0.85,
    reengageHitsPercent: 0.95,
};
BunkerDefenseOverlord = __decorate$1([
    profile
], BunkerDefenseOverlord);

var DistractionOverlord_1;
/**
 * 5 Move 1 RA creep that avoids all enemies and distracts attackers.
 * Just for fun
 * TODO: Make them prefer swamps when at max hp
 */
let DistractionOverlord = DistractionOverlord_1 = class DistractionOverlord extends CombatOverlord {
    constructor(directive, _boosted = false, priority = OverlordPriority.defense.rangedDefense) {
        super(directive, "distraction", priority, { requiredRCL: 1 });
        this.distractions = this.combatZerg(Roles.rangedDistractor);
    }
    handleDistraction(distraction) {
        if (this.room && this.room.hostiles.length > 0) {
            distraction.autoCombat(this.room.name, {
                preferredRange: 5,
                moveOptions: {
                    preferRamparts: false,
                },
            });
            DistractionOverlord_1.taunt(distraction, this.room.hostiles[0].owner.username);
            const nearbyHostiles = this.room.hostiles.filter((hostile) => hostile.pos.getRangeTo(distraction) <= 6);
            if (nearbyHostiles.length > 0) {
                distraction.kite(nearbyHostiles);
            }
        }
    }
    static taunt(distraction, name) {
        const taunts = [
            "Heylisten!",
            "Pssssst",
            "So close",
            "🎣",
            "Try harder",
            "Get good;)",
            "Base ⬆️",
            "🔜",
            "⚠️Swamp⚠️",
            "Follow me!",
            "Catch Me!",
            `Hi ${name || ""}`,
            "🍑🍑🍑",
            "🏎️ VROOM",
        ];
        distraction.sayRandom(taunts, true);
    }
    init() {
        // this.reassignIdleCreeps(Roles.ranged); until it's it's own role don't reassign
        const setup = CombatSetups.distractors.ranged;
        this.wishlist(1, setup);
    }
    run() {
        // need to check room exists
        // console.log(`Distraction overlord running in ${this.room.print} with ${this.distractions}!`);
        this.autoRun(this.distractions, (distraction) => this.handleDistraction(distraction));
    }
};
DistractionOverlord.settings = {
    retreatHitsPercent: 0.85,
    reengageHitsPercent: 0.95,
};
DistractionOverlord = DistractionOverlord_1 = __decorate$1([
    profile
], DistractionOverlord);

/**
 * Spawns ranged defenders to defend against incoming player invasions in an owned room
 */
let RangedDefenseOverlord = class RangedDefenseOverlord extends CombatOverlord {
    constructor(directive, priority = OverlordPriority.defense.rangedDefense) {
        super(directive, "rangedDefense", priority, { requiredRCL: 1 });
        this.hydralisks = this.combatZerg(Roles.ranged);
    }
    handleDefender(hydralisk) {
        if (this.room.hostiles.length > 0) {
            hydralisk.autoCombat(this.room.name);
        }
        else {
            if (!hydralisk.doMedicActions(this.room.name) &&
                hydralisk.pos.getRangeTo(this.directive.pos) > 4) {
                hydralisk.goTo(this.directive.pos);
            }
        }
    }
    /**
     * Computes how much *additional* ranged parts we need
     */
    computeNeededAdditionalRangedPotential() {
        const healAmount = CombatIntel$1.maxHealingByCreeps(this.room.hostiles);
        const towerDamage = this.room.hostiles[0] ?
            CombatIntel$1.towerDamageAtPos(this.room.hostiles[0].pos) || 0
            : 0;
        const worstDamageMultiplier = _.min(_.map(this.room.hostiles, (creep) => CombatIntel$1.minimumDamageTakenMultiplier(creep)));
        const hydraliskDamage = RANGED_ATTACK_POWER *
            CombatIntel$1.getCombatPotentials(this.hydralisks).ranged;
        const maxDamageReceived = worstDamageMultiplier * (hydraliskDamage + towerDamage + 1);
        const needAdditionalDamage = Math.max(healAmount - maxDamageReceived, 0);
        const neededRangedParts = needAdditionalDamage / RANGED_ATTACK_POWER;
        return neededRangedParts;
    }
    init() {
        if (this.reassignIdleCreeps(Roles.ranged, 1)) {
            return;
        }
        let setup = CombatSetups.hydralisks.default;
        if (_.all(this.spawnGroup.colonies, (col) => col.room.energyCapacityAvailable < 800)) {
            setup = CombatSetups.hydralisks.noHeal; // can't spawn default hydras at very low rcl
        }
        else {
            const { attack, ranged, heal } = CombatIntel$1.getCombatPotentials(this.room.hostiles);
            // if there's a lot of big baddies or this assault has lasted a long time, pull out the boosts
            if (attack + ranged + heal > 100 || this.age > 1000) {
                setup = CombatSetups.hydralisks.boosted.default;
            }
        }
        const neededAdditionalRangedPotential = this.computeNeededAdditionalRangedPotential();
        if (neededAdditionalRangedPotential) {
            this.requestCreep(setup);
        }
    }
    run() {
        this.autoRun(this.hydralisks, (hydralisk) => this.handleDefender(hydralisk));
    }
};
RangedDefenseOverlord.settings = {
    retreatHitsPercent: 0.85,
    reengageHitsPercent: 0.95,
};
RangedDefenseOverlord = __decorate$1([
    profile
], RangedDefenseOverlord);

/**
 * Defend an owned room against an incoming player invasion
 */
let DirectiveInvasionDefense = class DirectiveInvasionDefense extends Directive {
    constructor(flag) {
        super(flag, (colony) => colony.level >= 1 && colony.spawns.length > 0);
    }
    spawnMoarOverlords() {
        if (!this.room) {
            return;
        }
        const expectedDamage = CombatIntel$1.maxDamageByCreeps(this.room.dangerousPlayerHostiles);
        const expectedHealing = CombatIntel$1.maxHealingByCreeps(this.room.dangerousPlayerHostiles);
        expectedDamage > ATTACK_POWER * 50 ||
            (expectedHealing > RANGED_ATTACK_POWER * 100 &&
                !!this.colony.terminal &&
                !!this.colony.evolutionChamber);
        _.filter(this.room.barriers, (s) => s.structureType == STRUCTURE_WALL).length / this.room.barriers.length;
        const meleeHostiles = _.filter(this.room.hostiles, (hostile) => hostile.getActiveBodyparts(ATTACK) > 0 ||
            hostile.getActiveBodyparts(WORK) > 0);
        const rangedHostiles = _.filter(this.room.hostiles, (hostile) => hostile.getActiveBodyparts(RANGED_ATTACK) > 0);
        this.overlords.rangedDefense = new RangedDefenseOverlord(this);
        // If serious bunker busting attempt, spawn lurkers
        // TODO understand dismantlers damage output
        if (meleeHostiles.length > 0 &&
            expectedDamage > ATTACK_POWER * 70 &&
            (this.colony.level >= BarrierPlanner.settings.bunkerizeRCL ||
                rangedHostiles.length > 3)) {
            this.overlords.bunkerDefense = new BunkerDefenseOverlord(this);
        }
        // If melee attackers, try distractions
        // TODO drop these if they don't work, need to detect effectiveness. Although the says make for great 🍿
        if (meleeHostiles.length > 0 && expectedDamage > 40 * ATTACK_POWER) {
            this.overlords.distraction = new DistractionOverlord(this);
        }
    }
    init() {
        const numHostiles = this.room ? this.room.hostiles.length.toString() : "???";
        this.alert(`Invasion (hostiles: ${numHostiles}) ${Game.time - this.memory.safeSince}`, NotifierPriority.Critical);
    }
    // TODO record baddies needs to be redone in a more systemic fashion. But here for the 🍿
    recordBaddies() {
        if (!this.room) {
            return;
        }
        const mem = Memory.playerCreepTracker;
        const hostiles = this.room.hostiles;
        hostiles.forEach((creep) => {
            if (!mem[creep.owner.username]) {
                mem[creep.owner.username] = {
                    creeps: {},
                    types: {},
                    parts: {},
                    boosts: {},
                };
            }
            const playerMem = mem[creep.owner.username];
            if (!playerMem.creeps[creep.name]) {
                playerMem.creeps[creep.name] = Game.time;
                const creepType = creep.name.substr(0, creep.name.indexOf(" "));
                if (creepType == creep.name) {
                    // memory protection if they don't split name
                    return;
                }
                playerMem.types[creepType] =
                    playerMem.types[creepType] + 1 || 1;
                for (const bodyPart of creep.body) {
                    playerMem.parts[bodyPart.type] =
                        playerMem.parts[bodyPart.type] + 1 || 1;
                    if (bodyPart.boost) {
                        playerMem.boosts[bodyPart.boost] =
                            playerMem.boosts[bodyPart.boost] + 1 || 1;
                    }
                }
            }
        });
    }
    printPlayerExpenditure() {
        let t3Count = 0;
        let energyCount = 0;
        const mem = Memory.playerCreepTracker.inakrin;
        for (const boostid in mem.boosts) {
            const boost = mem.boosts[boostid];
            console.log(`${boostid} : ${boost * 30}`);
            t3Count += boost * 30;
            energyCount += 20;
        }
        for (const partType in mem.parts) {
            const partCount = mem.parts[partType];
            const cost = BODYPART_COST[partType];
            console.log(`${partType} : ${cost * partCount}`);
            energyCount += cost * partCount;
        }
        console.log(`Total T3 Cost: ${t3Count}`);
        console.log(`Total Energy Cost: ${energyCount}`);
    }
    cleanUpPlayerMem() {
        const mem = Memory.playerCreepTracker;
        for (const player of _.keys(mem)) {
            const tracker = mem[player];
            for (const creep of _.keys(tracker.creeps)) {
                if (tracker.creeps[creep] + 1500 < Game.time) {
                    delete tracker.creeps[creep];
                }
            }
        }
    }
    run() {
        if (!this.room || this.room.hostiles.length > 0) {
            this.memory.safeSince = Game.time;
            this.recordBaddies();
        }
        // this.printPlayerExpenditure();
        if (Game.time % 5000 == 0) {
            // clean up, ya this shit
            this.cleanUpPlayerMem();
        }
        if (this.room && false) ;
        // If there are no hostiles left in the room and everyone's healed, then remove the flag
        if (this.room &&
            this.room.hostiles.length == 0 &&
            Game.time - this.memory.safeSince > this.safeEndTime) {
            if (_.filter(this.room.creeps, (creep) => creep.hits < creep.hitsMax).length == 0) {
                this.remove();
            }
        }
        else if (Game.time - this.memory.safeSince > 3000) {
            this.remove();
        }
    }
};
DirectiveInvasionDefense.directiveName = "invasionDefense";
DirectiveInvasionDefense.color = COLOR_BLUE;
DirectiveInvasionDefense.secondaryColor = COLOR_PURPLE;
DirectiveInvasionDefense = __decorate$1([
    profile
], DirectiveInvasionDefense);

var HarassOverlord_1;
/**
 * Spawns ranged harassers to stop mining for an enemy room
 */
let HarassOverlord = HarassOverlord_1 = class HarassOverlord extends CombatOverlord {
    constructor(directive, priority = OverlordPriority.outpostOffense.harass) {
        super(directive, "harass", priority, { requiredRCL: 1 });
        this.directive = directive;
        this.nibblers = this.combatZerg(Roles.melee);
        this.hydralisks = this.combatZerg(Roles.ranged);
    }
    handleHarass(hydralisk) {
        hydralisk.autoCombat(this.targetRemoteToHarass || hydralisk.room.name);
        // this.chooseRemoteToHarass(hydralisk, hydralisk.room.name);
        if (!this.targetRemoteToHarass) {
            this.chooseRemoteToHarass(hydralisk, hydralisk.room.name);
        }
        if (this.targetRemoteToHarass &&
            hydralisk.room.name != this.targetRemoteToHarass) {
            hydralisk.goToRoom(this.targetRemoteToHarass);
        }
        else if (hydralisk.room.dangerousHostiles.length > 2) {
            // Time to move on
            // Track when defense spawned
            hydralisk.room.dangerousHostiles.forEach((hostile) => {
                const nextSafeSpawn = Game.time -
                    HarassOverlord_1.settings.prespawn +
                    (hostile.ticksToLive || 0);
                if (nextSafeSpawn > this.directive.memory.nextSpawnTime) {
                    this.directive.memory.nextSpawnTime = nextSafeSpawn;
                }
            });
            if (hydralisk.room.name != this.targetRemoteToHarass) {
                hydralisk.goToRoom(this.targetRemoteToHarass);
            }
            else {
                const nextRoom = this.chooseRemoteToHarass(hydralisk, hydralisk.room.name);
                if (nextRoom) {
                    hydralisk.goToRoom(this.targetRemoteToHarass);
                }
            }
        }
        // Clean up construction sites then move on to another room
    }
    chooseRemoteToHarass(hydralisk, _currentRoom) {
        if (!this.directive.memory.roomsToHarass ||
            this.directive.memory.roomsToHarass.length == 0) {
            this.directive.memory.roomsToHarass =
                this.directive.findNearbyReservedRoomsForHarassment();
        }
        const nextRoom = this.directive.memory.roomsToHarass.shift();
        if (nextRoom) {
            this.directive.memory.roomsToHarass.push(nextRoom);
            this.targetRemoteToHarass = nextRoom;
            log.debug(`Selecting new target of ${this.targetRemoteToHarass} for ${hydralisk.print} from ` +
                `${this.directive.memory.roomsToHarass}`);
            hydralisk.say(`Tgt ${this.targetRemoteToHarass}`);
            return nextRoom;
        }
    }
    init() {
        this.reassignIdleCreeps(Roles.ranged);
        this.reassignIdleCreeps(Roles.melee);
        const setup = CombatSetups.hydralisks.default;
        const numtoSpawn = (!this.directive.memory.nextSpawnTime ||
            Game.time >= this.directive.memory.nextSpawnTime) ?
            1
            : 0;
        this.wishlist(numtoSpawn, setup);
    }
    run() {
        this.autoRun(this.hydralisks, (hydralisk) => this.handleHarass(hydralisk));
        this.autoRun(this.nibblers, (hydralisk) => this.handleHarass(hydralisk));
    }
};
HarassOverlord.settings = {
    retreatHitsPercent: 0.85,
    reengageHitsPercent: 0.95,
    prespawn: 200,
};
HarassOverlord = HarassOverlord_1 = __decorate$1([
    profile
], HarassOverlord);

/**
 * Harass Directive that wanders through enemy rooms killing stuff
 * Placed on an enemy room, it will harass all of it's remotes periodically
 */
let DirectiveHarass = class DirectiveHarass extends Directive {
    constructor(flag) {
        super(flag);
        this.memory.targetPlayer = RoomIntel$1.roomOwnedBy(flag.pos.roomName);
        this.memory.nextSpawnTime = Game.time;
        if (this.memory.targetPlayer === MY_USERNAME) {
            log.error(`Ahhhhhh harassing self in room ${flag.pos.roomName}`);
            this.remove();
        }
        else {
            log.alert(`Starting harass on ${flag.pos.roomName} owned by ${this.memory.targetPlayer}`);
        }
        if (this.memory.targetPlayer) {
            this.memory.roomsToHarass = this.findNearbyReservedRooms(flag.pos.roomName, this.memory.targetPlayer);
        }
    }
    spawnMoarOverlords() {
        // For now, just spawn from RCL 5+ rooms
        this.overlords.harassOverlord = new HarassOverlord(this);
    }
    init() {
        // if
        // if (!this.memory.roomsToHarass && this.memory.targetPlayer)
    }
    findNearbyReservedRoomsForHarassment() {
        if (this.memory.targetPlayer) {
            return this.findNearbyReservedRooms(this.flag.pos.roomName, this.memory.targetPlayer);
        }
        return [];
    }
    /**
     * Finds the rooms to harass
     *
     * @param roomName
     * @param playerName
     */
    findNearbyReservedRooms(roomName, playerName) {
        if (!this.memory.targetPlayer) {
            log.error(`Unable to find which player to harass in room ${roomName}`);
            return [];
        }
        const whitelist = Memory.settings.allies;
        const reservedByTargetPlayer = [];
        const adjacentRooms = _.values(Cartographer.describeExits(roomName));
        adjacentRooms.forEach((room) => {
            const reservation = RoomIntel$1.roomReservedBy(room);
            console.log("Checking for harass in room " + room);
            if (reservation && this.memory.aggressive ?
                !whitelist.includes(reservation)
                : reservation == playerName) {
                reservedByTargetPlayer.push(room);
                // TODO This will double add rooms next to owned rooms, making it more likely to harass them, reconsider
                _.values(Cartographer.describeExits(room)).forEach((room) => {
                    if (RoomIntel$1.roomReservedBy(room) == playerName) {
                        reservedByTargetPlayer.push(room);
                    }
                });
            }
        });
        Game.notify(`Looking for nearby rooms to harass, found ${reservedByTargetPlayer}`);
        return reservedByTargetPlayer;
    }
    run() {
        // Probably something modifying frequency of harassment
    }
};
DirectiveHarass.directiveName = "harass";
DirectiveHarass.color = COLOR_RED;
DirectiveHarass.secondaryColor = COLOR_WHITE;
DirectiveHarass = __decorate$1([
    profile
], DirectiveHarass);

/**
 * [LEGACY] Manually specify targets to be prioritized during a siege
 */
let DirectiveTargetSiege = class DirectiveTargetSiege extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() { }
    getTarget() {
        const targetedStructures = this.pos.lookFor(LOOK_STRUCTURES);
        for (const structure of targetedStructures) {
            for (const structureType of AttackStructurePriorities) {
                if (structure.structureType == structureType) {
                    return structure;
                }
            }
        }
    }
    init() { }
    run() {
        // Remove the directive once structures have been destroyed
        if (this.pos.isVisible && !this.getTarget()) {
            this.remove();
        }
    }
    visuals() {
        Visualizer.marker(this.pos, { color: "orange" });
    }
};
DirectiveTargetSiege.directiveName = "target:siege";
DirectiveTargetSiege.color = COLOR_GREY;
DirectiveTargetSiege.secondaryColor = COLOR_ORANGE;
DirectiveTargetSiege = __decorate$1([
    profile
], DirectiveTargetSiege);

var PairDestroyerOverlord_1;
/**
 *  Destroyer overlord - spawns attacker/healer pairs for combat within a hostile room
 */
let PairDestroyerOverlord = PairDestroyerOverlord_1 = class PairDestroyerOverlord extends CombatOverlord {
    constructor(directive, priority = OverlordPriority.offense.destroy) {
        super(directive, "destroy", priority, { requiredRCL: 0 });
        this.attackers = this.combatZerg(Roles.melee, {
            notifyWhenAttacked: false,
        });
        this.healers = this.combatZerg(Roles.healer, {
            notifyWhenAttacked: false,
        });
    }
    findTarget(attacker) {
        if (this.room) {
            // Prioritize specifically targeted structures first
            const targetingDirectives = DirectiveTargetSiege.find(this.room.flags);
            const targetedStructures = _.compact(_.map(targetingDirectives, (directive) => directive.getTarget()));
            if (targetedStructures.length > 0) {
                return CombatTargeting.findClosestReachable(attacker.pos, targetedStructures);
            }
            else {
                // Target nearby hostile creeps
                const creepTarget = CombatTargeting.findClosestHostile(attacker, {
                    checkReachable: true,
                    ignoreCreepsAtEdge: true,
                    playerOnly: true,
                    onlyUnramparted: true,
                });
                if (creepTarget) {
                    return creepTarget;
                }
                // Target nearby hostile structures
                const structureTarget = CombatTargeting.findClosestPrioritizedStructure(attacker);
                if (structureTarget) {
                    return structureTarget;
                }
            }
        } // TODO consider targets along path
    }
    attackActions(attacker, healer) {
        const target = this.findTarget(attacker);
        if (target) {
            if (attacker.pos.isNearTo(target)) {
                attacker.attack(target);
            }
            else {
                Movement.pairwiseMove(attacker, healer, target);
                attacker.autoMelee();
            }
        }
    }
    handleSquad(attacker) {
        const healer = attacker.findPartner(this.healers);
        // Case 1: you don't have an active healer
        if (!healer || healer.spawning || healer.needsBoosts) {
            // Wait near the colony controller if you don't have a healer
            if (attacker.pos.getMultiRoomRangeTo(this.colony.controller.pos) > 5) {
                attacker.goTo(this.colony.controller, { range: 5 });
            }
            else {
                attacker.park();
            }
        }
        else {
            // Case 2: you have an active healer
            // Activate retreat condition if necessary
            // Handle recovery if low on HP
            if (attacker.needsToRecover(PairDestroyerOverlord_1.settings.retreatHitsPercent) ||
                healer.needsToRecover(PairDestroyerOverlord_1.settings.retreatHitsPercent)) {
                // Healer leads retreat to fallback position
                Movement.pairwiseMove(healer, attacker, CombatIntel$1.getFallbackFrom(this.directive.pos));
            }
            else {
                // Move to room and then perform attacking actions
                if (!attacker.inSameRoomAs(this)) {
                    Movement.pairwiseMove(attacker, healer, this.pos);
                }
                else {
                    this.attackActions(attacker, healer);
                }
            }
        }
    }
    handleHealer(healer) {
        // If there are no hostiles in the designated room, run medic actions
        if (this.room &&
            this.room.hostiles.length == 0 &&
            this.room.hostileStructures.length == 0) {
            healer.doMedicActions(this.room.name);
            return;
        }
        const attacker = healer.findPartner(this.attackers);
        // Case 1: you don't have an attacker partner
        if (!attacker || attacker.spawning || attacker.needsBoosts) {
            if (healer.hits < healer.hitsMax) {
                healer.heal(healer);
            }
            // Wait near the colony controller if you don't have an attacker
            if (healer.pos.getMultiRoomRangeTo(this.colony.controller.pos) > 5) {
                healer.goTo(this.colony.controller, { range: 5 });
            }
            else {
                healer.park();
            }
        }
        else {
            // Case 2: you have an attacker partner
            if (attacker.hitsMax - attacker.hits >
                healer.hitsMax - healer.hits) {
                healer.heal(attacker);
            }
            else {
                healer.heal(healer);
            }
        }
    }
    init() {
        let amount;
        if (this.directive.memory.amount) {
            amount = this.directive.memory.amount;
        }
        else {
            amount = 1;
        }
        if (RoomIntel$1.inSafeMode(this.pos.roomName)) {
            amount = 0;
        }
        const attackerPriority = this.attackers.length < this.healers.length ?
            this.priority - 0.1
            : this.priority + 0.1;
        const attackerSetup = CombatSetups.zerglings.boosted.armored;
        this.wishlist(amount, attackerSetup, {
            priority: attackerPriority,
            reassignIdle: true,
        });
        const healerPriority = this.healers.length < this.attackers.length ?
            this.priority - 0.1
            : this.priority + 0.1;
        const healerSetup = CombatSetups.transfusers.boosted.default;
        this.wishlist(amount, healerSetup, {
            priority: healerPriority,
            reassignIdle: true,
        });
    }
    run() {
        this.autoRun(this.attackers, (attacker) => this.handleSquad(attacker));
        this.autoRun(this.healers, (healer) => this.handleHealer(healer));
    }
};
PairDestroyerOverlord.settings = {
    retreatHitsPercent: 0.85,
    reengageHitsPercent: 0.95,
};
PairDestroyerOverlord = PairDestroyerOverlord_1 = __decorate$1([
    profile
], PairDestroyerOverlord);

/**
 * Spawns a pair of attacker/healer creeps to siege a room
 */
let DirectivePairDestroy = class DirectivePairDestroy extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
        this.overlords.destroy = new PairDestroyerOverlord(this);
    }
    init() {
        this.alert(`Pair destroyer directive active`);
    }
    run() {
        // If there are no hostiles left in the room then remove the flag and associated healpoint
        if (this.room &&
            this.room.hostiles.length == 0 &&
            this.room.hostileStructures.length == 0) {
            log.notify(`Pair destroyer mission at ${this.pos.roomName} completed successfully.`);
            this.remove();
        }
    }
    visuals() {
        Visualizer.marker(this.pos, { color: "red" });
        const fallback = CombatIntel$1.getFallbackFrom(this.pos);
        Visualizer.marker(fallback, { color: "green" });
    }
};
DirectivePairDestroy.directiveName = "destroy";
DirectivePairDestroy.color = COLOR_RED;
DirectivePairDestroy.secondaryColor = COLOR_CYAN;
DirectivePairDestroy = __decorate$1([
    profile
], DirectivePairDestroy);

/**
 * SwarmOverlords extend the base CombatOverlord class, providing additional methods for spawning and controlling swarms
 */
let SwarmOverlord = class SwarmOverlord extends CombatOverlord {
    /* Wishlist of creeps to simplify spawning logic; includes automatic reporting */
    // TODO: at the moment, this assumes that every swarm within an overlord is the same configuration
    swarmWishlist(swarmQuantity, config) {
        var _a, _b, _c;
        var _d, _e, _f;
        // Make tables to log current and needed creep quantities
        const creepQuantities = {};
        const neededQuantities = {};
        // Handle filling out existing swarms first
        const validSwarms = _.filter(this.swarms, (swarm) => !swarm.isExpired);
        for (const swarm of validSwarms) {
            for (const creepType of config) {
                const { setup, amount } = creepType;
                const priority = creepType.priority || this.priority;
                const existingCreepsOfRole = _.filter(swarm.creeps, (creep) => creep.roleName == setup.role);
                // Log current and needed amounts for reporting
                (_a = creepQuantities[_d = setup.role]) !== null && _a !== void 0 ? _a : (creepQuantities[_d] = 0);
                creepQuantities[setup.role] += existingCreepsOfRole.length;
                (_b = neededQuantities[_e = setup.role]) !== null && _b !== void 0 ? _b : (neededQuantities[_e] = 0);
                neededQuantities[setup.role] += amount;
                // Spawn the needed quantity of creeps
                const spawnQuantity = amount - existingCreepsOfRole.length;
                for (let i = 0; i < spawnQuantity; i++) {
                    this.requestCreep(setup, { priority: priority });
                }
            }
        }
        // Spawn new swarms as needed
        const numRemainingSwarms = swarmQuantity - validSwarms.length;
        for (let n = 0; n < numRemainingSwarms; n++) {
            for (const creepType of config) {
                const { setup, amount } = creepType;
                const priority = creepType.priority || this.priority;
                (_c = neededQuantities[_f = setup.role]) !== null && _c !== void 0 ? _c : (neededQuantities[_f] = 0);
                neededQuantities[setup.role] += amount;
                for (let i = 0; i < amount; i++) {
                    this.requestCreep(setup, { priority: priority + 0.5 });
                }
            }
        }
        // Report creep amounts
        for (const role of _.keys(neededQuantities)) {
            this.creepReport(role, creepQuantities[role] || 0, neededQuantities[role]);
        }
    }
};
SwarmOverlord = __decorate$1([
    profile
], SwarmOverlord);

/**
 * Spawns squads of attackers and healers to siege a hostile room, moving with swarm logic in a coordinated fashion
 */
let SwarmDestroyerOverlord = class SwarmDestroyerOverlord extends SwarmOverlord {
    constructor(directive, priority = OverlordPriority.offense.destroy) {
        super(directive, "destroy", priority, {
            requiredRCL: DirectiveSwarmDestroy.requiredRCL,
        });
        this.directive = directive;
        this.memory = Mem.wrap(this.directive.memory, this.name);
        this.intel = new CombatIntel$1(this.directive);
        this.zerglings = this.combatZerg(Roles.melee, {
            notifyWhenAttacked: false,
        });
        // this.hydralisks = this.combatZerg(Roles.ranged, {
        // 	notifyWhenAttacked: false,
        // 	boostWishlist     : [BOOST_TIERS.ranged[3], BOOST_TIERS.tough[3], BOOST_TIERS.move[3]]
        // });
        this.healers = this.combatZerg(Roles.healer, {
            notifyWhenAttacked: false,
        });
        // Make swarms
        this.makeSwarms();
        // Compute fallback positions and assembly points
        this.fallback = $.pos(this, "fallback", () => this.intel.findSwarmAssemblyPointInColony({
            width: 2,
            height: 2,
        }), 200);
        this.assemblyPoints = [];
        for (let i = 0; i < _.keys(this.swarms).length + 1; i++) {
            this.assemblyPoints.push($.pos(this, `assemble_${i}`, () => this.intel.findSwarmAssemblyPointInColony({ width: 2, height: 2 }, i + 1), 200));
        }
    }
    refresh() {
        super.refresh();
        this.memory = Mem.wrap(this.directive.memory, this.name);
        this.makeSwarms();
    }
    makeSwarms() {
        this.swarms = {};
        const meleeZerg = [...this.zerglings, ...this.healers];
        // let rangedZerg: CombatZerg[] = this.hydralisks;
        const maxPerSwarm = {
            [Roles.melee]: 2,
            [Roles.healer]: 2,
            [Roles.ranged]: 4,
        };
        const meleeZergBySwarm = _.groupBy(meleeZerg, (zerg) => zerg.findSwarm(meleeZerg, maxPerSwarm));
        // let rangedZergBySwarm = _.groupBy(rangedZerg, zerg => zerg.findSwarm(rangedZerg, maxPerSwarm));
        // let zergBySwarm = _.merge(meleeZergBySwarm, rangedZergBySwarm);
        for (const ref in meleeZergBySwarm) {
            if (ref != undefined) {
                this.swarms[ref] = new Swarm(this, ref, meleeZergBySwarm[ref]);
            }
        }
        // for (let ref in rangedZergBySwarm) { // todo: finish changing
        // 	if (ref != undefined) {
        // 		if (DEBUG) log.debug(`Making swarm for ${_.map(meleeZergBySwarm[ref], z => z.name)}`);
        // 		this.swarms[ref] = new Swarm(this, ref, meleeZergBySwarm[ref]);
        // 	}
        // }
    }
    handleSwarm(swarm, index, waypoint = this.directive.pos) {
        // Swarm initially groups up at fallback location
        if (!swarm.memory.initialAssembly) {
            const assemblyPoint = this.assemblyPoints[index] || this.fallback;
            log.debug(`Assmbling at ${assemblyPoint.print}`);
            swarm.memory.initialAssembly = swarm.assemble(assemblyPoint);
            return;
        }
        // Swarm has now initially assembled with all members present
        // log.debug(`Done assmbling`);
        const room = swarm.rooms[0];
        if (!room) {
            log.warning(`${this.print} No room! (Why?)`);
        }
        // Siege the room
        const nearbyHostiles = _.filter(room.hostiles, (creep) => swarm.minRangeTo(creep) <= 3 + 1);
        const attack = _.sum(nearbyHostiles, (creep) => CombatIntel$1.getAttackDamage(creep));
        const rangedAttack = _.sum(nearbyHostiles, (creep) => CombatIntel$1.getRangedAttackDamage(creep));
        const myDamageMultiplier = CombatIntel$1.minimumDamageMultiplierForGroup(_.map(swarm.creeps, (c) => c.creep));
        const canPopShield = (attack +
            rangedAttack +
            CombatIntel$1.towerDamageAtPos(swarm.anchor)) *
            myDamageMultiplier >
            _.min(_.map(swarm.creeps, (creep) => 100 * creep.getActiveBodyparts(TOUGH)));
        if (canPopShield ||
            room.hostileStructures.length == 0 ||
            _.values(this.swarms).length > 1) {
            swarm.autoCombat(this.pos.roomName, waypoint);
        }
        else {
            swarm.autoSiege(this.pos.roomName, waypoint);
        }
    }
    init() {
        let numSwarms = this.directive.memory.amount || 1;
        if (RoomIntel$1.inSafeMode(this.pos.roomName)) {
            numSwarms = 0;
        }
        const zerglingPriority = this.zerglings.length <= this.healers.length ?
            this.priority - 0.1
            : this.priority + 0.1;
        const zerglingSetup = CombatSetups.zerglings.boosted.armored;
        const healerPriority = this.healers.length < this.zerglings.length ?
            this.priority - 0.1
            : this.priority + 0.1;
        const healerSetup = CombatSetups.transfusers.boosted.armored;
        this.healers.length < this.zerglings.length ?
            this.priority - 0.1
            : this.priority + 0.1;
        const swarmConfig = [
            { setup: zerglingSetup, amount: 2, priority: zerglingPriority },
            { setup: healerSetup, amount: 2, priority: healerPriority },
        ];
        this.swarmWishlist(numSwarms, swarmConfig);
        // const rangedSwarmConfig = [{setup: hydraliskSetup, amount: 4, priority: hydraliskPriority}];
        // this.swarmWishlist(numSwarms, rangedSwarmConfig);
    }
    run() {
        this.autoRun(this.zerglings, (_zergling) => undefined); // zergling => undefined is to handle boosting
        this.autoRun(this.healers, (_healer) => undefined);
        // this.autoRun(this.hydralisks, hydralisk => undefined);
        // Run swarms in order
        const refs = _.keys(this.swarms).sort();
        let i = 0;
        for (const ref of refs) {
            this.handleSwarm(this.swarms[ref], i);
            i++;
        }
    }
    visuals() {
        Visualizer.marker(this.fallback, { color: "green" });
        for (const ref in this.swarms) {
            const swarm = this.swarms[ref];
            Visualizer.marker(swarm.anchor, { color: "blue" });
            if (swarm.target) {
                Visualizer.marker(swarm.target.pos, { color: "orange" });
            }
        }
    }
};
SwarmDestroyerOverlord.settings = {
    retreatHitsPercent: 0.85,
    reengageHitsPercent: 0.95,
};
SwarmDestroyerOverlord = __decorate$1([
    profile
], SwarmDestroyerOverlord);

var DirectiveSwarmDestroy_1;
/**
 * Spawns a 2x2 squad of coordinated creeps to destroy a room
 */
let DirectiveSwarmDestroy = DirectiveSwarmDestroy_1 = class DirectiveSwarmDestroy extends Directive {
    constructor(flag) {
        super(flag, (colony) => colony.level >= DirectiveSwarmDestroy_1.requiredRCL);
    }
    spawnMoarOverlords() {
        this.overlords.destroy = new SwarmDestroyerOverlord(this);
    }
    init() {
        this.alert(`Swarm destroyer directive active`);
    }
    run() {
        // If there are no hostiles left in the room then remove the flag and associated healpoint
        if (this.room &&
            this.room.hostiles.length == 0 &&
            this.room.hostileStructures.length == 0) {
            log.notify(`Swarm destroyer mission at ${this.pos.roomName} completed successfully.`);
            this.remove();
        }
    }
    visuals() {
        Visualizer.marker(this.pos, { color: "red" });
    }
};
DirectiveSwarmDestroy.directiveName = "destroy";
DirectiveSwarmDestroy.color = COLOR_RED;
DirectiveSwarmDestroy.secondaryColor = COLOR_RED;
DirectiveSwarmDestroy.requiredRCL = 6;
DirectiveSwarmDestroy = DirectiveSwarmDestroy_1 = __decorate$1([
    profile
], DirectiveSwarmDestroy);

/**
 * An abstract class for encapsulating power creep power usage.
 */
let Power = class Power {
    constructor(powerCreep, target) {
        // log.notify(`Creating power task for ${powerCreep}`);
        this._powerCreep = {
            name: powerCreep.name,
        };
        if (target) {
            this._target = {
                ref: target.ref,
                _pos: target.pos,
            };
        }
    }
    /**
     * Dereferences the Task's target
     */
    get target() {
        return deref(this._target.ref);
    }
    canRunPower() {
        const power = this.powerCreep.powers[powerId$1];
        return power && power.level > 0 && power.cooldown == 0;
    }
    /**
     * Return the wrapped creep which is executing this task
     */
    get powerCreep() {
        // Get task's own creep by its name
        // Returns zerg wrapper instead of creep to use monkey-patched functions
        return Game.powerCreeps[this._powerCreep.name];
    }
    /**
     * Set the creep which is executing this task
     */
    set powerCreep(pc) {
        this._powerCreep.name = pc.name;
    }
    run() {
        if (this.canRunPower()) {
            this.operatePower();
        }
    }
    operatePower() { }
};
Power = __decorate$1([
    profile
], Power);

const powerId$1 = PWR_GENERATE_OPS;
/**
 * An abstract class for encapsulating power creep power usage.
 */
let GenerateOps = class GenerateOps extends Power {
    constructor(powerCreep, target) {
        super(powerCreep, target);
    }
    operatePower() {
        if (this.powerCreep.carry.ops &&
            this.powerCreep.carry.ops > this.powerCreep.carryCapacity * 0.9) {
            const storage = this.powerCreep.room.storage;
            if (!storage) {
                log.error(`Ops power creep with no storage`);
            }
            else {
                this.powerCreep.moveTo(storage);
                this.powerCreep.transfer(storage, RESOURCE_OPS, this.powerCreep.carry.ops);
            }
        }
        else {
            return this.powerCreep.usePower(powerId$1);
        }
        return ERR_TIRED;
    }
};
GenerateOps = __decorate$1([
    profile
], GenerateOps);

const powerId = PWR_OPERATE_EXTENSION;
/**
 * An abstract class for encapsulating power creep power usage.
 */
let OperateExtension = class OperateExtension extends Power {
    constructor(powerCreep, target) {
        super(powerCreep, target);
    }
    operatePower() {
        if (this.powerCreep.carry.ops &&
            this.powerCreep.carry.ops > 2 &&
            this.powerCreep.room &&
            this.powerCreep.room.energyAvailable <
                this.powerCreep.room.energyCapacityAvailable * 0.5) {
            const terminal = this.powerCreep.room.storage;
            if (!terminal) {
                log.error(`Ops power creep with no storage`);
            }
            else {
                this.powerCreep.moveTo(terminal);
                return this.powerCreep.usePower(powerId, terminal);
            }
        }
        return ERR_TIRED;
    }
};
OperateExtension = __decorate$1([
    profile
], OperateExtension);

var types;
(function (types) {
    types[types["opgen"] = 0] = "opgen";
    types[types["baseoperator"] = 1] = "baseoperator";
    types[types["basedefender"] = 2] = "basedefender";
})(types || (types = {}));
/**
 * Simple directive to run a power creep where the flag name is the power creep name
 */
let DirectiveBaseOperator = class DirectiveBaseOperator extends Directive {
    constructor(flag) {
        super(flag);
        this.defaultPowerPriorities = [
            PWR_GENERATE_OPS,
            PWR_REGEN_SOURCE,
            PWR_OPERATE_TOWER,
            PWR_OPERATE_STORAGE,
            PWR_OPERATE_LAB,
            PWR_OPERATE_SPAWN,
            PWR_OPERATE_EXTENSION,
            PWR_REGEN_MINERAL,
        ];
        const powerCreep = Game.powerCreeps[flag.name];
        if (!powerCreep) {
            log.error(`Power Creep not found for ${this.print}, deleting directive`);
            this.remove();
        }
        this.memory.powerPriorities =
            this.memory.powerPriorities || this.defaultPowerPriorities;
    }
    spawnMoarOverlords() { }
    init() { }
    // Wrapped powerCreep methods ==================================================================================
    renew(powerCreep, powerSource) {
        if (powerCreep.pos.inRangeToPos(powerSource.pos, 1)) {
            return powerCreep.renew(powerSource);
        }
        else {
            return powerCreep.moveTo(powerSource, {
                ignoreRoads: true,
                range: 1,
                swampCost: 1,
                reusePath: 0,
                visualizePathStyle: { lineStyle: "dashed", fill: "yellow" },
            });
        }
    }
    enablePower(powerCreep, controller) {
        log.alert(`Trying to enable power for ${controller} with `);
        if (powerCreep.pos.inRangeToPos(controller.pos, 1)) {
            return powerCreep.enableRoom(controller);
        }
        else {
            // let path = powerCreep.pos.findPathTo(controller, {ignoreRoads: true, range: 1, swampCost: 1});
            // log.alert(`Trying to enable power for ${controller} with ${JSON.stringify(path)}`);
            // return powerCreep.moveByPath(path);
            return powerCreep.moveTo(controller.pos, {
                ignoreRoads: true,
                range: 1,
                swampCost: 1,
                reusePath: 0,
                visualizePathStyle: { lineStyle: "solid" },
            });
        }
    }
    usePower(powerCreep, power) {
        // console.log(`The power constant is ${power}`)
        switch (power) {
            case PWR_GENERATE_OPS:
                return new GenerateOps(powerCreep);
            case PWR_OPERATE_EXTENSION:
                return new OperateExtension(powerCreep);
        }
    }
    runPowers(powerCreep) {
        const priorities = this.memory.powerPriorities;
        for (const powerId of priorities) {
            const powerToUse = this.usePower(powerCreep, priorities[powerId]);
            if (powerToUse && powerToUse.operatePower()) {
                break;
            }
        }
    }
    visuals() {
        Visualizer.marker(this.pos, { color: "red" });
    }
    run() {
        const powerCreep = Game.powerCreeps[this.flag.name];
        if (!powerCreep ||
            (Game.cpu.bucket < 5000 &&
                (!powerCreep.ticksToLive || powerCreep.ticksToLive > 500))) {
            this.powerCreepName = this.flag.name;
            // console.log('Not running power creep because not defined or bucket is low');
            return;
        }
        if (powerCreep.name == "BaseDefender" &&
            powerCreep.room &&
            powerCreep.room.terminal) {
            powerCreep.usePower(PWR_OPERATE_TERMINAL, powerCreep.room.terminal);
        }
        // For the power creeps that just sit on power spawn
        powerCreep.name
            .toLowerCase()
            .indexOf(types.basedefender.toString());
        if (powerCreep.name == "activate") {
            console.log("Power creep move is " + JSON.stringify(powerCreep.memory));
        }
        // console.log(`Running power creep ${JSON.stringify(powerCreep)}
        // with ttl ${powerCreep.ticksToLive} with ${this.room!.powerSpawn}`);
        if (!this.room) {
            return;
        }
        else if (!powerCreep.ticksToLive &&
            this.room &&
            this.room.powerSpawn) {
            // Spawn creep
            const res = powerCreep.spawn(this.room.powerSpawn);
            log.alert(`Running ${powerCreep} with spawn of ${res}`);
        }
        else if (this.room.controller &&
            !this.room.controller.isPowerEnabled) {
            // Enable power
            const res = this.enablePower(powerCreep, this.room.controller);
            log.alert(`Running ${powerCreep} with enable power of ${res}`);
        }
        else if (powerCreep &&
            powerCreep.ticksToLive &&
            powerCreep.ticksToLive < 900 &&
            this.room.powerSpawn) {
            const res = this.renew(powerCreep, this.room.powerSpawn);
            log.alert(`Running ${powerCreep} with renew of ${res}`);
        }
        else {
            this.runPowers(powerCreep);
            // log.alert(`Running ${powerCreep} with power of ${res}`);
        }
        if (this.room.hostiles.length > 2 ||
            (powerCreep.pos &&
                DirectiveNukeResponse.isPresent(powerCreep.pos.roomName))) {
            const towersToBoost = this.colony.towers.filter((tower) => !tower.effects || tower.effects.length == 0);
            if (towersToBoost.length > 0) {
                powerCreep.usePower(PWR_OPERATE_TOWER, towersToBoost[0]);
            }
            if ((!powerCreep.carry.ops || powerCreep.carry.ops < 20) &&
                this.room.storage &&
                this.room.storage.store.ops &&
                this.room.storage.store.ops > 100) {
                powerCreep.withdraw(this.room.storage, RESOURCE_OPS, 100);
            }
        }
    }
};
DirectiveBaseOperator.directiveName = "BaseOperator";
DirectiveBaseOperator.color = COLOR_CYAN;
DirectiveBaseOperator.secondaryColor = COLOR_PURPLE;
DirectiveBaseOperator = __decorate$1([
    profile
], DirectiveBaseOperator);

var ExtractorOverlord_1;
const BUILD_OUTPUT_FREQUENCY = 15;
/**
 * Spawns extractors to harvest minerals in an owned or sourcekeeper room
 */
let ExtractorOverlord = ExtractorOverlord_1 = class ExtractorOverlord extends Overlord {
    constructor(directive, priority) {
        super(directive, "mineral", priority);
        this.directive = directive;
        this.priority +=
            this.outpostIndex * OverlordPriority.remoteSKRoom.roomIncrement;
        this.drones = this.zerg(Roles.drone);
        // Populate structures
        this.populateStructures();
    }
    // If mineral is ready to be mined, make a container
    shouldHaveContainer() {
        return (this.mineral &&
            (this.mineral.mineralAmount > 0 ||
                (this.mineral.ticksToRegeneration || 0) < 2000));
    }
    populateStructures() {
        if (Game.rooms[this.pos.roomName]) {
            this.extractor = this.pos.lookForStructure(STRUCTURE_EXTRACTOR);
            this.mineral = this.pos.lookFor(LOOK_MINERALS)[0];
            this.container = this.pos.findClosestByLimitedRange(Game.rooms[this.pos.roomName].containers, 1);
        }
    }
    get deactivationReasons() {
        const reasons = super.deactivationReasons;
        reasons.add(SuspensionReason.overfilled);
        return reasons;
    }
    refresh() {
        if (!this.room && Game.rooms[this.pos.roomName]) {
            // if you just gained vision of this room
            this.populateStructures();
        }
        super.refresh();
        $.refresh(this, "extractor", "mineral", "container");
        if (this.colony.state.isOverfilled && !this.isSuspended) {
            log.alert(`${this.colony.print} overfilled, suspending ${this.print} for ${SUSPENSION_OVERFILL_DEFAULT_DURATION}`);
            this.suspend({
                reason: SuspensionReason.overfilled,
                duration: SUSPENSION_OVERFILL_DEFAULT_DURATION,
            });
        }
    }
    registerOutputRequests() {
        var _a, _b, _c;
        if (this.container) {
            const outputThreshold = this.drones.length == 0 ?
                this.container.store.getCapacity()
                : 0;
            const exhausted = ((_a = this.mineral) === null || _a === void 0 ? void 0 : _a.mineralAmount) === 0 &&
                ((_c = (_b = this.mineral) === null || _b === void 0 ? void 0 : _b.ticksToRegeneration) !== null && _c !== void 0 ? _c : 0) > 0;
            if (this.container.store.getUsedCapacity() > outputThreshold ||
                (exhausted && this.container.store.getUsedCapacity() > 0)) {
                this.colony.logisticsNetwork.requestOutput(this.container, {
                    resourceType: "all",
                });
            }
        }
    }
    /* Calculate where the container output will be built for this site */
    calculateContainerPos() {
        // log.debug(`Computing container position for mining overlord at ${this.pos.print}...`);
        let originPos;
        if (this.colony.storage) {
            originPos = this.colony.storage.pos;
        }
        else if (this.colony.roomPlanner.storagePos) {
            originPos = this.colony.roomPlanner.storagePos;
        }
        if (originPos) {
            const path = Pathing.findShortestPath(this.pos, originPos).path;
            const pos = _.find(path, (pos) => pos.getRangeTo(this) == 1);
            if (pos) {
                return pos;
            }
        }
        // Shouldn't ever get here
        log.warning(`Last resort container position calculation for ${this.print}!`);
        return _.first(this.pos.availableNeighbors(true));
    }
    buildOutputIfNeeded() {
        // Create container if there is not already one being built
        if (!this.container && this.shouldHaveContainer()) {
            const containerSite = _.first(_.filter(this.pos.findInRange(FIND_MY_CONSTRUCTION_SITES, 2), (site) => site.structureType == STRUCTURE_CONTAINER));
            if (!containerSite) {
                const containerPos = this.calculateContainerPos();
                log.info(`${this.print}: building container at ${containerPos.print}`);
                const result = containerPos.createConstructionSite(STRUCTURE_CONTAINER);
                if (result != OK) {
                    log.error(`${this.print}: cannot build container at ${containerPos.print}: ${errorForCode(result)}`);
                }
                return;
            }
        }
    }
    init() {
        this.registerOutputRequests();
        const amount = (this.mineral &&
            this.mineral.mineralAmount > 0 &&
            this.extractor &&
            this.container) ?
            Math.min(this.mineral.pos.availableNeighbors().length, ExtractorOverlord_1.settings.maxDrones)
            : 0;
        this.wishlist(amount, Setups.drones.extractor);
    }
    handleDrone(drone) {
        var _a;
        this.debug(`handling ${drone.print}`);
        // Stay safe out there!
        if (drone.avoidDanger({ timer: 10, dropEnergy: true })) {
            this.debug(`${this.print} avoiding danger`);
            return;
        }
        // Ensure you are in the assigned room
        if (drone.room == this.room && !drone.pos.isEdge) {
            if (this.mineral && !drone.pos.inRangeToPos(this.mineral.pos, 1)) {
                this.debug(`${drone.print} too far from ${this.mineral.print}`);
                return drone.goTo(this.mineral.pos);
            }
            if (this.mineral) {
                // Do harvest first - needs to check if in range anyway so this is more CPU efficient
                if (((_a = this.extractor) === null || _a === void 0 ? void 0 : _a.cooldown) === 0) {
                    this.debug(`${drone.print} harvesting from ${this.mineral.print}`);
                    const ret = drone.harvest(this.mineral);
                    if (ret == ERR_NOT_IN_RANGE) {
                        this.debug(`${drone.print} too far from ${this.mineral.print}, moving closer`);
                        return drone.goTo(this.mineral);
                    }
                }
                if (this.container) {
                    // Transfer to container if you need to (can do at same tick as harvest)
                    if (drone.store.getUsedCapacity() >
                        0.9 * drone.store.getCapacity()) {
                        this.debug(`${drone.print} full at ${drone.store.getUsedCapacity()}/${drone.store.getCapacity()}, transferring`);
                        const transfer = drone.transferAll(this.container);
                        if (transfer == ERR_NOT_IN_RANGE) {
                            return drone.goTo(this.container, { range: 1 });
                        }
                    }
                    // Move onto the container pos if you need to
                    if (this.drones.length == 1 &&
                        !drone.pos.isEqualTo(this.container.pos)) {
                        this.debug(`${this.print} moving onto container`);
                        return drone.goTo(this.container, { range: 0 });
                    }
                }
            }
            else {
                log.error(`${drone.print}: room defined and no mineral! (Why?)`);
            }
        }
        else {
            this.debug(`${drone.print} not in room`);
            drone.goTo(this);
        }
    }
    run() {
        this.autoRun(this.drones, (drone) => this.handleDrone(drone), (drone) => drone.avoidDanger({ timer: 10, dropEnergy: true }));
        if (this.room && Game.time % BUILD_OUTPUT_FREQUENCY == 2) {
            this.buildOutputIfNeeded();
        }
    }
};
ExtractorOverlord.settings = {
    maxDrones: 2,
};
ExtractorOverlord = ExtractorOverlord_1 = __decorate$1([
    profile
], ExtractorOverlord);

/**
 * Mineral extraction directive. Spawns extraction creeps to operate extractors in owned or source keeper rooms
 */
let DirectiveExtract = class DirectiveExtract extends Directive {
    constructor(flag) {
        var _a;
        super(flag);
        this.colony.markDestination(this.pos, (_a = this.memory["T" /* MEM.TICK */]) !== null && _a !== void 0 ? _a : Game.time);
    }
    spawnMoarOverlords() {
        let priority;
        if (this.room && this.room.my) {
            if (this.colony.level == 8) {
                priority = OverlordPriority.ownedRoom.mineralRCL8;
            }
            else {
                priority = OverlordPriority.ownedRoom.mineral;
            }
        }
        else {
            priority = OverlordPriority.remoteSKRoom.mineral;
        }
        this.overlords.extract = new ExtractorOverlord(this, priority);
    }
    init() { }
    run() {
        if (this.colony.level < 6) {
            log.notify(`Removing extraction directive in ${this.pos.roomName}: room RCL insufficient.`);
            this.remove();
        }
        else if (!this.colony.terminal) {
            log.notify(`Removing extraction directive in ${this.pos.roomName}: room is missing terminal.`);
            this.remove();
        }
    }
    visuals() {
        var _a, _b, _c;
        if (!(this.memory.debug && Memory.settings.enableVisuals)) {
            return;
        }
        const extract = this.overlords.extract;
        const data = [this.name];
        if (extract.container) {
            const store = extract.container.store;
            data.push(` S: ${store.getUsedCapacity()}/${store.getCapacity()}`);
        }
        if (extract.extractor) {
            data.push(` C: ${(_a = this.overlords.extract.extractor) === null || _a === void 0 ? void 0 : _a.cooldown} ticks`);
        }
        if ((_b = extract.mineral) === null || _b === void 0 ? void 0 : _b.mineralAmount) {
            data.push(` R: ${extract.mineral.mineralAmount} ${extract.mineral.mineralType}`);
        }
        else {
            data.push(` R: ${(_c = extract.mineral) === null || _c === void 0 ? void 0 : _c.ticksToRegeneration} ticks`);
        }
        const { x, y, roomName } = this.pos;
        new RoomVisual(roomName).infoBox(data, x, y, { color: "#7acf9c" });
    }
};
DirectiveExtract.directiveName = "extract";
DirectiveExtract.color = COLOR_YELLOW;
DirectiveExtract.secondaryColor = COLOR_CYAN;
DirectiveExtract = __decorate$1([
    profile
], DirectiveExtract);

const defaultDirectiveHarvestMemory = {
    ["u" /* HARVEST_MEM.USAGE */]: 1,
    ["d" /* HARVEST_MEM.DOWNTIME */]: 0,
};
/**
 * Standard mining directive. Mines from an owned, remote, or source keeper room
 */
let DirectiveHarvest = class DirectiveHarvest extends Directive {
    constructor(flag) {
        super(flag);
        if (this.colony) {
            this.colony.miningSites[this.name] = this;
        }
        _.defaultsDeep(this.memory, defaultDirectiveHarvestMemory);
    }
    spawnMoarOverlords() {
        // Create a mining overlord for this
        let priority = OverlordPriority.ownedRoom.mine;
        if (!(this.room && this.room.my)) {
            priority =
                (Cartographer.roomType(this.pos.roomName) ==
                    ROOMTYPE_SOURCEKEEPER) ?
                    OverlordPriority.remoteSKRoom.mine
                    : OverlordPriority.remoteRoom.mine;
        }
        this.overlords.mine = new MiningOverlord(this, priority);
    }
    init() {
        var _a, _b;
        const harvestPos = (_a = this.overlords.mine.harvestPos) !== null && _a !== void 0 ? _a : this.pos;
        this.colony.markDestination(harvestPos, (_b = this.memory["T" /* MEM.TICK */]) !== null && _b !== void 0 ? _b : Game.time);
    }
    get energyAvailable() {
        let energy = 0;
        const mine = this.overlords.mine;
        if (mine.container) {
            energy += mine.container.store.getUsedCapacity(RESOURCE_ENERGY);
        }
        if (mine.link) {
            energy += mine.link.store.getUsedCapacity(RESOURCE_ENERGY);
        }
        const drops = mine.pos.findInRange(FIND_DROPPED_RESOURCES, 1, {
            filter: RESOURCE_ENERGY,
        });
        energy += drops.reduce((sum, res) => (sum += res.amount), 0);
        return energy;
    }
    run() {
        this.computeStats();
    }
    computeStats() {
        const source = this.overlords.mine.source;
        if (source && source.ticksToRegeneration == 1) {
            this.memory["u" /* HARVEST_MEM.USAGE */] =
                (source.energyCapacity - source.energy) / source.energyCapacity;
        }
        const container = this.overlords.mine.container;
        this.memory["d" /* HARVEST_MEM.DOWNTIME */] = +ema(container ? +container.isFull : 0, this.memory["d" /* HARVEST_MEM.DOWNTIME */], CREEP_LIFE_TIME).toFixed(5);
    }
    visuals() {
        if (!(this.memory.debug && Memory.settings.enableVisuals)) {
            return;
        }
        const isSuspended = this.overlords.mine.suspensionReason;
        const data = [this.name];
        if (isSuspended) {
            data.push(` S: ${isSuspended === true ? "manual" : isSuspended}`);
        }
        else {
            data.push(` U: ${this.memory["u" /* HARVEST_MEM.USAGE */].toPercent()}`);
            data.push(` D: ${this.memory["d" /* HARVEST_MEM.DOWNTIME */].toPercent()}`);
            data.push(` E: ${this.overlords.mine.avgEnergyPerTick.toFixed(3)}`);
            if (this.memory["D" /* MEM.DISTANCE */]) {
                data.push(` P: ${this.memory["D" /* MEM.DISTANCE */]["w" /* MEM_DISTANCE.WEIGHTED */]}`);
            }
        }
        const { x, y, roomName } = this.pos;
        new RoomVisual(roomName).infoBox(data, x, y, {
            color: !isSuspended ? "#FFE87B" : "#D8DBC3",
        });
    }
};
DirectiveHarvest.directiveName = "harvest";
DirectiveHarvest.color = COLOR_YELLOW;
DirectiveHarvest.secondaryColor = COLOR_YELLOW;
DirectiveHarvest = __decorate$1([
    profile
], DirectiveHarvest);

var PowerDrillOverlord_1;
/**
 * PowerDrillOverlord -- spawns drills and coolant to mine power banks
 */
let PowerDrillOverlord = PowerDrillOverlord_1 = class PowerDrillOverlord extends CombatOverlord {
    constructor(directive, priority = OverlordPriority.powerMine.drill) {
        super(directive, "powerDrill", priority, {
            requiredRCL: DirectivePowerMine.requiredRCL,
            maxSpawnDistance: DirectivePowerMine.maxSpawnDistance,
        });
        this.directive = directive;
        this.priority +=
            this.outpostIndex * OverlordPriority.powerMine.roomIncrement;
        this.drills = this.combatZerg(Roles.drill);
        this.coolant = this.combatZerg(Roles.coolant);
        this.memory = Mem.wrap(this.directive.memory, "powerDrill");
        this.partnerMap = new Map();
    }
    refresh() {
        super.refresh();
        this.memory = Mem.wrap(this.directive.memory, "powerDrill");
    }
    init() {
        this.wishlist(1, CombatSetups.drill.default);
        this.wishlist(2, CombatSetups.coolant.small);
    }
    getHostileDrill(powerBank) {
        return (powerBank.hits < powerBank.hitsMax &&
            powerBank.pos.findInRange(FIND_HOSTILE_CREEPS, 2)[0]);
    }
    handleHostileDrill(hostileDrill, powerBank) {
        Game.notify(`${hostileDrill.owner.username} power harvesting ${powerBank.room.name}, competing for same power bank.`);
        // this.directive.remove();
    }
    handleDrill(drill) {
        if (drill.spawning) {
            return;
        }
        if (!this.directive.powerBank) {
            if (!this.room) ;
            else {
                // If power bank is dead
                if (this.directive.powerBank == undefined &&
                    this.directive.memory.state < PowerMineState.haulingStarted) {
                    Game.notify(`Power bank in ${this.room.print} is dead.`);
                    const result = drill.retire();
                    if (result == ERR_BUSY) ;
                    log.notify(`FINISHED POWER MINING IN ${this.room.name} DELETING CREEP at time: ${Game.time}: ${result}.`);
                    return;
                }
            }
        }
        // Go to power room
        if (!this.room ||
            drill.room != this.room ||
            drill.pos.isEdge ||
            !this.directive.powerBank) {
            // log.debugCreep(drill, `Going to room!`);
            // log.notify("Drill is moving to power site in " + this.pos.roomName + ".");
            drill.goTo(this.pos);
            return;
        }
        //  Handle killing bank
        if (drill.pos.isNearTo(this.directive.powerBank)) {
            if (!this.partnerMap.get(drill.name)) {
                this.partnerMap.set(drill.name, []);
            }
            PowerDrillOverlord_1.periodicSay(drill, "Drilling⚒️");
            drill.attack(this.directive.powerBank);
        }
        else {
            PowerDrillOverlord_1.periodicSay(drill, "🚗Traveling🚗");
            drill.goTo(this.directive.powerBank);
        }
    }
    handleCoolant(coolant) {
        if (coolant.spawning) {
            return;
        }
        // Go to powerbank room
        if (!this.room || coolant.room != this.room || coolant.pos.isEdge) {
            // log.debugCreep(coolant, `Going to room!`);
            coolant.healSelfIfPossible();
            coolant.goTo(this.pos);
            return;
        }
        else if (!this.directive.powerBank) {
            // If power bank is dead
            Game.notify(`Power bank in ${this.room.name} is dead.`);
            coolant.retire();
            return;
        }
        if (coolant.pos.getRangeTo(this.directive.powerBank) > 3) {
            coolant.goTo(this.directive.powerBank);
        }
        else {
            const activeDrills = this.pos
                .findInRange(FIND_MY_CREEPS, 1)
                .filter((creep) => _.contains(creep.name, "drill"));
            if (activeDrills.length > 0) {
                const drill = activeDrills[0];
                coolant.heal(drill);
                if (coolant.pos.getRangeTo(drill) > 1) {
                    coolant.goTo(drill, { range: 1, noPush: true });
                }
            }
        }
        // else if (coolant.pos.findInRange(FIND_MY_CREEPS, 1).filter(creep => _.contains(creep.name, "drill")).length == 0) {
        // 	let target = _.sample(_.filter(this.drills, drill => drill.hits < drill.hitsMax));
        // 	if (target) {
        // 		coolant.goTo(target, {range: 1, noPush: true});
        // 	}
        // }
        // // else if (coolant.pos.getRangeTo(this.directive.powerBank) == 1) {
        // // 	coolant.move(Math.round(Math.random()*7) as DirectionConstant);
        // // }
        // else {
        // 	let drill = _.sample(_.filter(this.drills, drill => drill.hits < drill.hitsMax));
        // 	if (drill) { coolant.goTo(drill); }
        // }
        //
        // coolant.autoHeal();
    }
    // private findDrillToPartner(coolant: CombatZerg) {
    // 	let needsHealing = _.min(Array.from(this.partnerMap.keys()), key => this.partnerMap.get(key)!.length);
    // 	if (this.partnerMap.get(needsHealing)) {
    // 		this.partnerMap.get(needsHealing)!.concat(coolant.name);
    // 		coolant.say(needsHealing.toString());
    // 		coolant.memory.partner = needsHealing;
    // 	} else {
    //
    // 	}
    // 	//console.log(JSON.stringify(this.partnerMap));
    // 	// let newPartner = _.sample(_.filter(this.drills, drill => this.room == drill.room));
    // 	// coolant.memory.partner = newPartner != undefined ? newPartner.name : undefined;
    // 	coolant.say('Partnering!');
    // }
    //
    // private runPartnerHealing(coolant: CombatZerg) {
    // 	if (coolant.memory.partner) {
    // 		let drill = Game.creeps[coolant.memory.partner];
    // 		if (!drill) {
    // 			// Partner is dead
    // 			coolant.memory.partner = undefined;
    // 			this.findDrillToPartner(coolant)
    // 		} else if (!coolant.pos.isNearTo(drill)) {
    // 			PowerDrillOverlord.periodicSay(coolant,'🚗Traveling️');
    // 			coolant.goTo(drill);
    // 		} else {
    // 			PowerDrillOverlord.periodicSay(coolant,'❄️Cooling❄️');
    // 			coolant.heal(drill);
    // 		}
    // 		if (Game.time % 10 == PowerDrillOverlord.getCreepNameOffset(coolant)) {
    // 			this.findDrillToPartner(coolant);
    // 		}
    // 		return;
    // 	} else {
    // 		this.findDrillToPartner(coolant);
    // 	}
    // }
    static periodicSay(zerg, text) {
        if (Game.time % 10 == PowerDrillOverlord_1.getCreepNameOffset(zerg)) {
            zerg.say(text, true);
        }
    }
    static getCreepNameOffset(zerg) {
        return parseInt(zerg.name.charAt(zerg.name.length - 1), 10) || 0;
    }
    run() {
        this.autoRun(this.drills, (drill) => this.handleDrill(drill));
        this.autoRun(this.coolant, (coolant) => this.handleCoolant(coolant));
        if (this.directive.memory.state >= PowerMineState.miningDone) {
            Game.notify("DELETING ALL POWER MINING CREEPS BECAUSE STATE IS >= 3 in " +
                this.directive.print);
            this.drills.forEach((drill) => drill.retire());
            this.coolant.forEach((coolant) => coolant.retire());
        }
    }
    visuals() {
        if (this.room && this.directive.powerBank) {
            Visualizer.marker(this.directive.powerBank.pos);
        }
    }
};
PowerDrillOverlord = PowerDrillOverlord_1 = __decorate$1([
    profile
], PowerDrillOverlord);

/**
 * Spawns special-purpose haulers for transporting resources to/from a specified target
 */
let PowerHaulingOverlord = class PowerHaulingOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.collectionUrgent.haul) {
        super(directive, "powerHaul", priority);
        // Allow time for body to spawn
        this.prespawnAmount = 300;
        this.directive = directive;
        this.spawnGroup = new SpawnGroup(this, {
            requiredRCL: DirectivePowerMine.requiredRCL,
            maxPathDistance: DirectivePowerMine.maxSpawnDistance,
        });
        this.haulers = this.zerg(Roles.transport);
        this.totalCollected = this.totalCollected || 0;
        // Spawn haulers to collect ALL the power at the same time.
        const haulingPartsNeeded = this.directive.totalResources / CARRY_CAPACITY;
        // Calculate amount of hauling each hauler provides in a lifetime
        const haulerCarryParts = Setups.transporters.default.getBodyPotential(CARRY, this.colony);
        // Calculate number of haulers
        this.numHaulers = Math.ceil(haulingPartsNeeded / haulerCarryParts);
        // setup time to request the haulers
        const distance = directive.distanceFromPOI.terrainWeighted;
        this.tickToSpawnOn =
            Game.time +
                (this.directive.calculateRemainingLifespan() || 0) -
                distance -
                this.prespawnAmount;
    }
    init() {
        if (Game.time >= this.tickToSpawnOn &&
            this.directive.memory.state < PowerMineState.haulingComplete) {
            this.wishlist(this.numHaulers, Setups.transporters.default);
        }
    }
    handleHauler(hauler) {
        if (hauler.store.getUsedCapacity() === 0) {
            if (this.directive.memory.state >= PowerMineState.haulingComplete) {
                // FIXME: Maybe ditch this and put it as a separate on-finishing method to reassign
                log.warning(`${hauler.name} is retiring as directive is done!`);
                this.numHaulers = 0;
                hauler.retire();
            }
            // Travel to directive and collect resources
            if (hauler.inSameRoomAs(this.directive)) {
                // Pick up drops first
                if (this.directive.hasDrops) {
                    const allDrops = _.flatten(_.values(this.directive.drops));
                    const drop = allDrops[0];
                    if (drop) {
                        hauler.task = Tasks$1.pickup(drop);
                        return;
                    }
                }
                else if (this.directive.powerBank) {
                    if (hauler.pos.getRangeTo(this.directive.powerBank) > 4) {
                        hauler.goTo(this.directive.powerBank);
                    }
                    else {
                        hauler.say("🚬", true);
                    }
                    return;
                }
                else if (this.room && this.room.ruins) {
                    const pb = this.room.ruins.filter((ruin) => !!ruin.store[RESOURCE_POWER] &&
                        ruin.store[RESOURCE_POWER] > 0);
                    if (pb.length > 0) {
                        hauler.task = Tasks$1.withdraw(pb[0], RESOURCE_POWER);
                    }
                }
                else if (this.room && this.room.drops) {
                    const allDrops = _.flatten(_.values(this.room.drops));
                    const drop = allDrops[0];
                    if (drop) {
                        hauler.task = Tasks$1.pickup(drop);
                        return;
                    }
                    else {
                        hauler.retire();
                        return;
                    }
                }
                // Shouldn't reach here
                log.warning(`${hauler.name} in ${hauler.room.print}: nothing to collect!`);
            }
            else {
                hauler.goTo(this.directive);
            }
        }
        else {
            // Travel to colony room and deposit resources
            if (hauler.inSameRoomAs(this.colony)) {
                for (const [resourceType, amount] of hauler.store.contents) {
                    if (amount == 0) {
                        continue;
                    }
                    if (resourceType == RESOURCE_ENERGY) {
                        // prefer to put energy in storage
                        if (this.colony.storage &&
                            this.colony.storage.store.getUsedCapacity() <
                                STORAGE_CAPACITY) {
                            hauler.task = Tasks$1.transfer(this.colony.storage, resourceType);
                            return;
                        }
                        else if (this.colony.terminal &&
                            this.colony.terminal.store.getUsedCapacity() <
                                TERMINAL_CAPACITY) {
                            hauler.task = Tasks$1.transfer(this.colony.terminal, resourceType);
                            return;
                        }
                    }
                    else {
                        // prefer to put minerals in terminal
                        this.directive.memory.totalCollected +=
                            hauler.store.power || 0;
                        if (this.colony.terminal &&
                            this.colony.terminal.store.getUsedCapacity() <
                                TERMINAL_CAPACITY) {
                            hauler.task = Tasks$1.transfer(this.colony.terminal, resourceType);
                            return;
                        }
                        else if (this.colony.storage &&
                            this.colony.storage.store.getUsedCapacity() <
                                STORAGE_CAPACITY) {
                            hauler.task = Tasks$1.transfer(this.colony.storage, resourceType);
                            return;
                        }
                    }
                }
                // Shouldn't reach here
                log.warning(`${hauler.name} in ${hauler.room.print}: nowhere to put resources!`);
            }
            else {
                hauler.task = Tasks$1.goToRoom(this.colony.room.name);
            }
        }
    }
    checkIfStillCarryingPower() {
        return _.find(this.haulers, (hauler) => hauler.store.power != undefined && hauler.store.power > 0);
    }
    run() {
        this.autoRun(this.haulers, (hauler) => this.handleHauler(hauler));
    }
};
PowerHaulingOverlord = __decorate$1([
    profile
], PowerHaulingOverlord);

// Creep utilities that don't belong anywhere else
// TODO should probably live in combat intell or something similar
// Does not account for range, just total of body parts
function calculateFormationStrength(creeps) {
    const tally = {
        move: 0,
        work: 0,
        carry: 0,
        attack: 0,
        ranged_attack: 0,
        tough: 0,
        heal: 0,
        claim: 0,
    };
    _.forEach(creeps, function (unit) {
        const individualTally = calculateBodyPotential(unit.body);
        for (const bodyType in individualTally) {
            const type = bodyType;
            tally[type] += individualTally[type];
        }
    });
    return tally;
}
function calculateBodyPotential(body) {
    const tally = {
        move: 0,
        work: 0,
        carry: 0,
        attack: 0,
        ranged_attack: 0,
        tough: 0,
        heal: 0,
        claim: 0,
    };
    _.forEach(body, function (bodyPart) {
        // Needs boost logic
        tally[bodyPart.type] += 1;
    });
    return tally;
}

var DirectivePowerMine_1;
const PowerMineState = {
    init: 0,
    miningStarted: 1,
    haulingStarted: 2,
    miningDone: 3,
    haulingComplete: 4,
};
function powerMineState(state) {
    var _a;
    const states = [
        "init",
        "mining started",
        "hauling started",
        "mining done",
        "hauling complete",
    ];
    return (_a = states[state]) !== null && _a !== void 0 ? _a : `unknown (${state})`;
}
/**
 * PowerMining directive: kills power banks and collects the resources.
 */
let DirectivePowerMine = DirectivePowerMine_1 = class DirectivePowerMine extends Directive {
    constructor(flag) {
        var _a;
        super(flag, (colony) => colony.level >= DirectivePowerMine_1.requiredRCL);
        this._powerBank = this.powerBank;
        this.memory.state = (_a = this.memory.state) !== null && _a !== void 0 ? _a : PowerMineState.init;
        this.memory["X" /* MEM.EXPIRATION */] =
            this.memory["X" /* MEM.EXPIRATION */] ||
                Game.time +
                    (this.powerBank ? this.powerBank.ticksToDecay + 1000 : 5500);
        this.memory.totalCollected = this.memory.totalCollected || 0;
    }
    spawnMoarOverlords() {
        if (this.memory.state < PowerMineState.miningDone) {
            this.overlords.powerMine = new PowerDrillOverlord(this);
        }
        if (this.memory.state > PowerMineState.miningStarted) {
            this.overlords.powerHaul = new PowerHaulingOverlord(this);
        }
    }
    get drops() {
        if (!this.pos.isVisible) {
            return {};
        }
        if (!this._drops || _.keys(this._drops).length == 0) {
            const drops = this.pos.lookFor(LOOK_RESOURCES);
            this._drops = _.groupBy(drops, (drop) => drop.resourceType);
        }
        return this._drops;
    }
    get hasDrops() {
        return _.keys(this.drops).length > 0;
    }
    get powerBank() {
        if (this.pos.isVisible) {
            this._powerBank =
                this._powerBank || !!this.flag.room ?
                    this.flag.pos.lookForStructure(STRUCTURE_POWER_BANK)
                    : undefined;
            return this._powerBank;
        }
    }
    /**
     * Total amount of resources remaining to be transported; cached into memory in case room loses visibility
     */
    get totalResources() {
        if (this.pos.isVisible) {
            // update total amount remaining
            this.memory.totalResources =
                this.powerBank ?
                    this.powerBank.power
                    : this.memory.totalResources;
        }
        if (this.memory.totalResources == undefined) {
            return 5000; // pick some non-zero number so that powerMiners will spawn
        }
        return this.memory.totalResources;
    }
    calculateRemainingLifespan() {
        if (!this.room) {
            return undefined;
        }
        else if (this.powerBank == undefined) {
            return 0;
        }
        else {
            const tally = calculateFormationStrength(this.powerBank.pos.findInRange(FIND_MY_CREEPS, 4));
            const healStrength = tally.heal * HEAL_POWER || 0;
            const attackStrength = tally.attack * ATTACK_POWER || 0;
            // PB have 50% hitback, avg damage is attack strength if its enough healing, otherwise healing
            const avgDamagePerTick = Math.min(attackStrength, healStrength * 2);
            return this.powerBank.hits / avgDamagePerTick;
        }
    }
    // TODO FIXME XXX
    manageState() {
        const currentState = this.memory.state;
        log.debug(`Managing state ${currentState} of directive ${this.print} with PB ${this.powerBank}`);
        if (currentState == PowerMineState.init &&
            this.powerBank &&
            this.powerBank.hits < this.powerBank.hitsMax) {
            if (this.powerBank.pos.findInRange(FIND_MY_CREEPS, 3).length == 0 &&
                this.powerBank.pos.findInRange(FIND_HOSTILE_CREEPS, 3).length >
                    0) {
                // Power bank is damage but we didn't mine it
                log.alert(`Power bank mining ${this.print} competing with ${this.powerBank.room.hostiles[0].owner.username}.`);
                // this.remove();
            }
            else {
                // Set to mining started
                this.memory.state = PowerMineState.miningStarted;
            }
        }
        else if ((currentState == PowerMineState.init ||
            currentState == PowerMineState.miningStarted) &&
            this.room &&
            (!this.powerBank || this.powerBank.hits < 500000)) {
            Game.notify("Activating spawning haulers for power mining in room " +
                this.pos.roomName);
            log.info("Activating spawning haulers for power mining in room " +
                this.pos.roomName);
            this.memory.state = PowerMineState.haulingStarted;
        }
        else if (currentState == PowerMineState.haulingStarted &&
            this.room &&
            !this.powerBank &&
            (this.hasDrops || this.room.ruins.length == 0)) {
            Game.notify(`Mining is complete for ${this.print} in ${this.room.print} at time ${Game.time}`);
            log.alert(`Mining is complete for ${this.print} in ${this.room.print} at time ${Game.time}`);
            this.memory.state = PowerMineState.miningDone;
            // TODO reassign them to guard the bank
            delete this.overlords.powerMine;
            this._powerBank = undefined; // This might be fluff
        }
        else if ((currentState == PowerMineState.init ||
            currentState == PowerMineState.miningStarted ||
            currentState == PowerMineState.haulingStarted) &&
            this.room &&
            this.pos.isVisible &&
            !this.powerBank) {
            if (!this.hasDrops && this.room.ruins.length == 0) {
                // TODO this had an error where it triggered incorrectly
                Game.notify(`WE FAILED. SORRY CHIEF, COULDN'T FINISH POWER MINING IN ${this.print} ` +
                    `DELETING Directive at time ${Game.time}`);
                log.error(`WE FAILED. SORRY CHIEF, COULDN'T FINISH POWER MINING IN ${this.room} ` +
                    `DELETING Directive at time: ${Game.time}`);
                this.remove();
            }
            else {
                // If somehow there is no bank but there is drops where bank was
                Game.notify(`Somehow the power bank died early in ${this.room} at state ${currentState}, ` +
                    `setting state to 3 ${Game.time}`);
                this.memory.state = PowerMineState.miningDone;
            }
        }
        else if (currentState == PowerMineState.miningDone &&
            this.room &&
            this.pos.isVisible &&
            !this.hasDrops &&
            this.room.ruins.filter((ruin) => !!ruin.store[RESOURCE_POWER] &&
                ruin.store[RESOURCE_POWER] > 0).length == 0) {
            Game.notify(`Hauler pickup is complete for ${this.print} in ${this.room.print} at time ${Game.time}`);
            // Hauler pickup is now complete
            log.alert(`Hauler pickup is complete for ${this.print} in ${this.room.print} at time ${Game.time}`);
            this.memory.state = PowerMineState.haulingComplete;
            // TODO  Stop spawning haulers
        }
        else if (currentState == PowerMineState.haulingComplete &&
            this.overlords.powerHaul &&
            this.overlords.powerHaul.checkIfStillCarryingPower() == undefined) {
            // TODO Doesn't give enough time to pick up power
            log.notify(`Hauling complete for ${this.print} at time ${Game.time}. Final power collected was ` +
                `${this.memory.totalCollected} out of ${this.memory.totalResources}`);
            this.remove();
        }
        else {
            log.debug(`Power mining ${this.print} is in state ${currentState}`);
            // Todo this isn't error but needs other stuff
        }
    }
    init() {
        let alert;
        if (this.pos.room && !!this.powerBank) {
            alert = `PM ${powerMineState(this.memory.state)} ${this.totalResources} P${Math.floor((100 * this.powerBank.hits) / this.powerBank.hitsMax)}% @ ${this.powerBank.ticksToDecay}TTL`;
        }
        else {
            alert = `PowerMine ${powerMineState(this.memory.state)} ${this.totalResources}`;
        }
        this.alert(alert);
    }
    run() {
        // Check frequently when almost mined and occasionally otherwise
        const frequency = this.memory.state == PowerMineState.haulingStarted ? 1 : 21;
        if (Game.time % frequency == 0) {
            this.manageState();
        }
    }
};
DirectivePowerMine.directiveName = "powerMine";
DirectivePowerMine.color = COLOR_YELLOW;
DirectivePowerMine.secondaryColor = COLOR_RED;
DirectivePowerMine.requiredRCL = 7;
DirectivePowerMine.maxSpawnDistance = 500;
DirectivePowerMine = DirectivePowerMine_1 = __decorate$1([
    profile
], DirectivePowerMine);

/**
 * Manually place a bunker anchored at the target location for the RoomPlanner to use in semiautomatic or manual mode
 */
let DirectiveRPBunker = class DirectiveRPBunker extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() { }
    init() {
        this.colony.roomPlanner.addComponent("bunker", this.pos, this.memory.rotation);
    }
    run() { }
    visuals() {
        Visualizer.drawLayout(bunkerLayout, this.pos);
    }
};
DirectiveRPBunker.directiveName = "roomPlanner:CommandCenter";
DirectiveRPBunker.color = COLOR_WHITE;
DirectiveRPBunker.secondaryColor = COLOR_RED;
DirectiveRPBunker = __decorate$1([
    profile
], DirectiveRPBunker);

/**
 * [DEPRECATED] Place a command center at the target location
 */
let DirectiveRPCommandCenter = class DirectiveRPCommandCenter extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() { }
    init() {
        log.info(`Classic overmind layout is deprecated; bunker layout is recommended.`);
        this.colony.roomPlanner.addComponent("commandCenter", this.pos, this.memory.rotation);
    }
    run() { }
};
DirectiveRPCommandCenter.directiveName = "roomPlanner:CommandCenter";
DirectiveRPCommandCenter.color = COLOR_WHITE;
DirectiveRPCommandCenter.secondaryColor = COLOR_BLUE;
DirectiveRPCommandCenter = __decorate$1([
    profile
], DirectiveRPCommandCenter);

/**
 * [DEPRECATED] Place a hatchery at the target location
 */
let DirectiveRPHatchery = class DirectiveRPHatchery extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() { }
    init() {
        log.info(`Classic overmind layout is deprecated; bunker layout is recommended.`);
        this.colony.roomPlanner.addComponent("hatchery", this.pos, this.memory.rotation);
    }
    run() { }
};
DirectiveRPHatchery.directiveName = "roomPlanner:Hatchery";
DirectiveRPHatchery.color = COLOR_WHITE;
DirectiveRPHatchery.secondaryColor = COLOR_GREEN;
DirectiveRPHatchery = __decorate$1([
    profile
], DirectiveRPHatchery);

/**
 * Bootstrapping overlord: spawns small miners and suppliers to recover from a catastrohpic colony crash
 */
let BootstrappingOverlord = class BootstrappingOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.emergency.bootstrap) {
        super(directive, "bootstrap", priority);
        this.fillers = this.zerg(Roles.filler);
        this.updateStructures();
    }
    refresh() {
        super.refresh();
        this.updateStructures();
    }
    /** Calculate structures fillers can supply / withdraw from */
    updateStructures() {
        this.supplyStructures = _.filter([...this.colony.spawns, ...this.colony.extensions], (structure) => structure.energy < structure.energyCapacity);
        this.withdrawStructures = _.filter(_.compact([
            this.colony.storage,
            this.colony.terminal,
            this.colony.powerSpawn,
            ...this.room.containers,
            ...this.room.links,
            ...this.room.towers,
            ...this.room.labs,
        ]), (structure) => structure.energy > 0);
    }
    spawnBootstrapMiners() {
        // Isolate mining site overlords in the room
        let miningSitesInRoom = _.filter(_.values(this.colony.miningSites), (site) => site.room == this.colony.room);
        if (this.colony.spawns[0]) {
            miningSitesInRoom = _.sortBy(miningSitesInRoom, (site) => site.pos.getRangeTo(this.colony.spawns[0]));
        }
        // If you have no miners then create whatever is the biggest miner you can make
        const pattern = [WORK, WORK, CARRY, MOVE];
        const miningOverlordsInRoom = _.map(miningSitesInRoom, (site) => site.overlords.mine);
        const allMiners = _.flatten(_.map(miningOverlordsInRoom, (overlord) => overlord.lifetimeFilter(overlord.miners)));
        const allMiningPower = _.sum(allMiners, (creep) => creep.getActiveBodyparts(WORK));
        let sizeLimit;
        if (allMiningPower == 0) {
            sizeLimit = Math.min(Math.floor(this.colony.room.energyAvailable / bodyCost(pattern)), 3);
        }
        else {
            // Otherwise if you have miners then you can afford to make normal ones
            sizeLimit = 3;
        }
        const setup = new CreepSetup(Roles.drone, {
            pattern: pattern,
            sizeLimit: sizeLimit,
        });
        this.debug(`found ${miningOverlordsInRoom.length} mining overlords for ${miningSitesInRoom.length} mines, ` +
            `at ${miningSitesInRoom.map((s) => `${s.pos}`).join(", ")}`);
        // Create a bootstrapMiners and donate them to the miningSite overlords as needed
        for (const overlord of miningOverlordsInRoom) {
            const filteredMiners = this.lifetimeFilter(overlord.miners);
            const miningPowerAssigned = _.sum(_.map(this.lifetimeFilter(overlord.miners), (creep) => creep.getActiveBodyparts(WORK)));
            if (miningPowerAssigned < overlord.miningPowerNeeded &&
                filteredMiners.length < overlord.pos.availableNeighbors().length) {
                if (this.colony.hatchery) {
                    const request = {
                        setup: setup,
                        overlord: overlord,
                        priority: this.priority + 1,
                    };
                    this.colony.hatchery.enqueue(request);
                    this.debug(`Enqueueing bootstrap miner with size ${sizeLimit}`);
                }
            }
        }
    }
    init() {
        // If you are super low on energy, spawn one miner, then a filler, then rest of the miners
        const totalEnergyInRoom = _.sum(this.withdrawStructures, (structure) => structure.store.energy);
        const costToMakeNormalMinerAndFiller = patternCost(Setups.drones.miners.emergency) * 3 +
            patternCost(Setups.filler); // costs 1000
        if (totalEnergyInRoom < costToMakeNormalMinerAndFiller) {
            if (this.colony.getCreepsByRole(Roles.drone).length == 0) {
                this.debug(`no drones, bootstrapping miners`);
                this.spawnBootstrapMiners();
                return;
            }
        }
        // Spawn fillers
        if (this.colony.getCreepsByRole(Roles.queen).length == 0 &&
            this.colony.hatchery) {
            // no queen
            const transporter = _.first(this.colony.getZergByRole(Roles.transport));
            if (transporter) {
                this.debug(`no queen, reassigning transporter`);
                transporter.reassign(this.colony.hatchery.overlord, Roles.queen);
            }
            else {
                // wish for a filler
                this.debug(`no queen, wishlisting a filler`);
                this.wishlist(1, Setups.filler);
            }
        }
        // Then spawn the rest of the needed miners
        this.debug(`bootstrapping miners`);
        this.spawnBootstrapMiners();
        // const energyInStructures = _.sum(_.map(this.withdrawStructures, structure => structure.energy));
        // const droppedEnergy = _.sum(this.room.droppedEnergy, drop => drop.amount);
        // if (energyInStructures + droppedEnergy < BootstrappingOverlord.settings.spawnBootstrapMinerThreshold) {
        // 	this.spawnBootstrapMiners();
        // }
    }
    supplyActions(filler) {
        const target = filler.pos.findClosestByRange(this.supplyStructures);
        if (target) {
            this.debug(`${filler.print}: going to get supply from ${target.structureType} at ${target.pos}`);
            filler.task = Tasks$1.transfer(target);
        }
        else {
            this.rechargeActions(filler);
        }
    }
    rechargeActions(filler) {
        const target = filler.pos.findClosestByRange(this.withdrawStructures);
        if (target) {
            this.debug(`${filler.print}: withdrawing from ${target.structureType} at ${target.pos}`);
            filler.task = Tasks$1.withdraw(target);
        }
        else {
            this.debug(`${filler.print}: recharging from anything`);
            filler.task = Tasks$1.recharge();
        }
    }
    handleFiller(filler) {
        if (filler.store.energy > 0) {
            this.supplyActions(filler);
        }
        else {
            this.rechargeActions(filler);
        }
    }
    run() {
        let toUpdate = true;
        for (const filler of this.fillers) {
            if (filler.isIdle) {
                if (toUpdate) {
                    toUpdate = false;
                    // Filter valid structures fillers can supply / withdraw from
                    this.supplyStructures = _.filter(this.supplyStructures, (structure) => structure.store.getFreeCapacity(RESOURCE_ENERGY) > 0);
                    this.withdrawStructures = _.filter(this.withdrawStructures, (structure) => structure.store.energy > 0);
                }
                this.handleFiller(filler);
            }
            filler.run();
        }
    }
};
BootstrappingOverlord.settings = {
    spawnBootstrapMinerThreshold: 3000,
};
BootstrappingOverlord = __decorate$1([
    profile
], BootstrappingOverlord);

/**
 * Bootstrapping directive: recover from a colony-wide crash or bootstrap from initial spawn-in
 */
let DirectiveBootstrap = class DirectiveBootstrap extends Directive {
    constructor(flag) {
        super(flag);
        this.refresh(); // data needs to be recomputed each tick
    }
    refresh() {
        super.refresh();
        this.colony.state.bootstrapping = true;
        this.needsMiner = this.colony.getCreepsByRole(Roles.drone).length == 0;
        this.needsManager =
            this.colony.commandCenter != undefined &&
                this.colony.commandCenter.overlord != undefined &&
                this.colony.commandCenter.link != undefined &&
                this.colony.getCreepsByRole(Roles.manager).length == 0;
        this.needsQueen = this.colony.getCreepsByRole(Roles.queen).length == 0;
    }
    spawnMoarOverlords() {
        this.overlords.bootstrap = new BootstrappingOverlord(this);
    }
    init() {
        this.alert(`Colony in bootstrap mode!`, NotifierPriority.High);
        if (Game.time % 100 == 0) {
            log.alert(`Colony ${this.room.print} is in emergency recovery mode.`);
        }
    }
    run() {
        if (!this.needsQueen && !this.needsMiner) {
            if (this.colony.storage && this.colony.assets.energy < 5000) {
                return; // wait a little while at higher levels before stopping bootstrapping
            }
            log.alert(`Colony ${this.room.print} has recovered from crash; removing bootstrap directive.`);
            // Reassign any filler to the work force
            const overlord = this.overlords.bootstrap;
            for (const filler of overlord.fillers) {
                filler.reassign(this.colony.overlords.logistics, Roles.transport);
            }
            // Remove the directive
            this.remove();
        }
    }
};
DirectiveBootstrap.directiveName = "bootstrap";
DirectiveBootstrap.color = COLOR_ORANGE;
DirectiveBootstrap.secondaryColor = COLOR_ORANGE;
DirectiveBootstrap = __decorate$1([
    profile
], DirectiveBootstrap);

/**
 * Launches nuke at target location
 */
let DirectiveNukeTarget = class DirectiveNukeTarget extends Directive {
    // TODO add sending multiple nukes and spacing the nukes out by x amount
    constructor(flag) {
        super(flag, (colony) => !!colony.nuker &&
            !(colony.nuker.cooldown > 0) &&
            Game.map.getRoomLinearDistance(colony.room.name, flag.pos.roomName) <= 10);
        this.refresh();
    }
    refresh() {
        super.refresh();
    }
    spawnMoarOverlords() { }
    init() { }
    run() {
        if (this.colony.nuker && this.colony.nuker.cooldown == 0) {
            const res = this.colony.nuker.launchNuke(this.flag.pos);
            if (res == OK) {
                log.notify(`Launching nuclear strike at ${this.flag.pos.print}, ETA ${Game.time + NUKE_LAND_TIME}`);
                this.remove();
            }
        }
        else if (!this.colony.nuker || this.colony.nuker.cooldown > 0) {
            log.error(`DirectiveNuke unable to fire from ${this.colony.name} due to nuker ${this.colony.nuker} ` +
                `being unavailable: ${this.print}`);
            this.remove();
        }
    }
};
DirectiveNukeTarget.directiveName = "nukeTarget";
DirectiveNukeTarget.color = COLOR_ORANGE;
DirectiveNukeTarget.secondaryColor = COLOR_RED;
DirectiveNukeTarget.requiredRCL = 8;
DirectiveNukeTarget = __decorate$1([
    profile
], DirectiveNukeTarget);

const DEFAULT_NUM_SCOUTS = 2;
/**
 * Sends out scouts which randomly traverse rooms to uncover possible expansion locations and gather intel
 */
let PortalScoutOverlord = class PortalScoutOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.scouting.randomWalker) {
        super(directive, "scout", priority);
        this.directive = directive;
        this.scouts = this.zerg(Roles.scout, { notifyWhenAttacked: false });
    }
    init() {
        this.wishlist(DEFAULT_NUM_SCOUTS, Setups.scout);
    }
    portalSays(creep, isPublic) {
        const says = [
            "One small",
            "step for",
            `${creep.name}`,
            `one giant`,
            `leap for`,
            `all`,
            `Creepkind`,
        ];
        creep.say(says[Game.time % says.length], isPublic);
    }
    handleScout(scout) {
        const finalDestination = this.directive;
        // log.alert(`Portal walker ${scout.print} is in ${scout.room.name}`);
        if (scout.pos != finalDestination.pos) {
            scout.goTo(finalDestination, { pathOpts: { avoidSK: true } });
        }
        this.portalSays(scout, true);
    }
    run() {
        this.autoRun(this.scouts, (scout) => this.handleScout(scout));
    }
};
PortalScoutOverlord = __decorate$1([
    profile
], PortalScoutOverlord);

/**
 * It's like the movie Interstellar, but the special effects budget is whatever cash I left in my jeans
 */
let DirectivePortalScout = class DirectivePortalScout extends Directive {
    constructor(flag, colonyFilter) {
        flag.memory.allowPortals = true;
        super(flag, colonyFilter);
    }
    spawnMoarOverlords() {
        this.overlords.portalScoutOverlord = new PortalScoutOverlord(this);
    }
    init() {
        this.alert(`Portal scout active`);
    }
    run() { }
};
DirectivePortalScout.directiveName = "portalScout";
DirectivePortalScout.color = COLOR_ORANGE;
DirectivePortalScout.secondaryColor = COLOR_WHITE;
DirectivePortalScout.requiredRCL = 3;
DirectivePortalScout = __decorate$1([
    profile
], DirectivePortalScout);

// The order in which resources are handled within the network
const highPriorityLoot = [
    ...BOOSTS_T3,
    RESOURCE_OPS,
    RESOURCE_POWER,
];
const lowPriorityLoot = [
    ...BOOSTS_T2,
    ...BOOSTS_T1,
    ...INTERMEDIATE_REACTANTS,
    ...BASE_RESOURCES,
];
const dontLoot = [RESOURCE_ENERGY];
const everythingElse = _.filter(RESOURCES_ALL, (res) => !(highPriorityLoot.includes(res) || lowPriorityLoot.includes(res)) &&
    !dontLoot.includes(res));
const LOOTING_ORDER = [
    ...highPriorityLoot,
    ...everythingElse,
    ...lowPriorityLoot,
];
/**
 * Spawns remote upgraders and energy carriers to travel to a distant room to upgrade the controller. The directive
 * should be placed on the controller in the child room and should only be used after the room has been claimed.
 */
let RemoteUpgradingOverlord = class RemoteUpgradingOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.colonization.remoteUpgrading) {
        super(directive, "remoteUpgrade", priority);
        this.directive = directive;
        this.parentColony = this.colony;
        this.childColony = Overmind.colonies[this.pos.roomName];
        if (!this.childColony) {
            log.error(`${this.print}: no child colony! (Why?)`);
        }
        if (this.parentColony == this.childColony) {
            log.error(`${this.print}: parent and child colonies are the same! (Why?)`);
        }
        this.upgradeSite = this.childColony.upgradeSite;
        // If new colony or boosts overflowing to storage
        this.carriers = this.zerg(Roles.transport);
        this.upgraders = this.zerg(Roles.upgrader);
        this.boosted = true; // TODO
    }
    /**
     * Computes the amount of carry capacity (in terms of energy units, not bodyparts) needed
     */
    computeNeededCarrierCapacity() {
        if (this.childColony.terminal && this.childColony.terminal.my) {
            return 0; // don't need this once you have a terminal
        }
        const roundTripDistance = 1.5 /* todo */ * this.directive.distanceFromPOI.terrainWeighted;
        const energyPerTick = _.sum(this.upgraders, (upgrader) => UPGRADE_CONTROLLER_POWER * upgrader.getActiveBodyparts(WORK));
        return energyPerTick * roundTripDistance;
    }
    init() {
        let neededCarriers = this.carriers.length;
        if (this.carriers.length == 0) {
            neededCarriers = 1;
        }
        else {
            const neededCarryCapacity = this.computeNeededCarrierCapacity();
            const currentCarryCapacity = _.sum(this.carriers, (carrier) => CARRY_CAPACITY *
                CombatIntel$1.getCarryPotential(carrier.creep, true));
            const avgCarrierCapactiy = currentCarryCapacity / this.carriers.length;
            this.debug(`Needed carry capacity: ${neededCarryCapacity}; Current carry capacity: ${currentCarryCapacity}`);
            neededCarriers = Math.ceil(neededCarryCapacity / avgCarrierCapactiy);
            this.debug(`Needed carriers: ${neededCarriers}`);
        }
        if (this.boosted) {
            this.wishlist(neededCarriers, Setups.transporters.boosted, {
                priority: this.priority,
            });
            this.wishlist(8, Setups.upgraders.remote_boosted, {
                priority: this.priority + 1,
            });
        }
        else {
            this.wishlist(neededCarriers, Setups.transporters.default, {
                priority: this.priority,
            });
            this.wishlist(8, Setups.upgraders.remote, {
                priority: this.priority + 1,
            });
        }
    }
    handleUpgrader(upgrader) {
        // Go to the room and don't pick up energy until you're there
        if (!upgrader.safelyInRoom(this.childColony.room.name)) {
            upgrader.goToRoom(this.childColony.room.name);
            return;
        }
        // You're in the room, upgrade if you have energy
        if (upgrader.store.energy > 0) {
            upgrader.task = Tasks$1.upgrade(this.upgradeSite.controller);
            return;
        }
        // If you're out of energy, recharge from link or battery
        if (this.upgradeSite.link && this.upgradeSite.link.energy > 0) {
            upgrader.task = Tasks$1.withdraw(this.upgradeSite.link);
            return;
        }
        if (this.upgradeSite.battery && this.upgradeSite.battery.energy > 0) {
            upgrader.task = Tasks$1.withdraw(this.upgradeSite.battery);
            return;
        }
        // Recharge from transporter?
        const nearbyCarriers = _.filter(this.carriers, (carrier) => upgrader.pos.getRangeTo(carrier) <= 5);
        const nearbyCarriersWaitingToUnload = _.filter(nearbyCarriers, (carrier) => carrier.store.energy > 0);
        const lowestEnergyCarrier = minBy(nearbyCarriersWaitingToUnload, (carrier) => carrier.store.energy);
        if (lowestEnergyCarrier) {
            upgrader.goTo(lowestEnergyCarrier);
            return;
        }
        else {
            // Just recharge how you normally would
            upgrader.task = Tasks$1.recharge();
        }
    }
    handleCarrier(carrier) {
        if (carrier.getActiveBodyparts(HEAL) > 0) {
            carrier.heal(carrier);
        }
        // Get energy from the parent colony if you need it
        if (carrier.store.energy == 0) {
            // If you are in the child room and there are valuable resources in a storage/terminal that isn't mine,
            // then take those back before you go home
            if (carrier.room == this.childColony.room &&
                carrier.store.getFreeCapacity() > 0) {
                const storeStructuresNotMy = _.filter(_.compact([
                    this.childColony.room.storage,
                    this.childColony.room.terminal,
                ]), (structure) => !structure.my);
                for (const resource of LOOTING_ORDER) {
                    const withdrawTarget = _.find(storeStructuresNotMy, (structure) => structure.store.getUsedCapacity(resource) > 0);
                    if (withdrawTarget) {
                        const amount = Math.min(withdrawTarget.store.getUsedCapacity(resource), carrier.store.getFreeCapacity());
                        carrier.task = Tasks$1.withdraw(withdrawTarget, resource, amount);
                        return;
                    }
                }
            }
            // Go to the parent room for energy
            if (!carrier.safelyInRoom(this.parentColony.room.name)) {
                carrier.goToRoom(this.parentColony.room.name);
                return;
            }
            const target = _.find(_.compact([
                this.parentColony.storage,
                this.parentColony.terminal,
            ]), (s) => s.store[RESOURCE_ENERGY] >= carrier.store.getCapacity());
            if (!target) {
                log.warning(`${this.print}: no energy withdraw target for ${carrier.print}!`);
                return;
            }
            if (carrier.store.getUsedCapacity() >
                carrier.store.getUsedCapacity(RESOURCE_ENERGY)) {
                carrier.task = Tasks$1.transferAll(target);
            }
            else {
                carrier.task = Tasks$1.withdraw(target);
            }
        }
        else {
            // Go to the room
            if (!carrier.safelyInRoom(this.childColony.room.name)) {
                carrier.goToRoom(this.childColony.room.name);
                return;
            }
            // Try to deposit in container, unless there's already a crowd waiting there;
            // otherwise put in storage if you can
            const depositPos = this.upgradeSite.batteryPos || this.upgradeSite.pos;
            const carriersWaitingToUnload = _.filter(this.carriers, (carrier) => carrier.store.energy > 0 &&
                carrier.pos.inRangeToPos(depositPos, 5));
            const firstCarrierInQueue = minBy(carriersWaitingToUnload, (carrier) => carrier.store.energy +
                (carrier.ticksToLive || Infinity) / 10000);
            // Put in storage if you can
            if (this.childColony.storage &&
                firstCarrierInQueue &&
                firstCarrierInQueue != carrier) {
                carrier.task = Tasks$1.transfer(this.childColony.storage);
                return;
            }
            // Otherwise go to the dropoff point
            const range = firstCarrierInQueue && carrier == firstCarrierInQueue ? 0 : 3;
            if (!carrier.pos.inRangeToPos(depositPos, range)) {
                carrier.goTo(depositPos);
                return;
            }
            // Otherwise try to transfer to any empty upgraders
            if (carrier == firstCarrierInQueue) {
                // Once you're nearby try to deposit in the battery if there is one
                if (this.upgradeSite.battery &&
                    this.upgradeSite.battery.store.getFreeCapacity() > 0) {
                    if (carrier.transfer(this.upgradeSite.battery) == OK) {
                        return;
                    }
                }
                // Carriers should unload one at a time
                const upgraderTransferTarget = maxBy(_.filter(this.upgraders, (upgrader) => upgrader.pos.isNearTo(carrier)), (upgrader) => upgrader.store.getFreeCapacity());
                if (upgraderTransferTarget) {
                    if (carrier.transfer(upgraderTransferTarget) == OK) {
                        return;
                    }
                }
            }
        }
    }
    run() {
        this.autoRun(this.upgraders, (upgrader) => this.handleUpgrader(upgrader));
        this.autoRun(this.carriers, (carrier) => this.handleCarrier(carrier));
    }
};
RemoteUpgradingOverlord = __decorate$1([
    profile
], RemoteUpgradingOverlord);

var DirectiveRemoteUpgrade_1;
/**
 * Spawns remote upgraders and energy carriers to travel to a distant room to upgrade the controller. The directive
 * should be placed on the controller in the child room and should only be used after the room has been claimed.
 */
let DirectiveRemoteUpgrade = DirectiveRemoteUpgrade_1 = class DirectiveRemoteUpgrade extends Directive {
    constructor(flag) {
        flag.memory.allowPortals = true;
        super(flag, (colony) => colony.level >= DirectiveRemoteUpgrade_1.requiredRCL);
    }
    spawnMoarOverlords() {
        this.overlords.remoteUpgrade = new RemoteUpgradingOverlord(this);
    }
    init() {
        this.alert(`Remote upgrade active`);
    }
    run() {
        if (this.room &&
            this.room.controller &&
            this.room.controller.level == 8) {
            this.remove();
        }
    }
};
DirectiveRemoteUpgrade.directiveName = "remoteUpgrade";
DirectiveRemoteUpgrade.color = COLOR_ORANGE;
DirectiveRemoteUpgrade.secondaryColor = COLOR_YELLOW;
DirectiveRemoteUpgrade.requiredRCL = 8;
DirectiveRemoteUpgrade = DirectiveRemoteUpgrade_1 = __decorate$1([
    profile
], DirectiveRemoteUpgrade);

var StrongholdOverlord_1;
/**
 * Prioritized list of what order enemy structures should be attacked in
 */
[
    STRUCTURE_INVADER_CORE,
    STRUCTURE_TOWER,
    STRUCTURE_RAMPART,
    STRUCTURE_WALL,
];
/**
 * Spawns ranged attacker against stronghold
 */
let StrongholdOverlord = StrongholdOverlord_1 = class StrongholdOverlord extends CombatOverlord {
    constructor(directive, priority = OverlordPriority.defense.rangedDefense) {
        super(directive, "stronghold", priority, { requiredRCL: 1 });
        this.strongholdKillers = this.combatZerg(Roles.strongholdKiller, {
            notifyWhenAttacked: false,
        });
    }
    /**
     * Returns [position, target] by searching for safe locations
     * @param target
     * @param range
     * @param myCreep
     */
    findAttackingPositionAndTarget(target, range, myCreep) {
        log.info(`Finding attacking position in ${target.room} for ${this.print}`);
        if (!target.room || range == 0) {
            return;
        }
        // bug with containers
        const shootPositions = target.pos.getPositionsAtRange(range, false, false);
        // Index is range to avoid from
        const avoidLocs = Array.from({ length: 5 }, () => []);
        avoidLocs[1] = avoidLocs[1].concat(target.room.ramparts.map((rampart) => rampart.pos));
        avoidLocs[4] = avoidLocs[4].concat(target.room.sources.map((s) => s.pos));
        avoidLocs[4] = avoidLocs[4].concat(target.room.keeperLairs.map((s) => s.pos));
        if (target.room.mineral) {
            avoidLocs[4] = avoidLocs[4].concat(target.room.mineral.pos);
        }
        // Array where first index is how many hostile locations there are
        const safeSpots = this.findSafeLocation(shootPositions, avoidLocs);
        _.forEach(safeSpots, (distanceArray, hostilesIndex) => distanceArray.forEach((spot) => Visualizer.marker(spot, {
            color: StrongholdOverlord_1.numberToColor(hostilesIndex),
            frames: 2,
        })));
        // If you can safely attack goal, do that
        if (safeSpots[0].length > 0) {
            const closestFirst = safeSpots[0].sort((a, b) => this.bestRampartToAttackSortFunction(a, b, myCreep.pos));
            return { attackPos: closestFirst[0], target: target };
        }
        else if (safeSpots[1].length > 0) {
            // Can't safely attack target, need to attack another position first
            const range1Spots = safeSpots[1];
            const ramparts = target.room.ramparts;
            const posToRampartMap = new Map();
            for (const spot of range1Spots) {
                for (const rampart of ramparts) {
                    if (rampart.pos.isNearTo(spot)) {
                        const temp = posToRampartMap.get(spot);
                        posToRampartMap.set(spot, !!temp ? temp.concat([rampart]) : [rampart]);
                    }
                }
            }
            // Now select closest
            if (myCreep) {
                // TODO currently extra filtering, don't need from above
                const orderedByBest = Array.from(posToRampartMap.keys())
                    .filter((p) => posToRampartMap.get(p) &&
                    posToRampartMap.get(p).length == 1)
                    .sort((a, b) => this.bestRampartToAttackSortFunction(a, b, myCreep.pos));
                for (const pos of orderedByBest) {
                    const res = this.findAttackingPositionAndTarget(posToRampartMap.get(pos)[0], range - 1, myCreep);
                    if (res) {
                        return res;
                    }
                }
            }
            else {
                for (const pos of posToRampartMap) {
                    const res = this.findAttackingPositionAndTarget(pos[1][0], range - 1, myCreep);
                    if (res) {
                        return res;
                    }
                }
            }
        }
        return;
    }
    get target() {
        if (this.memory.target && this.memory.target.exp > Game.time) {
            const target = Game.getObjectById(this.memory.target.id);
            if (target) {
                return target;
            }
        }
        // If nothing found
        delete this.memory.target;
    }
    set target(targ) {
        if (targ) {
            this.memory.target = { id: targ.id, exp: getCacheExpiration(3000) };
        }
        else {
            delete this.memory.target;
        }
    }
    bestRampartToAttackSortFunction(element1, element2, currentPos
    /* map: Map<RoomPosition, StructureRampart[]>*/
    ) {
        // const numRamparts1 = map.get(element1) == undefined ? 10 : map.get(element1)!.length;
        // const numRamparts2 = map.get(element2) == undefined ? 10 : map.get(element2)!.length;
        return (element1.getRangeTo(currentPos) - element2.getRangeTo(currentPos)); // + (numRamparts1 - numRamparts2);
        // if (element.roomName == currentPos.roomName) {
        //
        // }
    }
    /**
     * Returns double array of number of avoids per locations
     * @param locations
     * @param avoidLocationsAtDistance
     */
    findSafeLocation(locations, avoidLocationsAtDistance) {
        // Index is number of hostiles present.
        const locationToHostilesMapping = Array.from({ length: 8 }, () => []);
        locations.forEach((loc) => {
            let count = 0;
            avoidLocationsAtDistance.forEach((avoidArray, distance) => {
                avoidArray.forEach((avoidPos) => {
                    if (avoidPos.getRangeTo(loc) <= distance) {
                        count++;
                    }
                });
            });
            if (count < locationToHostilesMapping.length) {
                locationToHostilesMapping[count].push(loc);
            }
        });
        // Should probably do cost matrix to avoid ramparts, wrote a getNearRampartsMatrix in pathing but need to use it
        return locationToHostilesMapping;
    }
    get attackPos() {
        if (this._attackPos) {
            return this._attackPos;
        }
        if (this.memory.target && this.memory.attackingPosition) {
            this._attackPos = posFromReadableName(this.memory.attackingPosition);
            return this._attackPos;
        }
    }
    handleKiller(killer) {
        if (Game.time % 15 == 0) {
            log.info(`Stronghold Killer ${killer.print} for ${this.print} in room ${killer.room.print}`);
        }
        if (this.room && killer.pos.roomName == this.pos.roomName) {
            if (this.directive.core && !this.memory.target) {
                const before = Game.cpu.getUsed();
                this.resetAttacking(this.directive.core, 3, killer);
                log.info(`CPU used for stronghold is ${Game.cpu.getUsed() - before}`);
            }
        }
        // TODO creep was an idiot and walked next to rampart moving to next attack position
        killer.heal(killer);
        if (killer.pos.roomName != this.pos.roomName) {
            killer.goToRoom(this.directive.pos.roomName);
        }
        if (killer.hits / killer.hitsMax <
            StrongholdOverlord_1.settings.retreatHitsPercent) {
            killer.flee([this.directive.pos].concat(killer.room.hostiles.map((sk) => sk.pos)));
        }
        // Shoot nearby enemies before moving on
        const unprotectedHostiles = killer.room.hostiles.filter((hostile) => hostile.pos.getRangeTo(killer.pos) <= 3 && !hostile.inRampart);
        if (unprotectedHostiles.length > 0) {
            killer.rangedAttack(unprotectedHostiles[0]);
            return;
        }
        if (this.memory.attackingPosition) {
            const attackPos = posFromReadableName(this.memory.attackingPosition);
            // In room and in position
            if (!attackPos || !killer.pos.isEqualTo(attackPos)) {
                let avoids = [];
                if (this.directive.room) {
                    avoids = avoids.concat(_.flatten(this.directive.room.sourceKeepers.map((source) => source.pos.getPositionsInRange(3, false, false))));
                    avoids = avoids.concat(_.flatten(this.directive.room.ramparts.map((ramparts) => ramparts.pos.neighbors)));
                    if (this.directive.room.mineral) {
                        avoids = avoids.concat(this.directive.room.mineral.pos.getPositionsInRange(4, false, false));
                    }
                    avoids.forEach((av) => Visualizer.circle(av));
                    killer.goTo(attackPos, {
                        pathOpts: { obstacles: avoids },
                    });
                }
            }
        }
        if (killer.pos.roomName == this.directive.pos.roomName) {
            if (this.target) {
                const res = killer.rangedAttack(this.target);
                if (res == ERR_INVALID_TARGET) ;
            }
            else {
                killer.goTo(this.pos);
                killer.rangedMassAttack();
                // killer.autoCombat(this.directive.pos.roomName);
            }
        }
    }
    static numberToColor(colorNumber) {
        switch (colorNumber) {
            case 0:
                return "green";
            case 1:
                return "yellow";
            case 2:
                return "orange";
            default:
                return "red";
        }
    }
    init() {
        if (this.memory.attackingPosition) {
            const attackPos = posFromReadableName(this.memory.attackingPosition);
            if (!!attackPos) {
                Visualizer.marker(attackPos, "white");
            }
        }
        if (this.memory.target && Game.getObjectById(this.memory.target.id)) {
            const target = Game.getObjectById(this.memory.target.id);
            if (target) {
                Visualizer.marker(target.pos, "black");
            }
        }
        if (this.directive.memory.state >= 3) {
            return; // No need to spawn more
        }
        // log.info(`Setting up body type for ${this.print} with ${this.directive.memory.strongholdLevel}`);
        // let setup;
        // // TODO fix me for when strongholds typescript is out
        // switch (this.directive.memory.strongholdLevel) {
        // 	case 5:
        // 		return; // Fuck this shit we out
        // 	case 4:
        // 		return;
        // 	// setup = CombatSetups.strongholdKiller["4"];
        // 	// break;
        // 	case 3:
        // 		setup = CombatSetups.strongholdKiller['3'];
        // 		break;
        // 	case 2:
        // 		setup = CombatSetups.strongholdKiller['2'];
        // 		break;
        // 	case 1:
        // 		setup = CombatSetups.strongholdKiller['1'];
        // 		break;
        // 	case 0:
        // 		return; // Forget it, no need for the lil ones
        // 	default:
        // 		return;// setup = CombatSetups.strongholdKiller["3"];
        // }
        // if (!this.canBoostSetup(setup)) {// TODO: need to move this to the new CombatCreepSetup system
        // 	// Need boosts
        // 	return log.error(`Can't boost stronghold killer in ${this.print}!`);
        // }
        //
        // this.wishlist(1, setup, {});
    }
    resetAttacking(ultimateGoal, maxRange, myCreep) {
        const targetingInfo = this.findAttackingPositionAndTarget(ultimateGoal, 3, myCreep);
        if (targetingInfo) {
            this.target = targetingInfo.target;
            this.memory.attackingPosition =
                targetingInfo.attackPos.readableName;
        }
        return targetingInfo;
    }
    run() {
        // const avoids: RoomPosition[] = [];
        // if (this.directive.room) {
        // 	avoids = avoids.concat(_.flatten(this.directive.room.sources.map(source =>
        // 	source.pos.getPositionsInRange(4, false, false))));
        // 	avoids = avoids.concat(_.flatten(this.directive.room.ramparts.map(ramparts => ramparts.pos.neighbors)));
        // 	if (this.directive.room.mineral) {
        // 		avoids = avoids.concat(this.directive.room.mineral.pos.getPositionsInRange(4, false, false))
        // 	}
        // }
        // avoids.forEach(av => Visualizer.circle(av, 'blue'));
        // log.info(`Running stronghold overlord ${this.print}`);
        this.autoRun(this.strongholdKillers, (killer) => this.handleKiller(killer));
    }
};
StrongholdOverlord.settings = {
    retreatHitsPercent: 0.85,
    reengageHitsPercent: 0.95,
};
StrongholdOverlord = StrongholdOverlord_1 = __decorate$1([
    profile
], StrongholdOverlord);

/**
 * Spawns special-purpose dismantlers for transporting resources to/from a specified target
 */
let DismantleOverlord = class DismantleOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.tasks.dismantle) {
        super(directive, "dismantle", priority);
        this.directive = directive;
        // this.target = target || Game.getObjectById(this.directive.memory.targetId) || undefined;
        this.dismantlers = this.zerg(Roles.dismantler);
    }
    get dismantlerSetup() {
        let setup;
        // TODO: need to move this to the new CombatCreepSetup system
        if (!!this.directive.memory.attackInsteadOfDismantle) {
            setup = CombatSetups.dismantlers.attackDismantlers;
            // } else if (this.canBoostSetup(CombatSetups.dismantlers.boosted_T3)) {
            // setup = CombatSetups.dismantlers.boosted_T3;
            // }
        }
        else {
            setup = CombatSetups.dismantlers.default;
        }
        setup = CombatSetups.dismantlers.default;
        return setup;
    }
    get dismantlersNeeded() {
        var _a;
        // setup.create below can require that if boosting is involved
        if (PHASE !== "run") {
            return this._dismantlersNeeded;
        }
        // Estimate how good the setup is at dismantling
        const dismantlerSetup = this.dismantlerSetup.create(this.colony, true);
        let dismantlingPower;
        if (this.directive.memory.attackInsteadOfDismantle) {
            const attackParts = CombatIntel.getBodyPartPotential(dismantlerSetup.body, "attack", dismantlerSetup.boosts);
            dismantlingPower = attackParts * ATTACK_POWER;
        }
        else {
            const dismantlingParts = CombatIntel.getBodyPartPotential(dismantlerSetup.body, "dismantle", dismantlerSetup.boosts);
            dismantlingPower = dismantlingParts * DISMANTLE_POWER;
        }
        // Calculate total needed amount of dismantling power as (resource amount * trip distance)
        const tripDistance = (_a = Pathing.distance(this.colony.pos, this.directive.pos)) !== null && _a !== void 0 ? _a : 0;
        const dismantleLifetimePower = (CREEP_LIFE_TIME - tripDistance) * dismantlingPower;
        this._dismantlersNeeded = Math.ceil((this.target ? this.target.hits : 50000) / dismantleLifetimePower);
        return this._dismantlersNeeded;
    }
    init() {
        // Spawn a number of dismantlers, up to a max
        const MAX_DISMANTLERS = 2;
        // Calculate number of dismantlers
        const dismantlersNeeded = this.dismantlersNeeded;
        if (dismantlersNeeded === undefined) {
            return;
        }
        if (this.directive.room &&
            this.target &&
            !this.directive.memory.numberSpots) {
            this.directive.getDismantleSpots(this.target.pos);
        }
        const nearbySpots = this.directive.memory.numberSpots != undefined ?
            this.directive.memory.numberSpots
            : 1;
        // needs to be reachable spots
        const numDismantlers = Math.min(nearbySpots, MAX_DISMANTLERS, dismantlersNeeded);
        // Request the dismantlers
        this.wishlist(numDismantlers, this.dismantlerSetup, {
            reassignIdle: true,
        });
    }
    runDismantler(dismantler) {
        var _a, _b, _c;
        if (!dismantler.inSameRoomAs(this.directive) || this.pos.isEdge) {
            const goal = this.target || this.directive;
            this.debug(`${dismantler.print}: moving to ${goal.print}`);
            dismantler.goTo(goal, { pathOpts: { avoidSK: true } });
        }
        else {
            if (!this.target) {
                if (this.directive.memory.targetId) {
                    this.target =
                        Game.getObjectById(this.directive.memory.targetId) ||
                            undefined;
                }
                this.target = this.target || this.directive.getTarget();
                this.debug(`${dismantler.print}: had no target, but now is ${(_a = this.target) === null || _a === void 0 ? void 0 : _a.print}`);
                if (!this.target) {
                    log.error(`No target found for ${this.directive.print}`);
                }
            }
            else {
                const res = !!this.directive.memory.attackInsteadOfDismantle ?
                    dismantler.attack(this.target)
                    : dismantler.dismantle(this.target);
                this.debug(`${dismantler.print}: has target ${(_b = this.target) === null || _b === void 0 ? void 0 : _b.print}, tried to dismantle: ${errorForCode(res)}`);
                if (res === ERR_NOT_IN_RANGE || res === ERR_INVALID_TARGET) {
                    const ret = dismantler.goTo(this.target, {
                        pathOpts: { avoidSK: true },
                    });
                    this.debug(`${dismantler.print}: move to target ${(_c = this.target) === null || _c === void 0 ? void 0 : _c.print}: ${errorForCode(ret)}`);
                }
                else if (res == ERR_NO_BODYPART) {
                    if (dismantler.bodypartCounts[WORK] !== 0) ;
                    dismantler.retire();
                }
            }
        }
    }
    run() {
        // Call this here so that the calculation happens in the RUN phase
        this.dismantlersNeeded;
        this.autoRun(this.dismantlers, (dismantler) => this.runDismantler(dismantler));
    }
};
DismantleOverlord = __decorate$1([
    profile
], DismantleOverlord);

/**
 * Register a target to be dismantled by specific dismantlers
 */
let DirectiveModularDismantle = class DirectiveModularDismantle extends Directive {
    constructor(flag, onlyKillRampart = false, additionalTargets) {
        super(flag);
        this.memory.onlyKillRampart =
            onlyKillRampart || this.flag.name.includes("rampart");
        this.memory.boost =
            this.memory.boost || this.flag.name.includes("boost");
        if (this.flag.room) {
            if (!this.memory.targetId) {
                const target = this.getTarget();
                this.memory.targetId = target ? target.id : undefined;
            }
            this.memory.additionalTargets = additionalTargets;
            if (!this.memory.numberSpots) {
                const spots = this.getDismantleSpots(this.flag.pos);
                if (spots) {
                    this.memory.numberSpots = spots.length;
                }
            }
        }
    }
    spawnMoarOverlords() {
        this.overlords.dismantle = new DismantleOverlord(this);
    }
    getTarget() {
        if (!this.pos.isVisible) {
            return;
        }
        const targetedStructureTypes = this.memory.onlyKillRampart ?
            [STRUCTURE_RAMPART]
            : AttackStructurePriorities;
        const targets = this.pos.lookFor(LOOK_STRUCTURES);
        for (const structureType of targetedStructureTypes) {
            const correctTargets = targets.filter((target) => {
                if (target.structureType == structureType) {
                    return target;
                }
                else if (target.structureType == STRUCTURE_INVADER_CORE) {
                    this.memory.attackInsteadOfDismantle = true;
                    return target;
                }
            });
            if (correctTargets.length > 0) {
                return correctTargets[0];
            }
            // for (const structure of targets) {
            // 	if (structure.structureType == structureType) {
            // 		return structure;
            // 	}
            // 	if (structure.structureType == STRUCTURE_INVADER_CORE) {
            // 		this.memory.attackInsteadOfDismantle = true;
            // 		return structure;
            // 	}
            // }
        }
    }
    getDismantleSpots(target) {
        const nearbySpots = target.availableNeighbors(true);
        if (target.room && target.room.creeps.length > 0) {
            const startingCreep = target.room.creeps.filter((creep) => creep.my)[0];
            if (!!startingCreep) {
                const obstacles = _.filter(target.room.structures, (s) => !s.isWalkable);
                return _.filter(nearbySpots, (spot) => Pathing.isReachable(startingCreep.pos, spot, obstacles));
            }
        }
    }
    init() {
        let hits = "???";
        const target = this.getTarget();
        hits = target ? (target.hits / 1000).toString() + "K" : hits;
        this.alert(`Dismantling ${target === null || target === void 0 ? void 0 : target.pos.printPlain} ${hits}`);
    }
    run() {
        // Remove the directive once structures have been destroyed
        if (this.pos.isVisible && !this.getTarget()) {
            this.remove();
        }
    }
    visuals() {
        Visualizer.marker(this.pos, { color: "yellow" });
    }
};
DirectiveModularDismantle.directiveName = "modularDismantle";
DirectiveModularDismantle.color = COLOR_GREY;
DirectiveModularDismantle.secondaryColor = COLOR_CYAN;
DirectiveModularDismantle = __decorate$1([
    profile
], DirectiveModularDismantle);

var DirectiveStronghold_1;
/**
 * Stronghold directive contributed by @Davaned
 */
let DirectiveStronghold = DirectiveStronghold_1 = class DirectiveStronghold extends Directive {
    constructor(flag) {
        super(flag, (colony) => colony.level >= DirectiveStronghold_1.requiredRCL);
        this.memory.state = this.memory.state || 0;
        if (this.core) {
            this.memory.strongholdLevel = this.core.level;
        }
        this.memory.waveCount = this.memory.waveCount || 0;
    }
    spawnMoarOverlords() {
        // this.overlords.strongholdKiller = new StrongholdOverlord(this);
        if (this.memory.state < 3) ;
        if (this.memory.state > 0 && this.memory.state <= 4) {
            this.overlords.strongholdKiller = new StrongholdOverlord(this);
        }
    }
    get core() {
        if (this.room) {
            return (this._core ||
                this.room
                    .find(FIND_HOSTILE_STRUCTURES)
                    .filter((struct) => struct.structureType == STRUCTURE_INVADER_CORE)[0]);
        }
    }
    getResourcePickupLocations() {
        if (this.room) {
            let returns = [];
            const containers = this.room.containers;
            const ruins = this.room.ruins;
            if (containers) {
                returns = returns.concat(containers.filter((container) => container.pos.getRangeTo(this.pos) < 5 &&
                    container.store.getUsedCapacity() > 0));
            }
            if (ruins) {
                returns = returns.concat(ruins.filter((ruin) => ruin.pos.getRangeTo(this.pos) <= 3 &&
                    ruin.store.getUsedCapacity() > 0));
            }
            return returns;
        }
    }
    manageState() {
        const currentState = this.memory.state;
        if (this.core && this.core.level == 5) ;
        // Starting
        if (this.room && this.core && currentState == 0) {
            // Time to start
            if (!this.core.ticksToDeploy || this.core.ticksToDeploy < 150) {
                this.memory.state = 1;
            }
        }
        else if (this.room && this.memory.state == 0) ;
        else if (this.pos.isVisible &&
            !this.core &&
            this.pos.lookFor(LOOK_RUINS).length > 0) {
            this.memory.state = 4;
            if (Game.time % 50 == 0) {
                // log.notify(`Now looting stronghold ${this.print} in ${this.pos.roomName}`);
                this.handleLooting();
            }
        }
        else if (this.pos.isVisible &&
            !this.core &&
            this.pos.lookFor(LOOK_RUINS).length == 0) {
            // Stronghold is dead
            this.remove();
        }
    }
    handleLooting() {
        const lootSpots = this.getResourcePickupLocations();
        if (lootSpots && lootSpots.length > 0) {
            lootSpots.forEach((spot) => {
                const isRamparted = spot.pos
                    .lookFor(LOOK_STRUCTURES)
                    .filter((struct) => struct.structureType == STRUCTURE_RAMPART).length > 0;
                if (isRamparted) {
                    DirectiveModularDismantle.createIfNotPresent(spot.pos, "pos");
                }
                else {
                    DirectiveHaul.createIfNotPresent(spot.pos, "pos");
                }
            });
            const openingToCore = this.pos.getPositionAtDirection(TOP);
            const isRamparted = openingToCore
                .lookFor(LOOK_STRUCTURES)
                .filter((struct) => struct.structureType == STRUCTURE_RAMPART).length > 0;
            if (isRamparted) {
                DirectiveModularDismantle.createIfNotPresent(openingToCore, "pos");
            }
        }
    }
    checkStrongholdUnitComposition(_defenders) { }
    handleL5() {
        // Well this, this is an L5. Can't deal with it now so just nuke it's ugly mug
        // Wait for deploy
        if (!this.pos.isVisible || !this.core || Game.time % 5 != 0) {
            return;
        }
        if (this.core.ticksToDeploy) {
            log.info(`Stronghold is still deploying! ${this.print}`);
            return;
        }
        // const remainingDuration = this.core.effects.find(effect => effect.effect == EFFECT_COLLAPSE_TIMER);
        const ramparts = this.core.room.ramparts;
        if (ramparts.length == 0 ||
            ramparts[0].ticksToDecay < NUKE_LAND_TIME + 10000) {
            log.info(`Stronghold decaying too soon! ${this.print}`);
            return;
        }
        // if (remainingDuration != undefined && remainingDuration.ticksRemaining < NUKE_LAND_TIME + 10000) {
        // 	// It's too late, don't nuke
        // 	log.info(`Stronghold decaying too soon at ${remainingDuration.ticksRemaining}! ${this.print}`);
        // 	return;
        // }
        const bestTarget = this.pos.getPositionAtDirection(TOP_RIGHT);
        const nukes = this.core.room.find(FIND_NUKES);
        const nukesPrepped = DirectiveNukeTarget.isPresent(this.core.room.name);
        if (nukes.length < 2 && !nukesPrepped) {
            log.alert(`Nuking Stronghold! ${this.print}`);
            const res1 = DirectiveNukeTarget.create(bestTarget, {
                memory: { maxLinearRange: 10, pathNotRequired: true },
            });
            const res2 = DirectiveNukeTarget.create(bestTarget, {
                memory: { maxLinearRange: 10, pathNotRequired: true },
            });
            return typeof res1 === "string" && typeof res2 === "string" ?
                OK
                : NO_ACTION;
        }
        else {
            const strongholdDefenders = this.core.pos.findInRange(FIND_HOSTILE_CREEPS, 4);
            const reinforcers = strongholdDefenders.filter((creep) => creep.body.find((bodyPart) => bodyPart.type == WORK) !=
                undefined);
            if (reinforcers.length >= nukes.length - 1) {
                log.alert(`Launching additional nuke against Stronghold ` +
                    `with reinforcers ${reinforcers.length}! ${this.print}`);
                return DirectiveNukeTarget.create(bestTarget, {
                    memory: { maxLinearRange: 11, pathNotRequired: true },
                });
            }
        }
    }
    manageDirectives() { }
    lootPositions() {
        this.pos.findInRange(FIND_STRUCTURES, 4);
    }
    init() {
        this.alert(`Stronghold ${this.memory.strongholdLevel} is state ${this.memory.state}`);
    }
    run() {
        // Check frequently when almost mined and occasionally otherwise
        if (this.colony.commandCenter && this.colony.commandCenter.observer) {
            this.colony.commandCenter.requestRoomObservation(this.pos.roomName);
        }
        const duration = Game.time - (this.memory["T" /* MEM.TICK */] || Game.time);
        if (duration % 50000 == 0) {
            log.notify(`DirectiveStronghold ${this.print} in ${this.pos.roomName} ` +
                `has been active for ${duration} ticks`);
        }
        this.manageState();
    }
};
DirectiveStronghold.directiveName = "stronghold";
DirectiveStronghold.color = COLOR_ORANGE;
DirectiveStronghold.secondaryColor = COLOR_PURPLE;
DirectiveStronghold.requiredRCL = 7;
DirectiveStronghold = DirectiveStronghold_1 = __decorate$1([
    profile
], DirectiveStronghold);

// export const TERMINAL_STATE_EVACUATE: TerminalState = {
// 	name     : 'evacuate',
// 	type     : 'in/out',
// 	amounts  : {[RESOURCE_ENERGY]: 10000,},
// 	tolerance: 900,
// };
const EVACUATE_STATE_TIMEOUT = 25000;
/**
 * Put the colony's terminal in an evacuation state, which pushes resources out of a room which is about to be breached
 */
let DirectiveTerminalEvacuateState = class DirectiveTerminalEvacuateState extends Directive {
    // colony: Colony | undefined; // this is technically unallowable, but at end of life, colony can be undefined
    constructor(flag) {
        super(flag);
        this.refresh();
    }
    refresh() {
        super.refresh();
        this.colony.state.isEvacuating = true;
    }
    spawnMoarOverlords() { }
    init() {
        if (this.colony && this.colony.terminal) {
            for (const resource of RESOURCES_ALL) {
                if (resource == RESOURCE_ENERGY) {
                    // keep a little energy just to keep the room functioning
                    Overmind.terminalNetwork.exportResource(this.colony, resource, {
                        target: 10000,
                        tolerance: 2000,
                        surplus: 15000,
                    });
                }
                else {
                    Overmind.terminalNetwork.exportResource(this.colony, resource);
                }
            }
        }
        if (Game.time % 25 == 0) {
            log.alert(`${this.pos.print}: evacuation terminal state active!`);
        }
        this.alert("Evacuation terminal state active!", NotifierPriority.High);
    }
    run() {
        // Incubation directive gets removed once the colony has a command center (storage)
        if (!this.colony ||
            !this.colony.terminal ||
            !!this.colony.controller.safeMode ||
            Game.time > (this.memory["T" /* MEM.TICK */] || 0) + EVACUATE_STATE_TIMEOUT) {
            this.remove();
        }
    }
};
DirectiveTerminalEvacuateState.directiveName = "evacuateState";
DirectiveTerminalEvacuateState.color = COLOR_BROWN;
DirectiveTerminalEvacuateState.secondaryColor = COLOR_RED;
DirectiveTerminalEvacuateState = __decorate$1([
    profile
], DirectiveTerminalEvacuateState);

/**
 * Register a directive to mark a room as being forbidden
 */
let DirectiveAvoid = class DirectiveAvoid extends Directive {
    constructor(flag) {
        // It doesn't really matter since this directive acts as a global "do not go there"
        // flag but the directive system *needs* a colony so pick whichever the closest colony is.
        const colony = flag.pos.findClosestByMultiRoomRange(Object.values(Overmind.colonies));
        if (colony) {
            flag.memory["C" /* MEM.COLONY */] = colony.name;
        }
        super(flag);
    }
    spawnMoarOverlords() { }
    init() { }
    run() {
        Overmind.overseer.blockRoom(this.pos.roomName);
    }
    visuals() { }
};
DirectiveAvoid.directiveName = "avoid";
DirectiveAvoid.color = COLOR_GREY;
DirectiveAvoid.secondaryColor = COLOR_GREY;
DirectiveAvoid = __decorate$1([
    profile
], DirectiveAvoid);

const DEPOSIT_COOLDOWN_CUTOFF = 160;
/** Some leeway in how close to death a gatherer has to be before heading back to storage */
const GATHERER_LIFETIME_BUFFER = 50;
const getDefaultGatheringOverlordMemory = () => ({
    active: true,
    lastCooldown: 0,
    harvested: 0,
    loadedDistance: null,
});
/**
 * Spawns miners to harvest from remote, owned, or sourcekeeper energy deposits. Standard mining actions have been
 * heavily CPU-optimized
 */
let GatheringOverlord = class GatheringOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.deposit.gatherer) {
        super(directive, "gather", priority, getDefaultGatheringOverlordMemory);
        this.gatherers = this.zerg(Roles.gatherer);
        if (this.room) {
            this.deposit = this.pos.lookFor(LOOK_DEPOSITS)[0];
        }
        this.updateMemory();
    }
    get deactivationReasons() {
        const reasons = super.deactivationReasons;
        reasons.add(SuspensionReason.overfilled);
        return reasons;
    }
    refresh() {
        if (!this.room && Game.rooms[this.pos.roomName]) {
            // if you just gained vision of this room
            this.deposit = this.pos.lookFor(LOOK_DEPOSITS)[0];
        }
        super.refresh();
        // Refresh your references to the objects
        $.refresh(this, "deposit");
        this.updateMemory();
        this.handleSuspension();
    }
    /**
     * Handles suspending the overlord depending on the state of the colony
     */
    handleSuspension() {
        var _a, _b;
        if (this.isSuspended) {
            return;
        }
        if (this.deposit) {
            const resourceType = (_a = this.deposit) === null || _a === void 0 ? void 0 : _a.depositType;
            const threshold = Overmind.terminalNetwork.thresholds(this.colony, resourceType);
            if (this.colony.assets[resourceType] >=
                ((_b = threshold.surplus) !== null && _b !== void 0 ? _b : Infinity)) {
                log.alert(`${this.colony.print} has too much of ${resourceType}, suspending ${this.print} for ${SUSPENSION_OVERFILL_DEFAULT_DURATION}`);
                this.suspend({
                    reason: SuspensionReason.overfilled,
                    duration: SUSPENSION_OVERFILL_DEFAULT_DURATION,
                });
                return true;
            }
        }
        if (this.colony.state.isOverfilled && !this.isSuspended) {
            log.alert(`${this.colony.print} overfilled, suspending ${this.print} for ${SUSPENSION_OVERFILL_DEFAULT_DURATION}`);
            this.suspend({
                reason: SuspensionReason.overfilled,
                duration: SUSPENSION_OVERFILL_DEFAULT_DURATION,
            });
            return true;
        }
        return false;
    }
    updateMemory() {
        if (!this.deposit) {
            return;
        }
        this.memory.lastCooldown = this.deposit.lastCooldown;
    }
    init() {
        if (this.isDepleted) {
            return;
        }
        let gathererCount = 1;
        if (!this.colony.storage) {
            gathererCount = 0;
        }
        this.wishlist(gathererCount, Setups.gatherer.deposit);
    }
    distanceForLoadedCreep(gatherer) {
        if (this.colony.storage && this.memory.loadedDistance === null) {
            const path = Pathing.findPath(this.pos, this.colony.storage.pos, {
                terrainCosts: getTerrainCosts(gatherer, true),
                ensurePath: true,
            });
            if (path.incomplete) {
                return Infinity;
            }
            this.debug(`distance for creep: ${path.cost}, ${path.path.length}`);
            this.memory.loadedDistance = path.cost;
        }
        return this.memory.loadedDistance;
    }
    get isDepleted() {
        // DEPOSIT_EXHAUST_MULTIPLY * totalHarvested ^ DEPOSIT_EXHAUST_POW;
        // Deposit appears to be gone?
        if (this.room && !this.deposit) {
            return true;
        }
        if (this.memory.lastCooldown > DEPOSIT_COOLDOWN_CUTOFF) {
            return true;
        }
        return false;
    }
    /**
     * Preliminary actions performed before going into the harvest-transfer loop
     *
     * This checks for being in the deposit's room, then sends the creep back to its
     * drop-off point if its getting close to retirement, and retires it once
     */
    prepareActions(gatherer) {
        var _a;
        if (!this.deposit) {
            // We likely don't have visibilty, just move to it
            if (!gatherer.pos.inRangeTo(this.pos, 1) &&
                gatherer.store.getFreeCapacity() !== 0) {
                this.debug(`${gatherer.print} not in range, moving closer to ${this.pos.print}`);
                return this.goToGatheringSite(gatherer, true);
            }
            log.error(`${gatherer.print} has no deposit??`);
            return true;
        }
        const storage = this.colony.storage;
        if (!storage) {
            log.error(`${gatherer.print} cannot find colony ${this.colony.print} storage!`);
            return false;
        }
        // Check our lifetime so we're guaranteed to drop-off properly
        const distance = this.distanceForLoadedCreep(gatherer);
        if (distance === null || !isFinite(distance)) {
            log.error(`${gatherer.print} got invalid distance (${distance}) to drop-off point ${storage.print}!`);
            return false;
        }
        if (((_a = gatherer.ticksToLive) !== null && _a !== void 0 ? _a : Infinity) <=
            distance + GATHERER_LIFETIME_BUFFER) {
            this.debug(`${gatherer.print} is nearing death (${gatherer.ticksToLive}), dropping off at ${storage.print}`);
            gatherer.task = Tasks.transfer(storage, this.deposit.depositType);
            return true;
        }
        if (gatherer.store.getUsedCapacity() !== 0 && this.isDepleted) {
            this.debug(`${gatherer.print} has carry but deposit depleted, dropping off at ${storage.print}`);
            gatherer.task = Tasks.transfer(storage, this.deposit.depositType);
            return true;
        }
        if (gatherer.store.getUsedCapacity() === 0 && this.isDepleted) {
            this.debug(`${gatherer.print} has no carry and deposit depleted, retiring!`);
            gatherer.retire();
            return true;
        }
        return false;
    }
    /**
     * Actions for handling gathering from the deposit
     *
     * This will cause the gatherer to try and harvest from its deposit,
     * potentially sending it to sleep after dropping off its last batch, or move it
     * closer if it's still too far.
     */
    gatherActions(gatherer) {
        // Skip until we see the deposit
        if (!this.deposit) {
            return true;
        }
        // We don't have space, and we're not allowed to drop
        if (gatherer.store.getFreeCapacity() === 0 || this.isDepleted) {
            return false;
        }
        // At this point the miner is in the room so we have vision of the deposit
        // Handle harvesting and moving closer if that fails
        const result = gatherer.harvest(this.deposit);
        this.debug(`${gatherer.print} gathering from ${this.deposit.print}: ${errorForCode(result)}`);
        // The insufficent resources takes precedence over the range check, so we have
        // to make sure we are in range before deciding what to do
        const inRange = gatherer.pos.inRangeTo(this.pos, 1);
        if (result === OK) {
            this.memory.harvested += gatherer.bodypartCounts[WORK];
            // All good!
        }
        else if (inRange &&
            (result === ERR_NOT_ENOUGH_RESOURCES || result === ERR_TIRED)) {
            // Do one last transfer before going to sleep so we're empty when resuming
            const ticksToRegen = this.deposit.cooldown;
            if (ticksToRegen > (gatherer.ticksToLive || Infinity)) {
                this.debug(`${gatherer.print} retiring as death comes (${gatherer.ticksToLive}) and deposit on cooldown (${ticksToRegen})`);
                gatherer.retire();
            }
            else {
                this.debug(`${gatherer.print} sleeping for ${ticksToRegen}`);
                // Sleep until the deposit regens
                gatherer.sleep(Game.time + ticksToRegen);
            }
            return true;
        }
        else if (result === ERR_NOT_IN_RANGE) {
            this.debug(`${gatherer.print} not actually in range, moving closer to ${this.deposit.print}`);
            return this.goToGatheringSite(gatherer);
        }
        else if (result === ERR_NOT_OWNER && Game.time % 20 == 0) {
            log.alert(`${this.print} ${gatherer.print} room is reserved by hostiles!`);
        }
        else if (result === ERR_NO_BODYPART) {
            this.debug(`${gatherer.print} is not fit for duty, retiring`);
            gatherer.retire();
        }
        else {
            log.error(`${gatherer.print}: unhandled gatherer.harvest() exception: ${result}`);
        }
        // We return false here so that we attempt to transfer
        return false;
    }
    /**
     * Handle post-harvest transfer actions
     *
     * This checks on the current storage of the miner (shortcircuiting if it's about to sleep
     * so it doesn't keep energy around) and transfers it over to its preferred location.
     */
    handleTransfer(gatherer) {
        if (gatherer.store.getFreeCapacity() !== 0 && !this.isDepleted) {
            this.debug(`${gatherer.print} not transferring`);
            return false;
        }
        // We're above capacity, haul carry back
        if (this.colony.storage) {
            this.debug(`${gatherer.print} overfilled, dropping into ${this.colony.storage}`);
            gatherer.task = Tasks.transfer(this.colony.storage, this.deposit.depositType);
            return true;
        }
        return false;
    }
    /**
     * Move onto harvesting position or near to source
     */
    goToGatheringSite(gatherer, avoidSK = true) {
        const range = 1;
        const pos = this.pos;
        if (!gatherer.pos.inRangeToPos(pos, range)) {
            gatherer.task = Tasks.goTo(pos, {
                moveOptions: { range: 1, pathOpts: { avoidSK: avoidSK } },
            });
            return true;
        }
        return false;
    }
    handleGatherer(gatherer) {
        // Mining site upgrade & repairs, or better positioning if out of room
        if (this.prepareActions(gatherer)) {
            return;
        }
        // Harvest and potentially sleep
        if (this.gatherActions(gatherer)) {
            return;
        }
        // Transfer resources out to storage
        if (this.handleTransfer(gatherer)) {
            return;
        }
    }
    run() {
        this.autoRun(this.gatherers, (gatherer) => this.handleGatherer(gatherer), (gatherer) => gatherer.avoidDanger({ timer: 10, dropEnergy: true }));
    }
};
GatheringOverlord = __decorate$1([
    profile
], GatheringOverlord);

/**
 * Standard gathering directive. Harvests from a deposit
 */
let DirectiveGather = class DirectiveGather extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
        this.overlords.gather = new GatheringOverlord(this);
    }
    init() { }
    run() {
        if (this.overlords.gather.isDepleted &&
            this.overlords.gather.gatherers.length === 0) {
            log.alert(`${this.print} No more deposit at ${this.pos}, removing!`);
            this.remove();
        }
    }
};
DirectiveGather.directiveName = "gather";
DirectiveGather.color = COLOR_YELLOW;
DirectiveGather.secondaryColor = COLOR_GREEN;
DirectiveGather = __decorate$1([
    profile
], DirectiveGather);

// Jump table to instantiate flags based on type
/**
 * This is the initializer for directives, which maps flags by their color code to the corresponding directive
 */
function DirectiveWrapper(flag) {
    switch (flag.color) {
        // Colony directives ===========================================================================================
        case COLOR_PURPLE:
            switch (flag.secondaryColor) {
                case COLOR_PURPLE:
                    return new DirectiveOutpost(flag);
                case COLOR_YELLOW:
                    return new DirectiveSKOutpost(flag);
                case COLOR_WHITE:
                    return new DirectiveIncubate(flag);
                case COLOR_GREY:
                    return new DirectiveColonize(flag);
                case COLOR_ORANGE:
                    return new DirectiveClearRoom(flag);
                case COLOR_RED:
                    return new DirectivePoisonRoom(flag);
                case COLOR_CYAN:
                    return new DirectivePrioritize(flag);
            }
            break;
        // Offensive combat directives =================================================================================
        case COLOR_RED:
            switch (flag.secondaryColor) {
                case COLOR_RED:
                    return new DirectiveSwarmDestroy(flag);
                case COLOR_CYAN:
                    return new DirectivePairDestroy(flag);
                case COLOR_PURPLE:
                    return new DirectiveControllerAttack(flag);
                case COLOR_WHITE:
                    return new DirectiveHarass(flag);
            }
            break;
        // Defensive combat directives =================================================================================
        case COLOR_BLUE:
            switch (flag.secondaryColor) {
                case COLOR_BLUE:
                    return new DirectiveGuard(flag);
                case COLOR_RED:
                    return new DirectiveOutpostDefense(flag);
                case COLOR_PURPLE:
                    return new DirectiveInvasionDefense(flag);
            }
            break;
        // Situational directives ======================================================================================
        case COLOR_ORANGE:
            switch (flag.secondaryColor) {
                case COLOR_ORANGE:
                    return new DirectiveBootstrap(flag);
                case COLOR_BLUE:
                    return new DirectiveNukeResponse(flag);
                case COLOR_RED:
                    return new DirectiveNukeTarget(flag);
                case COLOR_PURPLE:
                    return new DirectiveStronghold(flag);
                case COLOR_WHITE:
                    return new DirectivePortalScout(flag);
                case COLOR_YELLOW:
                    return new DirectiveRemoteUpgrade(flag);
            }
            break;
        // Resource directives =========================================================================================
        case COLOR_YELLOW:
            switch (flag.secondaryColor) {
                case COLOR_YELLOW:
                    return new DirectiveHarvest(flag);
                case COLOR_CYAN:
                    return new DirectiveExtract(flag);
                case COLOR_BLUE:
                    return new DirectiveHaul(flag);
                case COLOR_RED:
                    return new DirectivePowerMine(flag);
                case COLOR_GREEN:
                    return new DirectiveGather(flag);
            }
            break;
        // Terminal state directives ===================================================================================
        case COLOR_BROWN:
            switch (flag.secondaryColor) {
                case COLOR_RED:
                    return new DirectiveTerminalEvacuateState(flag);
                // case COLOR_ORANGE:
                // 	return new DirectiveTerminalEmergencyState(flag);
                case COLOR_YELLOW:
                    return new DirectiveTerminalRebuildState(flag);
            }
            break;
        // Targeting colors ============================================================================================
        case COLOR_GREY:
            switch (flag.secondaryColor) {
                case COLOR_ORANGE:
                    return new DirectiveTargetSiege(flag);
                case COLOR_YELLOW:
                    return new DirectiveDismantle(flag);
                case COLOR_CYAN:
                    return new DirectiveModularDismantle(flag);
                case COLOR_GREY:
                    return new DirectiveAvoid(flag);
            }
            break;
        // Room planning directives ====================================================================================
        case COLOR_WHITE:
            switch (flag.secondaryColor) {
                case COLOR_GREEN:
                    return new DirectiveRPHatchery(flag);
                case COLOR_BLUE:
                    return new DirectiveRPCommandCenter(flag);
                case COLOR_RED:
                    return new DirectiveRPBunker(flag);
            }
            break;
        // Power directives ====================================================================================
        case COLOR_CYAN:
            switch (flag.secondaryColor) {
                case COLOR_PURPLE:
                    return new DirectiveBaseOperator(flag);
            }
            break;
    }
}

var TerminalNetwork_1;
const getDefaultTerminalNetworkMemory = () => ({});
const getDefaultTerminalNetworkStats = () => ({
    assets: {},
    fractionalEnergyTransferCost: 0.25, // some believable initial value
    incomingResources: {},
    outgoingResources: {},
    sendCosts: {},
    terminals: {
        avgCooldown: {},
        overload: {},
    },
    states: {
        activeProviders: {},
        passiveProviders: {},
        equilibriumNodes: {},
        passiveRequestors: {},
        activeRequestors: {},
    },
});
const DEFAULT_TARGET = TERMINAL_NETWORK_DEFAULT_TARGET;
const DEFAULT_TOLERANCE = TERMINAL_NETWORK_DEFAULT_TOLERANCE;
// Contains threshold values to use for all non-execeptional colonies so we don't recompute this every time
const ALL_THRESHOLDS = _.object(RESOURCES_ALL_EXCEPT_ENERGY, _.map(RESOURCES_ALL_EXCEPT_ENERGY, (res) => getThresholds(res, TERMINAL_NETWORK_THRESHOLDS)));
// The order in which resources are handled within the network
const _resourcePrioritiesOrdered = [
    ...BOOSTS_T3,
    RESOURCE_OPS,
    ...BOOSTS_T2,
    ...BOOSTS_T1,
    ...INTERMEDIATE_REACTANTS,
    ...BASE_RESOURCES,
    RESOURCE_POWER,
    RESOURCE_ENERGY,
];
const _resourcePrioritiesEverythingElse = _.filter(RESOURCES_ALL, (res) => !_resourcePrioritiesOrdered.includes(res));
const RESOURCE_EXCHANGE_ORDER = [
    ..._resourcePrioritiesOrdered,
    ..._resourcePrioritiesEverythingElse,
];
const _resourceExchangePrioritiesLookup = _.zipObject(RESOURCE_EXCHANGE_ORDER, _.map(RESOURCE_EXCHANGE_ORDER, (res) => _.indexOf(RESOURCE_EXCHANGE_ORDER, res)));
_.zipObject(RESOURCES_ALL, _.map(RESOURCES_ALL, () => []));
/**
 * The TerminalNetwork manages internal resource transfers between owned colonies and tries to get resources where
 * they need to be as fast as possible. This second version of the TerminalNetwork is inspired by Factorio's logistics
 * system. (Factorio is a fantastic game if you haven't played it but it's literally the video game equivalent of
 * Mexican black tar heroin and will consume your life if you let it, kind of like Screeps...) It works like this:
 * - Each colony with a terminal can be in one of 5 states for each resource depending on how much of the resource
 *   it has and on other conditions:
 *   - Active providers will actively push resources from the room into other rooms in the terminal network
 *     which are requestors or will sell the resource on the market no receiving rooms are available
 *   - Passive providers will place their resources at the disposal of the terminal network
 *   - Equilibrium nodes are rooms which are near their desired amount for the resource and prefer to stay there
 *   - Passive requestors are rooms which have less than their desired amount of the resource but which don't have an
 *     immediate need for it; they will request resources from activeProviders and passiveProviders
 *   - Active requestors are rooms which have an immediate need for and insufficient amounts of a resource; they will
 *     request resources from any room which is not also an activeRequestor
 * - The state of each room is determined by a `Thresholds` object, which has `target`, `tolerance`, and (posisbly
 *   undefined) `surplus` properties. Conditions for each state are based on `amount` of resource in a colony:
 *   - Active provider: `amount > surplus` (if defined) or `amont > target + tolerance` and room is near capacity
 *   - Passive provider: `surplus >= amount > target + tolerance`
 *   - Equilibrium: `target + tolerance >= amount >= target - tolerance`
 *   - Passive requestor: `target - tolerance > amount`
 *   - Active requestor: colonies can only be placed in this state by an active call to
 *     `TerminalNetwork.requestResource()` while `target > amount`
 * - To determine which room to request/provide resources from/to, a heuristic is used which tries to minimize
 *   transaction cost while accounting for:
 *   - If a terminal has a high output load (often on cooldown), receivers will de-prioritize it
 * 	 - If a terminal is far away, receivers will wait longer to find a less expensive sender
 * 	 - Bigger transactions with higher costs will wait longer for a closer colony, while smaller transactions are
 * 	   less picky
 */
let TerminalNetwork$1 = TerminalNetwork_1 = class TerminalNetwork {
    constructor() {
        this.name = "TerminalNetwork";
        this.colonies = [];
        this.refresh();
    }
    /**
     * Clears all the threshold and request data from the previous tick
     */
    refresh() {
        this.colonyThresholds = {};
        this.colonyLockedAmounts = {};
        this._energyThresholds = undefined;
        this.colonyStates = {};
        this._colonyStatesAssigned = false;
        this.activeProviders = {}; // _.clone(EMPTY_COLONY_TIER);
        this.passiveProviders = {}; // _.clone(EMPTY_COLONY_TIER);
        this.equilibriumNodes = {}; // _.clone(EMPTY_COLONY_TIER);
        this.passiveRequestors = {}; // _.clone(EMPTY_COLONY_TIER);
        this.activeRequestors = {}; // _.clone(EMPTY_COLONY_TIER);
        this.assets = {}; // populated when getAssets() is called in init()
        this.terminalOverload = {};
        this.notifications = [];
        this.memory = Mem.wrap(Memory.Overmind, "terminalNetwork", getDefaultTerminalNetworkMemory);
        this.stats = Mem.wrap(Memory.stats.persistent, "terminalNetwork", getDefaultTerminalNetworkStats);
    }
    debug(...args) {
        if (this.memory.debug) {
            log.alert("TerminalNetwork:", ...args);
        }
    }
    /**
     * Adds a colony to the terminal network; should be populated following constructor() phase
     */
    addColony(colony) {
        if (!(colony.terminal && colony.terminal.my && colony.level >= 6)) {
            log.error(`Cannot add colony ${colony.print} to terminal network!`);
        }
        else {
            this.colonies.push(colony); // add colony to list
        }
    }
    getAssets() {
        if (_.isEmpty(this.assets)) {
            this.assets = mergeSum(..._.map(this.colonies, (colony) => colony.assets));
        }
        return this.assets;
    }
    notify(msg) {
        this.notifications.push(bullet + msg);
    }
    /**
     * Transfer resources from one terminal to another, logging the results
     */
    transfer(sender, receiver, resourceType, amount, description) {
        Game.market.calcTransactionCost(amount, sender.room.name, receiver.room.name);
        const response = sender.send(resourceType, amount, receiver.room.name, description);
        if (response == OK) {
            let msg;
            const floorAmt = Math.floor(amount);
            if (description == "provide") {
                msg =
                    `${printRoomName(sender.room.name, true)} ${rightArrow} ${floorAmt} ${resourceType} ` +
                        `${rightArrow} ${printRoomName(receiver.room.name, true)} `;
            }
            else if (description == "request") {
                msg =
                    `${printRoomName(receiver.room.name, true)} ${leftArrow} ${floorAmt} ${resourceType} ` +
                        `${leftArrow} ${printRoomName(sender.room.name, true)} `;
            }
            else {
                msg =
                    `${printRoomName(sender.room.name, true)} ${rightArrow} ${floorAmt} ${resourceType} ` +
                        `${rightArrow} ${printRoomName(receiver.room.name, true)} `;
                if (description) {
                    msg += `(${description})`;
                }
            }
            this.notify(msg);
            // this.logTransfer(resourceType, amount, sender.room.name, receiver.room.name);
        }
        else {
            log.warning(`Could not send ${amount} ${resourceType} from ${sender.room.print} to ` +
                `${receiver.room.print}! Response: ${response}`);
            if (response == ERR_NOT_ENOUGH_RESOURCES || response == ERR_TIRED) {
                this.terminalOverload[sender.room.name] = true;
            }
        }
        return response;
    }
    /**
     * Computes the dynamically-changing energy thresholds object
     */
    getEnergyThresholds() {
        if (!this._energyThresholds) {
            const nonExceptionalColonies = _.filter(this.colonies, (colony) => colony.storage &&
                !(this.colonyThresholds[colony.name] &&
                    this.colonyThresholds[colony.name][RESOURCE_ENERGY]));
            const avgEnergy = _.sum(nonExceptionalColonies, (colony) => colony.assets.energy) / nonExceptionalColonies.length;
            this._energyThresholds = {
                target: avgEnergy,
                surplus: TERMINAL_NETWORK_ENERGY_SURPLUS,
                tolerance: avgEnergy / 5,
            };
        }
        return this._energyThresholds;
    }
    /**
     * Compute the default state of a colony for a given resource
     */
    getColonyState(colony, resource) {
        const { target, surplus, tolerance } = this.thresholds(colony, resource);
        const amount = colony.assets[resource];
        // Active provider if the room is above surplus amount or if the room is above target+tolerance and near full
        if ((surplus != undefined && amount > surplus) ||
            (amount > target + tolerance &&
                ResourceManager.getRemainingSpace(colony) < 0)) {
            return 5 /* TN_STATE.activeProvider */;
        }
        // Passive provider if the room has below surplus but above target+tolerance
        if ((surplus != undefined ? surplus : Infinity) >= amount &&
            amount > target + tolerance) {
            return 4 /* TN_STATE.passiveProvider */;
        }
        // Equilibrium state if room has within +/- tolerance of target amount
        if (target + tolerance >= amount &&
            amount >= Math.max(target - tolerance, 0)) {
            return 3 /* TN_STATE.equilibrium */;
        }
        // Passive requestor if room has below target-tolerance
        if (amount < Math.max(target - tolerance, 0)) {
            return 2 /* TN_STATE.passiveRequestor */;
        }
        // Active requestor if room has below target amount and there is an immediate need for the resource
        // This can only be triggered with an override from another part of the program
        // Should never reach here
        log.error(`Shouldn't reach this part of TerminalNetwork code!`);
        return 0 /* TN_STATE.error */;
    }
    /**
     * Gets the thresholds for a given resource for a specific colony
     */
    thresholds(colony, resource) {
        if (this.colonyThresholds[colony.name] &&
            this.colonyThresholds[colony.name][resource]) {
            return this.colonyThresholds[colony.name][resource];
        }
        else {
            if (resource == RESOURCE_ENERGY) {
                return this.getEnergyThresholds();
            }
            else {
                return ALL_THRESHOLDS[resource];
            }
        }
    }
    /**
     * Gets the locked amount for a given resource for a specific colony
     */
    lockedAmount(colony, resource) {
        if (this.colonyLockedAmounts[colony.name] &&
            this.colonyLockedAmounts[colony.name][resource]) {
            return this.colonyLockedAmounts[colony.name][resource];
        }
        else {
            return 0;
        }
    }
    /**
     * Request resources from the terminal network, placing the colony in an activeRequestor state; amount is the
     * quantity of TOTAL resources you need, including requestor.assets!
     */
    requestResource(requestor, resource, totalAmount, tolerance = 0) {
        var _a;
        var _b, _c;
        if (PHASE != "init") {
            log.error(`TerminalNetwork.requestResource must be called in the init() phase!`);
        }
        // If you already have enough resources, you shouldn't have made the request so throw an error message
        if (requestor.assets[resource] >= totalAmount) {
            log.error(`TerminalNetwork.requestResource() called for ${requestor.print} requesting ${totalAmount} ` +
                `of ${resource}, but colony already has ${requestor.assets[resource]} amount!`);
            return;
        }
        (_a = (_b = this.colonyThresholds)[_c = requestor.name]) !== null && _a !== void 0 ? _a : (_b[_c] = {});
        // If you already requested the resource via a different method, throw a warning and override
        if (this.colonyThresholds[requestor.name][resource] != undefined) {
            log.warning(`TerminalNetwork.colonyThresholds[${requestor.name}][${resource}] already set to:` +
                `${this.colonyThresholds[requestor.name][resource]}; overriding previous request!`);
        }
        // Set the thresholds and set state to activeRequestor
        this.colonyThresholds[requestor.name][resource] = {
            target: totalAmount,
            surplus: undefined,
            tolerance: tolerance,
        };
        this.colonyStates[requestor.name][resource] = 1 /* TN_STATE.activeRequestor */;
    }
    /**
     * Locks a given amount of resources from being withdrawn by the terminal network. Useful if you have obtained the
     * resources for something and want to keep them around until you can use them (for example, boosting a creep).
     * Subsequent calls to this method will increase the amount of the locked resource.
     */
    lockResource(requestor, resource, lockAmount) {
        var _a;
        var _b, _c;
        if (PHASE != "init") {
            log.error(`TerminalNetwork.lockResource() must be called in the init() phase!`);
        }
        (_a = (_b = this.colonyLockedAmounts)[_c = requestor.name]) !== null && _a !== void 0 ? _a : (_b[_c] = {});
        const alreadyLockedAmount = this.colonyLockedAmounts[requestor.name][resource] || 0;
        const newLockAmount = alreadyLockedAmount + lockAmount;
        // Need to have the resources to lock them
        if (requestor.assets[resource] < newLockAmount) ;
        // Lock this amount of resources
        this.colonyLockedAmounts[requestor.name][resource] = newLockAmount;
    }
    /**
     * Requests that the colony export (and not import) a resource, offloading it through the terminal network or
     * selling it on the market. If thresholds is specified, the room will actively export thresholds.surplus amount of
     * resource and will maintain target +/- tolerance amount in the room (so in/out, not necessarily a strict export)
     */
    exportResource(provider, resource, threshold = TERMINAL_NETWORK_THRESHOLDS
        .dontWant) {
        var _a;
        var _b, _c;
        if (PHASE != "init") {
            log.error(`TerminalNetwork.exportResource must be called in the init() phase!`);
        }
        // If you already requested the resource via a different method, throw a warning and override
        if (this.colonyThresholds[provider.name] &&
            this.colonyThresholds[provider.name][resource] != undefined) {
            log.warning(`TerminalNetwork.colonyThresholds[${provider.name}][${resource}] already set to:` +
                `${this.colonyThresholds[provider.name][resource]}; overriding previous export!`);
        }
        // Set the thresholds, but in this case we don't set the state to activeProvider - this is automatically done
        (_a = (_b = this.colonyThresholds)[_c = provider.name]) !== null && _a !== void 0 ? _a : (_b[_c] = {});
        this.colonyThresholds[provider.name][resource] = threshold;
    }
    /**
     * Returns whether the terminal network would be able to fulfill an activeRequest for an amount of resource.
     *
     * Performs a dry run of the request handling logic and returns true if the transfer would have been made.
     */
    canObtainResource(requestor, resource, totalAmount) {
        if (PHASE != "run") {
            // need to have all the information from init() about colony states first
            log.trace(new Error(`TerminalNetwork.canObtainResource() must be called in the run() phase!`));
            return false;
        }
        const requestAmount = totalAmount - requestor.assets[resource];
        if (requestAmount <= 0) {
            log.error(`TerminalNetwork.canObtainResource() called when you already have the resource! :thonk:`);
            return true;
        }
        const opts = {
            allowDivvying: false,
            takeFromColoniesBelowTarget: false,
            requestType: "active",
            allowMarketBuy: Game.market.credits >
                TraderJoe.settings.market.credits.canBuyAbove,
            receiveOnlyOncePerTick: false,
            complainIfUnfulfilled: true,
            dryRun: true,
        };
        this.assignColonyStates(); // this is cached once computed so it's OK to call this many times in a tick
        const prioritizedPartners = [
            this.activeProviders,
            this.passiveProviders,
            this.equilibriumNodes,
            this.passiveRequestors,
        ];
        const partnerSets = _.map(prioritizedPartners, (partners) => partners[resource] || []);
        // Do a dry run of handling the request instance
        const success = this.handleRequestInstance(requestor, resource, requestAmount, partnerSets, opts);
        return success;
    }
    init() {
        // Update assets
        this.assets = this.getAssets();
        // Clear out the colony states so they can be refreshed during Colony.init(), which is called after this
        for (const colony of this.colonies) {
            this.colonyStates[colony.name] = {};
        }
    }
    /**
     * Compute which colonies should act as active providers, passive providers, and requestors
     */
    assignColonyStates() {
        var _a, _b, _c, _d, _e, _f, _g;
        var _h, _j, _k, _l, _m, _o, _p, _q;
        if (this._colonyStatesAssigned) {
            return;
        }
        // Assign a state to each colony whose state isn't already specified
        for (const colony of this.colonies) {
            for (const resource of RESOURCE_EXCHANGE_ORDER) {
                (_a = (_h = this.colonyThresholds)[_j = colony.name]) !== null && _a !== void 0 ? _a : (_h[_j] = {});
                (_b = (_k = this.colonyStates[colony.name])[resource]) !== null && _b !== void 0 ? _b : (_k[resource] = this.getColonyState(colony, resource));
                // Populate the entry in the tier lists
                switch (this.colonyStates[colony.name][resource]) {
                    case 5 /* TN_STATE.activeProvider */:
                        (_c = (_l = this.activeProviders)[resource]) !== null && _c !== void 0 ? _c : (_l[resource] = []);
                        this.activeProviders[resource].push(colony);
                        break;
                    case 4 /* TN_STATE.passiveProvider */:
                        (_d = (_m = this.passiveProviders)[resource]) !== null && _d !== void 0 ? _d : (_m[resource] = []);
                        this.passiveProviders[resource].push(colony);
                        break;
                    case 3 /* TN_STATE.equilibrium */:
                        (_e = (_o = this.equilibriumNodes)[resource]) !== null && _e !== void 0 ? _e : (_o[resource] = []);
                        this.equilibriumNodes[resource].push(colony);
                        break;
                    case 2 /* TN_STATE.passiveRequestor */:
                        (_f = (_p = this.passiveRequestors)[resource]) !== null && _f !== void 0 ? _f : (_p[resource] = []);
                        this.passiveRequestors[resource].push(colony);
                        break;
                    case 1 /* TN_STATE.activeRequestor */:
                        (_g = (_q = this.activeRequestors)[resource]) !== null && _g !== void 0 ? _g : (_q[resource] = []);
                        this.activeRequestors[resource].push(colony);
                        break;
                    case 0 /* TN_STATE.error */:
                        log.error(`TN_STATE.error type encountered!`);
                        break;
                    default:
                        log.error(`Should not be here! colony state is ${this.colonyStates[colony.name][resource]}`);
                        break;
                }
            }
        }
        // Shuffle all the colony orders in each tier - this helps prevent jams
        _.forEach(this.activeRequestors, (cols, resource) => (this.activeRequestors[resource] = _.shuffle(cols)));
        _.forEach(this.passiveRequestors, (cols, resource) => (this.passiveRequestors[resource] = _.shuffle(cols)));
        _.forEach(this.equilibriumNodes, (cols, resource) => (this.equilibriumNodes[resource] = _.shuffle(cols)));
        _.forEach(this.passiveProviders, (cols, resource) => (this.passiveProviders[resource] = _.shuffle(cols)));
        _.forEach(this.activeProviders, (cols, resource) => (this.activeProviders[resource] = _.shuffle(cols)));
        // Mark the states as being assigned
        this._colonyStatesAssigned = true;
    }
    /**
     * Gets the best partner colony to send requested resources from based on a heuristic that minimizes transaction
     * cost while accounting for:
     * 1. If a terminal has a high output load (often on cooldown), receivers will de-prioritize it (avgCooldown term)
     * 2. If a terminal is far away, receivers will wait longer to find a less expensive sender (K term)
     * 3. Bigger transactions with higher costs will wait longer for a closer colony, while smaller transactions
     *    are less picky (BIG_COST term)
     */
    getBestSenderColony(resource, amount, colony, partners) {
        if (partners.length == 0) {
            log.error(`Passed an empty list of sender partners!`);
        }
        const K = 2; // these constants might need tuning
        const BIG_COST = 2000; // size of a typical large transaction cost
        return maxBy(partners, (partner) => {
            const sendCost = Game.market.calcTransactionCost(amount, partner.name, colony.name);
            const avgCooldown = this.stats.terminals.avgCooldown[partner.name] || 0;
            const score = -1 * sendCost * (K + sendCost / BIG_COST + avgCooldown);
            return score;
        });
    }
    /**
     * Handle a request instance, trying to obtain the desired resource
     */
    handleRequestInstance(colony, resource, requestAmount, partnerSets, opts) {
        const originalRequestAmount = requestAmount;
        if (resource == RESOURCE_ENERGY) {
            requestAmount = Math.min(requestAmount, TerminalNetwork_1.settings.maxEnergySendAmount);
        }
        else {
            requestAmount = Math.min(requestAmount, TerminalNetwork_1.settings.maxResourceSendAmount);
        }
        // Try to find the best single colony to obtain resources from
        for (const partners of partnerSets) {
            // First try to find a partner that has more free resources than (target + request)
            let validPartners = _.filter(partners, (partner) => partner.assets[resource] -
                requestAmount -
                this.lockedAmount(partner, resource) >=
                this.thresholds(partner, resource).target);
            // If that doesn't work, try to find a partner where assets - request - locked > target - tolerance
            if (validPartners.length == 0) {
                validPartners = _.filter(partners, (partner) => partner.assets[resource] -
                    requestAmount -
                    this.lockedAmount(partner, resource) >=
                    this.thresholds(partner, resource).target -
                        this.thresholds(colony, resource).tolerance);
            }
            // If that doesn't work, try to find a partner where assets - request - locked > 0
            if (validPartners.length == 0 && opts.takeFromColoniesBelowTarget) {
                validPartners = _.filter(partners, (partner) => partner.assets[resource] -
                    requestAmount -
                    this.lockedAmount(partner, resource) >
                    0);
            }
            if (validPartners.length > 0) {
                const bestPartner = this.getBestSenderColony(resource, requestAmount, colony, validPartners);
                const lockedAmount = this.lockedAmount(bestPartner, resource);
                const thresholds = this.thresholds(bestPartner, resource);
                const sendTerm = bestPartner.terminal;
                const recvTerm = colony.terminal;
                const sendAmount = opts.takeFromColoniesBelowTarget ?
                    Math.min(requestAmount, sendTerm.store[resource], bestPartner.assets[resource] - lockedAmount)
                    : Math.min(requestAmount, sendTerm.store[resource], bestPartner.assets[resource] -
                        (thresholds.target - thresholds.tolerance) -
                        lockedAmount);
                if (sendAmount <= 0) {
                    log.error(`Request from ${colony.print} to ${bestPartner.print} for ${sendAmount} ${resource}`);
                    return false;
                }
                // Send the resources or mark the terminal as overloaded for this tick
                if (!opts.dryRun) {
                    if (sendTerm.isReady) {
                        this.transfer(sendTerm, recvTerm, resource, sendAmount, `request`);
                    }
                    else {
                        this.terminalOverload[sendTerm.room.name] = true;
                    }
                }
                return true;
            }
        }
        // If no colony is sufficient to send you the resources, try to divvy it up among several colonies
        if (opts.allowDivvying) {
            const MAX_SEND_REQUESTS = 3;
            const allPartners = _.flatten(partnerSets);
            // find all colonies that have more than target amt of resource and pick 3 with the most amt
            let validPartners = _(allPartners)
                .filter((partner) => partner.assets[resource] -
                this.lockedAmount(partner, resource) >
                this.thresholds(partner, resource).target)
                .sortBy((partner) => partner.assets[resource] -
                this.lockedAmount(partner, resource) -
                this.thresholds(partner, resource).target)
                .take(MAX_SEND_REQUESTS)
                .run();
            // If still no partners and this is a super urgent request, steal from colonies that have below target amt
            if (validPartners.length == 0 && opts.takeFromColoniesBelowTarget) {
                validPartners = _(allPartners)
                    .filter((partner) => partner.assets[resource] -
                    this.lockedAmount(partner, resource) >
                    0)
                    .sortBy((partner) => partner.assets[resource] -
                    this.lockedAmount(partner, resource))
                    .take(MAX_SEND_REQUESTS)
                    .run();
            }
            // request bits of the amount until you have enough
            let remainingAmount = requestAmount;
            let sentSome = false;
            for (const partner of validPartners) {
                const sendTerm = partner.terminal;
                const recvTerm = colony.terminal;
                const amountPartnerCanSend = opts.takeFromColoniesBelowTarget ?
                    sendTerm.store[resource] -
                        this.lockedAmount(partner, resource)
                    : sendTerm.store[resource] -
                        this.lockedAmount(partner, resource) -
                        this.thresholds(partner, resource).target;
                let sendAmount = Math.min(amountPartnerCanSend, remainingAmount);
                if (resource == RESOURCE_ENERGY) {
                    // if we're sending energy, make sure we have amount + cost
                    const sendCost = Game.market.calcTransactionCost(sendAmount, colony.name, partner.name);
                    if (sendAmount + sendCost > sendTerm.store[resource]) {
                        sendAmount -= sendCost;
                    }
                }
                // Send the resources or mark the terminal as overloaded for this tick
                if (opts.dryRun) {
                    remainingAmount -= sendAmount;
                }
                else {
                    if (sendTerm.isReady) {
                        const ret = this.transfer(sendTerm, recvTerm, resource, sendAmount, `request`);
                        if (ret == OK) {
                            remainingAmount -= sendAmount;
                            sentSome = true;
                        }
                        else {
                            this.terminalOverload[sendTerm.room.name] = true;
                        }
                    }
                    else {
                        this.terminalOverload[sendTerm.room.name] = true;
                    }
                }
                // If you've obtained what you need from the assortment of colonies, we're done
                if (remainingAmount <= 0) {
                    return true;
                }
            }
            if (sentSome) {
                // if you were able to get at least some of resource by divvying, don't proceed to market
                return true;
            }
        }
        // If you are allowed to buy it on the market, try to do so
        if (opts.allowMarketBuy) {
            // Special cases if it's energy or boosts since these have higher buy thresholds
            if (resource == RESOURCE_ENERGY &&
                Game.market.credits <
                    TraderJoe.settings.market.credits.canBuyEnergyAbove) {
                return false;
            }
            if (Abathur$1.isIntermediateReactant(resource) ||
                resource == RESOURCE_GHODIUM) {
                return false; // just make these yourself, you lazy fuck
            }
            if (Abathur$1.isBoost(resource)) {
                if (Game.market.credits <
                    TraderJoe.settings.market.credits.canBuyBoostsAbove) {
                    return false;
                }
                const boostTier = Abathur$1.getBoostTier(resource);
                if (boostTier != "T3" &&
                    !TraderJoe.settings.market.resources.allowBuyT1T2boosts) {
                    return false;
                }
            }
            if (opts.requestType == "passive" &&
                !Abathur$1.isBaseMineral(resource)) {
                return false; // can only buy base minerals for passive requests
            }
            // If you can still buy the thing, then buy then thing!
            const buyOpts = { dryRun: opts.dryRun };
            if (Abathur$1.isBaseMineral(resource) &&
                colony.assets[resource] <
                    TerminalNetwork_1.settings.buyBaseMineralsDirectUnder) {
                if (opts.requestType == "active") {
                    buyOpts.preferDirect = true;
                    buyOpts.ignorePriceChecksForDirect = true;
                    buyOpts.ignoreMinAmounts = true;
                }
                else if (opts.requestType == "passive") {
                    buyOpts.preferDirect = false; // passive requests should only place buy orders
                    buyOpts.ignoreMinAmounts = false;
                }
                else {
                    log.error(`Need to specify active or passive request type request for ${resource}!`);
                }
            }
            const ret = Overmind.tradeNetwork.buy(colony.terminal, resource, originalRequestAmount, buyOpts);
            this.debug(`Buying ${requestAmount} ${resource} for ${colony.print} with opts=${JSON.stringify(buyOpts)} from trade network (${ret})`);
            if (ret >= 0) {
                return true;
            }
        }
        // Can't handle this request instance!
        return false;
    }
    handleProvideInstance(colony, resource, provideAmount, partnerSets, opts) {
        // Sometimes we don't necessarily want to push to other rooms - we usually do, but not always
        if (opts.allowPushToOtherRooms) {
            // Compute the amount we want to send
            let sendAmount = provideAmount;
            if (colony.state.isEvacuating) {
                sendAmount = Math.min(provideAmount, TerminalNetwork_1.settings.maxEvacuateSendAmount);
            }
            else {
                if (resource == RESOURCE_ENERGY) {
                    sendAmount = Math.min(provideAmount, TerminalNetwork_1.settings.maxEnergySendAmount);
                }
                else {
                    sendAmount = Math.min(provideAmount, TerminalNetwork_1.settings.maxResourceSendAmount);
                }
            }
            // Try to find the best single colony to send resources to
            for (const partners of partnerSets) {
                // First try to find a partner that has less resources than target - sendAmount and can hold more stuff
                let validPartners = _.filter(partners, (partner) => partner.assets[resource] + sendAmount <=
                    this.thresholds(partner, resource).target &&
                    ResourceManager.getRemainingSpace(partner) -
                        sendAmount >=
                        0);
                // If that doesn't work, tfind partner where assets + sendAmount < target + tolerance and has space
                if (validPartners.length == 0) {
                    validPartners = _.filter(partners, (partner) => partner.assets[resource] + sendAmount <=
                        this.thresholds(partner, resource).target +
                            this.thresholds(colony, resource)
                                .tolerance &&
                        ResourceManager.getRemainingSpace(partner) -
                            sendAmount >=
                            0);
                }
                // If that doesn't work, just try to find any room with space that won't become an activeProvider
                if (validPartners.length == 0) {
                    validPartners = _.filter(partners, (partner) => {
                        if (ResourceManager.getRemainingSpace(partner) -
                            sendAmount <
                            0) {
                            return false;
                        }
                        const { target, surplus, tolerance } = this.thresholds(partner, resource);
                        if (surplus != undefined) {
                            return (partner.assets[resource] + sendAmount < surplus);
                        }
                        else {
                            return (partner.assets[resource] + sendAmount <=
                                target + tolerance);
                        }
                    });
                }
                // If you've found partners, send it to the best one
                if (validPartners.length > 0) {
                    const bestPartner = minBy(validPartners, (partner) => Game.market.calcTransactionCost(sendAmount, colony.name, partner.name));
                    const sendTerm = colony.terminal;
                    const recvTerm = bestPartner.terminal;
                    sendAmount = Math.min(sendAmount, sendTerm.store[resource] -
                        this.lockedAmount(colony, resource));
                    if (resource == RESOURCE_ENERGY) {
                        // if we're sending energy, make sure we have amount + cost
                        const sendCost = Game.market.calcTransactionCost(sendAmount, colony.name, bestPartner.name);
                        if (sendAmount + sendCost > sendTerm.store[resource]) {
                            sendAmount -= sendCost;
                        }
                    }
                    // Send the resources or mark the terminal as overloaded for this tick
                    if (!opts.dryRun) {
                        if (sendTerm.isReady) {
                            this.transfer(sendTerm, recvTerm, resource, sendAmount, `provide`);
                        }
                        else {
                            this.terminalOverload[sendTerm.room.name] = true;
                        }
                    }
                    return true;
                }
            }
        }
        // Sell on the market if that's an option
        if (opts.allowMarketSell) {
            const sellOpts = { dryRun: opts.dryRun };
            if (resource == RESOURCE_ENERGY ||
                Abathur$1.isBaseMineral(resource)) {
                if (ResourceManager.getRemainingSpace(colony) < 0) {
                    sellOpts.preferDirect = true;
                    sellOpts.ignorePriceChecksForDirect = true;
                }
            }
            const ret = Overmind.tradeNetwork.sell(colony.terminal, resource, provideAmount, sellOpts);
            this.debug(`Selling ${provideAmount} ${resource} from ${colony.print} with opts=${JSON.stringify(sellOpts)} via trade network: ${errorForCode(ret)}`);
            if (ret >= 0) {
                return true;
            }
        }
        // Can't handle this provide instance!
        return false;
    }
    handleRequestors(requestors, prioritizedPartners, opts = {}) {
        _.defaults(opts, {
            allowDivvying: false,
            takeFromColoniesBelowTarget: false,
            // sendTargetPlusTolerance    : false,
            allowMarketBuy: Game.market.credits >
                TraderJoe.settings.market.credits.canBuyAbove,
            receiveOnlyOncePerTick: false,
            complainIfUnfulfilled: true,
            dryRun: false,
        });
        for (const resource of RESOURCE_EXCHANGE_ORDER) {
            for (const colony of requestors[resource] || []) {
                // Skip if the terminal if it has received in this tick if option is specified
                if (opts.receiveOnlyOncePerTick &&
                    colony.terminal &&
                    colony.terminal.hasReceived) {
                    continue;
                }
                // Compute the request amount
                const { target } = this.thresholds(colony, resource);
                const requestAmount = target - colony.assets[resource];
                // if (opts.sendTargetPlusTolerance) {
                // 	requestAmount += tolerance;
                // }
                if (requestAmount <= 0) {
                    continue;
                }
                // Generate a list of partner sets by picking the appropriate resource from the prioritizedPartners
                const partnerSets = _.map(prioritizedPartners, (partners) => partners[resource] || []);
                const success = this.handleRequestInstance(colony, resource, requestAmount, partnerSets, opts);
                if (!success &&
                    opts.complainIfUnfulfilled &&
                    Game.time %
                        TerminalNetwork_1.settings
                            .complainIfUnfulfilledFrequency ==
                        0) {
                    this.notify(`Unable to fulfill request instance: ${printRoomName(colony.name)} ${leftArrow} ` + `${requestAmount} ${resource}`);
                }
            }
        }
    }
    handleProviders(providers, prioritizedPartners, opts = {}) {
        _.defaults(opts, {
            allowPushToOtherRooms: true,
            allowMarketSell: true,
            complainIfUnfulfilled: true,
            dryRun: false,
        });
        for (const resource of RESOURCE_EXCHANGE_ORDER) {
            for (const colony of providers[resource] || []) {
                // Skip if the terminal is not ready -  prevents trying to send twice in a single tick
                if (colony.terminal && !colony.terminal.isReady) {
                    continue;
                }
                const provideAmount = colony.assets[resource] -
                    this.thresholds(colony, resource).target;
                if (provideAmount <= 0) {
                    continue;
                }
                // Generate a list of partner sets by picking the appropriate resource from the prioritizedPartners
                const partnerSets = _.map(prioritizedPartners, (partners) => partners[resource] || []);
                const success = this.handleProvideInstance(colony, resource, provideAmount, partnerSets, opts);
                if (!success &&
                    opts.complainIfUnfulfilled &&
                    Game.time %
                        TerminalNetwork_1.settings
                            .complainIfUnfulfilledFrequency ==
                        0) {
                    this.notify(`Unable to fulfill provide instance: ${printRoomName(colony.name)} ${rightArrow} ` + `${provideAmount} ${resource}`);
                }
            }
        }
    }
    run() {
        // Assign states to each colony; manual state specification should have already been done in directive.init()
        this.assignColonyStates();
        // Handle request types by descending priority: activeRequestors -> activeProviders -> xzsiveRequestors
        // (passiveProviders and equilibriumNodes have no action)
        this.handleRequestors(this.activeRequestors, [
            this.activeProviders,
            this.passiveProviders,
            this.equilibriumNodes,
            this.passiveRequestors,
        ], { requestType: "active", takeFromColoniesBelowTarget: true });
        this.handleProviders(this.activeProviders, [
            this.activeRequestors,
            this.passiveRequestors,
            this.equilibriumNodes,
            // this.passiveProviders // shouldn't include passiveProviders - these already have too many
        ], { allowMarketSell: true });
        // There are a lot of passive requestors, and usually their requests won't be able to be fulfilled, so
        // we only run this call every few ticks
        if (Overmind.tradeNetwork.ordersProcessedThisTick()) {
            const canBuyPassively = Game.market.credits >=
                TraderJoe.settings.market.credits.canBuyPassivelyAbove;
            this.handleRequestors(this.passiveRequestors, [
                this.activeProviders,
                this.passiveProviders,
                this.equilibriumNodes, // here we won't take enough of the resource to turn it into a passive requestor
            ], {
                requestType: "passive",
                complainIfUnfulfilled: false,
                allowMarketBuy: canBuyPassively,
            });
        }
        // Record stats for this tick
        this.recordStats();
        // Display a warning for colonies that are critically full
        if (Game.time % 10 == 0) {
            for (const colony of this.colonies) {
                if (ResourceManager.getRemainingSpace(colony) < 0 &&
                    !colony.state.isRebuilding) {
                    log.warning(`${colony.print} is critially full; requires immediate attention!`);
                }
            }
        }
        if (this.memory.debug) {
            this.summarize();
        }
        // Display notifications
        if (this.notifications.length > 0) {
            this.notifications.sort();
            log.info(`Terminal network activity: ` +
                alignedNewline +
                this.notifications.join(alignedNewline));
        }
    }
    isInternalTransaction(transaction) {
        return (!!transaction.sender &&
            !!transaction.sender.username &&
            !!transaction.recipient &&
            !!transaction.recipient.username &&
            transaction.sender.username == transaction.recipient.username);
    }
    recordStats() {
        // Record terminal stats
        for (const colony of this.colonies) {
            if (colony.terminal) {
                this.stats.terminals.avgCooldown[colony.name] = ema(colony.terminal.cooldown, this.stats.terminals.avgCooldown[colony.name] || 0, TerminalNetwork_1.settings.terminalCooldownAveragingWindow);
                this.stats.terminals.overload[colony.name] = ema(this.terminalOverload[colony.name] ? 1 : 0, this.stats.terminals.overload[colony.name], CREEP_LIFE_TIME);
            }
        }
        // Rearrange and populate the states entries of stats
        const activeRequestors = {};
        const passiveRequestors = {};
        const equilibriumNodes = {};
        const passiveProviders = {};
        const activeProviders = {};
        for (const [statsTier, thisTier] of [
            [activeRequestors, this.activeRequestors],
            [passiveRequestors, this.passiveRequestors],
            [equilibriumNodes, this.equilibriumNodes],
            [passiveProviders, this.passiveProviders],
            [activeProviders, this.activeProviders],
        ]) {
            for (const resource in thisTier) {
                for (const colony of thisTier[resource]) {
                    if (!statsTier[colony.name]) {
                        statsTier[colony.name] = [resource];
                    }
                    else {
                        statsTier[colony.name].push(resource);
                    }
                }
            }
            for (const colName in statsTier) {
                // sort the resources by the priority of exchange for consistency
                statsTier[colName] = _.sortBy(statsTier[colName], (resource) => _resourceExchangePrioritiesLookup[resource]);
            }
        }
        // Assign the transformed object to stats // TODO: graphite doesn't allow string values; need to rewrite this
        this.stats.states.activeRequestors = activeRequestors;
        this.stats.states.passiveRequestors = passiveRequestors;
        this.stats.states.equilibriumNodes = equilibriumNodes;
        this.stats.states.passiveProviders = passiveProviders;
        this.stats.states.activeProviders = activeProviders;
        // Record internal incoming/outgoing resource stats
        const lastTick = Game.time - 1;
        for (const transaction of Game.market.incomingTransactions) {
            if (transaction.time < lastTick) {
                break;
            } // only look at things from last tick
            if (!this.isInternalTransaction(transaction)) {
                continue;
            } // only count internal transfers here
            const resource = transaction.resourceType;
            const room = transaction.to;
            this.stats.incomingResources[resource] =
                this.stats.incomingResources[resource] || {};
            this.stats.incomingResources[resource][room] =
                this.stats.incomingResources[resource][room] || 0;
            this.stats.incomingResources[resource][room] += transaction.amount;
        }
        for (const transaction of Game.market.outgoingTransactions) {
            // only look at things from last tick
            if (transaction.time < lastTick) {
                break;
            }
            // only count internal transfers here
            if (!this.isInternalTransaction(transaction)) {
                continue;
            }
            const resource = transaction.resourceType;
            const room = transaction.from;
            this.stats.outgoingResources[resource] =
                this.stats.outgoingResources[resource] || {};
            this.stats.outgoingResources[resource][room] =
                this.stats.outgoingResources[resource][room] || 0;
            this.stats.outgoingResources[resource][room] += transaction.amount;
            // Also count the energy send costs
            const sendCost = Game.market.calcTransactionCost(transaction.amount, transaction.from, transaction.to);
            this.stats.sendCosts[room] = this.stats.sendCosts[room] || 0;
            this.stats.sendCosts[room] += sendCost;
            // Update fractional energy send cost, averaged over last 100 energy transfers
            if (resource == RESOURCE_ENERGY) {
                const fractionalEnergyTransferCost = sendCost / transaction.amount;
                this.stats.fractionalEnergyTransferCost = ema(fractionalEnergyTransferCost, this.stats.fractionalEnergyTransferCost, 100);
            }
        }
        // Record assets
        this.stats.assets = this.assets;
    }
    /**
     * Prints the current state of the terminal network to the console
     */
    summarize(resourceOrColony) {
        const { activeRequestors, passiveRequestors, equilibriumNodes, passiveProviders, activeProviders, } = this.stats.states;
        let info = "\nTerminalNetwork Summary: \n";
        if (resourceOrColony && resourceOrColony instanceof Colony) {
            const colony = resourceOrColony;
            info +=
                `${colony.print} actively providing -----------------------------------------------------\n` +
                    `${bullet}${activeProviders[colony.name] || "(None)"}\n` +
                    `${colony.print} passively providing ----------------------------------------------------\n` +
                    `${bullet}${passiveProviders[colony.name] || "(None)"}\n` +
                    `${colony.print} at equilibrium for -----------------------------------------------------\n` +
                    `${bullet}${equilibriumNodes[colony.name] || "(None)"}\n` +
                    `${colony.print} passively requesting ---------------------------------------------------\n` +
                    `${bullet}${passiveRequestors[colony.name] || "(None)"}\n` +
                    `${colony.print} actively requesting ----------------------------------------------------\n` +
                    `${bullet}${activeRequestors[colony.name] || "(None)"}\n`;
        }
        else {
            const resource = resourceOrColony || undefined;
            if (resource) {
                info +=
                    `Active providers for ${resource} -----------------------------------------------------\n` +
                        `${bullet}${_.map(this.activeProviders[resource], (col) => col.printAligned +
                            ` (${col.assets[resource]}), `) || "(None)"}\n` +
                        `Passive providers for ${resource} ----------------------------------------------------\n` +
                        `${bullet}${_.map(this.passiveProviders[resource], (col) => col.printAligned +
                            ` (${col.assets[resource]}), `) || "(None)"}\n` +
                        `Equilibrium nodes for ${resource} ----------------------------------------------------\n` +
                        `${bullet}${_.map(this.equilibriumNodes[resource], (col) => col.printAligned +
                            ` (${col.assets[resource]}), `) || "(None)"}\n` +
                        `Passive requestors for ${resource} ----------------------------------------------------\n` +
                        `${bullet}${_.map(this.passiveRequestors[resource], (col) => col.printAligned +
                            ` (${col.assets[resource]}), `) || "(None)"}\n` +
                        `Active requestors for ${resource} -----------------------------------------------------\n` +
                        `${bullet}${_.map(this.activeRequestors[resource], (col) => col.printAligned +
                            ` (${col.assets[resource]}), `) || "(None)"}\n`;
            }
            else {
                info +=
                    "Active providers ---------------------------------------------------------------------\n";
                for (const colonyName in activeProviders) {
                    info += `${bullet}${printRoomName(colonyName, true)}  ${activeProviders[colonyName]}\n`;
                }
                info +=
                    "Passive providers --------------------------------------------------------------------\n";
                for (const colonyName in passiveProviders) {
                    info += `${bullet}${printRoomName(colonyName, true)}  ${passiveProviders[colonyName]}\n`;
                }
                info +=
                    "Equilibrium nodes --------------------------------------------------------------------\n";
                for (const colonyName in equilibriumNodes) {
                    info += `${bullet}${printRoomName(colonyName, true)}  ${equilibriumNodes[colonyName]}\n`;
                }
                info +=
                    "Passive requestors -------------------------------------------------------------------\n";
                for (const colonyName in passiveRequestors) {
                    info += `${bullet}${printRoomName(colonyName, true)}  ${passiveRequestors[colonyName]}\n`;
                }
                info +=
                    "Active requestors --------------------------------------------------------------------\n";
                for (const colonyName in activeRequestors) {
                    info += `${bullet}${printRoomName(colonyName, true)}  ${activeRequestors[colonyName]}\n`;
                }
            }
        }
        console.log(info);
    }
};
TerminalNetwork$1.settings = {
    /** max size you can send of energy in one tick */
    maxEnergySendAmount: 25000,
    /** max size of resources you can send in one tick */
    maxResourceSendAmount: 3000,
    maxEvacuateSendAmount: 50000,
    /** duration for computing rolling average of terminal cooldowns */
    terminalCooldownAveragingWindow: 1000,
    /** buy base mins directly if very low */
    buyBaseMineralsDirectUnder: DEFAULT_TARGET - DEFAULT_TOLERANCE,
    complainIfUnfulfilledFrequency: 20,
};
TerminalNetwork$1 = TerminalNetwork_1 = __decorate$1([
    profile,
    assimilationLocked
], TerminalNetwork$1);

class DefenseDirective extends Directive {
    constructor(flag) {
        super(flag);
        Overmind.overseer.combatPlanner.directives.push(this);
    }
}

// High-level planning for skirmishing and combats
const THREAT_DECAY_TIMESCALE = 100;
const SIEGE_ANALYSIS_EXPIRATION = 2500;
const defaultCombatPlannerMemory = {
    threats: {},
    profiles: {},
    defenses: {},
    sieges: {},
    skirmishes: {},
};
class CombatPlanner {
    constructor() {
        _.defaults(this.memory, defaultCombatPlannerMemory);
    }
    get memory() {
        return Memory.combatPlanner;
    }
    static computeHitsToSpawn(_room) {
        // TODO
        return 0;
    }
    // private getNeededPotentials(): CombatPotentials {
    // 	// TODO
    // }
    spawnNeededCreeps() { }
    assembleSquads() {
        for (const creep of this.creeps) {
            if (!creep.overlord) ;
            else {
                const creepDirective = creep.overlord
                    .directive;
                if (creepDirective &&
                    creepDirective instanceof DefenseDirective) {
                    if (this.memory.threats[creepDirective.ref]) ;
                }
            }
        }
    }
    static getThreat(directive) {
        if (directive.room) {
            return {
                directive: directive,
                potentials: CombatIntel$1.getCombatPotentials(directive.room.hostiles),
                roomName: directive.room.name,
                closestColony: directive.colony.name,
                distances: directive.overlord.spawnGroup.memory.distances,
                lastSeen: {
                    tick: Game.time,
                },
            };
        }
        else {
            return {
                directive: directive,
                potentials: undefined,
                roomName: directive.pos.roomName,
                closestColony: directive.colony.name,
                distances: directive.overlord.spawnGroup.memory.distances,
                lastSeen: {
                    tick: Game.time,
                },
            };
        }
    }
    registerThreat(directive) {
        const threat = CombatPlanner.getThreat(directive);
        if (this.memory.threats[directive.ref]) {
            // If a threat already exists, update it or allow potentials to decay
            if (threat.potentials) {
                // you have vision
                // If you have new info on threat potentials, update the log in memory
                let attack, rangedAttack, heal;
                const lastPotentials = this.memory.threats[directive.ref].potentials;
                if (lastPotentials) {
                    attack = lastPotentials.attack;
                    rangedAttack = lastPotentials.ranged;
                    heal = lastPotentials.heal;
                }
                else {
                    attack = 0;
                    rangedAttack = 0;
                    heal = 0;
                }
                const decayedAttack = ema(threat.potentials.attack, attack, THREAT_DECAY_TIMESCALE);
                const decayedRangedAttack = ema(threat.potentials.ranged, rangedAttack, THREAT_DECAY_TIMESCALE);
                const decayedHeal = ema(threat.potentials.heal, heal, THREAT_DECAY_TIMESCALE);
                // TODO: adjust decay for creeps known to have moved to next visible room
                // Set new potential to maximum of current or decayed potential
                const potentials = {
                    attack: Math.max(threat.potentials.attack, decayedAttack),
                    ranged: Math.max(threat.potentials.ranged, decayedRangedAttack),
                    heal: Math.max(threat.potentials.heal, decayedHeal),
                };
                // Update the existing threat
                this.memory.threats[directive.ref].potentials = potentials;
                this.memory.threats[directive.ref].lastSeen.tick = Game.time;
            }
        }
        else {
            // Register a new threat
            this.memory.threats[directive.ref] = threat;
        }
    }
    static getRoomLayout(room) {
        let isExposed, isInnerWall, isEdgeWall = false;
        const exitPositions = RoomIntel$1.getExitPositions(room.name);
        const terrain = Game.map.getRoomTerrain(room.name);
        // Room is bunker if >80% of hostile structures are covered by ramparts
        const hostileStructures = room.find(FIND_HOSTILE_STRUCTURES);
        const hostileStructuresInRampart = _.filter(hostileStructures, (s) => s.pos.lookForStructure(STRUCTURE_RAMPART));
        const isBunker = hostileStructuresInRampart.length / hostileStructures.length >= 0.8;
        // Room is edgewall if every exit tile has wall or barrier at 2 range to left/right/top/bottom
        const walledOffExitTiles = _.filter(exitPositions, (pos) => {
            let lookPos;
            const x = pos.x;
            const y = pos.y;
            if (x == 0) {
                lookPos = new RoomPosition(x + 2, y, room.name);
            }
            else if (x == 49) {
                lookPos = new RoomPosition(x - 2, y, room.name);
            }
            else if (y == 0) {
                lookPos = new RoomPosition(x, y + 2, room.name);
            }
            else if (y == 49) {
                lookPos = new RoomPosition(x, y - 2, room.name);
            }
            else {
                // shouldn't ever get here
                lookPos = pos;
            }
            if (terrain.get(lookPos.x, lookPos.y) == TERRAIN_MASK_WALL) {
                return true;
            }
            else {
                const rampart = lookPos.lookForStructure(STRUCTURE_RAMPART);
                const wall = lookPos.lookForStructure(STRUCTURE_WALL);
                return rampart != undefined || wall != undefined;
            }
        });
        if (walledOffExitTiles.length == exitPositions.length) {
            isEdgeWall = true;
        }
        // Room is inner wall if not bunker or edgewall and there is no path to spawn, otherwise exposed
        if (!isBunker && !isEdgeWall) {
            const entryPoints = _.compact([
                _.find(exitPositions, (pos) => pos.x == 0), // left
                _.find(exitPositions, (pos) => pos.x == 49), // right
                _.find(exitPositions, (pos) => pos.y == 0), // top
                _.find(exitPositions, (pos) => pos.y == 49), // bottom
            ]);
            const target = room.spawns[0] || room.towers[0];
            if (target) {
                const obstacles = _.filter(room.structures, (s) => !s.isWalkable);
                const isReachable = _.find(entryPoints, (pos) => Pathing.isReachable(pos, target.pos, obstacles));
                if (isReachable) {
                    isExposed = true;
                }
            }
            if (!isExposed) {
                isInnerWall = true;
            }
        }
        if (isEdgeWall) {
            return "edgewall";
        }
        else if (isBunker) {
            return "bunker";
        }
        else if (isExposed) {
            return "exposed";
        }
        else if (isInnerWall) {
            return "innerwall";
        }
        else {
            log.warning(`Inconclusive room layout for ${room.print}! Assuming inner wall.`);
            return "innerwall";
        }
    }
    static getSiegeAnalysis(room) {
        const owner = room.owner;
        const level = room.controller ? room.controller.level : 0;
        const towerDamageSamplePositions = _.map(_.range(20), () => new RoomPosition(_.random(1, 48), _.random(1, 48), room.name));
        const maxTowerDamage = _.max(_.map(towerDamageSamplePositions, (pos) => CombatIntel$1.towerDamageAtPos(pos, true)));
        const minBarrierHits = room.barriers.length > 0 ?
            _.min(_.map(room.barriers, (b) => b.hits))
            : 0;
        const avgBarrierHits = room.barriers.length > 0 ?
            _.sum(room.barriers, (b) => b.hits) / room.barriers.length
            : 0;
        const numWalls = room.walls.length;
        const numRamparts = room.ramparts.length;
        const expiration = getCacheExpiration(SIEGE_ANALYSIS_EXPIRATION);
        const roomLayout = this.getRoomLayout(room);
        return {
            owner,
            level,
            maxTowerDamage,
            minBarrierHits,
            avgBarrierHits,
            numWalls,
            numRamparts,
            roomLayout,
            expiration,
        };
    }
    registerSiegeAnalysis(room) {
        if (!this.memory.sieges[room.name]) {
            this.memory.sieges[room.name] = {};
        }
        if (!this.memory.sieges[room.name].analysis ||
            Game.time > this.memory.sieges[room.name].analysis.expiration) {
            this.memory.sieges[room.name].analysis =
                CombatPlanner.getSiegeAnalysis(room);
        }
    }
    init() {
        // Register new interactions in visible rooms
        for (const roomName in Game.rooms) {
            const room = Game.rooms[roomName];
            // Make new siege analyses for rooms needing it
            if (room.owner && !room.my) {
                this.registerSiegeAnalysis(room);
            }
        }
        for (const directive of this.directives) {
            this.registerThreat(directive);
        }
    }
    run() { }
    visuals() { }
}
// @ts-expect-error global shenanigans
global.CombatPlanner = CombatPlanner;

var Overseer_1;
const getDefaultOverseerMemory = () => ({});
/**
 * The Overseer object acts as a scheduler, running directives and overlords for all colonies each tick. It is also
 * in charge of starting new "processes" (directives) to respond to various situations.
 */
let Overseer = Overseer_1 = class Overseer {
    constructor() {
        this.memory = Mem.wrap(Memory, "overseer", getDefaultOverseerMemory);
        this.directives = [];
        this.overlords = [];
        this.overlordsByColony = {};
        this._overlordsCached = false;
        this.notifier = new Notifier();
        this.combatPlanner = new CombatPlanner();
        this.blockedRooms = new Set();
    }
    refresh() {
        this.memory = Mem.wrap(Memory, "overseer", getDefaultOverseerMemory);
        this.notifier.clear();
    }
    registerDirective(directive) {
        this.directives.push(directive);
        this._directiveCached = false;
    }
    removeDirective(directive) {
        _.remove(this.directives, (dir) => dir.name == directive.name);
        for (const name in directive.overlords) {
            this.removeOverlord(directive.overlords[name]);
        }
        this._directiveCached = false;
    }
    ensureDirectivesCached() {
        if (!this._directiveCached) {
            this.directivesByType = _.groupBy(this.directives, (directive) => directive.directiveName);
            this.directivesByRoom = _.groupBy(this.directives, (directive) => directive.pos.roomName);
            this.directivesByColony = _.groupBy(this.directives, (directive) => directive.colony.name || "none");
            this._directiveCached = true;
        }
    }
    getDirectivesOfType(directiveName) {
        var _a;
        this.ensureDirectivesCached();
        return (_a = this.directivesByType[directiveName]) !== null && _a !== void 0 ? _a : [];
    }
    getDirectivesInRoom(roomName) {
        this.ensureDirectivesCached();
        return this.directivesByRoom[roomName] || [];
    }
    getDirectivesForColony(colony) {
        this.ensureDirectivesCached();
        return this.directivesByColony[colony.name] || [];
    }
    registerOverlord(overlord) {
        this.overlords.push(overlord);
        this._overlordsCached = false;
    }
    removeOverlord(overlord) {
        _.remove(this.overlords, (o) => o.ref == overlord.ref);
        this._overlordsCached = false;
    }
    ensureOverlordsCached() {
        if (!this._overlordsCached) {
            this.overlords.sort((o1, o2) => o1.priority - o2.priority);
            this.overlordsByColony = _.groupBy(this.overlords, (overlord) => overlord.colony.name);
            for (const colName in this.overlordsByColony) {
                this.overlordsByColony[colName].sort((o1, o2) => o1.priority - o2.priority);
            }
            this._overlordsCached = true;
        }
    }
    getOverlordsForColony(colony) {
        return this.overlordsByColony[colony.name] || [];
    }
    // Initialization ==================================================================================================
    registerLogisticsRequests(colony) {
        // Register logistics requests for all dropped resources and tombstones
        for (const room of colony.rooms) {
            // Pick up all nontrivial dropped resources
            for (const resourceType in room.drops) {
                for (const drop of room.drops[resourceType]) {
                    if (drop.amount >
                        LogisticsNetwork.settings.droppedEnergyThreshold ||
                        drop.resourceType != RESOURCE_ENERGY) {
                        colony.logisticsNetwork.requestOutput(drop, {
                            dAmountdt: 1,
                        });
                    }
                }
            }
        }
        // Pick up all nontrivial ruin resources
        for (const ruin of colony.ruins) {
            if (ruin.store.getUsedCapacity() >
                LogisticsNetwork.settings.droppedEnergyThreshold ||
                ruin.store.getUsedCapacity() > ruin.store.energy) {
                if (colony.bunker && ruin.pos.isEqualTo(colony.bunker.anchor)) {
                    continue;
                }
                colony.logisticsNetwork.requestOutput(ruin, {
                    resourceType: "all",
                });
            }
        }
        // Place a logistics request directive for every tombstone with non-empty store that isn't on a container
        for (const tombstone of colony.tombstones) {
            if (tombstone.store.getUsedCapacity() >
                LogisticsNetwork.settings.droppedEnergyThreshold ||
                tombstone.store.getUsedCapacity() > tombstone.store.energy) {
                if ((colony.bunker &&
                    tombstone.pos.isEqualTo(colony.bunker.anchor)) ||
                    tombstone.pos.lookForStructure(STRUCTURE_CONTAINER)) {
                    continue;
                }
                colony.logisticsNetwork.requestOutput(tombstone, {
                    resourceType: "all",
                });
            }
        }
    }
    init() {
        this.ensureDirectivesCached();
        this.ensureOverlordsCached();
        // Initialize directives
        for (const directive of this.directives) {
            directive.debug(`init`);
            directive.init();
        }
        // Initialize overlords
        for (const overlord of this.overlords) {
            overlord.tryInit();
        }
        // Register cleanup requests to logistics network
        for (const colony of getAllColonies()) {
            this.registerLogisticsRequests(colony);
        }
    }
    // Run phase methods ===============================================================================================
    placeHarvestingDirectives(colony) {
        for (const source of colony.sources) {
            DirectiveHarvest.createIfNotPresent(source.pos, "pos");
        }
        if (colony.controller.level >= 6 && colony.terminal) {
            _.forEach(colony.extractors, (extractor) => DirectiveExtract.createIfNotPresent(extractor.pos, "pos"));
        }
    }
    placeGatheringDirectives() {
        const gatherDirectives = this.getDirectivesOfType(DirectiveGather.directiveName);
        for (const [roomName] of entries(Memory.rooms)) {
            const info = RoomIntel$1.getAllRoomObjectInfo(roomName);
            if (!info || !info.deposits) {
                continue;
            }
            for (const deposit of info.deposits) {
                if (deposit.cooldown >= DEPOSIT_COOLDOWN_CUTOFF) {
                    continue;
                }
                if (gatherDirectives.some((directive) => deposit.pos.readableName ===
                    directive.pos.readableName)) {
                    log.debug(`Already found gather directive at ${deposit.pos.print}, skipping`);
                    continue;
                }
                DirectiveGather.createIfNotPresent(deposit.pos, "pos", {
                    memory: { maxLinearRange: 6 },
                });
            }
        }
    }
    handleBootstrapping(colony) {
        // Bootstrap directive: in the event of catastrophic room crash, enter emergency spawn mode.
        // Doesn't apply to incubating colonies.
        if (!colony.state.isIncubating) {
            const noQueen = colony.getCreepsByRole(Roles.queen).length == 0;
            if (noQueen && colony.hatchery && !colony.spawnGroup) {
                const setup = colony.hatchery.overlord.queenSetup;
                const energyToMakeQueen = bodyCost(setup.generateBody(colony.room.energyCapacityAvailable));
                if (colony.room.energyAvailable < energyToMakeQueen ||
                    hasJustSpawned()) {
                    const result = DirectiveBootstrap.createIfNotPresent(colony.hatchery.pos, "pos");
                    if (typeof result === "string") {
                        // successfully made flag
                        colony.hatchery.settings.suppressSpawning = true;
                    }
                }
            }
        }
    }
    handleOutpostDefense(colony) {
        // TODO: plug in threatLevel infra
        // Guard directive: defend your outposts and all rooms of colonies that you are incubating
        for (const room of colony.outposts) {
            if (room.dangerousPlayerHostiles.length > 0) {
                // Handle player defense of the main room
                DirectiveOutpostDefense.createIfNotPresent(Pathing.findPathablePosition(room.name), "room");
            }
            else if (Cartographer.roomType(room.name) === ROOMTYPE_CONTROLLER) {
                // Handle NPC invasion directives
                if (room.invaders.length > 0 ||
                    (room.invaderCore && room.invaderCore.level == 0)) {
                    const defenseDirectives = [
                        ...DirectiveGuard.find(room.flags),
                        ...DirectiveOutpostDefense.find(room.flags),
                    ];
                    if (defenseDirectives.length == 0) {
                        const placePos = (room.invaders[0] || room.invaderCore)
                            .pos;
                        DirectiveGuard.create(placePos);
                    }
                }
                // Suspend outpost if the controller has been reserved by someone else
                const controller = room.controller;
                if (room.name !== colony.room.name &&
                    controller.reservation &&
                    !controller.reservedByMe) {
                    const duration = controller.reservation.ticksToEnd;
                    log.warning(`Outpost ${room.name} of ${colony.print} is suspended for ${duration}: controller reserved`);
                    colony.suspendOutpost(room.name, {
                        reason: SuspensionReason.reserved,
                        duration,
                    });
                }
            }
        }
    }
    // private handleStrongholds(colony: Colony) {
    // 	if (Game.time % 57 == 0) {
    // 		for (const room of colony.outposts) {
    // 			if (room.invaderCore) {
    // 				log.alert(`Found core in ${room.name} with ${room.invaderCore} level ${room.invaderCore.level}`);
    // 				if (room.invaderCore.level == 0) {
    // 					DirectiveModularDismantle.createIfNotPresent(room.invaderCore.pos, 'pos');
    // 				}
    // 				// else if (room.invaderCore.level <= 4 && room.invaderCore.ticksToDeploy) {
    // 				// 	res = DirectiveStronghold.createIfNotPresent(room.invaderCore.pos, 'room');
    // 				// 	if (!!res) {
    // 				// 		log.notify(`Creating inactiveStronghold clearing ranged attacker in room ${room.name}`);
    // 				// 	}
    // 				// }
    // 			}
    // 		}
    // 	}
    // }
    handleColonyInvasions(colony, checkPersistent = false) {
        // See if invasion is big enough to warrant creep defenses
        if (!colony.room.isSafe && colony.room.threatLevel > 0.25) {
            if (checkPersistent) {
                // Place defensive directive after hostiles have been present for a long enough time
                const safetyData = RoomIntel$1.getSafetyData(colony.room.name);
                const invasionIsPersistent = safetyData.unsafeFor > 20;
                if (invasionIsPersistent) {
                    DirectiveInvasionDefense.createIfNotPresent(colony.controller.pos, "room");
                }
            }
            else {
                DirectiveInvasionDefense.createIfNotPresent(colony.controller.pos, "room");
            }
        }
    }
    handleNukeResponse(colony) {
        // Place nuke response directive if there is a nuke present in colony room
        if (colony.room && colony.level >= DirectiveNukeResponse.requiredRCL) {
            for (const _nuke of colony.room.find(FIND_NUKES)) {
                DirectiveNukeResponse.createIfNotPresent(colony.controller.pos, "room");
            }
        }
    }
    /**
     * Creates directives to handle mining from nearby power banks
     */
    handlePowerMining(room) {
        const powerSetting = Memory.settings.powerCollection;
        const roomType = Cartographer.roomType(room.name);
        if (powerSetting.enabled &&
            (roomType == ROOMTYPE_ALLEY || roomType == ROOMTYPE_CROSSROAD)) {
            const powerBank = _.first(room.powerBanks);
            if (powerBank &&
                powerBank.ticksToDecay > 4000 &&
                powerBank.power >= powerSetting.minPower) {
                if (DirectivePowerMine.isPresent(powerBank.pos)) {
                    return;
                }
                const validColonies = _.filter(getAllColonies(), (colony) => colony.level >= DirectivePowerMine.requiredRCL &&
                    Game.map.getRoomLinearDistance(colony.name, room.name) <= powerSetting.maxRange);
                for (const colony of validColonies) {
                    const route = Game.map.findRoute(colony.room, powerBank.room);
                    if (route != ERR_NO_PATH &&
                        route.length <= powerSetting.maxRange) {
                        log.info(`FOUND POWER BANK IN RANGE ${route.length}, STARTING MINING ${powerBank.room}`);
                        DirectivePowerMine.create(powerBank.pos);
                        return;
                    }
                }
            }
        }
    }
    /**
     * Check if a given room is blocked
     */
    roomIsBlocked(roomName) {
        return this.blockedRooms.has(roomName);
    }
    /**
     * Mark the given room as blocked
     */
    blockRoom(roomName) {
        this.blockedRooms.add(roomName);
    }
    computePossibleOutposts(colony, depth = 3) {
        const colonyRoomStatus = RoomIntel$1.getRoomStatus(colony.room.name).status;
        return _.filter(Cartographer.findRoomsInRange(colony.room.name, depth), (roomName) => {
            if (Cartographer.roomType(roomName) != ROOMTYPE_CONTROLLER) {
                return false;
            }
            const alreadyAnOutpost = _.any(Overmind.cache.outpostFlags, (flag) => (flag.memory.setPos || flag.pos).roomName == roomName);
            const alreadyAColony = !!Overmind.colonies[roomName];
            if (alreadyAColony || alreadyAnOutpost) {
                return false;
            }
            const alreadyOwned = RoomIntel$1.roomOwnedBy(roomName);
            const alreadyReserved = RoomIntel$1.roomReservedBy(roomName);
            const isBlocked = this.roomIsBlocked(roomName);
            if (isBlocked) {
                log.info(`Room ${roomName} is blocked, not expanding there.`);
            }
            if (alreadyOwned || alreadyReserved || isBlocked) {
                return false;
            }
            const neighboringRooms = _.values(Cartographer.describeExits(roomName));
            const isReachableFromColony = _.any(neighboringRooms, (r) => colony.roomNames.includes(r));
            return (isReachableFromColony &&
                RoomIntel$1.getRoomStatus(roomName).status ===
                    colonyRoomStatus);
        });
    }
    handleNewOutposts(colony) {
        const numSources = _.sum(colony.roomNames, // TODO: rewrite to include suspension?
        (roomName) => Memory.rooms[roomName] && Memory.rooms[roomName]["s" /* RMEM.SOURCES */] ?
            Memory.rooms[roomName]["s" /* RMEM.SOURCES */].length
            : 0);
        const numRemotes = numSources - colony.room.sources.length;
        if (numRemotes < Colony.settings.remoteSourcesByLevel[colony.level]) {
            const possibleOutposts = this.computePossibleOutposts(colony);
            const origin = colony.pos;
            const bestOutpost = minBy(possibleOutposts, function (outpostName) {
                const sourceInfo = RoomIntel$1.getSourceInfo(outpostName);
                if (!sourceInfo) {
                    return false;
                }
                const sourceDistances = _.map(sourceInfo, (src) => Pathing.distance(origin, src.pos));
                if (_.any(sourceDistances, (dist) => dist == undefined ||
                    dist > Colony.settings.maxSourceDistance)) {
                    return false;
                }
                return _.sum(sourceDistances) / sourceDistances.length;
            });
            if (bestOutpost) {
                const pos = Pathing.findPathablePosition(bestOutpost);
                log.info(`Colony ${colony.room.print} now remote mining from ${pos.print}`);
                DirectiveOutpost.createIfNotPresent(pos, "room", {
                    memory: { ["C" /* MEM.COLONY */]: colony.name },
                });
            }
        }
    }
    handleAutoPoisoning() {
        // Can only have a max number of concurrent poisons at a time
        const poisonDirectives = this.getDirectivesOfType(DirectivePoisonRoom.directiveName);
        if (poisonDirectives.length >= Memory.settings.autoPoison.maxConcurrent) {
            return;
        }
        // Find a room to poison
        for (const room of getAllRooms()) {
            if (DirectivePoisonRoom.canAutoPoison(room)) {
                const controller = room.controller;
                const maxRange = Memory.settings.autoPoison.maxRange;
                if (!DirectivePoisonRoom.isPresent(controller.pos)) {
                    // See if you can poison a room
                    const colonies = getAllColonies().filter((colony) => colony.level >= DirectivePoisonRoom.requiredRCL &&
                        Game.map.getRoomLinearDistance(room.name, colony.room.name) <= maxRange);
                    for (const colony of colonies) {
                        const route = Game.map.findRoute(colony.room, room);
                        if (route != ERR_NO_PATH && route.length <= maxRange) {
                            log.notify(`Poisoning room ${room.print}`);
                            DirectivePoisonRoom.create(controller.pos);
                            return;
                        }
                    }
                }
            }
        }
    }
    /**
     * Place directives to respond to various conditions
     */
    placeDirectives() {
        const allRooms = getAllRooms();
        const allColonies = getAllColonies();
        if (LATEST_BUILD_TICK == Game.time) {
            _.forEach(allColonies, (colony) => this.placeHarvestingDirectives(colony));
            this.placeGatheringDirectives();
        }
        _.forEach(allColonies, (colony) => this.handleBootstrapping(colony));
        _.forEach(allColonies, (colony) => this.handleOutpostDefense(colony));
        // _.forEach(allColonies, colony => this.handleStrongholds(colony));
        _.forEach(allColonies, (colony) => this.handleColonyInvasions(colony));
        _.forEach(allColonies, (colony) => this.handleNukeResponse(colony));
        if (Game.time % 100 == 67) {
            _.forEach(allColonies, (colony) => this.handleUnkillableStrongholds(colony));
        }
        if (Memory.settings.powerCollection.enabled && Game.cpu.bucket > 8000) {
            _.forEach(allRooms, (room) => this.handlePowerMining(room));
        }
        if (Memory.settings.autoPoison.enabled &&
            canClaimAnotherRoom() &&
            Game.cpu.bucket > 9500) {
            if (p(0.05)) {
                this.handleAutoPoisoning();
            }
        }
        if (getAutonomyLevel() > Autonomy.Manual) {
            _.forEach(allColonies, (colony) => {
                if (Game.time % Overseer_1.settings.outpostCheckFrequency ==
                    2 * colony.id) {
                    this.handleNewOutposts(colony);
                }
                // Place pioneer directives in case the colony doesn't have a spawn for some reason
                if (Game.time % 25 == 0 && colony.spawns.length == 0) {
                    // verify that there are no spawns (not just a caching glitch)
                    if (colony.room.find(FIND_MY_SPAWNS).length == 0) {
                        const pos = Pathing.findPathablePosition(colony.room.name);
                        DirectiveColonize.createIfNotPresent(pos, "room");
                    }
                }
            });
        }
    }
    // Harass Response =================================================================================================
    handleUnkillableStrongholds(colony) {
        for (const room of colony.outposts) {
            if (Cartographer.roomType(room.name) == ROOMTYPE_SOURCEKEEPER &&
                room.invaderCore &&
                room.invaderCore.level > 3) {
                log.warning(`Disabling outpost ${room.print} due to Stronghold presence`);
                colony.suspendOutpost(room.name, {
                    reason: SuspensionReason.stronghold,
                    duration: SUSPENSION_STRONGHOLD_DEFAULT_DURATION,
                });
            }
        }
    }
    // Safe mode condition =============================================================================================
    handleSafeMode(colony) {
        const hostiles = colony.room.dangerousPlayerHostiles;
        if (!hostiles.length || colony.controller.safeMode) {
            return;
        }
        // Safe mode activates when:
        // - any critical structure has less than 50% hitpoints and there are hostile creeps close by
        // - hostile creeps can path to the spawn
        let activateSafeMode = false;
        const criticalStructures = _.compact([
            ...colony.spawns,
            colony.storage,
            colony.terminal,
        ]);
        const hasEndangeredStructures = criticalStructures.some((s) => {
            return (s.hits < s.hitsMax / 2 &&
                s.pos.findInRange(hostiles, 2).length > 0);
        });
        if (hasEndangeredStructures) {
            activateSafeMode = true;
        }
        else {
            const spawn = colony.spawns[0];
            const closestHostileToSpawn = spawn &&
                spawn.pos.findClosestByRange(colony.room.dangerousPlayerHostiles);
            const barriers = colony.room.barriers.map((b) => b.pos);
            if (closestHostileToSpawn &&
                Pathing.isReachable(closestHostileToSpawn.pos, spawn.pos, barriers)) {
                activateSafeMode = true;
            }
        }
        if (activateSafeMode) {
            const ret = colony.controller.activateSafeMode();
            if (ret != OK && !colony.controller.safeMode) {
                if (colony.terminal) {
                    DirectiveTerminalEvacuateState.createIfNotPresent(colony.terminal.pos, "room");
                }
            }
        }
    }
    // Operation =======================================================================================================
    run() {
        for (const directive of this.directives) {
            directive.debug(`run`);
            directive.run();
        }
        for (const overlord of this.overlords) {
            overlord.tryRun();
        }
        for (const colony of getAllColonies()) {
            this.handleSafeMode(colony);
        }
        this.placeDirectives();
    }
    postRun() {
        var _a;
        if (Memory.settings.pixelGeneration.enabled && Game.cpu.generatePixel) {
            // Make sure that our current bucket delta looks fine so we recover quickly
            const delta = (_a = Memory.stats.persistent.avgBucketDelta) !== null && _a !== void 0 ? _a : 0;
            if (delta >= 20 && Game.cpu.bucket === MAX_BUCKET) {
                log.warning(`Generating pixels!`);
                Memory.pixelsTick = Game.time;
                // Reset the last bucket count so we don't tank the average
                Memory.stats.persistent.lastBucket = 0;
                Game.cpu.generatePixel();
            }
        }
    }
    getCreepReport(colony) {
        const roleOccupancy = {};
        for (const overlord of this.overlordsByColony[colony.name]) {
            for (const role in overlord.creepUsageReport) {
                const report = overlord.creepUsageReport[role];
                if (report == undefined) {
                    if (Game.time % 100 == 0) {
                        log.info(`Role ${role} is not reported by ${overlord.ref}!`);
                    }
                }
                else {
                    if (roleOccupancy[role] == undefined) {
                        roleOccupancy[role] = [0, 0];
                    }
                    roleOccupancy[role][0] += report[0];
                    roleOccupancy[role][1] += report[1];
                }
            }
        }
        return roleOccupancy;
    }
    visuals() {
        for (const directive of this.directives) {
            directive.visuals();
        }
        for (const overlord of this.overlords) {
            overlord.visuals();
        }
        this.notifier.visuals();
        // for (let colony of this.colonies) {
        // 	this.drawCreepReport(colony);
        // }
        RoomIntel$1.visuals();
    }
};
Overseer.settings = {
    outpostCheckFrequency: onPublicServer() ? 250 : 100,
};
Overseer = Overseer_1 = __decorate$1([
    profile
], Overseer);

const CHECK_EXPANSION_FREQUENCY = 1000;
const UNOWNED_MINERAL_BONUS = 100;
const CATALYST_BONUS = 75;
const MAX_SCORE_BONUS = _.sum([UNOWNED_MINERAL_BONUS, CATALYST_BONUS]);
const TOO_CLOSE_PENALTY = 100;
const defaultExpansionPlannerMemory = () => ({});
let ExpansionPlanner = class ExpansionPlanner {
    constructor() {
        this.memory = Mem.wrap(Memory, "expansionPlanner", defaultExpansionPlannerMemory);
    }
    refresh() {
        this.memory = Mem.wrap(Memory, "expansionPlanner", defaultExpansionPlannerMemory);
    }
    handleExpansion() {
        var _a;
        const allColonies = getAllColonies();
        const currentlyColonizing = DirectiveColonize.find(Object.values(Game.flags)).length;
        let maxRooms;
        if (Memory.settings.colonization.maxRooms === undefined) {
            maxRooms =
                (_a = MAX_SHARD_OWNED_ROOMS[Game.shard.name]) !== null && _a !== void 0 ? _a : MAX_OWNED_ROOMS;
            maxRooms = Math.min(Game.gcl.level, maxRooms);
        }
        else {
            maxRooms = Math.min(allColonies.length, Memory.settings.colonization.maxRooms);
        }
        if (allColonies.length + currentlyColonizing >= maxRooms) {
            log.info(`Colonization capped at ${maxRooms}. Not expanding!`);
            return;
        }
        const roomName = this.chooseNextColonyRoom();
        if (roomName) {
            const pos = Pathing.findPathablePosition(roomName);
            DirectiveColonize.createIfNotPresent(pos, "room");
            DirectiveIncubate.createIfNotPresent(pos, "room");
            log.notify(`Room ${roomName} selected as next colony! Creating colonization directive.`);
        }
    }
    chooseNextColonyRoom() {
        // Generate a list of possible colonies to expand from based on level and whether they are already expanding
        const possibleColonizers = [];
        for (const colony of getAllColonies()) {
            if (colony.level >= DirectiveColonize.requiredRCL &&
                _.filter(colony.flags, (flag) => DirectiveColonize.filter(flag))
                    .length == 0) {
                possibleColonizers.push(colony);
            }
        }
        const possibleBestExpansions = _.compact(_.map(possibleColonizers, (col) => this.getBestExpansionRoomFor(col)));
        log.debug("bestExpansions: " + JSON.stringify(possibleBestExpansions));
        const bestExpansion = maxBy(possibleBestExpansions, (choice) => choice.score);
        if (bestExpansion) {
            log.alert(`Next expansion chosen: ${bestExpansion.roomName} with score ${bestExpansion.score}`);
            return bestExpansion.roomName;
        }
        else {
            log.alert(`No viable expansion rooms found!`);
        }
    }
    getBestExpansionRoomFor(colony) {
        const allColonyRooms = _.zipObject(_.map(getAllColonies(), (col) => [col.room.name, true]));
        const allOwnedMinerals = _.map(getAllColonies(), (col) => col.room.mineral.mineralType);
        let bestRoom = "";
        let bestScore = -Infinity;
        for (const roomName in colony.memory.expansionData.possibleExpansions) {
            let score = colony.memory.expansionData.possibleExpansions[roomName];
            if (typeof score != "number") {
                continue;
            }
            const isBlocked = DirectiveAvoid.isPresent(roomName);
            if (isBlocked) {
                continue;
            }
            // Compute modified score
            if (score + MAX_SCORE_BONUS > bestScore) {
                // Is the room too close to an existing colony?
                const range2Rooms = Cartographer.findRoomsInRange(roomName, MIN_EXPANSION_DISTANCE);
                if (_.any(range2Rooms, (roomName) => allColonyRooms[roomName])) {
                    continue; // too close to another colony
                }
                const range3Rooms = Cartographer.findRoomsInRange(roomName, MIN_EXPANSION_DISTANCE + 1);
                if (_.any(range3Rooms, (roomName) => allColonyRooms[roomName])) {
                    score -= TOO_CLOSE_PENALTY;
                }
                // Are there powerful hostile rooms nearby?
                const adjacentRooms = Cartographer.findRoomsInRange(roomName, Memory.settings.colonization.safeZone);
                if (_.any(adjacentRooms, (roomName) => {
                    if (RoomIntel.isConsideredHostile(roomName)) {
                        return true;
                    }
                    const cont = RoomIntel.getControllerInfo(roomName);
                    if (!cont ||
                        (cont.owner &&
                            isPlayer(cont.owner) &&
                            !isAlly(cont.owner)) ||
                        (cont.reservation &&
                            isPlayer(cont.reservation.username) &&
                            !isAlly(cont.reservation.username))) {
                        return true;
                    }
                    return false;
                })) {
                    continue;
                }
                // Reward new minerals and catalyst rooms
                const mineralType = Memory.rooms[roomName]["m" /* RMEM.MINERAL */] ?
                    Memory.rooms[roomName]["m" /* RMEM.MINERAL */]["t" /* RMEM_MNRL.MINERALTYPE */]
                    : undefined;
                if (mineralType) {
                    if (!allOwnedMinerals.includes(mineralType)) {
                        score += UNOWNED_MINERAL_BONUS;
                    }
                    if (mineralType == RESOURCE_CATALYST) {
                        score += CATALYST_BONUS;
                    }
                }
                // Update best choices
                if (score > bestScore &&
                    RoomIntel.getRoomStatus(roomName).status ===
                        RoomIntel.getRoomStatus(colony.room.name).status) {
                    bestScore = score;
                    bestRoom = roomName;
                }
            }
        }
        if (bestRoom != "") {
            return { roomName: bestRoom, score: bestScore };
        }
    }
    init() { }
    run() {
        if (Game.time % CHECK_EXPANSION_FREQUENCY == 17 &&
            getAutonomyLevel() == Autonomy.Automatic) {
            this.handleExpansion();
        }
    }
};
ExpansionPlanner = __decorate$1([
    assimilationLocked,
    profile
], ExpansionPlanner);

const a0_0x717579=a0_0x227d;(function(_0x2373c1,_0x4f3abe){const _0x58d36c=a0_0x227d,_0x552b08=_0x2373c1();while(!![]){try{const _0x553dc9=-parseInt(_0x58d36c(0x241))/0x1*(-parseInt(_0x58d36c(0x1c7))/0x2)+parseInt(_0x58d36c(0x182))/0x3+-parseInt(_0x58d36c(0x1ab))/0x4+parseInt(_0x58d36c(0x1a8))/0x5*(parseInt(_0x58d36c(0x1d5))/0x6)+parseInt(_0x58d36c(0x1d8))/0x7*(-parseInt(_0x58d36c(0x1b3))/0x8)+-parseInt(_0x58d36c(0x1cc))/0x9+parseInt(_0x58d36c(0x21d))/0xa*(parseInt(_0x58d36c(0x1e3))/0xb);if(_0x553dc9===_0x4f3abe)break;else _0x552b08['push'](_0x552b08['shift']());}catch(_0x2bcd8d){_0x552b08['push'](_0x552b08['shift']());}}}(a0_0x16e5,0xdd439));const a0_0x149bb9=(function(){let _0x3f29f7=!![];return function(_0x27ac99,_0x22da39){const _0x18670b=_0x3f29f7?function(){const _0xafe991=a0_0x227d;if(_0x22da39){const _0x52d523=_0x22da39[_0xafe991(0x1f6)](_0x27ac99,arguments);return _0x22da39=null,_0x52d523;}}:function(){};return _0x3f29f7=![],_0x18670b;};}()),a0_0x3ba648=a0_0x149bb9(undefined,function(){const _0x53da98=a0_0x227d;return a0_0x3ba648[_0x53da98(0x17c)]()[_0x53da98(0x1b7)](_0x53da98(0x201))[_0x53da98(0x17c)]()[_0x53da98(0x23c)](a0_0x3ba648)[_0x53da98(0x1b7)](_0x53da98(0x201));});a0_0x3ba648();var __decorate=undefined&&undefined[a0_0x717579(0x192)]||function(_0x1dda3b,_0x54438f,_0x320818,_0x4fc8c5){const _0x3c17fb=a0_0x717579;var _0x48dde3=arguments[_0x3c17fb(0x20e)],_0x382557=_0x48dde3<0x3?_0x54438f:_0x4fc8c5===null?_0x4fc8c5=Object[_0x3c17fb(0x208)](_0x54438f,_0x320818):_0x4fc8c5,_0x2c5bef;if(typeof Reflect===_0x3c17fb(0x1a3)&&typeof Reflect[_0x3c17fb(0x1f9)]===_0x3c17fb(0x234))_0x382557=Reflect[_0x3c17fb(0x1f9)](_0x1dda3b,_0x54438f,_0x320818,_0x4fc8c5);else {for(var _0xa4152e=_0x1dda3b[_0x3c17fb(0x20e)]-0x1;_0xa4152e>=0x0;_0xa4152e--)if(_0x2c5bef=_0x1dda3b[_0xa4152e])_0x382557=(_0x48dde3<0x3?_0x2c5bef(_0x382557):_0x48dde3>0x3?_0x2c5bef(_0x54438f,_0x320818,_0x382557):_0x2c5bef(_0x54438f,_0x320818))||_0x382557;}return _0x48dde3>0x3&&_0x382557&&Object[_0x3c17fb(0x1f3)](_0x54438f,_0x320818,_0x382557),_0x382557;};function a0_0x227d(_0x55bc4b,_0x551ad8){const _0x1e6ad2=a0_0x16e5();return a0_0x227d=function(_0x3ba648,_0x149bb9){_0x3ba648=_0x3ba648-0x171;let _0x16e531=_0x1e6ad2[_0x3ba648];if(a0_0x227d['TtwGDi']===undefined){var _0x227d44=function(_0x1f662b){const _0x37bb8f='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=';let _0x3ac98e='',_0x3f29f7='',_0x27ac99=_0x3ac98e+_0x227d44;for(let _0x22da39=0x0,_0x18670b,_0x52d523,_0x1dda3b=0x0;_0x52d523=_0x1f662b['charAt'](_0x1dda3b++);~_0x52d523&&(_0x18670b=_0x22da39%0x4?_0x18670b*0x40+_0x52d523:_0x52d523,_0x22da39++%0x4)?_0x3ac98e+=_0x27ac99['charCodeAt'](_0x1dda3b+0xa)-0xa!==0x0?String['fromCharCode'](0xff&_0x18670b>>(-0x2*_0x22da39&0x6)):_0x22da39:0x0){_0x52d523=_0x37bb8f['indexOf'](_0x52d523);}for(let _0x54438f=0x0,_0x320818=_0x3ac98e['length'];_0x54438f<_0x320818;_0x54438f++){_0x3f29f7+='%'+('00'+_0x3ac98e['charCodeAt'](_0x54438f)['toString'](0x10))['slice'](-0x2);}return decodeURIComponent(_0x3f29f7);};a0_0x227d['mPQIov']=_0x227d44,_0x55bc4b=arguments,a0_0x227d['TtwGDi']=!![];}const _0x446724=_0x1e6ad2[0x0],_0xe42adf=_0x3ba648+_0x446724,_0x478e61=_0x55bc4b[_0xe42adf];if(!_0x478e61){const _0x4fc8c5=function(_0x48dde3){this['VPJWDV']=_0x48dde3,this['sPprJF']=[0x1,0x0,0x0],this['ymvWHC']=function(){return 'newState';},this['fdakZE']='\x5cw+\x20*\x5c(\x5c)\x20*{\x5cw+\x20*',this['vzWPqR']='[\x27|\x22].+[\x27|\x22];?\x20*}';};_0x4fc8c5['prototype']['yjlbHk']=function(){const _0x382557=new RegExp(this['fdakZE']+this['vzWPqR']),_0x2c5bef=_0x382557['test'](this['ymvWHC']['toString']())?--this['sPprJF'][0x1]:--this['sPprJF'][0x0];return this['CXCnAv'](_0x2c5bef);},_0x4fc8c5['prototype']['CXCnAv']=function(_0xa4152e){if(!Boolean(~_0xa4152e))return _0xa4152e;return this['PZvgvT'](this['VPJWDV']);},_0x4fc8c5['prototype']['PZvgvT']=function(_0x5f4a9c){for(let _0x500c06=0x0,_0x4c4eb5=this['sPprJF']['length'];_0x500c06<_0x4c4eb5;_0x500c06++){this['sPprJF']['push'](Math['round'](Math['random']())),_0x4c4eb5=this['sPprJF']['length'];}return _0x5f4a9c(this['sPprJF'][0x0]);},new _0x4fc8c5(a0_0x227d)['yjlbHk'](),_0x16e531=a0_0x227d['mPQIov'](_0x16e531),_0x55bc4b[_0xe42adf]=_0x16e531;}else _0x16e531=_0x478e61;return _0x16e531;},a0_0x227d(_0x55bc4b,_0x551ad8);}const profilerRooms={};if(config[a0_0x717579(0x19a)]){for(const name of config[a0_0x717579(0x196)]){profilerRooms[name]=!![];}const myRoomNames=_[a0_0x717579(0x215)](_[a0_0x717579(0x173)](Game[a0_0x717579(0x235)]),_0x5f4a9c=>Game[a0_0x717579(0x235)][_0x5f4a9c]&&Game[a0_0x717579(0x235)][_0x5f4a9c]['my']);for(const name of _[a0_0x717579(0x211)](myRoomNames,config[a0_0x717579(0x220)]-config[a0_0x717579(0x196)][a0_0x717579(0x20e)])){profilerRooms[name]=!![];}}const OVERMIND_SMALL_CAPS=a0_0x717579(0x21c);global[a0_0x717579(0x1f2)]='«'+OVERMIND_SMALL_CAPS+'»';let _Overmind=class _Overmind{constructor(){const _0x4868bd=a0_0x717579;this[_0x4868bd(0x1e2)]=Memory[_0x4868bd(0x206)],this[_0x4868bd(0x23b)]=new Overseer(),this[_0x4868bd(0x1f7)]=!![],this[_0x4868bd(0x22e)]=Game[_0x4868bd(0x229)]+config[_0x4868bd(0x210)],this[_0x4868bd(0x1fd)]=new GameCache(),this[_0x4868bd(0x1cb)]={},this[_0x4868bd(0x1ac)]=[],this[_0x4868bd(0x19d)]=[],this[_0x4868bd(0x1f4)]={},this[_0x4868bd(0x1b8)]={},this[_0x4868bd(0x1e1)]={},this[_0x4868bd(0x240)]={},this[_0x4868bd(0x1d7)]={},this[_0x4868bd(0x238)]={},this[_0x4868bd(0x178)]=new TerminalNetwork$1(),global[_0x4868bd(0x18e)]=this[_0x4868bd(0x178)],this[_0x4868bd(0x1af)]=new TraderJoe(),global[_0x4868bd(0x1c0)]=this[_0x4868bd(0x1af)],this[_0x4868bd(0x1ec)]=new ExpansionPlanner(),this[_0x4868bd(0x19e)]=new RoomIntel$1(),this[_0x4868bd(0x1c6)]=[];}[a0_0x717579(0x223)](){const _0x43a04b=a0_0x717579;log[_0x43a04b(0x176)](_0x43a04b(0x1eb)),this[_0x43a04b(0x1fd)][_0x43a04b(0x223)](),this[_0x43a04b(0x175)](),this[_0x43a04b(0x217)]();for(const _0x500c06 of Object[_0x43a04b(0x1c5)](this[_0x43a04b(0x1cb)])){this[_0x43a04b(0x1ea)](()=>_0x500c06[_0x43a04b(0x1bc)]());}for(const _0x4c4eb5 of Object[_0x43a04b(0x1c5)](this[_0x43a04b(0x1f4)])){this[_0x43a04b(0x1ea)](()=>_0x4c4eb5[_0x43a04b(0x1bc)]());}this[_0x43a04b(0x1f7)]=![];}[a0_0x717579(0x1be)](){const _0x2a8d47=a0_0x717579;this[_0x2a8d47(0x1f7)]=!![],this[_0x2a8d47(0x1e2)]=Memory[_0x2a8d47(0x206)],this[_0x2a8d47(0x1c6)]=[],this[_0x2a8d47(0x1fd)][_0x2a8d47(0x1be)](),this[_0x2a8d47(0x23b)][_0x2a8d47(0x1be)](),this[_0x2a8d47(0x178)][_0x2a8d47(0x1be)](),this[_0x2a8d47(0x1af)][_0x2a8d47(0x1be)](),this[_0x2a8d47(0x1ec)][_0x2a8d47(0x1be)](),this[_0x2a8d47(0x195)](),this[_0x2a8d47(0x212)]();for(const _0x5f10b8 in this[_0x2a8d47(0x240)]){this[_0x2a8d47(0x240)][_0x5f10b8][_0x2a8d47(0x176)](_0x2a8d47(0x214)),this[_0x2a8d47(0x240)][_0x5f10b8][_0x2a8d47(0x1be)]();}for(const _0x4e9e08 in this[_0x2a8d47(0x1d7)]){this[_0x2a8d47(0x1d7)][_0x4e9e08][_0x2a8d47(0x1be)]();}this[_0x2a8d47(0x1f7)]=![];}[a0_0x717579(0x1ea)](_0x27c691,_0x31d6a7){const _0x554bd1=a0_0x717579;if(config[_0x554bd1(0x1a6)])try{_0x27c691();}catch(_0x402dac){_0x402dac instanceof Error?(_0x31d6a7?_0x402dac[_0x554bd1(0x21a)]=_0x554bd1(0x22d)+_0x402dac[_0x554bd1(0x21a)]+_0x554bd1(0x18c)+_0x27c691+_0x554bd1(0x20b)+_0x31d6a7+_0x554bd1(0x191)+_0x402dac[_0x554bd1(0x1b9)]:_0x402dac[_0x554bd1(0x21a)]=_0x554bd1(0x22d)+_0x402dac[_0x554bd1(0x21a)]+_0x554bd1(0x18c)+_0x27c691+':\x0a'+_0x402dac[_0x554bd1(0x1b9)],this[_0x554bd1(0x1c6)][_0x554bd1(0x174)](_0x402dac)):log[_0x554bd1(0x1a7)](_0x554bd1(0x227)+_0x27c691+':\x20'+_0x402dac);}else _0x27c691();}[a0_0x717579(0x18d)](){const _0x49aacd=a0_0x717579;if(this[_0x49aacd(0x1c6)][_0x49aacd(0x20e)]==0x0)return;else {log[_0x49aacd(0x17a)](_0x49aacd(0x236)),Memory[_0x49aacd(0x20c)][_0x49aacd(0x190)][_0x49aacd(0x1a0)]=Game[_0x49aacd(0x229)],this[_0x49aacd(0x1f7)]=!![],this[_0x49aacd(0x22e)]=Game[_0x49aacd(0x229)];if(this[_0x49aacd(0x1c6)][_0x49aacd(0x20e)]==0x1)throw _[_0x49aacd(0x239)](this[_0x49aacd(0x1c6)]);else {for(const _0x4eb818 of this[_0x49aacd(0x1c6)]){log[_0x49aacd(0x228)](_0x4eb818);}const _0x3d584f=new Error(_0x49aacd(0x202));_0x3d584f[_0x49aacd(0x1b9)]=_[_0x49aacd(0x1a9)](this[_0x49aacd(0x1c6)],_0xa19295=>_0xa19295[_0x49aacd(0x21a)])[_0x49aacd(0x20a)]('\x0a');throw _0x3d584f;}}}[a0_0x717579(0x175)](){const _0x3f71e7=a0_0x717579,_0x7bd950={};this[_0x3f71e7(0x238)]={};const _0x3b0feb=_[_0x3f71e7(0x1b6)](this[_0x3f71e7(0x1fd)][_0x3f71e7(0x1d9)],_0x5b2949=>_0x5b2949[_0x3f71e7(0x1e2)]['C']);for(const _0x43d1c5 in Game[_0x3f71e7(0x235)]){const _0x1c3d6b=Game[_0x3f71e7(0x235)][_0x43d1c5];if(_0x1c3d6b['my']){const _0x3ad7fb=Memory[_0x3f71e7(0x1cb)][_0x43d1c5];if(_0x3ad7fb&&_0x3ad7fb[_0x3f71e7(0x1ba)]){this[_0x3f71e7(0x1ac)][_0x3f71e7(0x174)](_0x43d1c5);continue;}if(_0x1c3d6b[_0x3f71e7(0x226)]){const _0x44396a=_[_0x3f71e7(0x215)](_0x1c3d6b[_0x3f71e7(0x226)],_0x84e0f1=>DirectiveClearRoom[_0x3f71e7(0x215)](_0x84e0f1)||DirectivePoisonRoom[_0x3f71e7(0x215)](_0x84e0f1));if(_0x44396a[_0x3f71e7(0x20e)]>0x0){this[_0x3f71e7(0x19d)][_0x3f71e7(0x174)](_0x43d1c5);continue;}_0x7bd950[_0x43d1c5]=_[_0x3f71e7(0x1a9)](_0x3b0feb[_0x43d1c5],_0x3f4507=>(_0x3f4507[_0x3f71e7(0x1e2)][_0x3f71e7(0x1cf)]||_0x3f4507[_0x3f71e7(0x23e)])[_0x3f71e7(0x186)]);}this[_0x3f71e7(0x238)][_0x43d1c5]=_0x43d1c5;}}for(const _0x164770 in _0x7bd950){for(const _0x3a5a26 of _0x7bd950[_0x164770]){this[_0x3f71e7(0x238)][_0x3a5a26]=_0x164770;}}let _0xd001a2=0x0;for(const _0x387592 in _0x7bd950){if(config[_0x3f71e7(0x19a)]&&!profilerRooms[_0x387592]){Game[_0x3f71e7(0x229)]%0x14==0x0&&log[_0x3f71e7(0x1a7)](_0x3f71e7(0x184)+_0x387592+'.');continue;}this[_0x3f71e7(0x1ea)](()=>{const _0x13fb55=_0x3f71e7;this[_0x13fb55(0x1cb)][_0x387592]=new Colony(_0xd001a2,_0x387592,_0x7bd950[_0x387592]);}),_0xd001a2++;}}[a0_0x717579(0x195)](){const _0xca315b=a0_0x717579;for(const _0x485dbf in this[_0xca315b(0x1cb)]){this[_0xca315b(0x1ea)](()=>this[_0xca315b(0x1cb)][_0x485dbf][_0xca315b(0x1be)]());}}[a0_0x717579(0x217)](_0x8cde36=![]){const _0x11b348=a0_0x717579;for(const _0x5f1c54 in Game[_0x11b348(0x226)]){if(this[_0x11b348(0x1f4)][_0x5f1c54])continue;const _0x433cf9=Game[_0x11b348(0x226)][_0x5f1c54][_0x11b348(0x1e2)]['C'];if(_0x433cf9){if(config[_0x11b348(0x19a)]&&!profilerRooms[_0x433cf9])continue;const _0xd3f89=Memory[_0x11b348(0x1cb)][_0x433cf9];if(_0xd3f89&&_0xd3f89[_0x11b348(0x1ba)])continue;}this[_0x11b348(0x1ea)](()=>{const _0x35e10b=_0x11b348,_0x3acfe4=DirectiveWrapper(Game[_0x35e10b(0x226)][_0x5f1c54]),_0x597cb6=!!this[_0x35e10b(0x1f4)][_0x5f1c54];_0x3acfe4&&_0x597cb6&&_0x8cde36&&_0x3acfe4[_0x35e10b(0x1bc)](),!_0x3acfe4&&!config[_0x35e10b(0x1e5)]&&Game[_0x35e10b(0x229)]%0xa==0x0&&log[_0x35e10b(0x1a7)](_0x35e10b(0x198)+_0x5f1c54+_0x35e10b(0x21b)+Game[_0x35e10b(0x226)][_0x5f1c54][_0x35e10b(0x23e)][_0x35e10b(0x185)]+_0x35e10b(0x1da)+alignedNewline+_0x35e10b(0x172));});}}[a0_0x717579(0x212)](){const _0x469bd8=a0_0x717579;for(const _0x3da1e6 in this[_0x469bd8(0x1f4)]){this[_0x469bd8(0x1f4)][_0x3da1e6][_0x469bd8(0x1be)]();}this[_0x469bd8(0x217)](!![]);}[a0_0x717579(0x187)](){const _0x4972bb=a0_0x717579;this[_0x4972bb(0x1ea)](()=>RoomIntel$1[_0x4972bb(0x187)]()),this[_0x4972bb(0x1ea)](()=>this[_0x4972bb(0x1af)][_0x4972bb(0x187)]()),this[_0x4972bb(0x1ea)](()=>this[_0x4972bb(0x178)][_0x4972bb(0x187)]()),this[_0x4972bb(0x1ea)](()=>this[_0x4972bb(0x23b)][_0x4972bb(0x187)](),_0x4972bb(0x1db));for(const _0x2531f0 in this[_0x4972bb(0x1cb)]){const _0x4c62f5=Game[_0x4972bb(0x1a4)][_0x4972bb(0x1c3)]();this[_0x4972bb(0x1ea)](()=>this[_0x4972bb(0x1cb)][_0x2531f0][_0x4972bb(0x187)](),_0x2531f0),Stats[_0x4972bb(0x17f)](_0x4972bb(0x1f0)+_0x2531f0+_0x4972bb(0x230),Game[_0x4972bb(0x1a4)][_0x4972bb(0x1c3)]()-_0x4c62f5);}for(const _0x1cacde in this[_0x4972bb(0x1d7)]){this[_0x4972bb(0x1ea)](()=>this[_0x4972bb(0x1d7)][_0x1cacde][_0x4972bb(0x187)](),_0x1cacde);}this[_0x4972bb(0x1ea)](()=>this[_0x4972bb(0x1ec)][_0x4972bb(0x187)]());}[a0_0x717579(0x204)](){const _0x9cd33d=a0_0x717579;Game[_0x9cd33d(0x229)]%0x3==0x0&&IntelManagement[_0x9cd33d(0x204)]();for(const _0x33db33 in this[_0x9cd33d(0x1d7)]){this[_0x9cd33d(0x1ea)](()=>this[_0x9cd33d(0x1d7)][_0x33db33][_0x9cd33d(0x204)](),_0x33db33);}this[_0x9cd33d(0x1ea)](()=>this[_0x9cd33d(0x23b)][_0x9cd33d(0x204)](),_0x9cd33d(0x194));for(const _0x5c9096 in this[_0x9cd33d(0x1cb)]){this[_0x9cd33d(0x1ea)](()=>this[_0x9cd33d(0x1cb)][_0x5c9096][_0x9cd33d(0x204)](),_0x5c9096);}this[_0x9cd33d(0x1ea)](()=>this[_0x9cd33d(0x178)][_0x9cd33d(0x204)]()),this[_0x9cd33d(0x1ea)](()=>this[_0x9cd33d(0x1af)][_0x9cd33d(0x204)]()),this[_0x9cd33d(0x1ea)](()=>this[_0x9cd33d(0x1ec)][_0x9cd33d(0x204)]()),this[_0x9cd33d(0x1ea)](()=>RoomIntel$1[_0x9cd33d(0x204)]()),this[_0x9cd33d(0x1ea)](()=>Assimilator[_0x9cd33d(0x204)]());}[a0_0x717579(0x1b4)](){const _0x3f8d2c=a0_0x717579;this[_0x3f8d2c(0x23b)][_0x3f8d2c(0x1b4)](),this[_0x3f8d2c(0x1ea)](()=>VersionUpdater[_0x3f8d2c(0x204)]()),this[_0x3f8d2c(0x1ea)](()=>Segmenter[_0x3f8d2c(0x204)]()),this[_0x3f8d2c(0x18d)]();}[a0_0x717579(0x1b1)](){const _0x368fd8=a0_0x717579;for(const _0x550c44 of this[_0x368fd8(0x1ac)]){this[_0x368fd8(0x23b)][_0x368fd8(0x1e7)][_0x368fd8(0x1a7)](_0x368fd8(0x1d4),_0x550c44,NotifierPriority[_0x368fd8(0x22a)]);}for(const _0x347285 of this[_0x368fd8(0x19d)]){this[_0x368fd8(0x23b)][_0x368fd8(0x1e7)][_0x368fd8(0x1a7)](_0x368fd8(0x23a),_0x347285,NotifierPriority[_0x368fd8(0x203)]);}}[a0_0x717579(0x1a5)](){const _0x578ef9=a0_0x717579;var _0x136492;if(((_0x136492=Memory[_0x578ef9(0x20c)][_0x578ef9(0x190)][_0x578ef9(0x189)])!==null&&_0x136492!==void 0x0?_0x136492:0x0)>0xa){Visualizer[_0x578ef9(0x1a5)]();if(VersionUpdater[_0x578ef9(0x1e2)][_0x578ef9(0x225)]){const _0x2543b6=VersionUpdater[_0x578ef9(0x1e2)][_0x578ef9(0x225)];VersionUpdater[_0x578ef9(0x1ce)](_0x2543b6)&&this[_0x578ef9(0x23b)][_0x578ef9(0x1e7)][_0x578ef9(0x1a7)](_0x578ef9(0x209)+__VERSION__+_0x578ef9(0x197)+_0x2543b6,undefined,NotifierPriority[_0x578ef9(0x213)]);}this[_0x578ef9(0x23b)][_0x578ef9(0x1a5)]();for(const _0x522893 in this[_0x578ef9(0x1cb)]){this[_0x578ef9(0x1cb)][_0x522893][_0x578ef9(0x1a5)]();}}else Game[_0x578ef9(0x229)]%0xa==0x0&&log[_0x578ef9(0x21f)](_0x578ef9(0x19c)+Game[_0x578ef9(0x1a4)][_0x578ef9(0x1e0)]+_0x578ef9(0x23d));}};_Overmind=__decorate([profile,assimilationLocked],_Overmind);var _Overmind$1 = _Overmind;class IntelManagement{static[a0_0x717579(0x1d2)](){const _0x365ef7=a0_0x717579,_0x3fee26=[],_0x14bb02=getAllColonies();if(_0x14bb02[_0x365ef7(0x20e)]==0x0)return;for(const _0x5c3b8b of _0x14bb02){if(_0x5c3b8b[_0x365ef7(0x1dd)]>DEFCON[_0x365ef7(0x1c1)]||_0x5c3b8b[_0x365ef7(0x177)][_0x365ef7(0x20e)]==0x0)continue;const _0x998305=_0x5c3b8b[_0x365ef7(0x1fe)];if(_0x998305[_0x365ef7(0x1bb)]||_0x998305[_0x365ef7(0x1d6)]<0x4)continue;let _0x208244=![];if(_0x998305[_0x365ef7(0x218)]){const _0x1f3316=_0x998305[_0x365ef7(0x218)][_0x365ef7(0x1b5)];(_0x1f3316[_0x365ef7(0x19f)]()[_0x365ef7(0x1ad)](_0x365ef7(0x1d1))||_0x1f3316[_0x365ef7(0x1ad)](_0x365ef7(0x21c)))&&(_0x208244=!![]);}!_0x208244&&_0x3fee26[_0x365ef7(0x174)](_0x998305[_0x365ef7(0x218)]?_0x998305[_0x365ef7(0x218)][_0x365ef7(0x1b5)]:_0x365ef7(0x219));}if(_0x3fee26[_0x365ef7(0x20e)]>=0.5*_[_0x365ef7(0x173)](Overmind[_0x365ef7(0x1cb)])[_0x365ef7(0x20e)]){Memory[_0x365ef7(0x188)][_0x365ef7(0x1a2)]=__DEFAULT_OVERMIND_SIGNATURE__,log[_0x365ef7(0x17a)](_0x365ef7(0x1e8)+bulleted(_0x3fee26)+alignedNewline+_0x365ef7(0x1e9)+_0x365ef7(0x1bf));throw new Error(_0x365ef7(0x17b));}}static[a0_0x717579(0x199)](){const _0x561eb6=a0_0x717579;if(Assimilator[_0x561eb6(0x21e)](config[_0x561eb6(0x207)]))return;let _0x26488e=![];for(const _0x5157d7 in Game[_0x561eb6(0x235)]){const _0x56d4c9=Game[_0x561eb6(0x235)][_0x5157d7];if(_0x56d4c9[_0x561eb6(0x1fe)]&&_0x56d4c9[_0x561eb6(0x1fe)][_0x561eb6(0x183)]&&_0x56d4c9[_0x561eb6(0x1fe)]['my']){const _0x1f4b08=RoomIntel$1[_0x561eb6(0x216)](_0x56d4c9[_0x561eb6(0x21a)]);if(_0x1f4b08[_0x561eb6(0x1ef)]==_0x561eb6(0x224)){_0x26488e=!![];break;}}}if(_0x26488e){const _0x8cfd75=[_0x561eb6(0x1de),_0x561eb6(0x1f1),_0x561eb6(0x22b),_0x561eb6(0x1e4),_0x561eb6(0x18b),_0x561eb6(0x1ee),_0x561eb6(0x20f),_0x561eb6(0x23f)],_0x4b6346=_[_0x561eb6(0x211)](_0x8cfd75);log[_0x561eb6(0x1a7)](_0x4b6346);const _0x1bd0e8=[COLOR_RED],_0x2cd884=[[COLOR_RED,COLOR_RED]];for(const _0x174bf4 in Game[_0x561eb6(0x226)]){const _0x4a81ce=Game[_0x561eb6(0x226)][_0x174bf4],_0x472239=[_0x4a81ce[_0x561eb6(0x232)],_0x4a81ce[_0x561eb6(0x1ed)]];(_0x1bd0e8[_0x561eb6(0x1ad)](_0x4a81ce[_0x561eb6(0x232)])||_0x2cd884[_0x561eb6(0x1ad)](_0x472239))&&(_0x4a81ce[_0x561eb6(0x1e6)](),log[_0x561eb6(0x17a)](_0x561eb6(0x1ca)+_0x4a81ce[_0x561eb6(0x21a)]+'.'));}}}static[a0_0x717579(0x204)](){const _0x2cead1=a0_0x717579;this[_0x2cead1(0x1d2)](),Game[_0x2cead1(0x229)]%0x1e==0x0&&this[_0x2cead1(0x199)]();}}function a0_0x16e5(){const _0x2ea3d9=['q29SB255ihn1ChbYzxnZzwq','B3zLCNnLzxi','y29UC3rYDwn0B3i','ksaTihnRAxaGCMvUzgvYAw5NihzPC3vHBhmU','Cg9Z','rgL0y2GGDgHLihbYzw1HzguGyM90lIbzB3vYignYzwvWCYbKzxnLCNzLigfUig9YAwDPBMfSigHPDcWGBM90igeGy292zxiGyMfUzce','B3zLCMXVCMrZ','mJaXndnZtgPZDNu','idWGicaGpIa','vxnLihjLBw92zuvYCMfUDezSywDZkcKGDg8GCMvTB3zLigzSywDZihDOAwnOigrVig5VDcbTyxrJAcbHigrPCMvJDgL2zs4','A2v5CW','ChvZAa','CMvNAxn0zxjdB2XVBMLLCW','zgvIDwC','y3jLzxbZ','DgvYBwLUywXozxr3B3jR','z2vUzxjHDgvvCgrHDgvnzxnZywDL','D2fYBMLUzW','sw52ywXPzcbJB250CM9SBgvYihnPz25HDhvYzxmGzgv0zwn0zwq7ihDVBID0ihj1BIb0AgLZihrPy2SH','Dg9tDhjPBMC','C2f5','BwfYA1nLz21LBNrbC1b1yMXPyW','Bg9N','pgeGAhjLzJ0IAhr0Chm6lY9NAxrODwiUy29Tl2jLBMnIyxj0Bgv0Dc9pDMvYBwLUzc9YzwXLyxnLCYi+rg93BMXVywq8l2e+','z2v0rM9YzwLNBLnLz21LBNq','ndK0nJm3wNfJqK5q','B3DUzxi','u3vWChjLC3nPBMCGAw5ZDgfUDgLHDgLVBIbVzIbJB2XVBNKG','ChjPBNq','CM9VBu5HBwu','Aw5PDa','C2v0DgLUz3m','yxzNqNvJA2v0rgvSDge','icaGicaGicaGicaGicdILzek','v1jjveuGwu9vuIbpv04Gr09erefntIbdt0rf','igv4y2vWDgLVBIbPBIa','AgfUzgXLrxHJzxb0Aw9UCW','vgvYBwLUywXozxr3B3jR','4PwA4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4PwD','CgvYC2LZDgvUDa','ktOk','x19KzwnVCMf0zq','z2vUzxjHDgvvCgrHDgvnzxnZywDLu21HBgW','B3zLCNnLzxiUCNvUkcK','CMvMCMvZAenVBg9UAwvZ','ufjprKLmrvjFsu5dtfverv9dt0XptKLfuW','iokgKIa','rMXHzYbB','CNvUuM9VBuLUDgvSxZi','vvnfx1nduKvfufnFufjprKLmrvi','4PwA4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4PwD','q1bvigj1y2TLDcbPCYb0B28GBg93icG','C3vWChjLC3nLzenVBg9UAwvZ','CM9VBuLUDgvS','Dg9mB3DLCKnHC2u','BgfZDevYCM9YvgLJAW','4Pwu4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4PwxcG','C2LNBMf0DxjL','B2jQzwn0','y3b1','DMLZDwfSCW','vvnfx1rswv9dqvrdsa','ywXLCNq','mZaZotGWEKHtve1m','BwfW','q2HLy2TgCMvXDwvUy3K','ndq2nJCXnKP1CNbcEG','C3vZCgvUzgvKq29SB25Pzxm','Aw5JBhvKzxm','DMvYC2LVBG','DhjHzgvozxr3B3jR','CMvXDwvZDezVCMvPz25tzwDTzw50','AgfUzgXLtM90AwzPy2f0Aw9UCW','DMvYC2LVBLvWzgf0zxi','mZjQyu16AwC','Cg9ZDfj1BG','Dgv4Da','z3jVDxbcEq','C2vHCMnO','EMvYzW','C3rHy2S','C3vZCgvUza','C2LNBMvKqNLty3jLzxbZ','C3bHD25nB2fYt3zLCMXVCMrZ','BM90Awz5','CMvMCMvZAa','4Bsp4BsG4BshYOdHTi3jQSM04BsflG','vhjHzgvozxr3B3jR','C2fMzq','4PwricaGicaGie9wrvjnsu5eifnduKvfufmGquKGicaGicaG4PwrcG','z2v0vxnLza','4Pwrid4G','DMfSDwvZ','zxHJzxb0Aw9UCW','mtu4yLPpzK9W','4PwG4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4PwJcG','tvvptG','swXSzwDHBcbKAxjLy3rPDMvZigrLDgvJDgvKigfUzcbYzw1VDMvKoIa','y29SB25Pzxm','mtqYnZK0otLgsxrqr00','pc9MB250pG','AxnwzxjZAw9Ut3v0zgf0zwq','C2v0ug9Z','idWG4PwrcG','B3zLCM1PBMq','CNvUuM9VBuLUDgvSxZe','C2XHDMvFzMv0y2HwzxjZAw9U','q29SB255ihn1C3bLBMrLza','otz2yK1OAuK','Bgv2zwW','C3bHD25hCM91Chm','mte4odKWmujtuMHxtG','B3v0Cg9ZDezSywDZ','xsbKB2vZig5VDcbTyxrJAcbHihzHBgLKigrPCMvJDgL2zsbJB2XVCIbJB2rLisaOuMvMzxiGDg8Gl3nYyY9KAxjLy3rPDMvZl2LUAxrPywXPEMvYlNrZkq','B3zLCNnLzxiUAw5PDcGP','idWGicaGicaGicaGicaGiokvKqO','zgvMy29U','ww91ig1Pz2H0igjLig1PC3nPBMCGDgHLihbVAw50ig9MihrOAxmGz2fTzsaTig1VC3qGB2yGDgHLigz1BIbVzIb0AguGz2fTzsbPCYbWCM9NCMfTBwLUzYb5B3vYig93BIbIB3qGyw5KihDHDgnOAw5NihLVDxiGBgL0DgXLigfUDcbMyxjTihj1BIe','BwfZDgvYx3b1C2HwzxjZAw9U','yNvJA2v0','Cg93zxjAzxjN','BwvTB3j5','mtCXnJa1mtDYB2rgAhu','q29KAw5NihLVDxiGB3DUifnJCMvLChmGquKGAxmGBgLRzsbICMv3Aw5NihLVDxiGB3DUigjLzxiUifn1CMuSihn0B3jLlwjVDwDODcbPCYbMAw5LlcbIDxqGAg9Tzw1Hzgu/ifrOyxqNCYbZB21LigDVB2qGC2HPDc4','u1vqufjfu1nFsu5wquXjrf9esvjfq1rjvKvFquXfuLrt','CMvTB3zL','BM90AwzPzxi','sw52ywXPzcbJB250CM9SBgvYihnPz25HDhvYzxmGzgv0zwn0zwq6','u2LNBMf0DxjLCYbTDxn0ignVBNrHAw4GDgHLihn0CMLUzYaIt3zLCM1PBMqIig9Yia','Dhj5','uMvIDwLSzgLUzYbpDMvYBwLUzcbVyMPLy3qH','zxHWyw5ZAw9UugXHBM5LCG','C2vJB25Kyxj5q29SB3i','swyGt3zLCM1PBMqGAxmGDgHLihjLywr5ig1LywWGB2yGu2nYzwvWCYWGy29KAw5NihLVDxiGB3DUiefjigLZihrOzsbMyxjTlxrVlxrHyMXLigv4CgvYAwvUy2uUiezYzxnOlcbZyxrPC2z5Aw5NlcbYzxDHCMrPBMCH','C3rHDhvZ','y3b1lNvZywDLlG','u3vYzsWGt3zLCM1PBMqGBwLNAhqGD2LUihLVDsbIyxr0BgvZlcbIDxqGB25SEsb5B3vYig93BIbJB2rLignHBIb3Aw4GDgHLigHLyxj0CYbVzIb5B3vYignYzwvWCY4Grg9Uj3qGBgv0ihrOzw0Gzg93BIe','x19eruzbvuXux09wrvjnsu5ex1njr05bvfvsrv9F','zgvMAw5LuhjVCgvYDhK','zgLYzwn0AxzLCW','pgeGAhjLzJ0IAhr0Chm6lY9NAxrODwiUy29Tl2jLBMnIyxj0Bgv0Dc9pDMvYBwLUzc9IBg9Il21HC3rLCI9dsefor0vmt0CUBwqIpLbHDgnOig5VDgvZpc9HpG','yxbWBhK','C2HVDwXKqNvPBgq','D3jHCa','zgvJB3jHDgu','4Pwu4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4Pwq4PwxcG','vxbKyxrLig1Liq','C2v0u2vNBwvUDfbYB3bLCNr5','y2fJAgu','y29UDhjVBgXLCG','C2f5vxbKyxrLtwvZC2fNzq','iokvKqO','kcGOlISPkYKRksSK','txvSDgLWBguGzxHJzxb0Aw9UCYbJyxvNAhqGDgHPCYb0AwnRiq','tg93','CNvU','BM90Awz5tMv3vMvYC2LVBG','t3zLCM1PBMq','tvLFvvnfuK5btuu','z2v0t3DUuhjVCgvYDhLezxnJCMLWDg9Y','wYfDifvWzgf0zsbHDMfPBgfIBgu6ia','AM9PBG','icHPzgvUDgLMAwvYoIa','C3rHDhm','zgLZCgXHEvvWzgf0zu1LC3nHz2u','BgvUz3rO','u3vYzsWGt3zLCM1PBMqGy2fUihbSyxKGDgHLigDHBwuSigj1DcbJyw4GAxqGC2vYzw5HzguGEw91CIbJCMvLChmGDw5KzxiGDgHLig1VB25SAwDODd8GvgLTzsb0BYbJB2rLihvWihnVBwuGCM9Tyw5Jzse','tKvxx09wrvjnsu5ex0LovevsvKfm','C2fTCgXL','CMvMCMvZAerPCMvJDgL2zxm','rMf0ywW','CMvMCMvZAgLUzW','zMLSDgvY','z2v0uM9VBvn0yxr1CW','CMvNAxn0zxjeAxjLy3rPDMvZ','C2LNBG','Dw5KzwzPBMvK','BMfTzq','ieaG','4Bsp4BsG4BshYOdHTi3jQSM04Bsf','mtbZBLDNyLG','AxnbC3nPBwLSyxrLza','Aw5MBW','ufjprKLmrvjFq09mt05zx0XjtuLu','4PwricaGicaGicaGicaGvxbKyxrLigf2ywLSywjSztOG','CMvXDwvZDfnLz21LBNrZ','yNvPBgq','BM92AwnL','BMv3zxn0vMvYC2LVBG','zMXHz3m','q2f1z2H0ihvUA25VD24GzxHJzxb0Aw9UigLUia','DgHYB3C','DgLTzq','sgLNAa','uM9ZzxmGyxjLihjLzcWGDMLVBgv0CYbHCMuGyMX1zsWGt3zLCM1PBMqNCYbJB29SlcbIDxqGEw91CIbJB2rLigLZihrVBYeGvw5SzwfZAcb5B3vYigLUBMvYignVzgvYigfUzcbZAg93ihvZihDOyxqGEw91j3zLigDVDce','C3bSAxq','q2f1z2H0ihvUAgfUzgXLzca','zxHWAxjHDgLVBG','q2HLy2TpBLrPy2S','lMLUAxq','4PwrifvWzgf0zsbHDMfPBgfIBgu6ia','y29SB3i','4PwricaGicaGicaGicaGpIa','zNvUy3rPB24','CM9VBxm','rxHJzxb0Aw9UCYbWCMvZzw50ihrOAxmGDgLJAYeGuMvIDwLSzgLUzYbpDMvYBwLUzcbVyMPLy3qGAw4GBMv4Dcb0AwnRlG','pgzVBNqGy29SB3i9jYnMzJaWzMyNpG','y29SB255twfW','zMLYC3q'];a0_0x16e5=function(){return _0x2ea3d9;};return a0_0x16e5();}const downloadURL=a0_0x717579(0x180),changelogURL=a0_0x717579(0x1f5);class VersionUpdater{static get[a0_0x717579(0x1e2)](){const _0x2ea6c9=a0_0x717579;return Mem[_0x2ea6c9(0x1f8)](Memory[_0x2ea6c9(0x206)],_0x2ea6c9(0x1b2),()=>({'versions':{},'newestVersion':undefined}));}static[a0_0x717579(0x1d3)](){const _0x1ed714=a0_0x717579;if(Game[_0x1ed714(0x229)]%this[_0x1ed714(0x1aa)]==this[_0x1ed714(0x22f)]-0x1)Segmenter[_0x1ed714(0x1b0)](config[_0x1ed714(0x1c9)],SEGMENTS[_0x1ed714(0x1ae)]);else {if(Game[_0x1ed714(0x229)]%this[_0x1ed714(0x1aa)]==this[_0x1ed714(0x22f)]){const _0x423ae2=Segmenter[_0x1ed714(0x181)](config[_0x1ed714(0x1c9)],SEGMENTS[_0x1ed714(0x1ae)]);if(_0x423ae2)return _0x423ae2[_0x1ed714(0x1ae)];}}}static[a0_0x717579(0x1ce)](_0x578576){const _0x21e41a=a0_0x717579,[_0x35d6d8,_0x48bae8,_0x5b09d1]=_[_0x21e41a(0x1a9)](__VERSION__[_0x21e41a(0x22c)]('.'),_0x572eff=>parseInt(_0x572eff,0xa)),[_0x373359,_0x1f2fd3,_0x58d1f0]=_[_0x21e41a(0x1a9)](_0x578576[_0x21e41a(0x22c)]('.'),_0xa2ebda=>parseInt(_0xa2ebda,0xa));return _0x373359>_0x35d6d8||_0x1f2fd3>_0x48bae8||_0x58d1f0>_0x5b09d1;}static[a0_0x717579(0x1df)](){const _0x367177=a0_0x717579;if(Game[_0x367177(0x229)]%this[_0x367177(0x1aa)]==this[_0x367177(0x22f)]-0x2)Segmenter[_0x367177(0x222)](SEGMENTS[_0x367177(0x1ae)]);else Game[_0x367177(0x229)]%this[_0x367177(0x1aa)]==this[_0x367177(0x22f)]-0x1&&(Segmenter[_0x367177(0x17e)](SEGMENTS[_0x367177(0x1ae)]),Segmenter[_0x367177(0x1fc)](SEGMENTS[_0x367177(0x1ae)],_0x367177(0x1ae),__VERSION__));}static[a0_0x717579(0x179)](_0x1de888,_0x4a2737){const _0x58c4fe=a0_0x717579;let _0x2b576f='\x0a';for(const _0xc8473 of asciiLogoSmall){_0x2b576f+=_0xc8473+'\x0a';}const _0x1ab8f6=_0x58c4fe(0x1a1)+(_0x58c4fe(0x221)+_0x1de888+_0x58c4fe(0x197)+_0x4a2737+_0x58c4fe(0x18a))+(_0x58c4fe(0x233)+downloadURL+_0x58c4fe(0x171)+changelogURL+_0x58c4fe(0x1dc))+_0x58c4fe(0x19b);return _0x2b576f+_0x1ab8f6;}static[a0_0x717579(0x193)](_0x5dffaf,_0x5c12d9){const _0x235e53=a0_0x717579,_0x504334=_0x235e53(0x1fa)+_0x235e53(0x1c2)+_0x235e53(0x1c8)+(_0x235e53(0x231)+_0x5dffaf+_0x235e53(0x197)+_0x5c12d9+_0x235e53(0x200))+(_0x235e53(0x1c4)+downloadURL+_0x235e53(0x171)+changelogURL+_0x235e53(0x1d0))+_0x235e53(0x18f);return '\x0a'+_0x504334;}static[a0_0x717579(0x20d)](_0x5c2e62){const _0x48846f=a0_0x717579,_0x32e43c=this[_0x48846f(0x179)](__VERSION__,_0x5c2e62);console[_0x48846f(0x17f)](_0x48846f(0x237)+_0x32e43c+_0x48846f(0x1cd));}static[a0_0x717579(0x1ff)](){const _0x476f4e=a0_0x717579;for(const _0x59eeeb in Game[_0x476f4e(0x177)]){const _0x5064d5=Game[_0x476f4e(0x177)][_0x59eeeb];_0x5064d5[_0x476f4e(0x17d)](_0x476f4e(0x1fb),!![]);}}static[a0_0x717579(0x205)](_0x2c2a40){const _0x53871a=a0_0x717579,_0x2e0889=this[_0x53871a(0x193)](__VERSION__,_0x2c2a40);Game[_0x53871a(0x1bd)](_0x53871a(0x237)+_0x2e0889+_0x53871a(0x1cd));}static[a0_0x717579(0x204)](){const _0x101452=a0_0x717579;config[_0x101452(0x207)]==config[_0x101452(0x1c9)]&&this[_0x101452(0x1df)]();const _0x26f92e=this[_0x101452(0x1d3)]();_0x26f92e&&(this[_0x101452(0x1e2)][_0x101452(0x225)]=_0x26f92e);const _0x2cd5f4=this[_0x101452(0x1e2)][_0x101452(0x225)];_0x2cd5f4&&this[_0x101452(0x1ce)](_0x2cd5f4)&&(Game[_0x101452(0x229)]%0xa==0x0&&(this[_0x101452(0x20d)](_0x2cd5f4),this[_0x101452(0x1ff)]()),Game[_0x101452(0x229)]%0x2710==0x0&&this[_0x101452(0x205)](_0x2cd5f4));}}VersionUpdater[a0_0x717579(0x1aa)]=0x64,VersionUpdater[a0_0x717579(0x22f)]=0x5b;

// Disable a whole lot of things since this migrates deleted or renamed properties
/* eslint @typescript-eslint/no-unsafe-assignment: "off" */
/* eslint @typescript-eslint/no-unsafe-call: "off" */
/* eslint @typescript-eslint/no-unsafe-argument: "off" */
/* eslint @typescript-eslint/dot-notation: "off" */
/**
 * The VersionMigration class contains ad-hoc methods for migrating older versions of Overmind to newer versions
 */
class VersionMigration {
    static run() {
        /*
        if (!this.memory.versions['02Xto03X']) {
            this.migrate_02X_03X();
        }
        if (!this.memory.versions['03Xto04X']) {
            this.migrate_03X_04X();
        }
        if (!this.memory.versions['04Xto05X']) {
            this.migrate_04X_05X();
        }
        if (!this.memory.versions['04Xto05X_part2']) {
            this.migrate_04X_05X_part2();
        }
        if (!this.memory.versions['04Xto05X_part3']) {
            this.migrate_04X_05X_part3();
        }
        */
        if (!this.memory.versions["05Xto051"]) {
            this.migrate_050_051();
        }
        if (!this.memory.versions["05Xto051_part2"]) {
            this.migrate_050_051_part2();
        }
        if (!this.memory.versions["05Xto051_part3"]) {
            this.migrate_050_051_part3();
        }
        if (!this.memory.versions["05Xto051_part4"]) {
            this.migrate_050_051_part4();
        }
        if (!this.memory.versions["051to052"]) {
            this.migrate_051_052();
        }
        if (!this.memory.versions["052to053"]) {
            this.migrate_052_053();
        }
        if (!this.memory.versions["053to06X_part1"]) {
            this.migrate_053_06X_part1();
        }
        if (!this.memory.versions["053to06X_part2"]) {
            this.migrate_053_06X_part2();
        }
        if (!this.memory.versions["053to06X_part3"]) {
            this.migrate_053_06X_part3();
        }
        if (!this.memory.versions["053to06X_part4"]) {
            this.migrate_053_06X_part4();
        }
        if (!this.memory.versions["053to06X_part5"]) {
            this.migrate_053_06X_part5();
        }
    }
    static get memory() {
        return Mem.wrap(Memory.Overmind, "versionMigrator", () => ({
            versions: {},
        }));
    }
    /*
    static migrate_02X_03X() {
        // This technically won't run correctly because it gets run only on global reset, but no one is using v0.2.x
        // anymore anyway, so I don't feel the need to maintain support for this function
        let allColoniesUpdated = true;
        let i = 0;
        for (let name in Memory.colonies) {
            let rpMemory = Memory.colonies[name].roomPlanner;
            let lastBuilt = rpMemory.lastGenerated;
            // Reboot colony room planners one at a time every 3 ticks
            if (!lastBuilt) {
                allColoniesUpdated = false;
                if (Game.time % 100 == 3 * i) {
                    // Delete all white/white routing hints from memory
                    rpMemory.savedFlags = _.filter(rpMemory.savedFlags, (flag: {secondaryColor: number}) =>
                        flag.secondaryColor != COLOR_WHITE);
                    rpMemory.active = true;
                    log.alert(`Version migration: rebooting roomPlanner for colony ${name}!`);
                } else if (Game.time % 100 == 3 * i + 1) {
                    colony.roomPlanner.finalize(true);
                }
            }
        }
        if (allColoniesUpdated) {
            this.memory.versions['02Xto03X'] = true;
            log.alert(`Version migration from 0.2.x -> 0.3.x completed successfully.`);
        }
    }

    static migrate_03X_04X() {
        // Update creep memory
        for (let i in Memory.creeps) {
            // Migrate all old-style overlord references to new ones
            if (Memory.creeps[i].overlord) {
                let hcName = Memory.creeps[i].overlord!.split(':')[0];
                if (hcName == 'commandCenter'
                    || hcName == 'hatchery'
                    || hcName == 'evolutionChamber'
                    || hcName == 'miningSite'
                    || hcName == 'upgradeSite') {
                    let id = Memory.creeps[i].overlord!.split(':')[1];
                    let roomObject = Game.getObjectById(id) as RoomObject | undefined;
                    if (roomObject) {
                        let overlordName = Memory.creeps[i].overlord!.split(':')[2];
                        Memory.creeps[i].overlord = hcName + '@' + roomObject.pos.name + ':' + overlordName;
                    }
                }
            }
            // Change all miner roles to drone roles
            if (Memory.creeps[i].role == 'miner') {
                Memory.creeps[i].role = 'drone';
            }
        }
        // Delete old-style miningSite overlords from memory
        OvermindConsole.deepCleanMemory();
        this.memory.versions['03Xto04X'] = true;
        log.alert(`Version migration from 0.3.x -> 0.4.x completed successfully.`);
    }

    static migrate_04X_05X() {
        let migrateClusterNames = ['commandCenter', 'evolutionChamber', 'hatchery', 'upgradeSite'];
        for (let i in Memory.creeps) {
            if (Memory.creeps[i].overlord) {
                let hcName = Memory.creeps[i].overlord!.split('@')[0];
                if (migrateClusterNames.includes(hcName)) {
                    let overlordName = _.last(Memory.creeps[i].overlord!.split(':'));
                    if (overlordName == 'hatchery') {
                        overlordName = 'supply';
                    }
                    let colonyName = Memory.creeps[i].colony;
                    Memory.creeps[i].overlord = hcName + '@' + colonyName + ':' + overlordName;
                }
            }
        }
        for (let i in Memory.rooms) {
            delete (<any>Memory.rooms[i]).tick;
            delete (<any>Memory.rooms[i]).score;
        }
        // Change to new signature
        let oldSignature = '[Overmind]';
        if ((<any>Memory).signature && (<any>Memory).signature.includes(oldSignature)) {
            (<any>Memory).signature = (<any>Memory).signature.replace(oldSignature, DEFAULT_OVERMIND_SIGNATURE);
        }
        this.memory.versions['04Xto05X'] = true;
        log.alert(`Version migration from 0.4.x -> 0.5.x (part 1) completed successfully.`);
    }

    static migrate_04X_05X_part2() {
        // Copy old memory to new memory locations
        if (Memory.signature) {
            Memory.settings.signature = (<any>Memory).signature;
        }
        delete (<any>Memory).signature;
        delete (<any>Memory).bot;
        delete (<any>Memory).log;
        delete (<any>Memory).autoclaim;
        this.memory.versions['04Xto05X_part2'] = true;
        log.alert(`Version migration from 0.4.x -> 0.5.x (part 2) completed successfully.`);
    }

    static migrate_04X_05X_part3() {
        for (let i in Memory.creeps) {
            if (Memory.creeps[i].overlord) {
                let ref = Memory.creeps[i].overlord as string;
                let n = ref.lastIndexOf(':');
                ref = ref.slice(0, n) + ref.slice(n).replace(':', '>');
                Memory.creeps[i].overlord = ref;
            }
        }
        this.memory.versions['04Xto05X_part3'] = true;
        log.alert(`Version migration from 0.4.x -> 0.5.x (part 3) completed successfully.`);
    }

    */
    static migrate_050_051() {
        // Destroy all links that aren't hatchery or commandCenter links
        for (const id in Game.structures) {
            const s = Game.structures[id];
            if (s.structureType == STRUCTURE_LINK) {
                const isCommandCenterLink = s.pos.findInRange(_.compact([s.room.storage, s.room.terminal]), 2).length > 0;
                const isHatcheryLink = s.pos.findInRange(s.room.spawns, 2).length > 0;
                if (!isCommandCenterLink && !isHatcheryLink) {
                    s.destroy();
                }
            }
        }
        let count = 0;
        for (const name in Game.creeps) {
            const creep = Game.creeps[name];
            if (creep.memory.role == "drone" &&
                creep.memory.overlord &&
                creep.memory.overlord.includes("miningSite")) {
                creep.suicide();
                count++;
            }
        }
        this.memory.versions["05Xto051"] = true;
        log.alert(`Genocide complete: suicided ${count} innocent drones.`);
        log.alert(`Version migration from 0.5.0 -> 0.5.1 (part 1) completed successfully.`);
    }
    static migrate_050_051_part2() {
        // Destroy all links that aren't hatchery or commandCenter links
        for (const name in Game.creeps) {
            const creep = Game.creeps[name];
            if (creep.memory.role == "reserver") {
                creep.memory.role = "infestor";
            }
            else if (creep.memory.role == "guard") {
                creep.memory.role = "broodling";
            }
        }
        this.memory.versions["05Xto051_part2"] = true;
        log.alert(`Version migration from 0.5.0 -> 0.5.1 (part 2) completed successfully.`);
    }
    static migrate_050_051_part3() {
        const mem = Memory.assimilator;
        if (mem && mem.users) {
            delete mem.users;
        }
        this.memory.versions["05Xto051_part3"] = true;
        log.alert(`Version migration from 0.5.0 -> 0.5.1 (part 3) completed successfully.`);
    }
    static migrate_050_051_part4() {
        const protectedKeywords = [
            "suspendUntil",
            "amount",
            "created",
            "persistent",
            "setPosition",
            "rotation",
            "colony",
            "parent",
            "pathing",
            "stats",
            "safeTick",
            "enhanced",
            "persistent",
            "recoveryWaypoint",
            "totalResources",
            "maxPathLength",
            "maxLinearRange",
        ];
        for (const name in Memory.flags) {
            for (const prop in Memory.flags[name]) {
                if (!protectedKeywords.includes(prop)) {
                    delete Memory.flags[name][prop];
                }
            }
        }
        this.memory.versions["05Xto051_part4"] = true;
        log.alert(`Version migration from 0.5.0 -> 0.5.1 (part 4) completed successfully.`);
    }
    static migrate_051_052() {
        if (__VERSION__ == "0.5.2") {
            for (const name in Game.creeps) {
                if (name.includes("mutalisk")) {
                    Game.creeps[name].suicide();
                }
            }
        }
        this.memory.versions["051to052"] = true;
        log.alert(`Version migration from 0.5.1 -> 0.5.2 completed successfully.`);
    }
    static migrate_052_053() {
        // Reformat flag and harvest directive memory
        const newFlagKeys = {
            created: "T" /* MEM.TICK */,
            expiration: "X" /* MEM.EXPIRATION */,
            overlord: "O" /* MEM.OVERLORD */,
            colony: "C" /* MEM.COLONY */,
        };
        for (const name in Memory.flags) {
            // Replace old keys with new ones
            Memory.flags[name] = _.mapKeys(Memory.flags[name], function (value, key) {
                return newFlagKeys[key] || key;
            });
            // Special opertions for harvest flags
            if (name.includes("harvest:")) {
                const pathing = Memory.flags[name].pathing;
                if (pathing) {
                    Memory.flags[name]["P"] = {
                        D: pathing.distance,
                        X: pathing.expiration,
                    };
                    delete Memory.flags[name].pathing;
                }
                Memory.flags[name]["u"] = (Memory.flags[name]).stats.usage;
                Memory.flags[name]["d"] = (Memory.flags[name]).stats.downtime;
                delete Memory.flags[name].stats;
            }
        }
        // Reformat creep memory
        const newCreepKeys = {
            overlord: "O" /* MEM.OVERLORD */,
            colony: "C" /* MEM.COLONY */,
        };
        for (const name in Memory.creeps) {
            // Replace old keys with new ones
            Memory.creeps[name] = _.mapKeys(Memory.creeps[name], function (value, key) {
                return newCreepKeys[key] || key;
            });
        }
        // Delete outdated colony memory properties
        for (const name in Memory.colonies) {
            for (const key in Memory.colonies[name]) {
                if (key.includes("miningSite@")) {
                    // @ts-expect-error migrated
                    delete Memory.colonies[name][key];
                }
            }
        }
        // Delete ALL room memory
        for (const name in Memory.rooms) {
            delete Memory.rooms[name];
        }
        this.memory.versions["052to053"] = true;
        log.alert(`Version migration from 0.5.2 -> 0.5.3 completed successfully.`);
    }
    static migrate_053_06X_part1() {
        // Delete some old properties
        delete Memory.overseer.suspendUntil;
        // Delete ALL room memory
        for (const name in Memory.rooms) {
            delete Memory.rooms[name];
        }
        this.memory.versions["053to06X_part1"] = true;
        log.alert(`Version migration from 0.5.3 -> 0.6.X part 1 completed successfully.`);
    }
    static migrate_053_06X_part2() {
        // Delete some old properties
        if (Memory.Overmind.terminalNetwork) {
            delete Memory.Overmind.terminalNetwork;
        }
        // Remove all orders
        for (const id in Game.market.orders) {
            Game.market.cancelOrder(id);
        }
        this.memory.versions["053to06X_part2"] = true;
        log.alert(`Version migration from 0.5.3 -> 0.6.X part 2 completed successfully.`);
    }
    static migrate_053_06X_part3() {
        var _a, _b, _c, _d;
        // Remove all orders
        for (const colonyName in Memory.colonies) {
            if (Memory.colonies[colonyName].evolutionChamber) {
                (_a = Memory.colonies[colonyName].evolutionChamber) === null || _a === void 0 ? true : delete _a.activeReaction;
                (_b = Memory.colonies[colonyName].evolutionChamber) === null || _b === void 0 ? true : delete _b.reactionQueue;
                (_c = Memory.colonies[colonyName].evolutionChamber) === null || _c === void 0 ? true : delete _c.status;
                (_d = Memory.colonies[colonyName].evolutionChamber) === null || _d === void 0 ? true : delete _d.statusTick;
            }
        }
        this.memory.versions["053to06X_part3"] = true;
        log.alert(`Version migration from 0.5.3 -> 0.6.X part 3 completed successfully.`);
    }
    static migrate_053_06X_part4() {
        // Remove orders for reaction intermediates
        for (const id in Game.market.orders) {
            const order = Game.market.orders[id];
            const deleteOrdersFor = [
                RESOURCE_GHODIUM,
                RESOURCE_ZYNTHIUM_KEANITE,
                RESOURCE_UTRIUM_LEMERGITE,
                RESOURCE_HYDROXIDE,
            ];
            if (deleteOrdersFor.includes(order.resourceType)) {
                Game.market.cancelOrder(id);
            }
        }
        this.memory.versions["053to06X_part4"] = true;
        log.alert(`Version migration from 0.5.3 -> 0.6.X part 4 completed successfully.`);
    }
    static migrate_053_06X_part5() {
        // Find oldest tick we can find
        log.alert(`Fetching approximate empire age...`);
        if (MY_USERNAME == "Muon") {
            Memory.tick = Game.time - 4461275; // oldest tick I could find
        }
        else {
            let oldestTick = Infinity;
            for (const name in Memory.colonies) {
                if (Memory.colonies[name] &&
                    Memory.colonies[name].roomPlanner) {
                    const rpmem = Memory.colonies[name].roomPlanner;
                    if (rpmem &&
                        rpmem.lastGenerated &&
                        rpmem.lastGenerated < oldestTick) {
                        oldestTick = rpmem.lastGenerated;
                    }
                }
            }
            for (const name in Memory.flags) {
                const fmem = Memory.flags[name];
                if (fmem.T && fmem.T < oldestTick) {
                    oldestTick = fmem.T;
                }
            }
            if (oldestTick < Infinity) {
                Memory.tick = Game.time - oldestTick;
            }
        }
        // Clean some properties we don't use anymore
        log.alert(`Cleaning memory...`);
        delete Memory.strategist;
        delete Memory.zoneRooms;
        // @ts-expect-error reset this
        Memory.roomIntel = {};
        const mem = Memory;
        // @ts-expect-error not used
        delete mem.pathing.paths;
        // @ts-expect-error not used
        delete mem.pathing.weightedDistances;
        // Changes will need repathing
        for (const name in Game.creeps) {
            const creep = Game.creeps[name];
            if (creep) {
                delete creep.memory._go;
            }
        }
        function derefCoords(coordName) {
            const [x, y] = coordName.split(":");
            return { x: parseInt(x, 10), y: parseInt(y, 10) };
        }
        for (const name in Memory.colonies) {
            const colmem = Memory.colonies[name];
            // @ts-expect-error migrated
            delete colmem.abathur; // outdated
            // @ts-expect-error migrated
            delete colmem.expansionData; // bugged
            log.alert(`Migrating room planner memories...`);
            // Clean room planner memory of some old shit
            const validRoomPlannerMemKeys = [
                "active",
                "relocating",
                "recheckStructuresAt",
                "bunkerData",
                "lastGenerated",
                "mapsByLevel",
                "savedFlags",
            ];
            if (colmem.roomPlanner) {
                for (const key in colmem.roomPlanner) {
                    if (!validRoomPlannerMemKeys.includes(key)) {
                        // @ts-expect-error migrated
                        delete colmem.roomPlanner[key];
                    }
                }
            }
            // Migrate road planner to new format
            log.alert(`Migrating road planner memories...`);
            if (colmem.roadPlanner) {
                // @ts-expect-error migration
                const roadLookup = colmem.roadPlanner.roadLookup;
                if (roadLookup) {
                    const roadCoordsPacked = {};
                    for (const roomName in roadLookup) {
                        const roadCoords = _.map(_.keys(roadLookup[roomName]), (coordName) => derefCoords(coordName));
                        roadCoordsPacked[roomName] = packCoordList(roadCoords);
                    }
                    colmem.roadPlanner.roadCoordsPacked = roadCoordsPacked;
                    // @ts-expect-error migration
                    delete colmem.roadPlanner.roadLookup;
                }
            }
            // Migrate barrier planner to new format
            log.alert(`Migrating barrier planner memories...`);
            if (colmem.barrierPlanner) {
                // @ts-expect-error migration
                const barrierLookup = colmem.barrierPlanner.barrierLookup;
                if (barrierLookup) {
                    const barrierCoords = _.map(_.keys(barrierLookup), (coordName) => derefCoords(coordName));
                    colmem.barrierPlanner.barrierCoordsPacked =
                        packCoordList(barrierCoords);
                    // @ts-expect-error migration
                    delete colmem.barrierPlanner.barrierLookup;
                }
            }
        }
        log.alert(`Clearing room memories...`);
        for (const roomName in Memory.rooms) {
            delete Memory.rooms[roomName];
        }
        this.memory.versions["053to06X_part5"] = true;
        log.alert(`Version migration from 0.5.3 -> 0.6.X part 5 completed successfully.`);
    }
}

/* tslint:disable:no-eval */
const DEBUG_TIMEOUT = 1000;
const NO_COMMAND = "No command";
const defaultDebuggerMemory = {
    username: undefined,
    enabled: false,
    expiration: 0,
    command: undefined,
    response: undefined,
};
/**
 * Debugging tool which lets me remotely debug other Overmind players' code by communicating through public memory
 * segments. Can be toggled on and off with console commands startRemoteDebugSession() and endRemoteDebugSession().
 */
class RemoteDebugger {
    constructor() {
        Memory.remoteDebugger = _.defaultsDeep({}, Memory.remoteDebugger, defaultDebuggerMemory);
    }
    get memory() {
        return Memory.remoteDebugger;
    }
    /**
     * Push all commands from secret memory to public memory and clear secret memory commands
     */
    pushCommands_master() {
        Segmenter.setSegmentProperty(SEGMENTS.remoteDebugger, "command", this.memory.command);
        if (this.memory.command) {
            log.info(`[DEBUGGER] Sending command: ${this.memory.command}`);
        }
        this.memory.command = undefined;
    }
    /**
     * Fetch the response from the debugee
     */
    fetchResponse_master() {
        const response = Segmenter.getForeignSegmentProperty(MUON, SEGMENTS.remoteDebugger, "response");
        return response;
    }
    /**
     * Execute the commands you are given
     */
    fetchCommands_slave() {
        const cmd = Segmenter.getForeignSegmentProperty(MUON, SEGMENTS.remoteDebugger, "command");
        if (cmd) {
            log.info(`[DEBUGGER] Executing command: ${cmd}`);
            // eslint-disable-next-line
            const response = eval(cmd);
            log.info(`[DEBUGGER] Relaying response: ${response}`);
            this.memory.response = JSON.stringify(response);
        }
        else {
            this.memory.response = NO_COMMAND;
        }
    }
    /**
     * Push the response from the last run command
     */
    pushResponse_slave() {
        Segmenter.setSegmentProperty(SEGMENTS.remoteDebugger, "response", this.memory.response);
        this.memory.response = undefined;
    }
    extendSession() {
        this.memory.expiration = Game.time + DEBUG_TIMEOUT;
    }
    enable() {
        this.memory.enabled = true;
        this.memory.expiration = Game.time + DEBUG_TIMEOUT;
        log.info(`[DEBUGGER] Starting remote debug session. Timeout: ${this.memory.expiration} ` +
            alignedNewline +
            `Warning: this enables remote arbitrary code execution!`);
    }
    disable() {
        this.memory.enabled = false;
        this.memory.expiration = -1;
        log.info(`[DEBUGGER] Remote debugging session ended`);
    }
    connect(username) {
        this.memory.username = username;
        this.memory.enabled = true;
        this.memory.expiration = Game.time + DEBUG_TIMEOUT;
        log.info(`[DEBUGGER] Starting remote debug session with ${username}. Timeout: ${this.memory.expiration}`);
    }
    cancelCommand() {
        this.memory.command = undefined;
    }
    /* Register a debug command to be sent to the user */
    debug(command) {
        this.memory.command = command;
        return `[DEBUGGER] Sending command next tick.`;
    }
    run_master() {
        if (Game.time % 2 == 0) {
            const response = this.fetchResponse_master();
            if (response && response != NO_COMMAND) {
                log.info(`[DEBUGGER] Response: ` + response);
            }
            this.pushCommands_master();
        }
    }
    run_slave() {
        if (Game.time % 2 == 1) {
            this.fetchCommands_slave();
            this.pushResponse_slave();
        }
    }
    run() {
        if (this.memory.enabled) {
            // Run the debugger
            if (MY_USERNAME == MUON) {
                if (this.memory.username) {
                    Segmenter.requestSegments(SEGMENTS.remoteDebugger);
                    Segmenter.requestForeignSegment(this.memory.username, SEGMENTS.remoteDebugger);
                    Segmenter.markSegmentAsPublic(SEGMENTS.remoteDebugger);
                    this.run_master();
                }
            }
            else {
                Segmenter.requestSegments(SEGMENTS.remoteDebugger);
                Segmenter.requestForeignSegment(MUON, SEGMENTS.remoteDebugger);
                Segmenter.markSegmentAsPublic(SEGMENTS.remoteDebugger);
                this.run_slave();
            }
            if (Game.time % 20 == 0) {
                log.alert(`[DEBUGGER] Remote session is still enabled! Expiration: ${this.memory.expiration}`);
            }
            // Disable after timeout
            if (!this.memory.expiration || Game.time > this.memory.expiration) {
                this.disable();
            }
        }
    }
}

const AVOID_RANGE = 4;
const APPROACH_RANGE = 1;
/**
 * NeuralZerg augments CombatZerg with some additional simplified actions suitable for use in reinforcement learning
 * training scenarios
 */
let NeuralZerg = class NeuralZerg extends CombatZerg {
    constructor(creep, notifyWhenAttacked = true) {
        super(creep, notifyWhenAttacked);
        this.isNeuralZerg = true;
        this.isBot = creep.name.includes("_BOT");
    }
    approachHostiles() {
        const approach = _.map(this.room.hostiles, (hostile) => ({
            pos: hostile.pos,
            range: APPROACH_RANGE,
        }));
        return Movement.combatMove(this, approach, []);
    }
    avoidHostiles() {
        const avoid = _.map(this.room.hostiles, (hostile) => ({
            pos: hostile.pos,
            range: AVOID_RANGE,
        }));
        return Movement.combatMove(this, [], avoid);
    }
    approachAllies() {
        const approach = _.map(this.room.creeps, (friendly) => ({
            pos: friendly.pos,
            range: APPROACH_RANGE,
        }));
        return Movement.combatMove(this, approach, []);
    }
    avoidAllies() {
        const avoid = _.map(this.room.creeps, (friendly) => ({
            pos: friendly.pos,
            range: AVOID_RANGE,
        }));
        return Movement.combatMove(this, [], avoid);
    }
    maneuver(approachTargs, avoidTargs) {
        const approach = _.map(approachTargs, (targ) => ({
            pos: targ.pos,
            range: APPROACH_RANGE,
        }));
        const avoid = _.map(avoidTargs, (targ) => ({
            pos: targ.pos,
            range: AVOID_RANGE,
        }));
        return Movement.combatMove(this, approach, avoid);
    }
    autoEngage(combatTarget) {
        const target = combatTarget ? [combatTarget.creep] : undefined;
        // Do standard melee, ranged, and heal actions
        if (this.getActiveBodyparts(ATTACK) > 0) {
            this.autoMelee(target); // Melee should be performed first
        }
        if (this.getActiveBodyparts(RANGED_ATTACK) > 0) {
            this.autoRanged(target);
        }
        if (this.canExecute("heal")) {
            this.autoHeal(this.canExecute("rangedHeal"));
        }
    }
};
NeuralZerg = __decorate$1([
    profile
], NeuralZerg);

class TrainingOpponents {
    /**
     * Simple combat behavior to train against. Every creep just chases the nearest opponent and attacks them.
     */
    static simpleCombat(zerg) {
        const closestOpponent = zerg.pos.findClosestByRange(zerg.room.hostiles);
        if (closestOpponent) {
            zerg.creep.moveTo(closestOpponent);
            zerg.attack(closestOpponent);
            zerg.rangedAttack(closestOpponent);
            zerg.heal(zerg);
        }
    }
    /**
     * Stupid combat behavior. Moves in a random direction and attacks a random target in range if combat is allowed
     */
    static stupidCombat(zerg, allowAttack = false, allowHeal = false) {
        const direction = _.random(1, 8);
        zerg.move(direction);
        if (allowAttack) {
            const meleeTarget = _.sample(zerg.pos.findInRange(zerg.room.hostiles, 1));
            if (meleeTarget) {
                zerg.attack(meleeTarget);
            }
            const rangedTarget = _.sample(zerg.pos.findInRange(zerg.room.hostiles, 3));
            if (rangedTarget) {
                zerg.rangedAttack(rangedTarget);
            }
        }
        if (allowHeal) {
            zerg.heal(zerg);
        }
    }
}

/*

 _____  _    _ _______  ______ _______ _____ __   _ ______
|     |  \  /  |______ |_____/ |  |  |   |   | \  | |     \
|_____|   \/   |______ |    \_ |  |  | __|__ |  \_| |_____/
....... R E I N F O R C E M E N T   L E A R N I N G .......

*/
/**
 * The ActionParser provides a line of direct interaction for the external Python optimizers to control
 * creep actions via the Memory.reinforcementLearning object.
 */
class ActionParser {
    /**
     * Parse an individual action from its serialized format and command the actor to execute it.
     * Returns whether the action was valid.
     */
    static parseAction(actor, action, autoEngage = true) {
        var _a, _b;
        const command = action[0];
        const predicate = action[1];
        const targ = typeof predicate == "string" ? Game.getObjectById(predicate) : null;
        switch (command) {
            case "move":
                actor.move(predicate);
                break;
            case "goTo":
                if (targ) {
                    actor.goTo(targ);
                }
                break;
            case "attack":
                if (targ) {
                    actor.attack(targ);
                }
                break;
            case "rangedAttack":
                if (targ) {
                    actor.rangedAttack(targ);
                }
                break;
            case "rangedMassAttack":
                actor.rangedMassAttack();
                break;
            case "heal":
                if (targ) {
                    actor.heal(targ);
                }
                else if (typeof predicate != "string") {
                    actor.heal(actor);
                }
                break;
            case "rangedHeal":
                if (targ) {
                    actor.rangedHeal(targ);
                }
                break;
            case "approachHostiles":
                actor.approachHostiles();
                break;
            case "avoidHostiles":
                actor.avoidHostiles();
                break;
            case "approachAllies":
                actor.approachAllies();
                break;
            case "avoidAllies":
                actor.avoidAllies();
                break;
            case "maneuver":
                const approachNames = ((_a = predicate) !== null && _a !== void 0 ? _a : [])[0];
                const avoidNames = ((_b = predicate) !== null && _b !== void 0 ? _b : [])[1];
                const approachTargs = _.map(approachNames, (name) => Game.creeps[name]);
                const avoidTargs = _.map(avoidNames, (name) => Game.creeps[name]);
                actor.maneuver(approachTargs, avoidTargs);
                break;
            case "noop":
                break;
            default:
                console.log(`[${Game.time}] Invalid command: ${command}!`);
                return false;
        }
        if (autoEngage) {
            actor.autoEngage();
        }
        return true;
    }
    /**
     * Determine the list of actions for each Zerg to perform
     */
    static parseActions(actors, serializedActions) {
        const receivedOrders = _.mapValues(actors, () => false);
        // Deserialize the actions for each actor
        for (const creepName in serializedActions) {
            const creep = actors[creepName];
            if (!creep) {
                console.log(`No creep with name ${creepName}!`);
                continue;
            }
            // Parse and execute each action, recording whether it was valid
            for (const action of serializedActions[creepName]) {
                const validAction = ActionParser.parseAction(creep, action);
                if (validAction) {
                    receivedOrders[creepName] = true;
                }
            }
        }
        // Ensure each actor was given an order (possibly noop)
        for (const actorName in actors) {
            if (!receivedOrders[actorName]) {
                console.log(`[${Game.time}] Actor with name ${actorName} did not receive an order this tick!`);
            }
        }
    }
    /**
     * Periodic logging functions that are used to describe state of training map and identify bugs
     */
    static logState(contents) {
        console.log(`[${Game.time}] My creeps: `, _.map(Game.creeps, (creep) => `${creep.name} ${creep.pos}`));
        if (Memory.reinforcementLearning) {
            console.log(`[${Game.time}] RL Segment: ${contents}`);
        }
    }
    /**
     * Wraps all creeps as Zerg
     */
    static getAllActors() {
        return _.mapValues(Game.creeps, (creep) => new NeuralZerg(creep));
    }
    /**
     * Read action commands from the designated memory segment, parse them, and run them
     */
    static run() {
        // Wrap all creep as NeuralZerg and partition actors into controllable and uncontrollable (scripted) sets
        const allActors = ActionParser.getAllActors();
        const controllableActors = {};
        const uncontrollableActors = {};
        for (const name in allActors) {
            const actor = allActors[name];
            if (allActors[name].isBot) {
                uncontrollableActors[name] = actor;
            }
            else {
                controllableActors[name] = actor;
            }
        }
        // Parse memory and relay actions to controllable actors
        const raw = RawMemory.segments[SEGMENTS.reinforcementLearning];
        if (raw != undefined && raw != "") {
            const actions = (JSON.parse(raw));
            ActionParser.parseActions(controllableActors, actions);
        }
        else {
            if (_.size(controllableActors) > 0) {
                console.log(`[${Game.time}]: No actions received!`);
            }
        }
        // Run uncontrollable actors on a script
        for (const name in uncontrollableActors) {
            const bot = uncontrollableActors[name];
            // TrainingOpponents.stupidCombat(bot);
            TrainingOpponents.simpleCombat(bot);
        }
        // Log state according to verbosity
        if (RL_TRAINING_VERBOSITY == 0) ;
        else if (RL_TRAINING_VERBOSITY == 1) {
            if (Game.time % 100 == 0 || Game.time % 100 == 1) {
                this.logState(raw);
            }
        }
        else if (RL_TRAINING_VERBOSITY == 2) {
            this.logState(raw);
        }
        // Clear the segment and keep it requested
        RawMemory.segments[SEGMENTS.reinforcementLearning] = "";
        RawMemory.setActiveSegments([SEGMENTS.reinforcementLearning]);
    }
}

//
// ___________________________________________________________
//
//  _____  _    _ _______  ______ _______ _____ __   _ ______
// |     |  \  /  |______ |_____/ |  |  |   |   | \  | |     \
// |_____|   \/   |______ |    \_ |  |  | __|__ |  \_| |_____/
//
// _______________________ Screeps AI ________________________
//
//
// Overmind repository: github.com/bencbartlett/overmind
//
// @formatter:off
/* tslint:disable:ordered-imports */
global.PHASE = "assimilating";
global.LATEST_BUILD_TICK = Game.time;
// =====================================================================================================================
// Main loop
function main() {
    // Bump the stack trace limit so we see more of it
    Error.stackTraceLimit = 20;
    // Memory operations: load and clean memory, suspend operation as needed -------------------------------------------
    Mem.load(); // Load previous parsed memory if present
    if (!Mem.shouldRun()) {
        // Suspend operation if necessary
        return;
    }
    Mem.clean(); // Clean memory contents
    // Instantiation operations: build or refresh the game state -------------------------------------------------------
    if (!Overmind || Overmind.shouldBuild || Game.time >= Overmind.expiration) {
        PHASE = "build";
        // @ts-expect-error global shenanigans
        delete global.Overmind; // Explicitly delete the old Overmind object
        Mem.garbageCollect(true); // Run quick garbage collection
        // @ts-expect-error obfuscated
        global.Overmind = new _Overmind$1(); // Instantiate the Overmind object
        Overmind.build(); // Build phase: instantiate all game components
        LATEST_BUILD_TICK = Game.time; // Record this tick as having a build reset
    }
    else {
        PHASE = "refresh";
        Overmind.refresh(); // Refresh phase: update the Overmind state
    }
    // Tick loop cycle: initialize and run each component --------------------------------------------------------------
    PHASE = "init";
    Overmind.init(); // Init phase: spawning and energy requests
    PHASE = "run";
    Overmind.run(); // Run phase: execute state-changing actions
    PHASE = "postRun";
    Overmind.visuals(); // Draw visuals
    Stats.run(); // Record statistics
    Mem.didRun(); // Record successful tick
    global.remoteDebugger.run(); // Run remote debugger code if enabled
    Overmind.postRun(); // Throw errors at end of tick; anything after here might not get run
}
// Main loop if RL mode is enabled (~settings.ts)
function main_RL() {
    Mem.clean();
    // @ts-expect-error global shenanigans
    delete global.Overmind;
    // @ts-expect-error obfuscated
    global.Overmind = new _Overmind$1();
    ActionParser.run();
}
// This gets run on each global reset
function onGlobalReset() {
    global.LATEST_GLOBAL_RESET_TICK = Game.time;
    global.LATEST_GLOBAL_RESET_DATE = new Date();
    Mem.format();
    OvermindConsole.init();
    VersionMigration.run();
    Memory.stats.persistent.lastGlobalReset = Game.time;
    OvermindConsole.printUpdateMessage();
    // Update the master ledger of valid checksums
    Assimilator.updateValidChecksumLedger();
    // Make a new Overmind object
    // @ts-expect-error obfuscated
    global.Overmind = new _Overmind$1();
    // Make a remote debugger
    global.remoteDebugger = new RemoteDebugger();
}
// Global reset function if RL mode is enabled
function onGlobalReset_RL() {
    Mem.format();
}
// Decide which loop to export as the script loop
let _loop;
if (RL_TRAINING_MODE) {
    // Use stripped version for training reinforcment learning model
    _loop = main_RL;
}
else {
    {
        // Use the default main loop
        _loop = main;
    }
}
const loop = _loop;
// Run the appropriate global reset function
if (RL_TRAINING_MODE) {
    OvermindConsole.printTrainingMessage();
    onGlobalReset_RL();
}
else {
    // Register these functions for checksum computations with the Assimilator
    Assimilator.validate(main);
    Assimilator.validate(loop);
    // Run the global reset code
    onGlobalReset();
}

exports.loop = loop;
